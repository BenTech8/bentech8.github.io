<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ben&#39;s Blog</title>
  
  
  <link href="https://bentech8.github.io/atom.xml" rel="self"/>
  
  <link href="https://bentech8.github.io/"/>
  <updated>2025-06-22T07:41:01.442Z</updated>
  <id>https://bentech8.github.io/</id>
  
  <author>
    <name>Ben</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s-控制器</title>
    <link href="https://bentech8.github.io/2025/06/22/k8s-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <id>https://bentech8.github.io/2025/06/22/k8s-%E6%8E%A7%E5%88%B6%E5%99%A8/</id>
    <published>2025-06-22T07:41:01.000Z</published>
    <updated>2025-06-22T07:41:01.442Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>入侵检测</title>
    <link href="https://bentech8.github.io/2025/04/09/Linux-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/"/>
    <id>https://bentech8.github.io/2025/04/09/Linux-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/</id>
    <published>2025-04-09T07:53:29.000Z</published>
    <updated>2025-05-05T08:09:23.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入侵检测"><a href="#入侵检测" class="headerlink" title="入侵检测"></a>入侵检测</h2><h3 id="查看系统日志"><a href="#查看系统日志" class="headerlink" title="查看系统日志"></a>查看系统日志</h3><h4 id="查看安全相关日志"><a href="#查看安全相关日志" class="headerlink" title="查看安全相关日志"></a>查看安全相关日志</h4><p>1）ssh远程登录失败日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep -i Failed /var/log/secure</span><br><span class="line">Apr    9 15:58:33 localhost unix_chkpwd[1572]: password check failed for user (root) </span><br><span class="line">Apr    9 15:58:35 localhost login: FAILED LOGIN 1 FROM tty1 FOR root, Authentication failure</span><br></pre></td></tr></table></figure><p>2）ssh远程登录成功日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep -i Accepted /var/log/secure</span><br><span class="line">Apr    6 15:21:19 localhost sshd[1594]: Accepted password for root from 172.20.10.3 port 50205 ssh2</span><br></pre></td></tr></table></figure><p>3）统计登录成功或登录失败的ip，并进行去重降序排列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep -i Accepted /var/log/secure | awk &#x27;&#123;print $(NF-3)&#125;&#x27; | grep &#x27;^[0-9]&#x27; | sort | uniq -c | sort -rn</span><br><span class="line">1 172.20.10.7</span><br><span class="line">1 172.20.10.3</span><br><span class="line">[root@localhost ~]# grep -i Failed /var/log/secure | awk &#x27;&#123;print $(NF-3)&#125;&#x27; | grep &#x27;^[0-9]&#x27; | sort | uniq -c | sort -rn</span><br></pre></td></tr></table></figure><h4 id="查看历史用户登录信息"><a href="#查看历史用户登录信息" class="headerlink" title="查看历史用户登录信息"></a>查看历史用户登录信息</h4><p>1）查看最后5条登录信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# last -a -5</span><br></pre></td></tr></table></figure><p>2）查看指定时间之前登录信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# last -a -t 20250304123030</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2025-03-04 12：30：30之前</span></span><br></pre></td></tr></table></figure><p>3）查看登录系统的用户相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# last -a -f /var/log/btmp</span><br><span class="line">Ben      ssh:notty    Wed Apr  9 17:20    gone - no logout  172.20.10.3</span><br><span class="line">Ben      ssh:notty    Wed Apr  9 17:20 - 17:20  (00:00)     172.20.10.3</span><br><span class="line">Ben      ssh:notty    Wed Apr  9 17:20 - 17:20  (00:00)     172.20.10.3</span><br><span class="line">root     tty1         Wed Apr  9 15:58    gone - no logout</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:25 - 17:20 (3+02:54)    172.20.10.7</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:25 - 14:25  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:25 - 14:25  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:23 - 14:25  (00:01)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:23 - 14:23  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:23 - 14:23  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:23 - 14:23  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:23 - 14:23  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:22 - 14:23  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sun Apr  6 14:05 - 14:22  (00:17)     172.20.10.7</span><br><span class="line">test1    ssh:notty    Sun Apr  6 14:05 - 14:05  (00:00)     172.20.10.7</span><br><span class="line">test3    ssh:notty    Sun Apr  6 14:05 - 14:05  (00:00)     172.20.10.7</span><br><span class="line">test3    ssh:notty    Sun Apr  6 13:58 - 14:05  (00:06)     172.20.10.7</span><br><span class="line">test3    ssh:notty    Sun Apr  6 13:58 - 13:58  (00:00)     172.20.10.7</span><br><span class="line">test3    ssh:notty    Sun Apr  6 13:58 - 13:58  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sat Apr  5 22:17 - 13:58  (15:41)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sat Apr  5 22:17 - 22:17  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sat Apr  5 21:54 - 22:17  (00:22)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sat Apr  5 21:54 - 21:54  (00:00)     172.20.10.7</span><br><span class="line">ben      tty1         Sat Apr  5 21:50 - 15:58 (3+18:08)</span><br><span class="line">ben      tty1         Sat Apr  5 20:24 - 21:50  (01:25)</span><br><span class="line">ben      tty1         Sat Apr  5 20:24 - 20:24  (00:00)</span><br><span class="line">ben      tty1         Sat Apr  5 20:24 - 20:24  (00:00)</span><br><span class="line">ben      tty1         Sat Apr  5 20:23 - 20:24  (00:00)</span><br><span class="line">root     ssh:notty    Sat Apr  5 19:59 - 21:54  (01:55)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sat Apr  5 19:59 - 19:59  (00:00)     172.20.10.7</span><br><span class="line">root     ssh:notty    Sat Apr  5 19:58 - 19:59  (00:00)     172.20.10.7</span><br><span class="line">(unknown tty1         Fri Apr  4 12:02 - 20:23 (1+08:20)</span><br></pre></td></tr></table></figure><p>4）查看记录每个用户最后的登录信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lastlog</span><br><span class="line">root             pts/0    172.20.10.3      三 4月  9 17:23:24 +0800 2025</span><br><span class="line">bin                                        **从未登录过**</span><br><span class="line">daemon                                     **从未登录过**</span><br><span class="line">adm                                        **从未登录过**</span><br><span class="line">lp                                         **从未登录过**</span><br><span class="line">sync                                       **从未登录过**</span><br><span class="line">shutdown                                   **从未登录过**</span><br><span class="line">halt                                       **从未登录过**</span><br><span class="line">mail                                       **从未登录过**</span><br><span class="line">operator                                   **从未登录过**</span><br><span class="line">games                                      **从未登录过**</span><br><span class="line">ftp                                        **从未登录过**</span><br><span class="line">nobody                                     **从未登录过**</span><br><span class="line">systemd-network                            **从未登录过**</span><br><span class="line">dbus                                       **从未登录过**</span><br><span class="line">polkitd                                    **从未登录过**</span><br><span class="line">sshd                                       **从未登录过**</span><br><span class="line">postfix                                    **从未登录过**</span><br><span class="line">chrony                                     **从未登录过**</span><br><span class="line">ben              tty1                      六 4月  5 21:50:06 +0800 2025</span><br><span class="line">owen                                       **从未登录过**</span><br><span class="line">it01             tty1                      六 4月  5 17:44:42 +0800 2025</span><br><span class="line">it02                                       **从未登录过**</span><br><span class="line">test1            pts/0    172.20.10.7      日 4月  6 13:57:05 +0800 2025</span><br><span class="line">test2                                      **从未登录过**</span><br><span class="line">test3            pts/0    172.20.10.7      日 4月  6 13:58:58 +0800 2025</span><br></pre></td></tr></table></figure><h4 id="统计当前在线状态"><a href="#统计当前在线状态" class="headerlink" title="统计当前在线状态"></a>统计当前在线状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 17:32:18 up 17 min,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     tty1                      17:15   16:26   0.03s  0.03s -bash</span><br><span class="line">root     pts/0    172.20.10.3      17:23    2.00s  0.68s  0.00s w</span><br><span class="line">root     pts/1    172.20.10.3      17:21    9:22   0.14s  0.14s -bash</span><br></pre></td></tr></table></figure><h4 id="查看系统主日志"><a href="#查看系统主日志" class="headerlink" title="查看系统主日志"></a>查看系统主日志</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# less /var/log/messages</span><br></pre></td></tr></table></figure><h4 id="查看计划任务"><a href="#查看计划任务" class="headerlink" title="查看计划任务"></a>查看计划任务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# less /var/log/cron</span><br><span class="line">[root@localhost ~]# cat /var/spool/cron/*</span><br><span class="line">[root@localhost ~]# less /etc/crontab</span><br><span class="line">[root@localhost ~]# ls /etc/cron.*</span><br></pre></td></tr></table></figure><h3 id="查看异常流量"><a href="#查看异常流量" class="headerlink" title="查看异常流量"></a>查看异常流量</h3><h4 id="iftop动态查看网卡接口流量"><a href="#iftop动态查看网卡接口流量" class="headerlink" title="iftop动态查看网卡接口流量"></a>iftop动态查看网卡接口流量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install epel-release</span><br><span class="line">[root@localhost ~]# yum -y install iftop</span><br><span class="line">[root@localhost ~]# iftop -i ens33</span><br></pre></td></tr></table></figure><h4 id="流量监控"><a href="#流量监控" class="headerlink" title="流量监控"></a>流量监控</h4><ul><li>Cacti</li><li>Zabbix</li><li>Ganglia</li><li>Prometheus</li></ul><h4 id="数据包抓取"><a href="#数据包抓取" class="headerlink" title="数据包抓取"></a>数据包抓取</h4><ul><li>wireshark</li><li>tcpdump</li><li>sniffer</li></ul><h4 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h4><p>1）基本用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取100个包</span></span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv -c 100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取包内容写入文件</span></span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv -w /file1.tcpdump</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从文件中读取包，一般不用tcpdump查看，用wireshark可视化查看更清晰</span></span><br><span class="line">[root@localhost ~]# tcpdump -nnv -r /file1.tcpdump</span><br></pre></td></tr></table></figure><p>2）条件(port|host|net)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取指定端口的包</span></span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv not port 80</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv port 22</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv port 80</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取指定网络的包</span></span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv net 192.168.0.0/24</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取指定主机的包</span></span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv host 192.168.0.15</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv dst port 22</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv src port 22</span><br></pre></td></tr></table></figure><p>3）条件(协议)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv arp</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv icmp</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv udp</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv tcp</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv ip</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv vrrp</span><br></pre></td></tr></table></figure><p>4）多条件(与或非)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv not net 192.168.0.0/24</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv not port 80</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv host 192.168.0.15 and port 22</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv host 192.168.0.15 and host 192.168.0.33</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv host 192.168.0.15 or host 192.168.0.33</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv \(host 192.168.0.15 and port 22\) or \(host 192.168.0.33 and port 89 \)</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv host 192.168.0.110 and port 22 or port 80</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv host 192.168.0.110 and \(port 22 or port 80 \)</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv host 192.168.0.110 and port 80</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv host 192.168.0.110 and ! port 80</span><br></pre></td></tr></table></figure><p>5）条件为tcp仅有的SYN标记的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp包标识位</span><br><span class="line">| C | E | U | A | P | R | S | F |</span><br><span class="line">| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取SYN的包</span></span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv tcp[13]==2</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv tcp[13]==2 and port 22 -w ssh-conn.tcpdump</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">条件是：TCP仅有SYN/ACK标记的</span></span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv tcp[13]==18      # SYN+ACK的包</span><br><span class="line">[root@localhost ~]# tcpdump -i eth0 -nnv tcp[13]==17      # FIN+ACK的包</span><br></pre></td></tr></table></figure><h3 id="检查可疑进程"><a href="#检查可疑进程" class="headerlink" title="检查可疑进程"></a>检查可疑进程</h3><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p>系统进程一般带有“[]”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# px -aux | less</span><br></pre></td></tr></table></figure><h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><p>显示每个程序的完全指令，包含路径、参数或是常驻服务标识、列出树状图时特别标注现在执行的程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示所有</span></span><br><span class="line">[root@localhost ~]# pstree -a</span><br><span class="line">[root@localhost ~]# pstree -h</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>按cpu、内存排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top -d 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按P以CPU使用排序</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按M以内存使用排序</span></span><br></pre></td></tr></table></figure><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>查看网络连接情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -anputl</span><br></pre></td></tr></table></figure><h4 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h4><p>查看某个协议或端口的监听状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ss -an | grep tcp</span><br><span class="line">[root@localhost ~]# ss -an | grep 22</span><br></pre></td></tr></table></figure><h4 id="根据文件或端口查找进程"><a href="#根据文件或端口查找进程" class="headerlink" title="根据文件或端口查找进程"></a>根据文件或端口查找进程</h4><p>1）根据某文件查看正在被某些进程使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof /usr/sbin/vsftpd</span><br><span class="line">[root@localhost ~]# fuser /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>2）根据某个端口查看对应进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsof -i TCP:22</span><br><span class="line">[root@localhost ~]# fuser -v 22/tcp</span><br></pre></td></tr></table></figure><h3 id="kernel-audit-内核审计"><a href="#kernel-audit-内核审计" class="headerlink" title="kernel audit 内核审计"></a>kernel audit 内核审计</h3><h3 id="文件完全性检查"><a href="#文件完全性检查" class="headerlink" title="文件完全性检查"></a>文件完全性检查</h3><h4 id="检验RPM包完整性"><a href="#检验RPM包完整性" class="headerlink" title="检验RPM包完整性"></a>检验RPM包完整性</h4><p>没有显示说明包没有被修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -V bash</span><br><span class="line">[root@localhost ~]# rpm -V kernel</span><br><span class="line">[root@localhost ~]# rpm -v vsftpd</span><br><span class="line">[root@localhost ~]# rpm -vf /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><h4 id="md5sum-sha1sum检测"><a href="#md5sum-sha1sum检测" class="headerlink" title="md5sum&#x2F;sha1sum检测"></a>md5sum&#x2F;sha1sum检测</h4><p>1）获取当前的&#x2F;etc目录的md5值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# find /etc -type f -exec md5sum &#123;&#125; \; &gt;/tmp/`date +%F%H%M`-md5.txt</span><br></pre></td></tr></table></figure><p>2）对比以上md5值获取操作过的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#　diff /tmp/1-md5.txt /tmp/2-md5.txt</span><br></pre></td></tr></table></figure><h4 id="HIDS-AIDE高级入侵检测环境"><a href="#HIDS-AIDE高级入侵检测环境" class="headerlink" title="HIDS:AIDE高级入侵检测环境"></a>HIDS:AIDE高级入侵检测环境</h4><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><h3 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看本机mac地址列表</span></span><br><span class="line">[root@localhost ~]# arp -a</span><br></pre></td></tr></table></figure><h3 id="arping"><a href="#arping" class="headerlink" title="arping"></a>arping</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取某个IP对应的mac地址</span></span><br><span class="line">[root@localhost ~]# arping -I eth0 192.168.43.20</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;入侵检测&quot;&gt;&lt;a href=&quot;#入侵检测&quot; class=&quot;headerlink&quot; title=&quot;入侵检测&quot;&gt;&lt;/a&gt;入侵检测&lt;/h2&gt;&lt;h3 id=&quot;查看系统日志&quot;&gt;&lt;a href=&quot;#查看系统日志&quot; class=&quot;headerlink&quot; title=&quot;查看系统日志&quot;&gt;&lt;/a&gt;查看系统日志&lt;/h3&gt;&lt;h4 id=&quot;查看安全相关日志&quot;&gt;&lt;a href=&quot;#查看安全相关日志&quot; class=&quot;headerlink&quot; title=&quot;查看安全相关日志&quot;&gt;&lt;/a&gt;查看安全相关日志&lt;/h4&gt;&lt;p&gt;1）ssh远程登录失败日志&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]# grep -i Failed /var/log/secure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Apr    9 15:58:33 localhost unix_chkpwd[1572]: password check failed for user (root) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Apr    9 15:58:35 localhost login: FAILED LOGIN 1 FROM tty1 FOR root, Authentication failure&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bentech8.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://bentech8.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-网络安全</title>
    <link href="https://bentech8.github.io/2025/04/09/Linux-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>https://bentech8.github.io/2025/04/09/Linux-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2025-04-09T07:52:57.000Z</published>
    <updated>2025-04-09T07:52:57.979Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>系统安全</title>
    <link href="https://bentech8.github.io/2025/04/09/Linux-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/"/>
    <id>https://bentech8.github.io/2025/04/09/Linux-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</id>
    <published>2025-04-09T06:56:09.000Z</published>
    <updated>2025-04-09T07:45:01.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><ul><li><p>选择稳定版操作系统</p></li><li><p>最小化安装</p></li><li><p>不要安装gcc，make</p></li><li><p>安装完系统后更新系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y update</span><br></pre></td></tr></table></figure></li></ul><h2 id="系统权限"><a href="#系统权限" class="headerlink" title="系统权限"></a>系统权限</h2><h3 id="基本权限（rwx）"><a href="#基本权限（rwx）" class="headerlink" title="基本权限（rwx）"></a>基本权限（rwx）</h3><ul><li><p>对于目录，默认权限&#x3D;777-umask</p></li><li><p>对于文件，默认权限&#x3D;666-umask（文件默认无执行权限）</p></li><li><p>修改umask</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/bashrc</span><br><span class="line">        umask 002    # 普通用户</span><br><span class="line">    else</span><br><span class="line">        umask 022    # 超级用户</span><br><span class="line">    fi</span><br><span class="line">[root@localhost ~]#　vim /etc/profile</span><br><span class="line">        umask 002    # 普通用户</span><br><span class="line">    else</span><br><span class="line">        umask 022    # 超级用户</span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>1）suid</p><p>冒险位，执行二进制文件与文件所有人有关，与谁来执行无关。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod 4XXX filename</span><br></pre></td></tr></table></figure><p>2）sgid</p><p>强制位，对目录生效，在此目录中创建文件自动归入目录所在组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#　chmod 2XXX dirname</span><br></pre></td></tr></table></figure><p>3）sticky</p><p>粘制位，目录中的文件只能被文件所有者删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chmod 1XXX dirname</span><br></pre></td></tr></table></figure><h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><ul><li>对文件的权限进行附加说明的权限设定方式</li><li>ACL提供传统的owner&#x2F;group&#x2F;other的read&#x2F;write&#x2F;execute之外的细分权限设定。(可以使用单一的使用者、目录等等)</li></ul><p>1）查看ACL权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l</span><br><span class="line">总用量</span><br><span class="line">-rw-r--r--  1 root root    4 2月    17 20:56 test.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-rw-r--r--+ 如果权限后面带有<span class="string">&#x27;+&#x27;</span>号表示有ACL权限</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# getfacl test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: test.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::rw--</span><br><span class="line">group::r--</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure><p>2）设定ACL权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# useradd ben</span><br><span class="line">[root@localhost ~]# setfacl  -m u:ben:rw test.txt</span><br><span class="line">[root@localhost ~]# getfacl test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: test.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::rw-</span><br><span class="line">user:ben:rw-</span><br><span class="line">group::r--</span><br><span class="line">mask::rw-</span><br><span class="line">other::r--</span><br><span class="line">[root@localhost ~]# ls -l test.txt</span><br><span class="line">-rw-r-xr--+ 1 root root 4 2月    17 20:56 test.txt</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# setfacl -x u:ben test.txt    # 删除acl权限</span><br></pre></td></tr></table></figure><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chattr +a test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只能给文件添加内容，但是删除不了，属于追加</span></span><br><span class="line">[root@localhost ~]# chattr +i test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件不能删除，不能更改，不能移动</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件属性</span></span><br><span class="line">[root@localhost ~]# lsattr test.txt</span><br><span class="line">----i----------- test.txt</span><br></pre></td></tr></table></figure><p>案例1：防删除，防修改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#　find /bin /sbin /usr/sbin /usr/bin /etc/shadow /etc/passwd /etc/pam.d -type f -exec chattr +i &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>案例2：日志文件防删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chattr +a /var/log/messages /var/log/secure</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志切割要先去掉a属性，之后增加a属性</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# vim /etc/logrotate.d/syslog</span><br><span class="line">prerotate</span><br><span class="line">    chattr -a /var/log/messages</span><br><span class="line">endscript</span><br><span class="line">...</span><br><span class="line">postrotate</span><br><span class="line">    chattr +a /var/log/messages</span><br><span class="line">endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="umask权限"><a href="#umask权限" class="headerlink" title="umask权限"></a>umask权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# umask</span><br><span class="line">0022</span><br><span class="line">[root@localhost ~]# umask -S</span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure><h3 id="mount权限"><a href="#mount权限" class="headerlink" title="mount权限"></a>mount权限</h3><p>1）rw&amp;ro</p><p>合理规划权限，尽量避免777权限出现。</p><p>2）sync&amp;async</p><p>此选项的默认模式为异步模式，在同步模式下，内存的任何修改都会实时的同步到硬盘当中，这种模式的安全性基本属于最高，但是因为内存的数据基本一致都在变化，所以这种模式会使得程序运行变得缓慢，影响效率。而在异步模式下，虽然同步没有实时，但是现在考虑到日志文件系统的存在，所以安全性基本不用考虑，而异步模式的效会更高，所以目前普遍使用异步模式为默认。</p><h2 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h2><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>1）由超级用户切换为普通用户，仅切换用户，环境变量不切换，如若为普通用户，会导致命令不可用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# su ben</span><br><span class="line">[ben@localhost ~]$</span><br></pre></td></tr></table></figure><p>2）由超级用户切换为普通用户，切换用户到家目录，环境变量会发生改变。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# su - ben</span><br><span class="line">[ben@localhost ~]$</span><br></pre></td></tr></table></figure><p>3）由普通用户切换为root用户。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ben@localhost ~]$ su - root</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure><h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>给普通用户提升(赋予)权限的方法有：</p><ul><li>suid,sgid</li><li>usermod</li><li>switching users with su</li><li>running commands as root with sudo</li></ul><p>使用sudo提升(赋予)权限普通用户的权限，可根据&#x2F;etc&#x2F;sudoers文件设置普通用户使用sudo命令时可以以root身份或其他用户身份运行命令。</p><p>1)sudoers文件编辑方式</p><p>使用vim直接编辑&#x2F;etc&#x2F;sudoers文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/sudoers</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不推荐</span></span><br></pre></td></tr></table></figure><p>使用visudo编辑&#x2F;etc&#x2F;sudoers：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推荐，会检查语法</span></span><br></pre></td></tr></table></figure><p>2）sudo语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">user        MACHINE=(RUN_AS_USER)           COMMANDS</span></span><br><span class="line">ben          ALL=ALL                         ALL</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">允许ben用户   在任何主机上=（以任何人的身份）      执行任何命令</span></span><br></pre></td></tr></table></figure><p>3）案例</p><p>案例1：对用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">ben        ALL=/sbin/ip, /sbin/fdisk, /bin/less</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予ben用户使用以上3个命令的权限</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# visudo</span><br><span class="line">ben        ALL=NOPASSWD: /bin/less</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予ben用户使用以上一个命令的权限，切换时不需要输入密码</span></span><br></pre></td></tr></table></figure><p>案例2：对组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd smartgo</span><br><span class="line">[root@localhost ~]# useradd it01 -G smartgo</span><br><span class="line">[root@localhost ~]# useradd it02 -G smartgo</span><br><span class="line">[root@localhost ~]# id it01</span><br><span class="line">uid=1003(it01) gid=1004(it01) 组=1004(it01),1003(smartgo)</span><br><span class="line">[root@localhost ~]# id it02</span><br><span class="line">uid=1004(it02) gid=1005(it02) 组=1005(it02),1003(smartgo)</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# visudo</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">smartgo        ALL=NOPASSWD: /sbin/ip</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">smartgo        ALL=NOPASSWD: /sbin/useradd, /sbin/userdel, /bin/passwd</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">smartgo        ALL=NOPASSWD: !/bin/passwd root, !/bin/passwd root --stdin, !/bin/passwd --stdin root</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# su - it01</span><br><span class="line">[it01@localhost ~]# sudo passwd root</span><br><span class="line">Sorry, user it01 is not allowed to execute &#x27;/bin/passwd root&#x27; as root on localhost.localdomain.</span><br></pre></td></tr></table></figure><p>案例3：别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Host Aliases</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host_Alias        FILESERVERS = fs1, fs2</span></span><br><span class="line">Host_Alias        FILESERVERS = smtp, smtp2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># User Aliases</span></span></span><br><span class="line">User_Alias ADMINS = jsmith, mikem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Command Aliases</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># These are groups of related commands...</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Networking</span></span></span><br><span class="line">Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient, /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig, /sbin/mii-tool</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Installation and management of software</span></span></span><br><span class="line">Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Services</span></span></span><br><span class="line">Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Updating the locate database</span></span></span><br><span class="line">Cmnd_Alias LOCATE = /usr/bin/updatedb</span><br><span class="line"></span><br><span class="line">ADMINS        ALL=NOPASSWD: NETWORKING, SOFTWARE</span><br></pre></td></tr></table></figure><p>4）sudo日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]#　grep &#x27;^authpriv&#x27; /etc/rsyslog.conf    # 查看日志文件路径</span><br><span class="line">authpriv.*                        /var/log/secure</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# tail -f /var/log/secure</span><br></pre></td></tr></table></figure><h2 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h2><h3 id="PAM介绍"><a href="#PAM介绍" class="headerlink" title="PAM介绍"></a>PAM介绍</h3><p>PAM（Pluggable Authentication Modules）即可插拔式认证模块，它是一种高效而且灵活的用户级别的认证方式，它也是当前Linux服务器普通使用的认证方式。</p><p>PAM可以根据用户的网段、时间、用户名、密码等实现认证。</p><h3 id="PAM身份认证"><a href="#PAM身份认证" class="headerlink" title="PAM身份认证"></a>PAM身份认证</h3><p>使用PAM做身份认证的服务有：本地(login、gdm、kdm)，sshd，vsftpd，samba等。</p><p>不使用PAM做身份认证的服务有：MySQL-Server, Zabbix等。</p><p>1）PAM使用帮助</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# firefox /usr/share/doc/pam-1.1.8/html/Linux-PAM_SAG.html</span><br></pre></td></tr></table></figure><p>2）PAM认证原理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Service(进程文件)  -&gt; PAM（配置文件）  -&gt; pam_*.so                   -&gt; 模块的配置文件</span><br><span class="line">/usr/bin/sshd    /etc/pam.d/sshd  /lib64/security/pam_access.so  /etc/security/access.conf</span><br><span class="line">                                  /lib64/security/pam_limits.so  /etc/security/limits.conf</span><br><span class="line">                                  /lib64/security/pam_time.so    /etc/security/time.comf</span><br><span class="line">/bin/su          /etc/pam.d/su    /lib64/security/pam_rootok.so</span><br></pre></td></tr></table></figure><p>3）PAM认证原理案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ldd /usr/sbin/sshd | grep -i pam</span><br><span class="line">        libpam.so.0 =&gt; /lib64/libpam.so.0 (0X00007fe76776a000)</span><br><span class="line">[root@localhost ~]# grep -i pam /etc/ssh/sshd_config</span><br><span class="line">UsePAM yes</span><br><span class="line">[root@localhost ~]# vim /etc/pam.d/sshd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">%PAM-1.0</span></span><br><span class="line">auth        required        pam_sepermit.so</span><br><span class="line">auth        substack        password-auth</span><br><span class="line">auth        include         postlogin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Used sith polkit to reauthorize <span class="built_in">users</span> <span class="keyword">in</span> remote sessions</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与polkit一起使用以重新授权远程会话中的用户</span></span><br><span class="line">-auth       optional        pam_reauthorize.so prepare</span><br><span class="line">account     required        pam_nologin.so</span><br><span class="line">account     include         password-auth</span><br><span class="line">password    include         password-auth</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pam_selinux.so close should be the first session rule</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">selinux并闭执行如下</span></span><br><span class="line">session     required        pam_selinux.so close</span><br><span class="line">session     required        pam_loginuid.so</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pam_selinux.so open should only be followed by sessions to be executed <span class="keyword">in</span> the user context</span></span><br><span class="line">session     required       pam_selinux open env_params</span><br><span class="line">session     required       pam_namespace.so</span><br><span class="line">session     optional       pam_keyinit.so force revoke</span><br><span class="line">session     include        password-auth</span><br><span class="line">session     include        postlogin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Used with polkit to reauthorize <span class="built_in">users</span> <span class="keyword">in</span> remote sessions</span></span><br><span class="line">-session    optional       pam_reauthorize.so prepare</span><br></pre></td></tr></table></figure><p>4）PAM常见的四种认证类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auth          认证管理          验证使用者身份，账号和密码</span><br><span class="line">account       用户管理          基于用户时间或密码有效期来决定是否允许访问</span><br><span class="line">password      密码(口令)        认证管理，禁止用户反复尝试登录，在变更密码时进行密码复杂性控制</span><br><span class="line">session       会话管理          进行日志记录，或者限制用户登录的次数，资源限制</span><br></pre></td></tr></table></figure><p>5）PAM认证流程控制（流程标记）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">required         (必要条件)    验证失败时仍然继续,但返回fail               </span><br><span class="line">requisite        (必要条件)    验证失败时则立即结束整个验证过程，返回fail       </span><br><span class="line">sufficient       (充分条件)    验证成功则立即返回，不再继续，否则忽略结果并继续   </span><br><span class="line">optional         (可选条件)    无论验证结果如何，均不会影响</span><br><span class="line">include                      包含另外一个配置文件中类型相同的行</span><br><span class="line">substack                     垂直叠加</span><br></pre></td></tr></table></figure><p>6）PAM常用模块</p><ul><li><p>pam_rootok.so模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">模块：pam_rootok.so</span><br><span class="line">功能：用户UID是0，返回成功</span><br><span class="line"></span><br><span class="line">示例：限制root切换用户也需要密码</span><br><span class="line">[root@localhost ~]# head -2 /etc/pam.d/su</span><br><span class="line"># auth sufficient pam_rootok.so</span><br></pre></td></tr></table></figure></li><li><p>pam_access.so模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">模块：pam_access.so</span><br><span class="line">功能：访问控制，默认配置文件/etc/security/access.conf</span><br><span class="line">通常用作登录程序，如su,login,gdm,sshd,例如限制用户从哪些网段登录sshd</span><br><span class="line"></span><br><span class="line">示例：不允许root从172.20.10.7登录sshd</span><br><span class="line">[root@localhost ~]# grep access.so /etc/pam.d/sshd</span><br><span class="line">auth    required    pam_access.so</span><br><span class="line">[root@localhost ~]# vim /etc/security/access.conf</span><br><span class="line">-:root:172.20.10.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：使用不同的模块配置文件</span><br><span class="line">[root@localhost ~]# grep access /etc/pam.d/login</span><br><span class="line">auth    required    pam_access.so accessfile=accessfile2</span><br><span class="line">[root@localhost ~]# grep ben /accessfile2</span><br><span class="line">-:ben:tty5 tty6</span><br><span class="line">[root@localhost ~]# grep access /etc/pam.d/sshd</span><br><span class="line">auth    required    pam_access.so accessfile=/accessfile1</span><br><span class="line">[root@localhost ~]# grep 110 /accessfile1</span><br><span class="line">-:root:ALL EXCEPT 192.168.2.110</span><br></pre></td></tr></table></figure></li><li><p>pam_listfile.so</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">模块：pam_listfile.so</span><br><span class="line">功能：基于自定义文件允许或拒绝(黑名单或白名单)</span><br><span class="line"></span><br><span class="line">示例：vsftpd黑名单或白名单</span><br><span class="line">[root@localhost ~]# grep listfile /etc/pam.d/vsftpd</span><br><span class="line">auth    required    pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed</span><br><span class="line"></span><br><span class="line">示例：sshd黑名单或白名单</span><br><span class="line">[root@localhost ~]# grep listfile /etc/pam.d/sshd</span><br><span class="line">auth    required    pam_listfile.so item=user sense=allow file=/etc/ssh_users onerr=fail</span><br></pre></td></tr></table></figure></li><li><p>pam_time.so</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">模块：pam_time.so</span><br><span class="line">功能：基于时间的访问控制，默认文件/etc/security/time.conf</span><br><span class="line"></span><br><span class="line">示例：基于时间限制sshd的访问</span><br><span class="line">[root@localhost ~]# grep time /etc/pam.d/sshd</span><br><span class="line">account    required    pam_time.so</span><br><span class="line">[root@localhost ~]# grep 0800 /etc/security/time.conf</span><br><span class="line">sshd;*;*;MoTuWeThFr0800-1100</span><br></pre></td></tr></table></figure></li><li><p>pam_tally2.so</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">模块：pam_tally2.so</span><br><span class="line">功能：登录统计</span><br><span class="line"></span><br><span class="line">示例：实现防止对sshd暴力破解</span><br><span class="line">[root@localhost ~]# grep tally2 /etc/pam.d/sshd</span><br><span class="line">auth    required    pam_tally2.so deny=2 even_deny_root root_unlock_time=60 unlock_time=60</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">deny=2            连续错误登录最大次数，超过最大次数，将被锁定</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">even_deny_root    root用户也被要求锁定</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root_unlock_time  root用户被锁定后等待的时间，单位为秒</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">unlock_time       普通用户被锁定后等待的时间，单位为秒</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# pam_tally2 -u root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看用户错误登录次数</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# pam_tally2 --reset -u root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除用户错误登录次数</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="PAM资源限制"><a href="#PAM资源限制" class="headerlink" title="PAM资源限制"></a>PAM资源限制</h3><p>PAM资源限制主要是对<strong>用户</strong>进行系统资源使用的限制。</p><p>PAM资源限制默认已使用，我们只需要调整相应限制值即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">模块：pam_limits.so</span><br><span class="line">功能：限制用户会话过程中对各种资源的使用情况，缺省情况下该模块的配置文件是</span><br><span class="line">/etc/security/limits.conf</span><br><span class="line">/etc/security/limits.d/*.conf</span><br></pre></td></tr></table></figure><p>PAM资源限制案例</p><p>案例1：设置用户最大打开文件数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ulimit -a</span><br><span class="line">[root@localhost ~]# ulimit -n</span><br><span class="line">1024</span><br><span class="line">[root@localhost ~]# vim /etc/security/limits.conf</span><br><span class="line">*        soft        nofile        10240</span><br><span class="line">*        hard        nofile        20480</span><br></pre></td></tr></table></figure><p>案例2：设置用户最大创建的进程数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ulimit -u</span><br><span class="line">7183</span><br><span class="line">[root@localhost ~]# vim /etc/security/limits.d/90-noproc.conf</span><br><span class="line">*        soft        nproc        10240</span><br><span class="line">*        hard        nproc        20480</span><br></pre></td></tr></table></figure><p>案例3：设置用户nginx最大使用CPU的时间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/security/limits.conf</span><br><span class="line">nginx        hard        cpu        1</span><br></pre></td></tr></table></figure><h2 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h2><h3 id="CGroups介绍"><a href="#CGroups介绍" class="headerlink" title="CGroups介绍"></a>CGroups介绍</h3><p>控制组(CGroups)是Linux内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免多个容器同时运行时对主机系统的资源竞争。控制组可以提供对容器的内存、CPU、磁盘IO等资源进行限制和计费管理。控制组的设计目标是为不同的应用情况提供统一的接口，从控制单一进程(比如nice工具)到系统级虚拟化(包括OpenVZ、Linux-VServer、LXC等)。</p><p>具体来看，控制组提供：</p><p>资源限制(Resource limiting)：可以将组设置为不超过设定的内存限制。比如：内存子系统可以为进程组设定一个内存使用上限，一旦进程组使用的内存达到限额再申请内存，就会发生Out of Memory警告。</p><p>优先级(Prioritzation)：通过优先级让一些组优先得到更多的CPU等资源。</p><p>资源审计(Accounting)：用来统计系统实际上把多少资源用到适合的目的上，可以使用cpuacct子系统记录某个进程组使用的CPU时间。</p><p>隔离(isolation)：为组隔离命名空间，这样一个组不会看到另一个组的进程、网络连接和文件系统。</p><p>控制(Control)：挂起、恢复和重启动等操作。</p><p>cgroups: Control Groups</p><p>基于进程的限制，而非用户，因此对于超级用户运行的进程也是一样。</p><p>cgroup将各种子系统定义为资源，命名为controller。可配额&#x2F;可度量-Control Groups(CGroups)</p><p>cgroups实现了对资源的配额和度量九大子系统的资源：</p><ul><li>blkio：限制每个块设备的输入输出空间。例如：磁盘，光盘以及usb</li><li>cpu：限制使用cpu比例</li><li>cpuacct：产生cgroup任务的cpu资源报告</li><li>cpuset：多核心的cpu时为cgroup任务分配单独的cpu和内存</li><li>devices：允许或拒绝对设备的访问</li><li>freezer：暂停和恢复cgroup任务</li><li>memory：设置内存限制以及产生内存资源报告</li><li>net_cls：标记每个网络包</li><li>ns：名称空间子系统</li></ul><p>案例1：对某个进程使用内存进行限制步骤</p><ul><li>需要在controller memory下建立cgroup，如nginx_mem控制组，并针对该控制组nginx_mem设置相应的内存限制参数。</li><li>将进程Nginx分配到memory controller的控制组(nginx_mem)，没有使用controller则不会限制。</li></ul><h3 id="Cgroups实现资源限制的方法"><a href="#Cgroups实现资源限制的方法" class="headerlink" title="Cgroups实现资源限制的方法"></a>Cgroups实现资源限制的方法</h3><ul><li>cgexec手动分配</li><li>cgred自动分配</li></ul><h3 id="Cgroups部署过程"><a href="#Cgroups部署过程" class="headerlink" title="Cgroups部署过程"></a>Cgroups部署过程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install libcgroup libcgroup-tools</span><br><span class="line">[root@localhost ~]# systemctl enable cgconfig</span><br><span class="line">[root@Localhost ~]# systemctl start cgconfig</span><br></pre></td></tr></table></figure><h3 id="Cgroups限制步骤"><a href="#Cgroups限制步骤" class="headerlink" title="Cgroups限制步骤"></a>Cgroups限制步骤</h3><ul><li>创建cgroup，定义相应的限制</li><li>分配程序到cgroup</li></ul><h3 id="Cgroups限制案例"><a href="#Cgroups限制案例" class="headerlink" title="Cgroups限制案例"></a>Cgroups限制案例</h3><p>1）限制进程使用CPU</p><p>a.使用cpu子系统创建两个cgroup</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/cgconfig.conf</span><br><span class="line">group lesscpu &#123;</span><br><span class="line">    cpu &#123;</span><br><span class="line">        cpu.shares=200;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">group morecpu &#123;</span><br><span class="line">    cpu &#123;</span><br><span class="line">        cpu.shares=800;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# systemctl restart cgconfig</span><br></pre></td></tr></table></figure><p>b.将程序分配到相应的group</p><p>实验中，为了让两个进程抢CPU时间片，故意只留一个CPU在线</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lscpu</span><br><span class="line">[root@localhost ~]# echo 0 &gt; /sys/devices/system/cpu/cpu0/online</span><br><span class="line">[root@localhost ~]# echo 1 &gt; /sys/devices/system/cpu/cpu1/online</span><br></pre></td></tr></table></figure><p>手动分配：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cgexec -g cpu:lesscpu shalsum /dev/zero</span><br><span class="line">[root@localhost ~]# cgexec -g cpu:morecpu md5sum  /dev/zero</span><br><span class="line">[root@localhost ~]# top</span><br></pre></td></tr></table></figure><p>2）限制进程使用Memory</p><p>a.添加cgroup</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/cgconfig.conf</span><br><span class="line">group lessmem &#123;</span><br><span class="line">    memory &#123;</span><br><span class="line">        memory.limit_in_bytes=268435465; // 物理内存限制256M</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]# systemctl restart cgconfig</span><br></pre></td></tr></table></figure><p>b.创建内存盘</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /mnt/mem_test</span><br><span class="line">[root@localhost ~]# mount -t tmpfs /dev/shm /mnt/mem_test</span><br><span class="line">[root@localhost ~]# cgexec -g memory:lessmem dd if=/dev/zero of=/mnt/mem_test/file bs=1M count=200  //ok</span><br><span class="line">[root@localhost ~]# cgexec -g memory:lessmem dd if=/dev/zero of=/mnt/mem_test/file bs=1M count=500  //ok</span><br><span class="line">[root@localhost ~]# free -m</span><br></pre></td></tr></table></figure><p>结果为失败，因为只限制内存，没有限制swap。</p><p>c.创建cgroup</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/cgconf.conf</span><br><span class="line">group lessmem &#123;</span><br><span class="line">    memory &#123;</span><br><span class="line">        memory.limit_in_bytes=268435465; // 物理内存限制256M</span><br><span class="line">        memory.memsw.limit_in_bytes=268435465;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]# systemctl restart cgconfig</span><br></pre></td></tr></table></figure><p>d.创建内存盘并测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /mnt/mem_test</span><br><span class="line">[root@localhost ~]# mount -t tmpfs /dev/zero /mnt/mem_test</span><br><span class="line">[root@localhost ~]# cgexec -g memory:lessmem dd if=/dev/zero of=/mnt/mem_test/file bs=1M count=200  //ok</span><br><span class="line">[root@localhost ~]# cgexec -g memory:lessmem dd if=/dev/zero of=/mnt/mem_test/file bs=1M count=500  //fail</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;系统安装&quot;&gt;&lt;a href=&quot;#系统安装&quot; class=&quot;headerlink&quot; title=&quot;系统安装&quot;&gt;&lt;/a&gt;系统安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;选择稳定版操作系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最小化安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要安装gcc，make&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装完系统后更新系统&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]# yum install -y update&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;系统权限&quot;&gt;&lt;a href=&quot;#系统权限&quot; class=&quot;headerlink&quot; title=&quot;系统权限&quot;&gt;&lt;/a&gt;系统权限&lt;/h2&gt;&lt;h3 id=&quot;基本权限（rwx）&quot;&gt;&lt;a href=&quot;#基本权限（rwx）&quot; class=&quot;headerlink&quot; title=&quot;基本权限（rwx）&quot;&gt;&lt;/a&gt;基本权限（rwx）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于目录，默认权限&amp;#x3D;777-umask&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于文件，默认权限&amp;#x3D;666-umask（文件默认无执行权限）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改umask&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]# vim /etc/bashrc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        umask 002    # 普通用户&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        umask 022    # 超级用户&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fi&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]#　vim /etc/profile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        umask 002    # 普通用户&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        umask 022    # 超级用户&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bentech8.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://bentech8.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Redis性能问题排查</title>
    <link href="https://bentech8.github.io/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://bentech8.github.io/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2025-03-20T12:39:21.000Z</published>
    <updated>2025-03-24T14:45:05.806Z</updated>
    
    <content type="html"><![CDATA[<p>Redis作为内存数据库，具有非常高的性能，单个实例的OPS能够达到10W左右。</p><h2 id="确认是否Redis本身响应慢"><a href="#确认是否Redis本身响应慢" class="headerlink" title="确认是否Redis本身响应慢"></a>确认是否Redis本身响应慢</h2><p>如果你发现你的业务服务API响应延迟变长，首先你需要先排查服务内部，究竟是哪个环境拖慢了整个服务。比较高效的做法是在服务内部集成链路追踪。</p><p>如果发现确实是操作Redis的这条链路耗时变长了，那么此刻需要把焦点关注在业务服务到Redis这条链路上。</p><p>从你的业务服务到Redis这条链路变慢的原因可能也有2个：</p><ul><li>业务服务器到Redis服务器之间的网络存在问题，例如网络线路质量不佳，网络数据包在传输时存在延迟、丢包等情况。</li><li>Redis本身存在问题，需要进一步排查是什么原因导致Redis变慢。</li></ul><h2 id="Redis基准性能测试"><a href="#Redis基准性能测试" class="headerlink" title="Redis基准性能测试"></a>Redis基准性能测试</h2><p>从Redis角度来排查，是否存在导致变慢的场景，以及都有哪些因素会导致Redis的延迟增加，然后针对性的进行优化。</p><p>排除网络原因，确认你的Redis是否真的变慢了，首先需要对Redis进行基准性能测试，了解你的Redis在生产环境服务器上的基准性能。</p><p>什么是基准性能？</p><p>基准性能就是指Redis在一台负载正常的机器上，其最大的响应延迟和平均响应延迟分别是怎样的。</p><p>Redis在不同的软硬件环境下，它的性能是不同的，比如我的机器配置比较低，当延迟为2ms时，我就认为Redis变慢了，但是如果你的硬件配置比较高，那么在你的运行环境下，可能延迟在0.5ms时就可以认为Redis变慢了。所以，只有在了解你的Redis在生产环境服务器上的基准性能，才能进一步评估，当其延迟达到什么程度时，才认为Redis确实变慢了。</p><p>具体如何做？</p><p>为避免业务服务器到Redis服务器之间的网络延迟，你需要直接在Redis服务器上测试实例的响应延迟情况。</p><p>执行以下命令，就可以测试出这个实例60s内的最大响应延迟：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli -h 127.0.0.1 -p 6379 --intrinsic-latency 60</span></span><br><span class="line">Max latency so far: 1 microseconds.</span><br><span class="line">Max latency so far: 15 microseconds.</span><br><span class="line">Max latency so far: 17 microseconds.</span><br><span class="line">Max latency so far: 18 microseconds.</span><br><span class="line">Max latency so far: 31 microseconds.</span><br><span class="line">Max latency so far: 32 microseconds.</span><br><span class="line">Max latency so far: 59 microseconds.</span><br><span class="line">Max latency so far: 72 microseconds.</span><br><span class="line"></span><br><span class="line">1428669267 total runs (avg latency: 0.0420 microseconds / 42.00 nanoseconds per run).</span><br><span class="line">Worst run took 1429x longer than the average latency.</span><br></pre></td></tr></table></figure><p>从输出结果可以看到，这60s内的最大响应延迟为72微秒。</p><p>还可以执行以下命令，查看一段时间内Redis的最小、最大、平均访问延迟：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli -h 127.0.0.1 -p 6379 --latency-history -i 1</span></span><br><span class="line">min: 0, max: 1, avg: 0.13 (100 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.12 (99 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.13 (99 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.10 (99 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.13 (98 samples) -- 1.00 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.08 (99 samples) -- 1.01 seconds range</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>以上输出结果为每间隔1s，采样Redis的平均操作耗时，其结果分布在0.08~0.13ms之间。</p><p>基准性能测试方法</p><p>了解了基准性能测试方法，就可以按照以下几步，来判断你的Redis是否真的变慢了：</p><ul><li>在相同配置的服务器上，测试一个正常Redis实例的基准性能。</li><li>找到你认为可能变慢的Redis实例，测试这个实例的基准性能。</li><li>如果观察到，这个可能变慢的Redis实例的运行延迟是正常Redis基准性能的2倍以上，即可认为这个Redis实例确实变慢了。</li></ul><h2 id="Redis变慢的因素"><a href="#Redis变慢的因素" class="headerlink" title="Redis变慢的因素"></a>Redis变慢的因素</h2><h3 id="使用复杂度过高的命令"><a href="#使用复杂度过高的命令" class="headerlink" title="使用复杂度过高的命令"></a>使用复杂度过高的命令</h3><p>如何发现耗时长的命令？</p><p>Redis提供了慢日志(slowlog)命令统计功能，它记录了有哪些命令在执行时耗时比较久。</p><p>查看Redis慢日志前，你需要设置慢日志的阈值。如设置慢日志的阈值为5ms，并且保留最近500条慢日志记录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令执行耗时超过5ms，记录慢日志</span></span><br><span class="line">CONFIG SET slowlog-log-slower-than 5000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只保留最近500条慢日志</span></span><br><span class="line">CONFIG SET slowlog-max-len 500</span><br></pre></td></tr></table></figure><p>设置完成后，所有执行的命令如果操作耗时超过了5ms，都会被Redis记录下来。</p><p>此时，你执行以下命令，就可以查询到最近记录的慢日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG get 5</span><br><span class="line">1) 1) (integer) 32693       # 慢日志ID</span><br><span class="line">   2) (integer) 1593763337  # 执行时间戳</span><br><span class="line">   3) (integer) 5299        # 执行耗时(微秒)</span><br><span class="line">   4) 1) &quot;LRANGE&quot;           # 具体执行的命令和参数</span><br><span class="line">      2) &quot;user_list:2000&quot;</span><br><span class="line">      3) &quot;0&quot;</span><br><span class="line">      4) &quot;-1&quot;</span><br><span class="line">2) 1) (integer) 32692</span><br><span class="line">   2) (integer) 1593763337</span><br><span class="line">   3) (integer) 5044</span><br><span class="line">   4) 1) &quot;GET&quot;</span><br><span class="line">      2) &quot;user_info:1000&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过查看慢日志，就可以知道在什么时间间，执行了哪些命令比较耗时。</p><p>使用复杂度过高命令的场景有哪些？</p><p>如果你的应用程序执行的Redis命令有以下特点，那么可能会导致操作延迟变大：</p><ul><li>经常使用O(N)以上复杂度的命令，例如SORT、SUNION、ZUNIONSTORE聚合类命令</li><li>使用O(N)复杂度的命令，但N的值非常大</li></ul><p>第一种情况导致变慢的原因在于，Redis在操作内存数据时，时间复杂度过高，要花费更多的CPU资源。</p><p>第二种情况导致变慢的原因在于，Redis一次需要返回给客户端的数据过多，更多时间花费在数据协议的组装和网络传输过程中。</p><p>另外，我们还可以从资源使用率层面来分析，如果你的应用程序操作Redis的OPS不是很大，但Redis实例的CPU使用率却很高，那么很有可能是使用了复杂度过高的命令导致的。</p><p>除此之外，我们都知道，Redis是单线程处理客户端请求的，如果你经常使用以上命令，那么当Redis处理客户端请求时，一旦前面某个命令发生耗时，就会导致后面的请求发生排队，对于客户端来说，响应延迟也会变长。</p><p>如何解决？</p><ul><li>尽量不使用O(N)以上复杂度过高的命令，对于数据的聚合操作，放在客户端做。</li><li>执行O(N)命令，保证N尽量小(推荐N&lt;&#x3D;300)，每次获取尽量少的数据，让Redis可以及时处理返回。</li></ul><h3 id="操作bigkey"><a href="#操作bigkey" class="headerlink" title="操作bigkey"></a>操作bigkey</h3><p>如果查询慢日志发现，并不是复杂度过高的命令导致，而都是SET&#x2F;DEL这种简单命令出现在慢日志中，那么就要怀疑你的实例是否写入了bigkey。</p><p>何为bigkey?</p><p>Redis在写入数据时，需要为新的数据分配内存，相对应的，当从Redis中删除数据时，它会释放对应的内存空间。</p><p>例如一个key写入的value非常大，那么Redis在分配内存时就会比较耗时；同样的，当删除这个key时，释放内存也会比较耗时，这种类型的key我们一般称之为bigkey。</p><p>如何扫描bigkey？</p><p>Redis提供了扫描bigkey的命令，执行以下命令就可以扫描出来，一个实例中bigkey的分布情况，输出结果是以类型维度展示的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01</span></span><br><span class="line">...</span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 829675 keys in the keyspace!</span><br><span class="line">Total key length in bytes is 10059825 (avg len 12.13)</span><br><span class="line"></span><br><span class="line">Biggest string found &#x27;key:291880&#x27; has 10 bytes</span><br><span class="line">Biggest   list found &#x27;mylist:004&#x27; has 40 items</span><br><span class="line">Biggest    set found &#x27;myset:2386&#x27; has 38 members</span><br><span class="line">Biggest   hash found &#x27;myhash:3574&#x27; has 37 fields</span><br><span class="line">Biggest   zset found &#x27;myzset:2704&#x27; has 42 members</span><br><span class="line"></span><br><span class="line">36313 strings with 363130 bytes (04.38% of keys, avg size 10.00)</span><br><span class="line">787393 lists with 896540 items (94.90% of keys, avg size 1.14)</span><br><span class="line">1994 sets with 40052 members (00.24% of keys, avg size 20.09)</span><br><span class="line">1990 hashs with 39632 fields (00.24% of keys, avg size 19.92)</span><br><span class="line">1985 zsets with 39750 members (00.24% of keys, avg size 20.03)</span><br></pre></td></tr></table></figure><p>从输出结果可以清晰地看到，每种数据类型所占用的最大内存&#x2F;拥用最多元素的key是哪一个，以及每种数据类型在整个实例中的占比和平均大小&#x2F;元素数量。</p><p>这个命令的原理就是Redis在内部执行了SCAN命令，遍历了整个实例中所有的key，然后针对key的类型，分别执行STRLEN、LLEN、HLEN、SCARD、ZCARD命令，来获取string类型的长度、容器类型(List、Hash、Set、ZSet)的元素个数。</p><p>当执行这个命令时，需要注意两个问题：</p><ul><li>对线上实例进行bigkey扫描时，Redis的OPS会突增，为了降低扫描过程中对Redis的影响，最好控制下扫描频率，指定-i参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒。</li><li>扫描结果中，对于容器类型(List、Hash、Set、ZSet)的key，只能扫描出元素最多的key。但一个key的元素多，不一定表示占用内存也多，还需要根据业务情况，进一步评估内存占用情况。</li></ul><p>如何解决？</p><p>针对bigkey导致延迟的问题，有两点可以优化：</p><ul><li>业务应用尽量避免写入bigkey。</li><li>如果使用的Redis是4.0以上版本，用UNLINK命令替代DEL，此命令可以把释放key内存的操作，放到后台线程中去执行，从而降低对Redis的影响。如果使用的Redis是6.0以上版本，可以开启lazy-free机制(lazyfree-lazy-user-del &#x3D; yes)，在执行DEL命令时，释放内存也会放到后线程中执行。</li></ul><p>但即便可以使用方案二，也不建议在实例中存入bigkey。因为bigkey在很多场景下，依旧会产生性能问题。例如bigkey在分片集群模式下，对于数据的迁移也会有性能影响，以及数据过期、数据淘汰、透明大页等都会受到bigkey的影响。</p><h3 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h3><p>如果你发现，平时在操作Redis时，并没有延迟很大的情况发生，但在某个时间点突然出现一波延时，其现象表现为：<strong>变慢的时间点很有规律，例如某个整点，或者每间隔一段时间就会发生一波延迟。</strong></p><p>如果出现这种情况，那么就需要排查一下业务代码中是否存在设置大量key集中过期的情况。如果有大量的key在某个固定时间点集中过期，在这个时间点访问Redis时，就有可能导致延时变大。</p><p>为何集中过期会导致Redis延迟变大？</p><p>这就需要了解Redis的过期策略是怎样的，Redis的过期数据采用被动过期+主动过期两种策略：</p><ul><li><strong>被动过期</strong>：只有当访问某个key时，才判断这个key是否已过期，如果已过期，则从实例中删除。</li><li><strong>主动过期</strong>：Redis内部维护了一个定时任务，默认每隔100ms(1秒10次)就会从全局的过期哈希表中随机取出20个key，然后删除其中过期的key，如果过期key的比例超过了25%，则继续重复此过程，直到过期key的比例下降到25%以下，或者这次任务的执行耗时超过了25ms，才会退出循环。</li></ul><p><strong>这个主动过期key的定时任务，是在Redis主线程中执行的</strong>。也就是说如果在执行主动过期的过程中，出现了需要大量删除过期key的情况，那么此时应用程序在访问Redis时，必须要等待这个过期任务执行结束，Redis才可以响应这个客户端的请求。此时就会出现应用访问Redis延时变大。</p><p>如果此时需要过期删除的是一个bigkey，那么这个耗时会更久。而且，<strong>这个操作延迟的命令并不会记录在慢日志中</strong>。所以此时你会看到慢日志中没有操作耗时的命令，但我们的应用程序却感知到了延迟变大，其实时间都花费在了删除过期key上，这种情况需要尤为注意。</p><img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681422.jpg" class="" width="16113834681422"><p>如何排查？</p><p>1）你需要检查你的业务代码，是否存在集中过期key的逻辑。</p><p>一般集中过期使用的是expireat&#x2F;pexpireat命令，你需要在代码中搜索这个关键字。</p><p>2）通过运维手段及时发现问题</p><p>运维层面，你需要把Redis的各项运行状态数据监控起来，在Redis上执行INFO命令就可以拿到这个实例所有的运行状态数据。在这里我们需要重点关注expired_keys这一项，它代表整个实例到目前为止，累计删除过期key的数量。当这个指标在很短时间内出现了突增，需要及时报警出来，然后与业务应用报慢的时间点进行对比分析，确认时间是否一致，如果一致，则可以确认确实是因为集中过期key导致的延迟变大。</p><p>如何解决？</p><p>排查代码后，如果确实存在集中过期key的逻辑存在，但这种逻辑又是业务所必须的，那此时如何优化，同时又不对Redis产生性能影响，一般有两种方案来规避这个问题：</p><ul><li><p>集中过期key增加一个随机过期时间，把集中过期的时间打散，降低Redis清理过期key的压力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在过期时间点之后的5分钟内随机过期掉</span><br><span class="line">redis.expireat(key, expire_time + random(300))</span><br></pre></td></tr></table></figure></li><li><p>如果你使用的的Redis是4.0以上的版本，可以开启lazy-free机制，当删除过期key时，把释放内存的操作放到后台线程中执行，避免阻塞主线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 释放过期key的内存，放到后台线程执行</span><br><span class="line">lazyfree-lazy-expire yes</span><br></pre></td></tr></table></figure></li></ul><h3 id="实例内存达到上限"><a href="#实例内存达到上限" class="headerlink" title="实例内存达到上限"></a>实例内存达到上限</h3><p>如果你的Redis实例设置了内存上限maxmemory，那么也可能导致Redis变慢。</p><p>当我们把Redis当做纯缓存使用时，通常会给这个实例设置一个内存上限maxmemory，然后设置一个数据淘汰策略。而当实例的内存达到了maxmemory后，你可能会发现，在此之后每次写入新数据，操作延迟变大了。</p><p>为什么延迟变大？</p><p>原因在于，当Redis内存达到maxmemory后，每次写入新的数据之前，Redis必须先从实例中踢出一部分数据，让整个实例的内存维持在maxmemory之下，然后才能把新数据写进来。</p><p>这个踢出旧数据的逻辑也是需要消耗时间的，而具体耗时的长短，要取决于你配置的淘汰策略：</p><ul><li>allkeys-lru：不管key是否设置了过期，淘汰最近最少访问的key</li><li>volatile-lru：只淘汰最近最少访问、并设置了过期时间的key</li><li>allkeys-random：不管key是否设置了过期，随机淘汰key</li><li>volatile-random: 只随机淘汰设置了过期时间的key</li><li>volatile-ttl: 不管key是否设置了过期，淘汰即将过期的key</li><li>noeviction: 不淘汰任何key，实例内存达到maxmemory后，再写入新数据直接返回错误</li><li>allkeys-lfu: 不管key是否设置了过期，淘汰访问频率最低的key（4.0+版本支持）</li><li>volatile-lfu: 只淘汰访问频率最低、并设置了过期时间key（4.0+版本支持）</li></ul><p>具体使用哪种策略，我们需要根据具体的业务场景来配置。</p><p>一般最常用的是allkeys-lru和volatile-lru淘汰策略，它们的处理逻辑是，每次从实例中随机取出一批key（这个数量可配置），然后淘汰一个最少访问的key，之后把剩下的key暂存到一个池子中，继续随机取一批key，并与之前池子中的key比较，再淘汰一个最少访问的key。以此往复，直到实例内存降到maxmemory之下。</p><p>需要注意的是，Redis的淘汰数据的逻辑与删除过期key的逻辑一样，<strong>也是在命令真正执行之前执行的</strong>，也就是说它也会增加我们操作Redis的延迟，而且，写OPS越高，延迟也会越明显。</p><p>另外，如果此时你的Redis实例中还存储了bigkey，那么在<strong>淘汰删除bigkey释放内存时，也会耗时比较久</strong>。</p><img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681427.jpg" class=""><p>bigkey的危害到处都是，所以尽量不存储bigkey。</p><p>如何解决？</p><p>四个优化建议：</p><ul><li>避免存储bigkey，降低释放内存的耗时</li><li>淘汰策略改为随机淘汰，随机淘汰比LRU要快很多(视业务情况调整)</li><li>拆分实例，把淘汰key的压力分摊到多个实例上</li><li>如果使用的是Redis 4.0以上版本，开启lazy-free机制，把淘汰key释放内存的操作放到后台线程中执行(配置lazyfree-lazy-eviction&#x3D;yes)</li></ul><h3 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h3><p>为了保证Redis数据的安全性，我们可能会开启后台定时RDB和AOF rewrite功能。</p><p>但如果你发现，<strong>操作Redis延迟变大，都发生在Redis后台RDB和AOF rewrite期间</strong>，那你就需要排查，在这期间有可能导致变量的情况。</p><p>当Redis开启了后台RDB和AOF rewrite后，在执行时，它们都需要主进程创建出一个子进程进行数据的持久化。</p><p>主进程创建子进程，会调用操作系统提供的fork函数。</p><p>而fork在执行过程中，<strong>主进程需要拷贝自己的内存页表给子进程</strong>，如果这个实例很大，那么这个拷贝的过程也会比较耗时。而且这个fork过程会消耗大量的CPU资源，在完成fork之前，整个Redis实例会被阻塞住，无法处理任何客户端请求。</p><p>如果此时你的CPU资源本来就很紧张，那么fork的耗时会更长，甚至达到秒级，这会严重影响Redis的性能。</p><p>你可以在Redis上执行INFO命令，查看latest_fork_usec项，单位微稍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 上一次fork耗时，单位微秒</span><br><span class="line">latest_fork_usec:59477</span><br></pre></td></tr></table></figure><p>这个时间就是主进程在fork子进程期间，整个实例阻塞无法处理客户端请求的时间。</p><p>如果你发现这个耗时很久，就要警惕起来了，这意味着在这期间，你的整个Redis实例都处于不可用的状态。</p><p>除了数据持久化会生成RDB之外，当主从节点第一次建立数据同步时，主节点也创建子进程生成RDB，然后发给从节点进行一次全量同步，所以，这个过程也会对Redis产生性能影响。</p><img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681431.jpg" class=""><p>如何解决？</p><p>要想避免这种情况，你可以采取以下方案进行优化：</p><ul><li>控制Redis实例的内存：尽量在10G以下，执行fork的耗时与实例大小有关，实例越大，耗时越久</li><li>合理配置数据持久化策略：在slave节点执行RDB备份，推荐在低峰期执行，而对于丢失数据不敏感的业务(例如把Redis当做纯缓存使用)，可以关闭AOF和AOF rewrite</li><li>Redis实例不要部署在虚拟机上：fork的耗时也与系统有关，虚拟机比物理机耗时更久</li><li>降低主从库全量同步的概率：适当调大repl-backlog-size参数，避免主从全量同步</li></ul><h3 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h3><p>子进程RDB和AOF rewrite期间，除了fork耗时导致的延迟变大之外，还有一个方面也会导致性能问题，这就是操作系统是否开启了内存大页机制。</p><p>什么是内存大页？</p><p>我们都知道，应用程序向操作系统申请内存时，是按内存页进行申请的，而常规的内存页大小是4KB。</p><p>Linux内核从2.6.38开始，支持了内存大页机制，该机制允许应用程序以2MB大小为单位，向操作系统申请内存。</p><p>应用程序每次向操作系统申请的内存单位变大了，但这也意味着申请内存的耗时变长。</p><p>这对Redis会有什么影响？</p><p>当Redis在执行后台RDB和AOF rewrite时，采用fork子进程的方式来处理。但主进程fork子进程后，此时的<strong>主进程依旧是可以接收写请求的</strong>，而进来的写请求，会采用Copy On Write(写时复制)的方式操作内存数据。</p><p>也就是说，主进程一旦有数据需要修改，Redis并不会直接修改现有内存中的数据，而是<strong>先将这块内存数据拷贝出来，再修改这块新内存的数据</strong>，这就是所谓的<strong>写时复制</strong>。可以理解成谁需要发生写操作，谁就需要先拷贝，再修改。</p><p>这样做的好处是，父进程有任何写操作，并不会影响子进程的数据持久化(子进程只持久化fork这一瞬间整个实例中的所有数据即可，不关心新的数据变更，因为子进程只需要一份内存快照，然后持久化到磁盘上)。</p><p>但是请注意，主进程在拷贝内存数据时，这个阶段就涉及到新内存的申请，如果此时操作系统开启了内存大页，那么在此期间，客户端即便只修改10B的数据，<strong>Redis在申请内存时也会以2MB为单位向操作系统申请，申请内存的耗时变长，进而导致每个写请求的延迟增加，影响到Redis性能</strong>。</p><p>同样地，如果这个写请求操作的是一个bigkey，那么主进程在拷贝这个bigkey内存块时，一次申请的内存会更大，时间也会更久。可见，bigkey在这里又一次影响到了性能。</p><img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681437.jpg" class=""><p>如何解决？</p><p>很简单，你只需要关闭内存大页机制就可以了。</p><p>首先，你需要查看Redis机器是否开启了内存大页：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/kernel/mm/transparent_hugepage/enabled</span></span><br><span class="line">[always] madvise never</span><br></pre></td></tr></table></figure><p>如果输出选项是always，就表示目前开启了内存大页机制，我们需要关闭它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span></span><br></pre></td></tr></table></figure><p>其实，操作系统提供的内存大页机制，其优势是，可以在一定程度上降低应用程序申请内存的次数。</p><p>但是对于Redis这种对性能和延迟极其敏感的数据库来说，我们希望Redis在每次申请内存时，耗时尽量短，所以不建议在Redis机器上开启这个机制。</p><h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>前面我们分析了RDB和AOF rewrite对Redis性能的影响，主要关注点在fork上。</p><p>其实，关于数据持久化方面，还有影响Redis性能的因素。如果你的AOF配置不合理，还是有可能会导致性能问题。</p><p>当Redis开启AOF后，其工作原理如下：</p><ul><li>Redis执行写命令后，把这个命令写入到AOF文件内存中(write系统调用)</li><li>Redis根据配置的AOF刷盘策略，把AOF内存数据刷到磁盘上(fsync系统调用)</li></ul><p>为了保证AOF文件数据的安全性，Redis提供了3种刷盘机制：</p><ul><li><p>appendfsync always</p><p>主线程每次执行写操作后立即刷盘，此方案会占用比较大的磁盘IO资源，但数据安全性最高。</p></li><li><p>appendfsync no</p><p>主线程每次写操作只写内存就返回，内存数据什么时候刷到磁盘，交由操作系统决定，此方案对性能影响最小，但数据安全性也最低，Redis宕机时丢失的数据取决于操作系统刷盘时机。</p></li><li><p>appendfsync everysec</p><p>主线程每次写操作只写内存就返回，然后由后台线程每隔1s执行一次刷盘操作(触发fsync系统调用)，此方案对性能影响相对较小，但当Redis宕机时会丢失1s的数据。</p></li></ul><p>下面我们依次来分析，这几个机制对性能的影响。</p><p>如果你的AOF配置为appendfsync always，那么Redis每处理一次写操作，都会把这个命令写入到磁盘中才返回，整个过程都是主线程执行的，这个过程必须会加重Redis写负担。原因很简单，操作磁盘要比操作内存慢几百倍，采用这个配置会严重拖慢Redis的性能，因此不建议把AOF刷盘方式配置为always。</p><p>如果你的AOF配置为appendfsync no，那么Redis每次写操作只写内存，什么时候把内存中的数据刷到磁盘，交给操作系统决定，此方案对Redis的性能影响最小，但当Redis宕机时，会丢失一部分数据，为了数据的安全性，一般我们也不采取这种配置。如果你的Redis只用作纯缓存，对于数据丢失不敏感，采用这种方式也是可以的。</p><p>如果你的AOF配置为appendfsync everysec，那么Redis主线程写完内存就返回，具体的刷盘操作放到后台线程中执行，后台线程每隔1s把内存中的数据刷到磁盘中。</p><p>everysec这种方案既兼顾了性能，又尽可能的保证了数据安全，是不是觉得很完美？</p><p><strong>采用这种方案也要警惕一下，因为这种方案还是存在导致Redis延迟变大的情况发生，甚至会阻塞整个Redis</strong>。</p><p>试想这样一种情况：当Redis后台线程在执行AOF文件刷盘时，如果此时磁盘的IO负载很高，那这个后台线程在执行刷盘操作(fsync系统调用)时就会被阻塞住。</p><p>此时的主线程依旧会接收写请求，紧接着，主线程又需要把数据写到文件内存中(write系统调用)，但此时的后台子线程由于磁盘负载过高，导致fsync发生阻塞，迟迟不能返回，那主线程在执行write系统调用时，也会被阻塞住，直到后台线程fsync执行完成后，主线程执行write才能成功返回。这个过程中，主线程依旧有阻塞的风险。</p><p>所以，尽管你的AOF配置为appendfsync everysec，也不能掉以轻心，要警惕磁盘压力过大导致的Redis有性能问题。</p><img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681440.jpg" class=""><p>什么情况下会导致磁盘IO负载过大？以及如何解决这个问题？</p><p>主要有以下几种情况：</p><ul><li>子进程正在执行AOF rewrite，这个过程会占用大量的磁盘IO资源</li><li>有其他应用程序正在执行大量的写文件操作，也会占用磁盘IO资源</li></ul><p>第一种情况是Redis的AOF后台子线程刷盘操作，撞上了子进程AOF rewrite。</p><p>Redis提供了一个配置项，当子进程在AOF rewrite期间，可以让后台子线程不执行刷盘(不触发fsync系统调用)操作。</p><p>这相当于在AOF rewrite期间，临时把appendfsync设置为none，配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF rewrite期间，AOF后台子线程不进行刷盘操作</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相当于在这期间，临时把appendfsync设置为none</span></span><br><span class="line">no-appendfsync-on-rewrite yes</span><br></pre></td></tr></table></figure><p>当然，开启这个配置项，在AOF rewrite期间，如果实例发生宕机，那么此时会丢失更多的数据，性能和数据安全性需要权衡后进行选择。</p><p>如果占用磁盘资源的是其他应用程序，你需要定位到是哪个应用程序在大量写磁盘，然后把这个应用程序迁移到其他机器上执行就好了，避免对Redis产生影响。</p><p>当然，如果你对Redis的性能和数据安全性都有很高的要求，那么建议从<strong>硬件层面</strong>来优化，更换为SSD磁盘，提高磁盘的IO能力，保证AOF期间有充足的磁盘资源可以使用。</p><h3 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h3><p>很多时候，我们在部署服务时，为了提高服务性能，降低应用程序在多个CPU核心之间的上下文切换带来的性能损耗，通常采用的方案是进程绑定CPU的方式提高性能。</p><p>但在部署Redis时，如果你需要绑定CPU来提高其性能，我建议你仔细斟酌后再做操作。</p><p>为什么？</p><p>因为Redis在绑定CPU时，是有很多讲究的，如果你不了解Redis的运行原理，随意绑定CPU不仅不会提高性能，甚至有可能会带来相反的效果。</p><p>我们知道，一般现代的服务器会有多个CPU，而每个CPU又包含多个物理核心，每个物理核心又分为多个逻辑核心，每个物理核下的逻辑核共用L1&#x2F;L2 Cache。</p><p>而Redis Server除了主线程服务客户端请求之外，还有创建子进程、子线程。</p><p>其中子进程用于数据持久化，而子线程用于执行一些比较耗时的操作，例如异步释放fd、异步AOF刷盘、异步lazy-free等等。</p><p>如果你把Redis进程只绑定了一个CPU逻辑核心上，那么当Redis在进行数据持久化时，fork出的子进程会继承父进程的CPU使用偏好。</p><p><strong>而此时的子进程会消耗大量的CPU资源进行数据持久化(把实例数据全部扫描出来需要耗费CPU)，这就会导致子进程会与主进程发生CPU争抢，进而影响到主进程服务客户端请求，访问延迟变大</strong>。</p><p>如何解决？</p><p>如果你确实想要绑定CPU，可以优化的方案是，不要让Redis进程只绑定在一个CPU逻辑核上，而是绑定在多个逻辑核心上，而且，绑定的多个逻辑核心最好是同一个物理核心，这样它们还可以共用L1&#x2F;L2 Cache。</p><p>当然，即便我们把Redis绑定在多个逻辑核心上，只能在一定程度上缓解主进程、子进程、后台线程在CPU资源上的竞争。</p><p>因为这些子进程、子线程还是会在多个逻辑核心上进行切换，存在性能损耗。</p><p>再进一步，我们可以让主进程、子进程、后台线程分别绑定在固定的CPU核心上，不让它们来回切换，这样一来，他们各自使用的CPU资源互不影响。</p><p>Redis在6.0版本已经推出了这个功能，我们可以通过以下配置，对主进程、子进程、后台线程、后台RDB进程、AOF rewrite进程，绑定固定的CPU逻辑核心：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis Server和IO线程绑定至CPU核心0，2，4，6</span></span><br><span class="line">server_cpulist 0-7:2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台子线程绑定到CPU核心1，3</span></span><br><span class="line">bio_cpulist 1,3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台AOF rewrite进程绑定到CPU核心8，9，10，11</span></span><br><span class="line">aof_rewrite_cpulist 8-11</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台RDB进程绑定到CPU核心1，10，11</span></span><br><span class="line">bgsave_cpulist 1,10-1</span><br></pre></td></tr></table></figure><p>如果你使用的正好是Redis6.0版本，就可以通过以上配置，来进一步提高Redis性能。</p><p>一般来说，Redis的性能已经足够优秀，除非你对Redis的性能有更加严苛的要求，否则不建议你绑定CPU。</p><h3 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h3><p>如果你发现Redis突然变得非常慢，<strong>每次的操作耗时都达到了几面毫秒甚至秒级</strong>，那此时你就需要检查Redis是否使用到了Swap，在这种情况下Redis基本上已经无法提供高性能服务了。</p><p>什么是Swap？为什么使用Swap会导致Redis的性能下降？</p><p>操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是Swap。</p><p>问题就在于，当内存中的数据被换到磁盘上后，Redis再访问这些数据时，就需要从磁盘上读取，访问磁盘的速度要比访问内存慢几百倍。</p><p><strong>尤其是针对Redis这种对性能要求极高、性能极其敏感的数据库来说，这种操作延迟是无法接受的</strong>。</p><p>此时，你需要检查Redis机器的内存使用情况，确认是否存在使用了Swap:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先找到Redis的进程ID</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -aux | grep redis-server</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Redis Swap使用情况</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/<span class="variable">$pid</span>/smaps | egrep <span class="string">&#x27;^(Swap|Size)&#x27;</span></span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Size:               1256 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:                  4 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:                132 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:              63488 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:                132 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:              65404 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:            1921024 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这个结果会列出Redis进程的内存使用情况。</p><p>每一行Size表示Redis所用的一块内存大小，Size下面的Swap就表示这块Size大小的内存，有多少数据已经被换到磁盘上了，如果这两个值相等，说明这块内存的数据都已经完全被换到磁盘上了。</p><p>如果只是少量数据被换到磁盘上，例如每一块Swap占对应Size的比例很小，那影响并不是很大。<strong>如果是几百兆甚至上GB的内存被换到了磁盘上</strong>，那么你就需要警惕了，这种情况Redis的性能肯定会急剧下降。</p><p>如何解决？</p><p>此时的解决方案是：</p><ul><li><p>增加机器的内存，让Redis有足够的内存可以使用。</p></li><li><p>整理内存空间，释放出足够的内存供Redis使用，然后释放Redis的Swap，让Redis重新使用内存。</p></li></ul><p>释放Redis的Swap过程通常要重启实例，为了避免重启实例对业务的影响，一般会先进行主从切换，然后释放旧主节点的Swap，重启旧主节点实例，待从库数据同步完成后，再进行主从切换即可。</p><p>可见，当Redis使用到Swap后，此时的Redis性能基本达不到高性能的要求，所以需要提前预防。预防的办法是你需要对Redis机器的内存和Swap使用情况进行监控，在内存不足或使用到Swap时报警出来，及时处理。</p><h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><p>Redis的数据都存储在内存中，当我们的应用程序频繁修改Redis中的数据时，就有可能会导致Redis产生内存碎片。</p><p>内存碎片会降低Redis的内存使用率，我们可以通过INFO命令，得到这个实例的内存碎片率：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Memory</span><br><span class="line">used_memory:5709194824</span><br><span class="line">used_memory_human:5.32G</span><br><span class="line">used_memory_rss:8264855552</span><br><span class="line">used_memory_rss_human:7.70G</span><br><span class="line">...</span><br><span class="line">mem_fragmentation_ratio:1.45</span><br></pre></td></tr></table></figure><p>mem_fragmentation_ratio &#x3D; used_memory_rss&#x2F;used_memory</p><p>其中used_memory表示Redis存储数据的内存大小，而used_memory_rss表示操作系统实际分配给Redis进程的大小。</p><p>如果mem_fragmentation_ratio &gt; 1.5，说明内存碎片率已经超过了50%，这时我们就需要采取一此措施来降低内存碎片了。</p><p>如何解决？</p><p>解决的方案一般有：</p><ul><li>如果你使用的是Redis 4.0以下的版本，只能通过重启实例来解决。</li><li>如你使用的是Redis 4.0以上版本，它正好提供了自动碎片整理的功能，可以通过配置开启碎片自动整理。</li></ul><p><strong>但是，开启内存碎片整理，它也有可能会导致Redis性能下降</strong>。</p><p>原因在于，Redis的碎片整理工作也是主进程中执行的，当其进行碎片整理时，必然会消耗CPU资源，产生更多的耗时，从而影响到客户端的请求。</p><p>所以，当你需要开启这个功能时，最好提前测试评估它对Redis的影响。</p><p>Redis碎片整理的参数配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启自动内存碎片整理(总开关)</span></span><br><span class="line">activedefrag yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存使用100MB以下，不进行碎片整理</span></span><br><span class="line">active-defrag-ignore-bytes 100mb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存碎片率超过10%，开始碎片整理</span></span><br><span class="line">active-defrag-threshold-lower 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存碎片率超过100%，尽最大努力碎片整理</span></span><br><span class="line">active-defrag-threshold-upper 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存碎片整理占用CPU资源最小百分比</span></span><br><span class="line">active-defrag-cycle-min 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存碎片整理占用CPU资源最大百分比</span></span><br><span class="line">active-defrag-cycle-max 25</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">碎片整理期间，对于List/Set/Hash/ZSet类型元素一次Scan的数量</span></span><br><span class="line">active-defrag-mzx-scan-fields 1000</span><br></pre></td></tr></table></figure><p>你需要结合Redis机器的负载情况，以及应用程序可接受的延迟范围进行评估，合理调整碎片整理的参数，尽可能降低碎片整理期间对Redis的影响。</p><h3 id="网络带宽过载"><a href="#网络带宽过载" class="headerlink" title="网络带宽过载"></a>网络带宽过载</h3><p>如果以上产生性能问题的场景，你都规避掉了，而且Redis也稳定运行了很长时间，但在某个时间点之后开始，操作Redis突然开始变慢了，而且一直持续下去，这种情况又是什么原因导致？</p><p>此时你需要排查一下Redis机器的网络带宽是否过载，是否存在某个实例把整个机器的网络带宽占满的情况。</p><p>网络带宽过载的情况下，服务器在TCP层和网络层就会出现数据包发送延迟、丢包等情况。</p><p>Redis的高性能，除了操作内存之外，就在于网络IO了，如果网络IO存在瓶颈，那么也会严重影响Redis的性能。</p><p>如果确实出现这种情况下，你需要及时确认占满网络带宽Redis实例，如果属于正常的业务访问，那就需要及时扩容或迁多实例了，避免因为这个实例流量过大，影响这个机器的其他实例。</p><p>运维层面，你需要对Redis机器的各项指标增加监控，包括网络流量，在网络流量达到一定阈值时提前报警，及时确认和扩容。</p><h3 id="其他原因"><a href="#其他原因" class="headerlink" title="其他原因"></a>其他原因</h3><p>1）频繁短连接</p><p>你的业务应用，应该使用长连接操作Redis，避免频繁的短连接。</p><p>频繁的短连接会导致Redis大量时间耗费在连接的建立和释放上，TCP的三次握手和四次挥手同样也会增加访问延迟。</p><p>2）运维监控</p><p>要想提前预知Redis变慢的情况发生，必不可少的就是做好完善的监控。</p><p>监控其实就是对采集Redis的各项运行时指标，通常的做法是监控程序定时采集Redis的INFO信息，然后根据INFO信息中的状态数据做数据展示和报警。</p><p>这里提醒一下，在写一些监控脚本，或使用开源的监控组件时，也不以掉以轻心。</p><p>在写监控脚本访问Redis时，尽量采用长连接的方式采集状态信息，避免频繁短连接。同时，还要注意控制访问Redis的频率，避免影响到业务请求。</p><p>在使用一些开源的监控组件时，最好了解一下这些组件的实现原理，以及正确配置这些组件，防止出现监控组件发生Bug，导致短时大量操作Redis，影响Redis性能的情况发生。</p><p>3）其他程序争抢资源</p><p>最后需要提醒的是，你的Redis机器最好专机专用，只用来部署Redis实例，不要部署其他应用程序，尽量给Redis提供一个相对“安静”的环境，避免其它程序占用CPU、内存、磁盘资源，导致分配给Redis的资源不足而受到影响。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是在使用Redis过程中，常见的可能导致延迟、甚至阻塞的问题场景，以及如何快速定位和分析这些问题，并且针对性地提供了解决方案。</p><p>这时汇总成了思维导图，方便排查Redis性能问题时，快速分析和定位。</p><img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681446.png" class="">]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis作为内存数据库，具有非常高的性能，单个实例的OPS能够达到10W左右。&lt;/p&gt;
&lt;h2 id=&quot;确认是否Redis本身响应慢&quot;&gt;&lt;a href=&quot;#确认是否Redis本身响应慢&quot; class=&quot;headerlink&quot; title=&quot;确认是否Redis本身响应慢&quot;&gt;&lt;/a&gt;确认是否Redis本身响应慢&lt;/h2&gt;&lt;p&gt;如果你发现你的业务服务API响应延迟变长，首先你需要先排查服务内部，究竟是哪个环境拖慢了整个服务。比较高效的做法是在服务内部集成链路追踪。&lt;/p&gt;
&lt;p&gt;如果发现确实是操作Redis的这条链路耗时变长了，那么此刻需要把焦点关注在业务服务到Redis这条链路上。&lt;/p&gt;
&lt;p&gt;从你的业务服务到Redis这条链路变慢的原因可能也有2个：&lt;/p&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://bentech8.github.io/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://bentech8.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL调优</title>
    <link href="https://bentech8.github.io/2025/03/15/DB-MySQL%E8%B0%83%E4%BC%98/"/>
    <id>https://bentech8.github.io/2025/03/15/DB-MySQL%E8%B0%83%E4%BC%98/</id>
    <published>2025-03-15T15:05:40.000Z</published>
    <updated>2025-03-20T09:14:03.348Z</updated>
    
    
    
    
    <category term="MySQL" scheme="https://bentech8.github.io/categories/MySQL/"/>
    
    
    <category term="DataBase" scheme="https://bentech8.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>Argo Rollouts</title>
    <link href="https://bentech8.github.io/2025/03/14/argo-rollouts/"/>
    <id>https://bentech8.github.io/2025/03/14/argo-rollouts/</id>
    <published>2025-03-14T07:39:17.000Z</published>
    <updated>2025-03-16T10:10:17.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Argo-Rollouts简介"><a href="#Argo-Rollouts简介" class="headerlink" title="Argo Rollouts简介"></a>Argo Rollouts简介</h2><p>Argo Rollouts是一个Kubernetes Operator实现，它为Kubernetes提供更加高级的部署能力，如蓝绿、金丝雀、金丝雀分析、实验和渐进式交付功能，为云原生应用和服务实现自动化、基于GitOps的逐步交付。</p><p>支持如下特性：</p><ul><li>蓝绿更新策略</li><li>金丝雀更新策略</li><li>更加细粒度、加权流量拆分</li><li>自动回滚</li><li>手动判断</li><li>可定制的指标查询和业务KPI分析</li><li>Ingress控制器集成：NGINX，ALB</li><li>Metrics指标集成：Prometheus、Wavefront、Kayenta、Web、Kubernetes Jobs、Datadog、New Relic、Graphite、InfluxDB</li></ul><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>与Deployment对象类似，Argo Rollout控制器将管理ReplicaSets的创建、缩放和删除，这些ReplicaSet由Rollout资源中的spec.template定义，使用与Deployment对象相同的pod模板。</p><p>当spec.template变更时，这会向Argo Rollouts控制器发出信号，表示将引入新的ReplicaSet，控制器将使用spec.strategy字段内的策略来确定从旧ReplicaSet到新ReplicaSet的rollout将如何进行，一旦这个新的ReplicaSet被放大(可以选择通过一个Analysis)，控制器会将其标记为稳定。</p><p>如果在spec.template从稳定的ReplicaSet过渡到新的ReplicaSet的过程中发生另一次变更(即在发布过程中更改了应用程序版本)，那么之前的新ReplicaSet将缩小，并且控制器将尝试反映更新spec.template字段的ReplicaSet。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Argo-Rollouts简介&quot;&gt;&lt;a href=&quot;#Argo-Rollouts简介&quot; class=&quot;headerlink&quot; title=&quot;Argo Rollouts简介&quot;&gt;&lt;/a&gt;Argo Rollouts简介&lt;/h2&gt;&lt;p&gt;Argo Rollouts是一个Kubernetes Operator实现，它为Kubernetes提供更加高级的部署能力，如蓝绿、金丝雀、金丝雀分析、实验和渐进式交付功能，为云原生应用和服务实现自动化、基于GitOps的逐步交付。&lt;/p&gt;
&lt;p&gt;支持如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;蓝绿更新策略&lt;/li&gt;
&lt;li&gt;金丝雀更新策略&lt;/li&gt;
&lt;li&gt;更加细粒度、加权流量拆分&lt;/li&gt;
&lt;li&gt;自动回滚&lt;/li&gt;
&lt;li&gt;手动判断&lt;/li&gt;
&lt;li&gt;可定制的指标查询和业务KPI分析&lt;/li&gt;
&lt;li&gt;Ingress控制器集成：NGINX，ALB&lt;/li&gt;
&lt;li&gt;Metrics指标集成：Prometheus、Wavefront、Kayenta、Web、Kubernetes Jobs、Datadog、New Relic、Graphite、InfluxDB&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="https://bentech8.github.io/categories/Kubernetes/"/>
    
    
    <category term="Kubernetes" scheme="https://bentech8.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Argo CD</title>
    <link href="https://bentech8.github.io/2025/03/14/argo-cd/"/>
    <id>https://bentech8.github.io/2025/03/14/argo-cd/</id>
    <published>2025-03-14T03:32:37.000Z</published>
    <updated>2025-03-16T09:53:00.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ArgoCD简介"><a href="#ArgoCD简介" class="headerlink" title="ArgoCD简介"></a>ArgoCD简介</h2><p>Argo CD是一个基于Kubernetes的声明式的GitOps工具。</p><h3 id="GitOps"><a href="#GitOps" class="headerlink" title="GitOps"></a>GitOps</h3><p>GitOps是以Git为基础，使用CI&#x2F;CD来更新运行在云原生环境的应用，它秉承了DevOps的核心理念——“构建它并交付它(you built it you ship it)”。</p><p>当开发人员将开发完成的代码推送到git仓库会触发CI制作镜像并推送到镜像仓库。</p><p>CI处理完成后，可以手动或者自动修改应用配置，再将其推送到git仓库。</p><p>GitOps会同时对比目标状态和当前状态，如果两者不一致会触发CD将新的配置部署到集群中。</p><p>其中，目标状态是Git中的状态，现有状态是集群里的应用状态。</p><h3 id="ArgoCD"><a href="#ArgoCD" class="headerlink" title="ArgoCD"></a>ArgoCD</h3><p>Argo CD 遵循GitOps模式，使用Git存储库存储所需应用程序的配置。</p><p>Kubernetes清单可以通过以下几种方式指定：</p><ul><li>kustomize</li><li>helm</li><li>ksonnet</li><li>jsonnet</li><li>基于YAML&#x2F;json</li><li>配置管理插件配置的任何自定义配置管理工具</li></ul><p>Argo CD实现为kubernetes控制器，它持续监视运行中的应用程序，并将当前的活动状态与期望的目标状态进行比较(如Git repo中指定的那样)。如果已部署的应用程序的活动状态偏离了目标状态，则认为是OutOfSync。Argo CD报告和可视化这些差异，同时提供了方法，可以自动或手动将活动状态同步回所需的目录状态。在Git repo中对所需目标状态所做的任何修改都可以自动应用并反映到指定的目标环境中。</p><h3 id="ArgoCD优势"><a href="#ArgoCD优势" class="headerlink" title="ArgoCD优势"></a>ArgoCD优势</h3><ul><li>应用定义、配置和环境信息是声明式的，并且可以进行版本控制。</li><li>应用部署和生命周期管理是全自动化的，是可审计的，清晰易懂。</li><li>Argo CD是一个独立的部署工具，支持对多个环境、多个Kubernetes集群上的应用进行统一部署和管理。</li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul><li>官方文档：<a href="https://argo-cd.readthedocs.io/en/stable/">https://argo-cd.readthedocs.io/en/stable/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;ArgoCD简介&quot;&gt;&lt;a href=&quot;#ArgoCD简介&quot; class=&quot;headerlink&quot; title=&quot;ArgoCD简介&quot;&gt;&lt;/a&gt;ArgoCD简介&lt;/h2&gt;&lt;p&gt;Argo CD是一个基于Kubernetes的声明式的GitOps工具。&lt;/p&gt;
&lt;h3 id=&quot;GitOps&quot;&gt;&lt;a href=&quot;#GitOps&quot; class=&quot;headerlink&quot; title=&quot;GitOps&quot;&gt;&lt;/a&gt;GitOps&lt;/h3&gt;&lt;p&gt;GitOps是以Git为基础，使用CI&amp;#x2F;CD来更新运行在云原生环境的应用，它秉承了DevOps的核心理念——“构建它并交付它(you built it you ship it)”。&lt;/p&gt;
&lt;p&gt;当开发人员将开发完成的代码推送到git仓库会触发CI制作镜像并推送到镜像仓库。&lt;/p&gt;</summary>
    
    
    
    <category term="DevOps" scheme="https://bentech8.github.io/categories/DevOps/"/>
    
    
    <category term="DevOps" scheme="https://bentech8.github.io/tags/DevOps/"/>
    
    <category term="Kubernetes" scheme="https://bentech8.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置详解</title>
    <link href="https://bentech8.github.io/2025/03/13/nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://bentech8.github.io/2025/03/13/nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-13T09:54:28.000Z</published>
    <updated>2025-03-14T03:33:16.218Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p>nginx配置文件通常位于&#x2F;etc&#x2F;nginx&#x2F;nginx.conf和&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;目录。其中&#x2F;etc&#x2F;nginx&#x2F;nginx.conf用于存放全局配置信息。&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;目录用于存放业务配置信息。</p><h3 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h3><p>nginx.conf配置文件主要存放全局配置信息，主要有以下几个部分组成：</p><ul><li>全局块：配置影响Nginx全局的指令。</li><li>events块：配置影响Nginx服务器与客户端网络连接的指令。</li><li>http块：配置HTTP服务器相关指令。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="comment"># 定义运行nginx的用户和用户组</span></span><br><span class="line"><span class="attribute">worker_processes</span>auto;</span><br><span class="line"><span class="comment"># 定义工作进程数，通常设置为CPU核心数</span></span><br><span class="line"><span class="attribute">error_log</span>/home/wwwlogs/nginx_error.log<span class="literal">crit</span>;</span><br><span class="line"><span class="comment"># 定义错误日志文件路径</span></span><br><span class="line"><span class="attribute">pid</span>/usr/local/nginx/logs/nginx.pid;</span><br><span class="line"><span class="comment"># 定义Nginx主进程的PID文件路径</span></span><br><span class="line">events&#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="comment"># 使用epoll模型</span></span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">51200</span>;</span><br><span class="line">    <span class="comment"># 每个工作进程的最大连接数</span></span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 允许一个工作进程同时接受多个连接</span></span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">    <span class="comment"># 包含MIME类型配置文件</span></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    <span class="comment"># 默认MIME类型</span></span><br><span class="line">    <span class="attribute">log_format</span> main</span><br><span class="line">        <span class="string">&#x27;<span class="variable">$remote_addr</span> - &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &quot;<span class="variable">$http_user_agent</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$request_length</span> <span class="variable">$request_time</span> <span class="variable">$upstream_addr</span> &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$upstream_response_length</span> <span class="variable">$upstream_response_time</span> <span class="variable">$upstream_status</span>&#x27;</span>;</span><br><span class="line">    <span class="comment"># 定义日志格式</span></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line">    <span class="comment"># 定义访问日志文件路径和格式</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 开启高效文件传输模式</span></span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 防止网络阻塞</span></span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 防止网络延迟</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="comment"># 保持连接的超时时间</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 开启Gzip压缩</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">    <span class="comment"># 定义需要压缩的文件类型</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="comment"># 包含基他配置文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="etc-nginx-conf-d-default-con"><a href="#etc-nginx-conf-d-default-con" class="headerlink" title="&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.con"></a>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.con</h3><p>default.conf用于存放业务配置信息，主要有以下几部分组成：</p><ul><li>server块：配置虚拟主机的相关指令。</li><li>location块：配置请求的路由和处理规则。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># 监听端口</span></span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="comment"># 定义服务器名称(域名)</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">        <span class="comment"># 定义根目录</span></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        <span class="comment"># 定义默认首页文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        <span class="comment"># 反向代理到后端服务器</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="comment"># 将客户端请求的原始Host字段(即域名)传递给后端服务器。</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="comment"># 将客户端的真实IP传递给后端服务器。$remote_addr是nginx内置变量，表示客户端的真实IP地址</span></span><br><span class="line">        <span class="attribute">proxy_set</span> header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="comment"># 传递客户端IP列表。包含客户端请求经过的所有代理服务器的IP地址列表，格式为client,proxy1,proxy2。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /static/ &#123;</span><br><span class="line">        <span class="attribute">alias</span> /var/www/static/;</span><br><span class="line">        <span class="comment"># 定义静态文件目录</span></span><br><span class="line">        <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">        <span class="comment"># 设置缓存时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">503</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">    <span class="comment"># 定义错误页面</span></span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>注意配置文件中的结尾有“;”作为结束。</p></li><li><p>每次实验修改完配置文件后需要重新加载nginx配置才会生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">栓检查配置文件语法</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li></ul><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="nginx状态统计"><a href="#nginx状态统计" class="headerlink" title="nginx状态统计"></a>nginx状态统计</h3><ul><li><p>安装nginx时将–with-http_stub_status_module模块开启。</p></li><li><p>修改nginx配置文件(写入要访问的server标签中)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /nginx_status &#123;</span><br><span class="line">    <span class="attribute">stub_status</span><span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">access_log</span><span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端访问网址：<a href="http://ip/nginx_status">http://IP/nginx_status</a></p><ul><li>Active connections：表示当前的活动连接数；</li><li>server accetps handled request：表示已经处理的连接信息。三个数字依次表示已处理的连接数、成功的TCP握手次数、已处理的请求数。</li></ul></li></ul><h3 id="目录保护"><a href="#目录保护" class="headerlink" title="目录保护"></a>目录保护</h3><ul><li><p>原理和apache的目录保护原理一样。</p></li><li><p>在状态统计的location中添加：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auth_basic</span> <span class="string">&quot;Welcome to nginx_status!&quot;</span>;</span><br><span class="line"><span class="attribute">auth_basic_user_file</span>/usr/local/nginx/html/htpasswd.nginx;</span><br></pre></td></tr></table></figure></li><li><p>使用http的命令htpasswd进行用户密码文件的创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -c /usr/local/nginx/html/htpasswd.nginx user</span><br></pre></td></tr></table></figure></li><li><p>重启nginx并再次访问统计页面</p></li></ul><h3 id="基于IP的身份验证-访问控制"><a href="#基于IP的身份验证-访问控制" class="headerlink" title="基于IP的身份验证(访问控制)"></a>基于IP的身份验证(访问控制)</h3><ul><li><p>在状态统计的location中添加：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">allow</span><span class="number">192.168.88.1</span>;</span><br><span class="line"><span class="attribute">deny</span><span class="number">192.168.88.0</span>/<span class="number">24</span>;</span><br><span class="line"><span class="comment"># 仅允许192.168.88.1访问服务器</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="nginx的虚拟主机-基于域名"><a href="#nginx的虚拟主机-基于域名" class="headerlink" title="nginx的虚拟主机(基于域名)"></a>nginx的虚拟主机(基于域名)</h3><ul><li><p>提前准备好两个网站的域名，并且规划好两个网站网页存放目录</p></li><li><p>在Nginx主配置文件中并列编写两个server标签，并分别写好各自信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>blog.atguigu.com;</span><br><span class="line">    <span class="attribute">index</span> index.html index htm index.php;</span><br><span class="line">    <span class="attribute">root</span> html/blog;</span><br><span class="line">    <span class="attribute">access_log</span>logs/blog-access.log main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span><span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>bbs.atguigu.com;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">    <span class="attribute">root</span>html/bbs;</span><br><span class="line">    <span class="attribute">access_log</span>logs/bbs-access.log main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分别访问两个不同的域名验证结果</p></li></ul><h3 id="nginx的反向代理"><a href="#nginx的反向代理" class="headerlink" title="nginx的反向代理"></a>nginx的反向代理</h3><p>代理：找别人代替你去完成一件你完成不成的事(代购)，代理的对象是客户端</p><p>反向代理：替成厂家卖东西的人就叫反向代理(烟酒代理)，代理的对象是服务器端</p><ul><li><p>在另外一台机器上安装apache，启动并填写测试页面</p></li><li><p>在nginx服务器的配置文件中添加（写在某一个网站的server标签内）</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.88.100:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启nginx，并使用客户端访问测试</p></li></ul><h3 id="负载调度-负载均衡"><a href="#负载调度-负载均衡" class="headerlink" title="负载调度(负载均衡)"></a>负载调度(负载均衡)</h3><p>负载均衡（Load Balance）其意思就是将任务分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其他关键任务服务器等，从而共同完成工作任务。</p><ul><li><p>使用默认的rr轮询算法，修改nginx配置文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bbs &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.88.100:80</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.88.200:80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>http://bbs;<span class="comment"># 添加反向代理，代理地址填写upstream声明的名字</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;<span class="comment"># 重写请求头部，保证网站所有页面都可访问成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启并设置两台88.100和88.200的主机</p><p>安装apache并设置不同的index.html页面内容(设置不同页面是为了看实验效果)</p></li><li><p>重启nginx，并使用客户端访问测试</p></li></ul><p>rr算法实现加权轮询</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bbs &#123;</span><br><span class="line">    <span class="attribute">server</span><span class="number">192.168.88.100:80</span> weight=<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">server</span><span class="number">192.168.88.200:80</span> weight=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nginx实现https（证书-rewrite）"><a href="#nginx实现https（证书-rewrite）" class="headerlink" title="nginx实现https（证书+rewrite）"></a>nginx实现https（证书+rewrite）</h3><ul><li><p>安装nginx时，需要将–with-http_ssl_module模块开启</p></li><li><p>在对应要进行加密的server标签中添加以下内容开启SSL</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="attribute">ssl</span><span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>/usr/local/nginx/conf/ssl/atguigu.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>/usr/local/nginx/conf/ssl/atguigu.key;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span><span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span><span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">&quot;......&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成证书和密钥文件</p></li><li><p>设置http自动跳转https功能</p><p>原有的server标签修改监听端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="attribute">listen</span><span class="number">443</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增以下server标签(利用虚拟主机+rewrite的功能)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span><span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>bbs.atguigu.com;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://bbs.atguigu.com permancent;</span><br><span class="line">    <span class="attribute">root</span>html;</span><br><span class="line">    <span class="attribute">index</span>index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重启nginx，并测试</p></li></ul><h3 id="Nginx防盗链"><a href="#Nginx防盗链" class="headerlink" title="Nginx防盗链"></a>Nginx防盗链</h3><p>Nginx防盗链(Referer-based Access Control)是一种防止其他网站盗用你的资源(如图片、视频、文件等)的技术。通过检查请求头中的Referer字段，Nginx可以判断请求是否来自合法的来源，从而阻止非法盗链。</p><p>Nginx防盗链配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>                <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>           example.com;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|png|gif|mp4|flv|pdf)$</span> &#123;</span><br><span class="line">        <span class="attribute">valid_referers</span>    <span class="literal">none</span> <span class="literal">blocked</span> example.com <span class="regexp">*.example.com</span>;</span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">            <span class="attribute">return</span>        <span class="number">403</span>;</span><br><span class="line">            <span class="comment"># return      302 https://example.com/anti-leech.html;</span></span><br><span class="line">            <span class="comment"># 或者可以重定向到一个提示页面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">root</span>              /var/www/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>location ~* .(jpg|jpeg|png|gif|mp4|flv|pdf)$</p><p>匹配需要防盗链的文件类型(图片、视频、PDF等)，~*表示不区分大小写的正则匹配。</p></li><li><p>valid_referers</p><p>定义合法的Rerferer来源：</p><ul><li><p>none：允许没有Referer字段的请求（如直接访问）。</p></li><li><p>blocked：允许Referer字段被防火墙或代理修改的请求。</p><p>blocked实际效果：</p><ul><li>如果请求头中没有Referer字段，Nginx会将其视为blocked，并允许请求通过。</li><li>如果Referer字段被修改为非标准值（如unknown或空值），Nginx也会将其视为blocked，并允许请求通过。</li></ul></li><li><p>example.com和*.example.com：允许来自example.com及其子域名的请求。</p></li></ul></li><li><p>$invalid_referer</p><p>如果Referer不在valid_referers列表中，该变量为1，否则为0。</p></li><li><p>if ($invalid_referer)</p><p>如果Referer不合法，执行以下操作：</p><ul><li>return 403：返回403禁止访问。</li><li>return 302 <a href="https://example.com/anti-leech.html%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E4%B8%80%E4%B8%AA%E6%8F%90%E7%A4%BA%E9%A1%B5%E9%9D%A2%E3%80%82">https://example.com/anti-leech.html：重定向到一个提示页面。</a></li></ul></li><li><p>root &#x2F;var&#x2F;www&#x2F;html：定义资源的根目录。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;配置文件结构&quot;&gt;&lt;a href=&quot;#配置文件结构&quot; class=&quot;headerlink&quot; title=&quot;配置文件结构&quot;&gt;&lt;/a&gt;配置文件结构&lt;/h2&gt;&lt;p&gt;nginx配置文件通常位于&amp;#x2F;etc&amp;#x2F;nginx&amp;#x2F;nginx.conf和&amp;#x2F;etc&amp;#x2F;nginx&amp;#x2F;conf.d&amp;#x2F;目录。其中&amp;#x2F;etc&amp;#x2F;nginx&amp;#x2F;nginx.conf用于存放全局配置信息。&amp;#x2F;etc&amp;#x2F;nginx&amp;#x2F;conf.d&amp;#x2F;目录用于存放业务配置信息。&lt;/p&gt;
&lt;h3 id=&quot;nginx-conf&quot;&gt;&lt;a href=&quot;#nginx-conf&quot; class=&quot;headerlink&quot; title=&quot;nginx.conf&quot;&gt;&lt;/a&gt;nginx.conf&lt;/h3&gt;&lt;p&gt;nginx.conf配置文件主要存放全局配置信息，主要有以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局块：配置影响Nginx全局的指令。&lt;/li&gt;
&lt;li&gt;events块：配置影响Nginx服务器与客户端网络连接的指令。&lt;/li&gt;
&lt;li&gt;http块：配置HTTP服务器相关指令。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://bentech8.github.io/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx原理</title>
    <link href="https://bentech8.github.io/2025/03/12/nginx%E5%8E%9F%E7%90%86/"/>
    <id>https://bentech8.github.io/2025/03/12/nginx%E5%8E%9F%E7%90%86/</id>
    <published>2025-03-11T22:03:50.000Z</published>
    <updated>2025-03-13T09:55:12.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx概述"><a href="#Nginx概述" class="headerlink" title="Nginx概述"></a>Nginx概述</h2><p>Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔、赛索耶夫为俄罗斯访问第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。</p><p>Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件(IMAP&#x2F;POP3)代理服务器，在BSD-like协议下发行。其特点是占有内存少，并发能力强。</p><h2 id="Nginx工作原理"><a href="#Nginx工作原理" class="headerlink" title="Nginx工作原理"></a>Nginx工作原理</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步与异步的重点在消息通知的方式上，也就是调用结果的通知方式不同。</p><p>同步：当一个同步调用发出去后，调用者要一直等待调用的结果通知后，才能进行后续的执行。</p><p>异步：当一个异步调用发出去后，调用者不必一直等待调用结果的返回，异步调用要想获得结果，一般有两种方式：</p><ul><li>主动轮询异步调用的结果；</li><li>被调用方通过callback(回调通知)来通知调用方调用结果。</li></ul><p>实例解释：</p><p>同步取快递：小明收到快递将送达的短信，在楼下一直等到快递送达。</p><p>异步取快递：小时收到快递将送达的短信，快递到楼下后，小明再下楼去取。</p><p>异步取快递，小明知道快递到达楼下有两种方式：</p><ul><li>不停的电话问快递小哥到了没有，即主动轮询；</li><li>快递小哥到楼下后，打电话通知小明，然后小明下楼取快递，既定回调通知。</li></ul><h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞的重点在于进&#x2F;线程等待消息时候的行为，也就是在等待消息的时候，当前进&#x2F;线程是挂起状态，还是非挂起状态。</p><p>阻塞：调用在发出去后，在消息返回之前，当前进&#x2F;线程会被挂起，直到有消息返回，当前进&#x2F;线程才会被激活。</p><p>非阻塞：调用在发出去后，不会阻塞当前进&#x2F;线程，而会立即返回。</p><p>同步与异步，重点在于消息通知的方式；阻塞与非阻塞，重点在于等消息时候的行为。所以，就出现了四种重合方式：</p><ul><li><p>同步阻塞</p><p>小明收到信息后，啥都不干，等快递。</p></li><li><p>同步非阻塞</p><p>小明收到信息后，边刷微博，边等着取快递。</p></li><li><p>异步阻塞</p><p>小明收到信息后，啥都不干，一直等着快递员通知他取快递。</p></li><li><p>异步非阻塞</p><p>小明收到信息后，边刷着微博，边等快递员通知他取快递。</p></li></ul><p>大部分程序的I&#x2F;O模型都是同步阻塞的，单个进程每次只在一个文件描述符上执行I&#x2F;O操作，每次I&#x2F;O系统调用都会阻塞，直到完成数据传输，传统的服务器采用的就是同步阻塞的多进程模型。一个server采用一个进程负责一个request的方式，一个进程负责一个request，直到会话结束。进程数就是并发数，而操作系统支持的进程数是有限的，且进程数越多，调度的开销也越大，因此无法面对高并发。</p><h3 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h3><p>Nginx采用了异步非阻塞的方式工作。先了解一下I&#x2F;O多路复用中的epoll模型：</p><p>当连接有I&#x2F;O事件产生的时候，epoll就会去告诉进程哪个连接有I&#x2F;O事件产生，然后进程就去处理这个事件。</p><p>例如：小明家楼下有一个收发室，每次有快递到了，门卫就先代收并做了标记；然后通知小明去取送给小明的快递。</p><h3 id="Nginx工作原理-1"><a href="#Nginx工作原理-1" class="headerlink" title="Nginx工作原理"></a>Nginx工作原理</h3><p>Nginx配置use epoll后，以异步非阻塞方式工作，能够轻松处理百万级的并发连接。</p><p>处理过程：</p><p>每进来一个request，会有一个worker进程去处理。但不是全程的处理，处理到可能发生阻塞的地方。比如向后端服务器转发request，并等待请求返回。那么，这个处理的worker不会这么傻等着，他会在发送完请求后，注册一个事件：“如果后端服务器返回了，告诉我一声，我再接着干”。于是他就休息去了。此时如果再有新的request进来，他就可以很快再按这种方式处理。而一旦后端服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。通过这种快速处理，快速释放请求的方式，达到同样的配置可以处理更大并发量的目的。</p><h2 id="Nginx工作模式"><a href="#Nginx工作模式" class="headerlink" title="Nginx工作模式"></a>Nginx工作模式</h2><h3 id="master-worker模式"><a href="#master-worker模式" class="headerlink" title="master-worker模式"></a>master-worker模式</h3><p>该模式下，nginx启动成功后，会有一个master进程和至少一个worker进程。master进程负责处理系统信号，加载配置，管理worker进程(启动，杀死，监控，发送消息&#x2F;信号等)。worker进程负责处理具体的业务逻辑，也就是说，对外部来说，真正提供服务的是worker进程。生产环境下一般使用这种模式，这个模式有以下优点：</p><ul><li>稳定性高，只要还有worker进程存活，就能够提供服务，并且一个worker进程挂掉master进程会立即启动一个新的worker进程，保证worker进程数量不变，降低服务中断的概率。</li><li>配合linux的cpu亲和性配置，可以充分利用多核cpu的优势，提升性能。</li><li>处理信号&#x2F;配置重新加载&#x2F;升级时可以做到尽可能少或者不中断服务(热重启)。</li></ul><h3 id="单进程模式"><a href="#单进程模式" class="headerlink" title="单进程模式"></a>单进程模式</h3><p>单进程模式下，nginx启动后只有一个进程，nginx的所有工作都由这个进程负责。由于只有一个进程，因此可以很方便地利用gdb等工具进行调试。该模式下不支持nginx的平滑升级功能，任何的信号处理都可能造成服务中断，并且由于是单进程，进程挂掉后，在没有外部监控的情况下，无法重启服务。因此，该模式一般只在开发阶段和调试时使用，生产环境下不会使用。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Nginx概述&quot;&gt;&lt;a href=&quot;#Nginx概述&quot; class=&quot;headerlink&quot; title=&quot;Nginx概述&quot;&gt;&lt;/a&gt;Nginx概述&lt;/h2&gt;&lt;p&gt;Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&amp;#x2F;POP3&amp;#x2F;SMTP服务。Nginx是由伊戈尔、赛索耶夫为俄罗斯访问第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。&lt;/p&gt;
&lt;p&gt;Nginx是一款轻量级的Web服务器&amp;#x2F;反向代理服务器及电子邮件(IMAP&amp;#x2F;POP3)代理服务器，在BSD-like协议下发行。其特点是占有内存少，并发能力强。&lt;/p&gt;
&lt;h2 id=&quot;Nginx工作原理&quot;&gt;&lt;a href=&quot;#Nginx工作原理&quot; class=&quot;headerlink&quot; title=&quot;Nginx工作原理&quot;&gt;&lt;/a&gt;Nginx工作原理&lt;/h2&gt;&lt;h3 id=&quot;同步与异步&quot;&gt;&lt;a href=&quot;#同步与异步&quot; class=&quot;headerlink&quot; title=&quot;同步与异步&quot;&gt;&lt;/a&gt;同步与异步&lt;/h3&gt;</summary>
    
    
    
    <category term="Nginx" scheme="https://bentech8.github.io/categories/Nginx/"/>
    
    
  </entry>
  
  <entry>
    <title>日志管理</title>
    <link href="https://bentech8.github.io/2025/03/07/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/"/>
    <id>https://bentech8.github.io/2025/03/07/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</id>
    <published>2025-03-07T11:48:29.000Z</published>
    <updated>2025-03-10T11:51:58.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志简介"><a href="#日志简介" class="headerlink" title="日志简介"></a>日志简介</h2><h3 id="日志相关服务"><a href="#日志相关服务" class="headerlink" title="日志相关服务"></a>日志相关服务</h3><p>在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。Redhat认为syslogd已经不能满足在工作中的需求，rsyslogd相比syslogd具有一些新的特点：</p><ul><li>基于TCP网络协议传输日志信息；</li><li>更安全的网络传输方式；</li><li>有日志消息的及时分析框架；</li><li>后台数据库；</li><li>配置文件中可以写简单的逻辑判断；</li><li>与syslog配置文件相兼容。</li></ul><h3 id="系统中常见的日志文件"><a href="#系统中常见的日志文件" class="headerlink" title="系统中常见的日志文件"></a>系统中常见的日志文件</h3><table><thead><tr><th>日志文件</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;var&#x2F;log&#x2F;cron</td><td>记录了系统定时任务相关的日志。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;cups&#x2F;</td><td>记录打印信息的日志。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;dmesg</td><td>记录了系统在开机时内核自检的信息。也可以使用dmesg命令直接查看内核自检信息。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;btmp</td><td>记录错误登录的日志。这个文件是二进制文件，不能直接vim查看，而要使用lastb命令查看。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;lastlog</td><td>记录系统中所有用户最后一次登录时间的日志。这个文件也是二进制文件，不能直接vim查看，而要使用lastlog命令查看。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;mailog</td><td>记录邮件信息。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;message</td><td>记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;secure</td><td>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录。比如说系统的登录，ssh的登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;wtmp</td><td>永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vim，而需要使用last命令来查看。</td></tr><tr><td>&#x2F;var&#x2F;run&#x2F;utmp</td><td>记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样这个文件不能直接vim，而要使用w,who,users等命令来查询。</td></tr></tbody></table><p>除了系统默认的日志之外，采用RPM方式安装的系统服务也会默认把日志记录在&#x2F;var&#x2F;log&#x2F;目录中(源码包安装的服务日志是在源码包指定目录中)。不过这些日志不是由rsyslogd服务来记录和管理的，而是各个服务器使用自己的日志管理文档来记录自身日志。</p><table><thead><tr><th>日志文件</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;var&#x2F;log&#x2F;httpd&#x2F;</td><td>RPM包安装的apache服务的默认日志目录</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;mail&#x2F;</td><td>RPM包安装的邮件服务的额外日志目录</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;samba&#x2F;</td><td>RPM包安装的samba服务的日志目录</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;sssd&#x2F;</td><td>守护进程安全服务目录</td></tr></tbody></table><h2 id="日志服务-rsyslogd"><a href="#日志服务-rsyslogd" class="headerlink" title="日志服务(rsyslogd)"></a>日志服务(rsyslogd)</h2><h3 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h3><p>只要是由日志服务rsyslogd记录的日志文件，他们的格式是一样的。基本日志格式包含以下四列：</p><ul><li>事件产生的时间</li><li>发生事件的服务器的主机名</li><li>产生事件的服务名或程序名</li><li>事件的具体信息</li></ul><h3 id="rsyslogd服务的配置文件"><a href="#rsyslogd服务的配置文件" class="headerlink" title="rsyslogd服务的配置文件"></a>rsyslogd服务的配置文件</h3><h4 id="etc-rsyslog-d-50-default-conf"><a href="#etc-rsyslog-d-50-default-conf" class="headerlink" title="&#x2F;etc&#x2F;rsyslog.d&#x2F;50-default.conf"></a>&#x2F;etc&#x2F;rsyslog.d&#x2F;50-default.conf</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auth,authpriv.*/var/log/auth.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务名称[连接符号]日志等级    日志记录位置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">认证相关服务.所有日志等级     记录在/var/log/auth.log日志中</span></span><br></pre></td></tr></table></figure><ul><li><p>服务名称</p><p>我们首先需要确定rsyslogd服务可以识别哪些服务的日志，也可以理解为以下这些服务委托了rsyslogd服务来代为管理日志。这些服务如下表所示：</p><table><thead><tr><th>服务名称</th><th>说明</th></tr></thead><tbody><tr><td>auth（LOG_AUTH）</td><td>安全和认证相关消息(不推荐使用authpriv替代)</td></tr><tr><td>authpriv（LOG_AUTHPRIV）</td><td>安全和认证相关消息（私有的）</td></tr><tr><td>cron（LOG_CRON）</td><td>系统定时任务cront和at产生的日志</td></tr><tr><td>daemon（LOG_DAEMON）</td><td>和各个守护进程相关的日志</td></tr><tr><td>ftp（LOG_FTP）</td><td>ftp守护进程产生的日志</td></tr><tr><td>kern（LOG_KERN）</td><td>内核产生的日志（不是用户进程产生的）</td></tr><tr><td>local0-local7（LOG_LOCAL0-7）</td><td>为本地使用预留的服务</td></tr><tr><td>lpr（LOG_LPR）</td><td>打印产生的日志</td></tr><tr><td>Mail（LOG_MAIL）</td><td>邮件收发信息</td></tr><tr><td>news（LOG_NEWS）</td><td>与新闻服务器相关的日志</td></tr><tr><td>syslog（LOG_SYSLOG）</td><td>有syslogd服务产生的日志信息（虽然服务名称已经改为rsyslogd，但是很多配置都还是沿用了syslogd的，这里并没有修改服务名）。</td></tr><tr><td>user（LOG_USER）</td><td>用户等级类别的日志信息</td></tr><tr><td>uucp（LOG_UUCP）</td><td>uucp子系统的日志信息，uucp是早期linux系统进行数据传递的协议，后来也常用在新闻组服务中</td></tr></tbody></table></li><li><p>连接符号</p><p>日志服务连接日志等级的格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志服务[连接符号]日志等级日志记录位置</span><br></pre></td></tr></table></figure><p>在这里连接符号可以识别为：</p><ul><li>“.”代表只要比后面的等级高的（包含该等级）日志都记录下来。比如：”cron.info”代表cron服务产生的日志只要日志等级大于等于info级别，就记录。</li><li>“.&#x3D;”代表只记录所需等级的日志，其他等级的都不记录。比如：“*.&#x3D;emerg”代表任何日志服务产生的日志，只要等级是emerg等级就记录。这种用法极少见，了解就好。</li><li>“.!”代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。</li></ul></li><li><p>日志等级</p><table><thead><tr><th>等级名称</th><th>说明</th></tr></thead><tbody><tr><td>debug（LOG_DEBUG）</td><td>一般的调试信息说明</td></tr><tr><td>info（LOG_INFO）</td><td>基本的通知信息</td></tr><tr><td>notice（LOG_NOTICE）</td><td>普通信息，但是有一定的重要性</td></tr><tr><td>warning（LOG_WARNING）</td><td>警告信息，但是还不会影响到服务或系统的运行</td></tr><tr><td>err（LOG_ERR）</td><td>错误信息，一般达到err等级的信息以及可以影响到服务或系统的运行了</td></tr><tr><td>crit（LOG_CRIT）</td><td>临界状况信息，比err等级还要严重</td></tr><tr><td>alert（LOG_ALERT）</td><td>警告状态信息，比crit还要严重。必须立即采取行动</td></tr><tr><td>emerg（LOG_EMERG）</td><td>疼痛等级信息，系统已经无法使用了</td></tr><tr><td>*</td><td>代表所有日志等级，比如：“authpriv.*”代表authpriv认证信息服务产生的日志，所有的日志等级都记录</td></tr></tbody></table><p>日志等这里还可以识别”none”，如果日志等级是none，就说明忽略这个日志服务，该服务的所有日志都不再记录。</p></li><li><p>日志记录位置</p><p>日志记录位置就是当前日志输出到哪个日志文件中保存，当然也可以把日志输出到印机打印，或者输出到远程日志服务器上（当然日志服务器要允许接收才行）。日志的记录位置也是固定的：</p><ul><li><p>日志文件的绝对路径</p><p>这是最常见的日志保存方法，如“&#x2F;var&#x2F;log&#x2F;secure”就是保存系统验证和授权信息日志的。</p></li><li><p>系统设备文件</p><p>如“&#x2F;dev&#x2F;lp0”代表第一台打印机，如果日志保存位置是打印机设备的话，当有日志时就会在打印机打印（不太符合可持续发展战略）。</p></li><li><p>转发给远程主机</p><p>因为可以选择使用TCP协议和UDP协议传输日志信息，所以有两种发送格式。如使用“@192.168.0.210:514”，就会把日志内容使用UDP协议发送到192.168.0.210的UDP 514端口上；如果使用”@@192.168.0.210:514”就会把日志内容使用TCP协议发送到192.168.0.210的TCP 514端口上，其中514是日志服务默认端口。当然只要192.168.0.210同意接收此日志，就可以把日志内容保存在日志服务器上。</p></li><li><p>用户名</p><p>如“root”，就会把日志发送给root用户，当然root要在线，否则就收不到日志信息了。发送日志给用户时，可以使用“*”代表发送给所有在线用户，如“mail.* *”就会把mail服务产生的所有级别的日志发送给所有在线用户。如果需要把日志发送给多个在线用户，用户名之间用“,”分隔。</p></li></ul></li></ul><p>忽略或丢弃日志。如果接受日志的对象是“~”，代表这个日志不会记录，而被直接丢弃。如“local3.* ~”代表忽略local3服务类型所有的日志都不记录。</p><h4 id="etc-rsyslog-conf配置文件内容"><a href="#etc-rsyslog-conf配置文件内容" class="headerlink" title="&#x2F;etc&#x2F;rsyslog.conf配置文件内容"></a>&#x2F;etc&#x2F;rsyslog.conf配置文件内容</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rsyslog.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/rsyslog.conf configuration file <span class="keyword">for</span> rsyslog</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># For more information install rsyslog-doc and see</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/share/doc/rsyslog-doc/html/configuration/index.html</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default logging rules can be found in /etc/rsyslog.d/50-default.conf</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载模块</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### MODULES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载imuxsock模块，为本地系统登录提供支持</span></span><br><span class="line">module(load=&quot;imuxsock&quot;) # provides support for local system logging</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载immark模块，提供标记信息的能力</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">module(load=<span class="string">&quot;immark&quot;</span>)  <span class="comment"># provides --MARK-- message capability</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载UDP模块，允许使用UDP的514端口接收采用UDP协议转发的日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides UDP syslog reception</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">module(load=<span class="string">&quot;imudp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imudp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载TCP模块，允许使用TCP的514端口接收采用TCP协议转发的日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides TCP syslog reception</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">module(load=<span class="string">&quot;imtcp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imtcp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides kernel logging support and <span class="built_in">enable</span> non-kernel klog messages</span></span><br><span class="line">module(load=&quot;imklog&quot; permitnonkernelfacility=&quot;on&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义全局设置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### GLOBAL DIRECTIVES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Filter duplicated messages</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">RepeatedMsgReduction on</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Set the default permissions for all log files.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$FileOwner</span> syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileGroup adm</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileCreateMode 0640</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DirCreateMode 0755</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Umask 0022</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToUser syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToGroup syslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Where to place spool and state files</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Include all config files in /etc/rsyslog.d/</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 包含/etc/rsyslog.d/目录中所有的&quot;.conf&quot;子配置文件。也就是说这个目录中的所有子配置文件也同时生效</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IncludeConfig /etc/rsyslog.d/*.conf</span></span><br></pre></td></tr></table></figure><h3 id="定义自己的日志"><a href="#定义自己的日志" class="headerlink" title="定义自己的日志"></a>定义自己的日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rsyslog.d/60-custom.conf</span><br><span class="line">*.crit/var/log/alert.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把所有服务的<span class="string">&quot;临界点&quot;</span>以上的错误都保存在/var/log/alert.log日志中</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# systemctl restart syslog</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll /var/log/alert.log</span><br></pre></td></tr></table></figure><h2 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h2><h3 id="日志文件的命名规则"><a href="#日志文件的命名规则" class="headerlink" title="日志文件的命名规则"></a>日志文件的命名规则</h3><p>日志轮替最主要的作用就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除。那么旧的日志文件改名之后，如何命名呢？主要依靠&#x2F;etc&#x2F;logrotate.conf配置文件中“dateext”参数：</p><ul><li>如果配置文件中拥有”dateext”参数，那么日志会用日期来作为日志文件的后缀，例如“secure-20180605”。这样的话日志文件名不会重叠，所以也就不需要日志文件的改名，只需要保存指定的日志个数，删除多余的日志文件即可。</li><li>如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为”secure.1”，然后新建”secure”日志，用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为”secure.1”，然后也会新建”secure”日志，用来保存新的日志，以此类推。</li></ul><h3 id="logrotate配置文件"><a href="#logrotate配置文件" class="headerlink" title="logrotate配置文件"></a>logrotate配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/logrotate.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see <span class="string">&quot;man logrotate&quot;</span> <span class="keyword">for</span> details</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">global options <span class="keyword">do</span> not affect preceding include directives</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每周对日志文件进行一次轮替</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rotate <span class="built_in">log</span> files weekly</span></span><br><span class="line">weekly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use the adm group by default, since this is the owning group</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">of /var/log/.</span></span><br><span class="line">su root adm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存4个日志文件，也就是说如果进行了5次日志轮替，就会删除第一个备份日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">keep 4 weeks worth of backlogs</span></span><br><span class="line">rotate 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在日志轮替时，自动创建新的日志文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create new (empty) <span class="built_in">log</span> files after rotating old ones</span></span><br><span class="line">create</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用日期作为日志轮替文件的后缀</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use <span class="built_in">date</span> as a suffix of the rotated file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">dateext</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志文件是否压缩，如果取消注释，则日志会在转储的同时进行压缩</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment this <span class="keyword">if</span> you want your <span class="built_in">log</span> files compressed</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">compress</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含/etc/logrotate.d/目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来，进行日志轮替。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">packages drop <span class="built_in">log</span> rotation information into this directory</span></span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">system-specific logs may also be configured here.</span> </span><br></pre></td></tr></table></figure><p>以上日志配置为默认配置，如果需要轮替的日志没有设定独立的参数，那么都会遵守以上参数。如果轮替日志配置了独立参数，那么独立参数优先级更高。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/logrotate.d/wtmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">no packages own wtmp -- we<span class="string">&#x27;ll rotate it here</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">以下参数仅对此目录有效</span></span></span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line">    missingok</span><br><span class="line">    # 每月对日志文件进行一次轮替</span><br><span class="line">    monthly</span><br><span class="line">    # 建立的新日志文件,权限是0664,所有者是root，所属组是utmp组</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    # 日志文件最小轮替大小是1MB。也就是日志一定要超过1MB才会轮替，否则就算时间达到一个月，也不进行日志转储</span><br><span class="line">    minsize 1M</span><br><span class="line">    # 仅保留一个日志备份。也就是只有wtmp和wtmp.1日志保留而已</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logrotate配置文件的主要参数，通过如下表说明：</p><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>daily</td><td>日志的轮替周期是每天</td></tr><tr><td>weekly</td><td>日志的轮替周期是每周</td></tr><tr><td>monthly</td><td>日志的轮替周期是每月</td></tr><tr><td>rotate 数字</td><td>保留的日志文件的个数。0指没有备份</td></tr><tr><td>compress</td><td>日志轮替时，旧的日志进行压缩</td></tr><tr><td>create mode owner group</td><td>建立新日志，同时指定新日志的权限与所有者和所属组。如create 0600 root utmp</td></tr><tr><td>mail address</td><td>当日志轮替时，输出内容通过邮件发送到指定的邮件地址。如mail <a href="mailto:&#97;&#x61;&#x61;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;">aaa@163.com</a></td></tr><tr><td>missingok</td><td>如果日志不存在，则忽略该日志的警告信息</td></tr><tr><td>notifempty</td><td>如果日志为空文件，则不进行日志轮替</td></tr><tr><td>minsize 大小</td><td>日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替</td></tr><tr><td>size 大小</td><td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。如size 100k</td></tr><tr><td>dateext</td><td>使用日期作为日志轮替文件的后缀。如secure-20180605</td></tr><tr><td>sharedscripts</td><td>在此关键字之后的脚本只执行一次</td></tr><tr><td>prerotate&#x2F;endscript</td><td>在日志轮替之前执行脚本命令。endscript标示prerotate脚本结束。</td></tr><tr><td>postrotate&#x2F;endscript</td><td>在日志轮替之后执行脚本命令。endscript标示postrotate脚本结束。</td></tr></tbody></table><p>这些参数中较为不好理解的应该就是prerotate&#x2F;endscript和postrotate&#x2F;endscript参数了。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/var/log/httpd/error.log &#123;</span><br><span class="line">    rotate 5</span><br><span class="line">    mail www@my.org</span><br><span class="line">    size 100k</span><br><span class="line">    # 以下脚本只执行一次</span><br><span class="line">    sharedscripts</span><br><span class="line">    # 在日志轮替结束之后，执行以下脚本</span><br><span class="line">    postrotate</span><br><span class="line">    # 重启apache服务</span><br><span class="line">        /usr/bin/killall -HUP httpd</span><br><span class="line">    endscript</span><br><span class="line">    # 脚本结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prerotate和postrotate主要用于在日志轮替的同时，执行指定的脚本，一般用于日志轮替之后重启服务。这里强调，如果你的日志是写入rsyslog服务的配置文件的，那么把新日志加入logrotate后，一定要重启rsyslog服务，否则你会发现虽然新日志建立了，但是数据还是写入了旧的日志当中。那是因为虽然logrotate知道日志轮替了，但是rsyslog服务并不知道。同理，如果你的日志不是被rsyslog管理，如源码包安装的Apache、Nginx等服务，则需要重启Apache或Nginx服务，否则日志也不能正常轮替。</p><h3 id="把自己的日志加入日志轮替"><a href="#把自己的日志加入日志轮替" class="headerlink" title="把自己的日志加入日志轮替"></a>把自己的日志加入日志轮替</h3><p>1）方法一</p><p>直接在&#x2F;etc&#x2F;logrotate.conf配置文件中写入该日志的轮替策略，从而把日志加入轮替。</p><p>2）方法二</p><p>在&#x2F;etc&#x2F;logrotate.d&#x2F;目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可以把日志加入轮替。推荐使用此方法，因为系统中需要轮替的日志非常多，如果全部直接写入&#x2F;etc&#x2F;logrotate.conf配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。</p><p>举个例子，如果需要把Nginx服务的日志加入日志轮替，则也需要重启Nginx服务。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/date/logs/nginx/access/access.log /date/logs/nginx/access/default.log &#123;</span><br><span class="line">daily</span><br><span class="line">rotate 15</span><br><span class="line">sharedscripts</span><br><span class="line">postrotate</span><br><span class="line"># 重启rsyslog服务</span><br><span class="line">/bin/kill -HUP $(/bin/cat /var/run/syslogd.pid) &amp;&gt;/dev/null</span><br><span class="line"># 重启nginx服务</span><br><span class="line">/bin/kill -HUP $(/bin/cat /usr/local/nginx/logs/nginx.pid) &amp;&gt;/dev/null</span><br><span class="line">endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="logrotate命令"><a href="#logrotate命令" class="headerlink" title="logrotate命令"></a>logrotate命令</h3><p>日志轮替之所以可以在指定的时间备份日志，其实也要依赖系统定时任务。如果大家还记录&#x2F;etc&#x2F;cron&#x2F;daily&#x2F;目录，就会发现这个目录中是有logrotate文件，logrotate通过这个文件依赖定时任务执行的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# logrotate [选项] 配置文件名</span><br><span class="line">选项：</span><br><span class="line">如果此命令没有选项，则会按照配置文件中的条件进行日志轮替</span><br><span class="line">-v:显示日志轮替过程。加了-v选项，会显示日志的轮替的过程</span><br><span class="line">-f:强制进行日志轮替。不管日志轮替的条件是否已经符合，强制配置文件中所有的日志进行轮替</span><br></pre></td></tr></table></figure><p>执行logrotate命令，并查看下执行过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# logrotate -v /etc/logrotate.conf</span><br><span class="line">...</span><br><span class="line">rotating pattern: /var/log/wtmp  monthly (1 rotations)</span><br><span class="line">empty log files are rotated, only log files &gt;= 1048576 bytes are rotated, old logs are removed</span><br><span class="line">switching euid from 0 to 0 and egid from 0 to 4 (pid 39834)</span><br><span class="line">considering log /var/log/wtmp</span><br><span class="line">  Now: 2025-03-10 19:45</span><br><span class="line">  Last rotated at 2024-08-26 09:05</span><br><span class="line">  log does not need rotating (&#x27;minsize&#x27; directive is used and the log size is smaller than the minsize value)</span><br><span class="line">switching euid from 0 to 0 and egid from 4 to 0 (pid 39834)</span><br></pre></td></tr></table></figure><p>强制进行一次日志轮替，看看有什么效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# logrotate -vf /etc/logrotate.conf</span><br><span class="line">...</span><br><span class="line">rotating pattern: /var/log/wtmp  forced from command line (1 rotations)</span><br><span class="line">empty log files are rotated, only log files &gt;= 1048576 bytes are rotated, old logs are removed</span><br><span class="line">switching euid from 0 to 0 and egid from 0 to 4 (pid 40773)</span><br><span class="line">considering log /var/log/wtmp</span><br><span class="line">  Now: 2025-03-10 19:48</span><br><span class="line">  Last rotated at 2024-08-26 09:05</span><br><span class="line">  log needs rotating                                 # 日志需要轮替</span><br><span class="line">rotating log /var/log/wtmp, log-&gt;rotateCount is 1</span><br><span class="line">dateext suffix &#x27;-20250310&#x27;                           # 提取日期参数</span><br><span class="line">glob pattern &#x27;-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]&#x27;</span><br><span class="line">renaming /var/log/wtmp.1 to /var/log/wtmp.2 (rotatecount 1, logstart 1, i 1), </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">旧的日志被重命名</span></span><br><span class="line">renaming /var/log/wtmp to /var/log/wtmp.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新日志文件</span></span><br><span class="line">creating new /var/log/wtmp mode = 0664 uid = 0 gid = 43</span><br><span class="line">removing old log /var/log/wtmp.2</span><br><span class="line">switching euid from 0 to 0 and egid from 4 to 0 (pid 40773)</span><br></pre></td></tr></table></figure><p>logrotate命令使用“-f”选项之后，就不管日志是否已经符合了日志轮替条件，而强制把所有的日志都进行了轮替。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;日志简介&quot;&gt;&lt;a href=&quot;#日志简介&quot; class=&quot;headerlink&quot; title=&quot;日志简介&quot;&gt;&lt;/a&gt;日志简介&lt;/h2&gt;&lt;h3 id=&quot;日志相关服务&quot;&gt;&lt;a href=&quot;#日志相关服务&quot; class=&quot;headerlink&quot; title=&quot;日志相关服务&quot;&gt;&lt;/a&gt;日志相关服务&lt;/h3&gt;&lt;p&gt;在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。Redhat认为syslogd已经不能满足在工作中的需求，rsyslogd相比syslogd具有一些新的特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于TCP网络协议传输日志信息；&lt;/li&gt;
&lt;li&gt;更安全的网络传输方式；&lt;/li&gt;
&lt;li&gt;有日志消息的及时分析框架；&lt;/li&gt;
&lt;li&gt;后台数据库；&lt;/li&gt;
&lt;li&gt;配置文件中可以写简单的逻辑判断；&lt;/li&gt;
&lt;li&gt;与syslog配置文件相兼容。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;系统中常见的日志文件&quot;&gt;&lt;a href=&quot;#系统中常见的日志文件&quot; class=&quot;headerlink&quot; title=&quot;系统中常见的日志文件&quot;&gt;&lt;/a&gt;系统中常见的日志文件&lt;/h3&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bentech8.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux操作系统性能调优</title>
    <link href="https://bentech8.github.io/2025/03/06/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <id>https://bentech8.github.io/2025/03/06/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</id>
    <published>2025-03-06T15:13:48.000Z</published>
    <updated>2025-03-06T16:44:00.781Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU调优"><a href="#CPU调优" class="headerlink" title="CPU调优"></a>CPU调优</h2><p>目标：最大化CPU利用率，减少上下文切换和延迟。</p><h3 id="调整CPU频率策略"><a href="#调整CPU频率策略" class="headerlink" title="调整CPU频率策略"></a>调整CPU频率策略</h3><p>将CPU频率设置为’performance’模式，确保CPU始终以最高频率运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cpufrequtils工具</span></span><br><span class="line">sudo apt install cpufrequtils</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置为performance模式</span></span><br><span class="line">sudo cpufreq-set -g performance</span><br></pre></td></tr></table></figure><h3 id="绑定进程到特定CPU核心"><a href="#绑定进程到特定CPU核心" class="headerlink" title="绑定进程到特定CPU核心"></a>绑定进程到特定CPU核心</h3><p>使用’taskset’将关键进程绑定到特定CPU核心，减少上下文切换。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -cp 0,1 &lt;pid&gt;</span><br></pre></td></tr></table></figure><h3 id="优化中断处理"><a href="#优化中断处理" class="headerlink" title="优化中断处理"></a>优化中断处理</h3><p>将中断处理分散到多个CPU核心，避免单个CPU过载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2 | sudo tree /proc/irq/&lt;irq_number&gt;/smp_affinity</span><br></pre></td></tr></table></figure><h2 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h2><p>目标：减少内存碎片化，降低交换分区使用频率。</p><h3 id="调整Swappiness"><a href="#调整Swappiness" class="headerlink" title="调整Swappiness"></a>调整Swappiness</h3><p>降低swappiness值，减少系统使用交换分区（swap）的频率。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时生效</span></span><br><span class="line">sudo sysctl vm.swappiness=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久生效,在/etc/sysctl.conf下添加</span></span><br><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure><p>在读取swap交换分区中的数据时，由于数据需要从磁盘中读取，因此可能会比物理内存中读取慢得多。</p><p>Linux中的swap交换分区是类似于Windows的虚拟内存，它的作用是在物理内存使用完之后，将磁盘空间(也就是swap分区)虚拟成内存来使用。它的功能就是在内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出来让别的程序运行。</p><h3 id="调整内存分配策略"><a href="#调整内存分配策略" class="headerlink" title="调整内存分配策略"></a>调整内存分配策略</h3><p>设置vm.overcommit_memory为1，允许系统超额分配内存。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl vm.overcommit_memory=1</span><br></pre></td></tr></table></figure><p>可选值：</p><ul><li>0：表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</li><li>1：表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</li><li>2：表示内核允许分配超过所有物理内存和交换空间总和的内存。</li></ul><p>Linux对大部分申请的内存的请求都回复“yes”，以便能跑更多更大的程序。因为申请内存后，并不会马上使用内存。这种技术叫做overcommit。当Linux发现内存不足时，会发生OOM killer(OOM&#x3D;out-of-memory)。它会选择杀死一些进程(用户态进程，不是内核线程)，以便释放内存。</p><h3 id="调整透明大页-THP"><a href="#调整透明大页-THP" class="headerlink" title="调整透明大页(THP)"></a>调整透明大页(THP)</h3><p>对于某些工作负载(如数据库)，禁用透明大页可能更有利。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never | sudo tree /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure><h2 id="磁盘I-O调优"><a href="#磁盘I-O调优" class="headerlink" title="磁盘I&#x2F;O调优"></a>磁盘I&#x2F;O调优</h2><p>目标：优化磁盘读写性能，减少I&#x2F;O延迟。</p><h3 id="选择合适的I-O调度器"><a href="#选择合适的I-O调度器" class="headerlink" title="选择合适的I&#x2F;O调度器"></a>选择合适的I&#x2F;O调度器</h3><p>对于SSD，建议使用noop或deadline调度器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo noop | sudo tree /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure><p>对于HDD，建议使用deadline调度器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo deadline | sudo tree /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure><h3 id="调整文件系统挂载选项"><a href="#调整文件系统挂载选项" class="headerlink" title="调整文件系统挂载选项"></a>调整文件系统挂载选项</h3><p>对于ext4文件系统，启用noatime和data&#x3D;writeback选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o remount,noatime,data=writeback /</span><br></pre></td></tr></table></figure><p>默认的方式下linux会把文件访问的时间(atime)做记录，因为系统运行的时候要访问大量文件，如果能减少一些动作(比如减少时间戳的记录次数等)将会显著提高磁盘IO效率、提升文件系统的性能。</p><p>data&#x3D;ordered模式是ext4文件系统默认日志格式。在data&#x3D;writeback模式下，当元数据提交到日志后，data可以直接被提交到磁盘。即会做元数据日志，数据不做日志，并且不保证数据比元数据先落盘。writeback是ext4提供的性能最好的模式。</p><h3 id="优化磁盘队列深度"><a href="#优化磁盘队列深度" class="headerlink" title="优化磁盘队列深度"></a>优化磁盘队列深度</h3><p>增加磁盘队列深度以提高I&#x2F;O吞吐量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 256 | sudo tree /sys/block/sdX/queue/nr_requests</span><br></pre></td></tr></table></figure><p>队列深度决定了给块设备写I&#x2F;O的最大并发数，对于Linux系统，默认值为128。一般情况下不建议用户修改此参数。当对系统进行极限性能测试时，为了增大主机写I&#x2F;O的压力及I&#x2F;O在队列中被合并的概率，可以适当的增大此参数。</p><h2 id="网络调优"><a href="#网络调优" class="headerlink" title="网络调优"></a>网络调优</h2><p>目标：提高网络吞吐量，降低延迟。</p><h3 id="调整TCP缓冲区大小"><a href="#调整TCP缓冲区大小" class="headerlink" title="调整TCP缓冲区大小"></a>调整TCP缓冲区大小</h3><p>增加TCP接收和发送缓冲区大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.core.rmem_max=16777216</span><br><span class="line">sudo sysctl -w net.core.wmem_max=16777216</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_rmem=&quot;4096 87380 16777216&quot;</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_wmem=&quot;4096 65536 16777216&quot;</span><br></pre></td></tr></table></figure><h3 id="启用TCP快速打开"><a href="#启用TCP快速打开" class="headerlink" title="启用TCP快速打开"></a>启用TCP快速打开</h3><p>减少TCP连接的建立时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.tcp_fastopen=3</span><br></pre></td></tr></table></figure><h3 id="调整连接队列大小"><a href="#调整连接队列大小" class="headerlink" title="调整连接队列大小"></a>调整连接队列大小</h3><p>增加连接队列大小以应对高并发连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.core.somaxconn=65535</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_max_syn_backlog=65535</span><br></pre></td></tr></table></figure><h2 id="文件系统调优"><a href="#文件系统调优" class="headerlink" title="文件系统调优"></a>文件系统调优</h2><p>目标：提高文件系统性能，减少元数据操作开销。</p><h3 id="调整文件描述符限制"><a href="#调整文件描述符限制" class="headerlink" title="调整文件描述符限制"></a>调整文件描述符限制</h3><p>增加系统允许打开的文件描述符数量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w fs.file-max=100000</span><br><span class="line">ulimit -n 100000</span><br></pre></td></tr></table></figure><h3 id="优化inode缓存"><a href="#优化inode缓存" class="headerlink" title="优化inode缓存"></a>优化inode缓存</h3><p>增加inode缓存大小以提高文件系统性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w vm.vfs_cache_pressure=50</span><br></pre></td></tr></table></figure><h2 id="内核参数调优"><a href="#内核参数调优" class="headerlink" title="内核参数调优"></a>内核参数调优</h2><p>目标：优化内核行为，提升系统整体性能。</p><h3 id="调整进程调度策略"><a href="#调整进程调度策略" class="headerlink" title="调整进程调度策略"></a>调整进程调度策略</h3><p>对于实时性要求高的任务，使用SCHED_FIFO或SCHED_RR调度策略。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrt -f -p 99 &lt;pid&gt;</span><br></pre></td></tr></table></figure><h3 id="优化虚拟内存管理"><a href="#优化虚拟内存管理" class="headerlink" title="优化虚拟内存管理"></a>优化虚拟内存管理</h3><p>调整vm.dirty_ratio和vm.dirty_background_ratio，控制脏页写回行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w vm.dirty_ratio=10</span><br><span class="line">sudo sysctl -w vm.dirty_background_ratio=5</span><br></pre></td></tr></table></figure><h2 id="监控与维护"><a href="#监控与维护" class="headerlink" title="监控与维护"></a>监控与维护</h2><p>目标：持续监控系统性能，及时发现瓶颈。</p><h3 id="使用性能监控工具"><a href="#使用性能监控工具" class="headerlink" title="使用性能监控工具"></a>使用性能监控工具</h3><ul><li>top、htop：监控CPU和内存的使用情况。</li><li>vmstat：监控虚拟内存、CPU和I&#x2F;O状态。</li><li>iostat：监控磁盘I&#x2F;O性能。</li><li>netstat、ss：监控网络连接状态。</li></ul><h3 id="定期清理系统"><a href="#定期清理系统" class="headerlink" title="定期清理系统"></a>定期清理系统</h3><ul><li>清理不必要的日志文件和缓存。</li><li>使用logrotate管理日志文件大小。</li></ul><h2 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h2><p>目标：充分利用硬件资源</p><h3 id="升级硬件"><a href="#升级硬件" class="headerlink" title="升级硬件"></a>升级硬件</h3><ul><li>使用SSD替代HDD以提高I&#x2F;O性能。</li><li>增加内存容量以减少交换分区的使用。</li><li>使用多核CPU以提高并发处理能力。</li></ul><h2 id="持久化调优配置"><a href="#持久化调优配置" class="headerlink" title="持久化调优配置"></a>持久化调优配置</h2><p>将调优参数写入&#x2F;etc&#x2F;sysctl.conf，确保重启后生效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness=10</span><br><span class="line">vm.overcommit_memory=1</span><br><span class="line">net.core.somaxconn=65535</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=65535</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;CPU调优&quot;&gt;&lt;a href=&quot;#CPU调优&quot; class=&quot;headerlink&quot; title=&quot;CPU调优&quot;&gt;&lt;/a&gt;CPU调优&lt;/h2&gt;&lt;p&gt;目标：最大化CPU利用率，减少上下文切换和延迟。&lt;/p&gt;
&lt;h3 id=&quot;调整CPU频率策略&quot;&gt;&lt;a href=&quot;#调整CPU频率策略&quot; class=&quot;headerlink&quot; title=&quot;调整CPU频率策略&quot;&gt;&lt;/a&gt;调整CPU频率策略&lt;/h3&gt;&lt;p&gt;将CPU频率设置为’performance’模式，确保CPU始终以最高频率运行。&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta prompt_&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;安装cpufrequtils工具&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install cpufrequtils&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta prompt_&quot;&gt;# &lt;/span&gt;&lt;span class=&quot;language-bash&quot;&gt;设置为performance模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo cpufreq-set -g performance&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bentech8.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>系统管理</title>
    <link href="https://bentech8.github.io/2025/03/05/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://bentech8.github.io/2025/03/05/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</id>
    <published>2025-03-05T09:29:52.000Z</published>
    <updated>2025-03-07T11:45:41.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h3><p>1）什么是进程</p><p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</p><p>2）什么是程序</p><p>程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。</p><p>程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。</p><p>进程是正在执行当中的程序。程序被执行时，执行人的权限和属性、以及程序的代码都会被加载如内存，操作系统给这个进程分配一个ID号，称为PID（进程ID）。</p><p>3）进程管理的作用</p><ul><li><p>判断服务器健康状态</p><p>运维工程师最主要的工作就是保证服务器安全稳定的运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服务器的CPU占用率、内存占用率过高，就需要人为介入解决问题了。</p></li><li><p>查看系统中所有的进程</p><p>我们需要查看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务，是否有非法服务运行。</p></li><li><p>杀死进程</p><p>这是进程管理中最不常用的手段，当需要停止服务时，会通过正确关闭命令来停止服务（如apache服务可以通过service httpd sotp来关闭）。只有当正确终止进程的手段失效的情况下，才会考虑使用kill命令杀死进程（你不是杀手，不要什么进程都用kill来终止，否则非常容易导致服务器崩溃）。</p></li></ul><h3 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h3><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令是用来静态显示系统中进程的命令。不过这个命令有些特殊，它的部分命令的选项不能加入“-”，比如“ps aux”，这是因为ps命令的部分选项需要遵守BSD操作系统的格式，所以ps命令的常用选项的组合是固定的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统中所有进程，使用BSD操作系统格式</span></span><br><span class="line">[root@localhost ~]# pa aux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统中所有进程，使用Linux标准命令格式</span></span><br><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">选项：</span><br><span class="line">  a:显示一个终端的所有进程，除了会话引线</span><br><span class="line">  u:显示进程的归属用户及内存的使用情况</span><br><span class="line">  x:显示没有控制终端的进程</span><br><span class="line">  -l:长格式显示。显示更加详细的信息</span><br><span class="line">  -e:显示所有进程，和-A作用一致</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.2  24104 15260 ?        Ss   3月04   0:10 /sbin/init splash</span><br><span class="line">root           2  0.0  0.0      0     0 ?        S    3月04   0:00 [kthreadd]</span><br></pre></td></tr></table></figure><ul><li>USER：该进程是由哪个用户产生的</li><li>PID：进程的ID号</li><li>%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源</li><li>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源</li><li>VSZ：该进程占用虚拟内存的大小，单位KB</li><li>RSS：该进程占用实际物理内存的大小，单位KB</li><li>TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端(可以通过alt+F1-F7键切换不同的终端)，tty1-tty6是本地的字符界面终端，tty7是图形终端。pts&#x2F;0-255代表虚拟终端，一般是远程连接终端，第一个远程连接占用的是pts&#x2F;0终端，第二个远程连接占用pts&#x2F;1，依次增长。</li><li>STAT：进程状态。常见状态有：<ul><li>D：不可被唤醒的睡眠状态，通常用于I&#x2F;O情况</li><li>R：该进程正在运行</li><li>S：该进程在睡眠状态，可被唤醒</li><li>T：停止状态，可能是在后台暂停或进程在除错状态</li><li>W：内存交互状态（从2.6内核开始无效）</li><li>X：死掉的进程（应该不会出现）</li><li>Z：僵尸进程。进程已经终止，但是部分程序还在内存当中。</li><li>&lt;：高优先级（以下状态在BSD格式当中出现）</li><li>N：低优先级</li><li>L：被锁入内存</li><li>s：包含子进程</li><li>l：多线程</li><li>+：位于后台</li></ul></li><li>START：该进程的启动时间</li><li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li><li>COMMAND：产生此进程的命令名</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0       1       0  0  80   0 -  6026 -      ?        00:00:10 systemd</span><br><span class="line">1 S     0       2       0  0  80   0 -     0 -      ?        00:00:00 kthreadd</span><br></pre></td></tr></table></figure><ul><li>F：进程标志，说明进程的权限，常见标志有：<ul><li>1：进程可以复制，但是不能执行</li><li>4：进程使用超级用户权限</li></ul></li><li>S：进程状态。具体的状态和“ps aux”命令中STAT状态一致</li><li>UID：进程是哪个UID用户调用运行的</li><li>PID：进程的ID号</li><li>PPID：代进程的ID号</li><li>C：该进程的CPU使用率，单位是百分比</li><li>PRI：进程的优先级，数值越小该进程优先级越高，越快被CPU执行</li><li>NI：进程的优先级，也是数值越小越早被执行</li><li>ADDR：该进程在内存的哪个位置</li><li>SZ：该进程占用多大内存</li><li>WCHAN：该进程是否运行。“-”代表正在运行</li><li>TTY：该进程由哪个终端产生</li><li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li><li>CMD：产生此进程的命令名</li></ul><h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top [选项]</span><br><span class="line">选项：</span><br><span class="line">  -d 秒数：    指定top命令每隔几秒更新。默认是3秒。</span><br><span class="line">  -b:    使用批处理模式输出。一般和&quot;-n&quot;选项合用，用于把top命令重定向到文件中 </span><br><span class="line">  -n 次数: 指定top命令执行的次数。一般和&quot;-b&quot;选项合用</span><br><span class="line">  -p:   指定PID。只查看某个PID的进程</span><br><span class="line">  -s:          使top在安全模式运行，避免在交互模式中出现错误</span><br><span class="line">  -u 用户名:    只监听某个用户的进程</span><br><span class="line">在top命令的交互模式当中可以执行的命令：</span><br><span class="line">  ？或h:   显示交互模式的帮助</span><br><span class="line">  P:以CPU使用率排序，默认就是此项</span><br><span class="line">  M:以内存的使用率排序</span><br><span class="line">  N:以PID排序</span><br><span class="line">  T:按照CPU的累积运算时间排序，也就是用于TIME+项排序</span><br><span class="line">  k:按照PID号，给予某个进程一个信号，一般用于终止某个进程，信号9是强制终止的信号</span><br><span class="line">  r:按照PID号，给某个进程重设优先级（Nice）值</span><br><span class="line">  q:退出top</span><br></pre></td></tr></table></figure><p>top执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 20:40:42 up 1 day, 11:10,  1 user,  load average: 0.62, 0.43, 0.45</span><br><span class="line">任务: 394 total,   1 running, 385 sleeping,   8 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.9 us,  3.9 sy,  0.0 ni, 94.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st </span><br><span class="line">MiB Mem :   6865.1 total,    245.4 free,   4582.3 used,   2676.1 buff/cache     </span><br><span class="line">MiB Swap:   2048.0 total,    789.7 free,   1258.3 used.   2282.8 avail Mem </span><br><span class="line"> 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND                                                     </span><br><span class="line"> 231207 ben       20   0   17672   5632   3456 R  23.1   0.1   0:00.06 top                                                       </span><br><span class="line">      1 root      20   0   24104  14620   9348 S   0.0   0.2   0:11.09 systemd                                                   </span><br><span class="line">      2 root      20   0       0      0      0 S   0.0   0.0   0:00.06 kthreadd                                                   </span><br><span class="line">      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_workqueue_release        </span><br></pre></td></tr></table></figure><p>top命令的输出内容是动态的，默认每3秒刷新一次。命令的输出主要分为两大部分；第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出判断服务器的健康状态；第二部分从第六行开始，显示的是系统中进程的信息。</p><ul><li><p>第一部分内容</p><ul><li><p>第一行信息为任务队列信息</p><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>20:40:42</td><td>系统当前时间</td></tr><tr><td>up 1 day, 11:10</td><td>系统的运行时间，本机已经运行1天11小时10分钟</td></tr><tr><td>1 user</td><td>当前登录了1个用户</td></tr><tr><td>load average: 0.62, 0.43, 0.45</td><td>系统在之前1分钟，5分钟，15分钟的平均负载。如果CPU是单核，则这个数超过1，就是高负载。如果CPU是四核，则这个数超过4，就是高负载。（这个平均负载完全是个人经验来进行判断的，一般认为不应该超过服务器CPU的核数。）</td></tr></tbody></table></li><li><p>第二行为进程信息</p><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>任务: 394 total</td><td>系统中的进程总数</td></tr><tr><td>1 running</td><td>正在运行的进程数</td></tr><tr><td>385 sleeping</td><td>睡眠的进程</td></tr><tr><td>8 stopped</td><td>正在停止的进程</td></tr><tr><td>0 zombie</td><td>僵尸进程。如果不是0，需要手工检查僵尸进程</td></tr></tbody></table></li><li><p>第三行为CPU信息</p><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>%Cpu(s):  1.9 us</td><td>用户模式占用的CPU百分比</td></tr><tr><td>3.9 sy</td><td>系统模式占用的CPU百分比</td></tr><tr><td>0.0 ni</td><td>改变过优先级的用户进程占用的CPU百分比</td></tr><tr><td>94.2 id</td><td>空闲CPU的CPU百分比</td></tr><tr><td>0.0 wa</td><td>等待输入&#x2F;输出的进程的占用CPU百分比</td></tr><tr><td>0.0 hi</td><td>硬中断请求服务占用的CPU百分比</td></tr><tr><td>0.0 si</td><td>软中断请求服务占用的CPU百分比</td></tr><tr><td>0.0 st</td><td>st（Steal time）虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比</td></tr></tbody></table></li><li><p>第四行为物理内存信息</p><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>Mem :   6865.1 total</td><td>物理内存的总量</td></tr><tr><td>245.4 free</td><td>空闲的物理内存数量</td></tr><tr><td>4582.3 used</td><td>已经使用的物理内存数量</td></tr><tr><td>2676.1 buff&#x2F;cache</td><td>作为缓冲&#x2F;缓存的内存数量</td></tr></tbody></table></li><li><p>第五行为交换分区（swap）信息</p><table><thead><tr><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>Swap:   2048.0 total</td><td>交换分区（虚拟分区）的总大小</td></tr><tr><td>789.7 free</td><td>空闲交换分区的大小</td></tr><tr><td>1258.3 used</td><td>已经使用的交互分区的大小</td></tr><tr><td>2282.8 avail Mem</td><td>可利用的交互分区的大小</td></tr></tbody></table></li></ul></li><li><p>第二部分内容</p><p>主要是系统进程信息。这部分和ps命令的输出比较类似，只是如果在终端中执行top命令不能看到所有的进程，而只能看到占比靠前的进程。</p><ul><li>PID: 进程ID</li><li>USER: 该进程所属的用户</li><li>PR: 优先级，数值越小优先级越高</li><li>NI: 优先级，数值越小优先级越高</li><li>VIRT: 该进程使用的虚拟内存的大小，单位KB</li><li>RES: 该进程使用的物理内存的大小，单位KB</li><li>SHR: 共享内存大小，单位KB</li><li>%CPU: 该进程占用CPU的百分比</li><li>%MEM: 该进程占用内存的百分比</li><li>TIME+: 该进程总共占用的CPU时间</li><li>COMMAND: 进程的命令名</li></ul></li></ul><p>top命令查看某一个进程:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只查看PID为15273的apache进程</span></span><br><span class="line">[root@localhost ~]# top -p 15273</span><br></pre></td></tr></table></figure><p>在top命令的交互界面中按“q”键会退出top命令。也可以按“?”或“h”得到top命令交互界面的帮助信息。也可以按“k”键终止某个进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 21:30:33 up 1 day, 12:00,  1 user,  load average: 2.53, 1.43, 1.12</span><br><span class="line">任务: 391 total,   1 running, 382 sleeping,   8 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  5.5 us,  3.1 sy,  0.0 ni, 91.2 <span class="built_in">id</span>,  0.2 wa,  0.0 hi,  0.1 si,  0.0 st</span> </span><br><span class="line">MiB Mem :   6865.1 total,    196.3 free,   4604.8 used,   2714.5 buff/cache     </span><br><span class="line">MiB Swap:   2048.0 total,    742.7 free,   1305.3 used.   2260.2 avail Mem </span><br><span class="line">PID to signal/kill [default pid = 166294]                               # 按&quot;k&quot;键，会提示输入要杀死进程的PID</span><br></pre></td></tr></table></figure><p>如果在操作终端执行top命令，并不能看到系统中所有的进程，默认看到的只是CPU占比靠前的进程。如果我们想要看到所有的进程可以把top命令的结果重定向到文件当中即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让top命令只执行一次，然后把结果保存到top.log文件中。这样就能看到所有的进程了</span></span><br><span class="line">[root@localhost ~]# top -b -n 1 &gt; /root/top.log</span><br></pre></td></tr></table></figure><h4 id="pstree命令"><a href="#pstree命令" class="headerlink" title="pstree命令"></a>pstree命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pstree [选项]</span><br><span class="line">选项：</span><br><span class="line">  -p:显示进程的PID</span><br><span class="line">  -u:显示进程的所属用户</span><br></pre></td></tr></table></figure><h3 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h3><p>系统中可以识别的信号较多，可以使用命令“kill -l”或“man 7 signal”来查询：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill -l</span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure><p>主要信号：</p><table><thead><tr><th>信号代号</th><th>信号名称</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>SIGHUP</td><td>该信号让进程立即关闭，然后重新读取配置文件之后重启。</td></tr><tr><td>2</td><td>SIGINT</td><td>程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键。</td></tr><tr><td>8</td><td>SIGFPE</td><td>在发生致命的算术运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术的错误。</td></tr><tr><td>9</td><td>SIGKILL</td><td>用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。一般用于强制终止进程。</td></tr><tr><td>14</td><td>SIGALRM</td><td>时钟定时信号，计算的是实际的时间或时钟时间. alarm函数使用该信号。</td></tr><tr><td>15</td><td>SIGTERM</td><td>正常结束进程的信号，kill命令的默认信号。有时如果进程已经发生问题，这个信号是无法正常终止进程的，我们才会尝试SIGKILL信号，也就是信号9。</td></tr><tr><td>18</td><td>SIGCONT</td><td>该信号可以让暂停的进程恢复执行，本信号不能被阻断。</td></tr><tr><td>19</td><td>SIGSTOP</td><td>该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号不能被阻断。</td></tr></tbody></table><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill [信号] PID</span><br></pre></td></tr></table></figure><p>使用“-1”信号，让进程重启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill -1 2246</span><br></pre></td></tr></table></figure><p>使用“-19”信号，让进程暂停：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用vim命令编辑一个文件，不要退出</span></span><br><span class="line">[root@localhost ~]# vim /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">换不同的终端，查看下这个进程的状态</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vim&quot; | grep -v &quot;grep&quot;</span><br><span class="line">ben       271840  0.2  0.1  31228 13568 pts/0    Sl+  16:00   0:00 vim /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用-19信号，让PID是271840的进程暂停。相当于在vim界面按<span class="string">&quot;ctrl+z&quot;</span>快捷键</span></span><br><span class="line">[root@localhost ~]# kill -19 271840</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">271840进程的状态变成为T(暂停)状态。271840进程会卡在后台，如果想要恢复可以使用<span class="string">&quot;kill -9 271840&quot;</span>强制终止进程。</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vim&quot; | grep -v &quot;grep&quot;</span><br><span class="line">ben       271840  0.0  0.1  31228 13568 pts/0    Tl   16:00   0:00 vim /tmp/test.txt</span><br></pre></td></tr></table></figure><h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# killall [选项][信号] 进程名</span><br><span class="line">选项：</span><br><span class="line">  -i:交互式，询问是否要杀死某个进程</span><br><span class="line">  -l:忽略进程名的大小写</span><br></pre></td></tr></table></figure><p>交互式杀死docker进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux | grep &quot;docker-proxy&quot;</span><br><span class="line">root        5331  0.0  0.0 1746028 2160 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 127.0.0.1 -host-port 9090 -container-ip 172.23.0.2 -container-port 9090</span><br><span class="line">root        5345  0.0  0.0 1746028 2076 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 7891 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5352  0.0  0.0 1819504 2008 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 7891 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5366  0.0  0.0 1745772 2152 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5373  0.0  0.0 1746028 2088 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5388  0.0  0.0 1894260 4148 ?        Sl   3月04   0:02 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5395  0.0  0.0 1745772 2104 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5409  0.0  0.0 1671784 2204 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 7890 -container-ip 172.23.0.2 -container-port 7890</span><br><span class="line">root        5416  0.0  0.0 1671784 2168 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 7890 -container-ip 172.23.0.2 -container-port 7890</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式杀死docker进程</span></span><br><span class="line">[root@localhost ~]# killall -i docker-proxy</span><br><span class="line">杀死 docker-proxy(5331) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5345) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5352) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5366) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5373) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5388) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5395) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5409) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5416) ? (y/N) n</span><br></pre></td></tr></table></figure><h4 id="pkill命令"><a href="#pkill命令" class="headerlink" title="pkill命令"></a>pkill命令</h4><p>pkill命令和killall命令非常类似，也是按照进程名来杀死进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pkill [选项] [信号] 进程名</span><br><span class="line">选项：</span><br><span class="line">  -t 终端号:按照终端号踢出用户</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制杀死从pts/1虚拟终端登录的进程</span></span><br><span class="line">[root@localhost ~]# pkill -9 -t pts/1</span><br></pre></td></tr></table></figure><h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><h3 id="工作管理简介"><a href="#工作管理简介" class="headerlink" title="工作管理简介"></a>工作管理简介</h3><p>后台管理有个事项需要注意：</p><ul><li>前台是指当前可以操控和执行命令的这个操作环境，后台是指工作可以自行运行，但是不能直接用ctrl+c来终止它，只能使用fg&#x2F;bg来调用工作；</li><li>当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作。如tty1登录终端是不能管理tty2终端中的工作的；</li><li>放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作。如果把1s命令放入后台执行，它很快就会执行完成，我们很难操作它。</li><li>放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行。比如vim命令放入后台只能暂停，而不能执行，因为vim需要前台输入信息。top命令也不能放入后台执行，而只能放入后台暂停，因为top命令需要和前台有交互。</li></ul><h3 id="如何把命令放入后台"><a href="#如何把命令放入后台" class="headerlink" title="如何把命令放入后台"></a>如何把命令放入后台</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令 &amp;"></a>命令 &amp;</h4><p>第一种方法把命令放入后台的方法是在命令后面加入“空格&amp;”，这种方法放入后台的命令，在后台是执行状态。但是注意，放入后台执行的命令不能与前台有交互，否则这个命令是不能在后台执行的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find命令放入后台执行，每个后台命令会分配一个工作号，命令既然可以执行，就会有进程产生，所以也会有进程号。</span></span><br><span class="line">[root@localhost ~]# find / -name install.log &amp;</span><br><span class="line">[2] 284313</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[工作号] 进程号</span></span><br></pre></td></tr></table></figure><p>虽然find命令在执行，但是当前操作还是可以进行其他命令操作的。如果在终端出现：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">证明后台这个任务已经完成了，当然命令如果有执行结果的话，也会显示到操作终端上。[2]是这个命令的工作号，+号代表这个任务是最近一个被放入后台的工作。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### ctrl+z</span></span></span><br><span class="line"></span><br><span class="line">第二种方法是在命令执行过程中按ctrl+z快捷键，命令在后台是暂停状态。</span><br><span class="line"></span><br><span class="line">使用这种方法放入后台的命令，就算是不和前台有交互，能在后台执行的命令，也是暂停状态，ctrl+z快捷键就是暂停的快捷键。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在top命令执行的过程中，按下ctrl+z快捷键</span></span><br><span class="line">[root@localhost ~]# top</span><br><span class="line">[1]+  已停止               top</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提示命令被放入后台，工作号是1，状态是暂停。而且虽然top命令没有结束，也能取得控制台权限</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩一下/etc/目录</span></span><br><span class="line">[root@localhost ~]# tar -zcf etc.tar.gz /etc</span><br><span class="line">tar: 从成员名中删除开头的&quot;/&quot;</span><br><span class="line">tar: 从硬连接目标中删除开头的&quot;/&quot;</span><br><span class="line">^Z                              # 执行过程中，按下ctrl+z快捷键</span><br><span class="line">[2]+   Stopped    tar -zcf etc.tar.gz /etc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令被放入后台，工作号是2，状态是暂停</span></span><br></pre></td></tr></table></figure><h3 id="后台命令管理"><a href="#后台命令管理" class="headerlink" title="后台命令管理"></a>后台命令管理</h3><h4 id="查看后台的工作"><a href="#查看后台的工作" class="headerlink" title="查看后台的工作"></a>查看后台的工作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jobs [-l]</span><br><span class="line">选项：</span><br><span class="line">  -l:显示工作的PID</span><br></pre></td></tr></table></figure><h4 id="将后台暂停的工作恢复到前台执行"><a href="#将后台暂停的工作恢复到前台执行" class="headerlink" title="将后台暂停的工作恢复到前台执行"></a>将后台暂停的工作恢复到前台执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fg %工作号</span><br><span class="line">参数：</span><br><span class="line">  %工作号:%号可以省略，但是注意工作号和PID的区别</span><br></pre></td></tr></table></figure><h4 id="把后台暂停的工作恢复到后台执行"><a href="#把后台暂停的工作恢复到后台执行" class="headerlink" title="把后台暂停的工作恢复到后台执行"></a>把后台暂停的工作恢复到后台执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bg %工作号</span><br></pre></td></tr></table></figure><h4 id="后台命令脱离登录终端运行"><a href="#后台命令脱离登录终端运行" class="headerlink" title="后台命令脱离登录终端运行"></a>后台命令脱离登录终端运行</h4><p>我们已经知道把命令放入后台，只能在当前登录终端执行。那如果我是远程管理的服务器，在远程终端中执行了后台命令，这时我退出终端，这个后台命令还能继续执行吗？当然是不行的， 这个后台命令会被终止。如果确实需要在远程终端中执行某些后台命令，可以这么做：</p><ul><li>把需要后台执行的命令加入&#x2F;etc&#x2F;rc.local文件，让系统在启动时执行这个后台程序。这种方法的问题是，服务器是不能随便重启的，万一有临时后台任务，就不能执行。</li><li>使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的。</li><li>使用nohup命令。</li></ul><p>nohup命令的作用就是让后台工作在离开操作终端时，也能够正确的在后台执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nohup [命令] &amp; </span><br></pre></td></tr></table></figure><p>用find命令打印&#x2F;下所有文件，放入后台执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nohup find / -print &gt; /root/file.log &amp;</span><br><span class="line">[3] 2349</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有提示信息</span></span><br><span class="line">[root@localhost ~]# nohup：忽略输入并把输出追加到&quot;nohup.out&quot;</span><br></pre></td></tr></table></figure><h2 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>监控系统资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat [刷新延时 刷新次数]</span><br></pre></td></tr></table></figure><p>使用vmstat检测，每1秒刷新一次，共刷新3次：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat 1 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- -------cpu-------</span><br><span class="line"> r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st gu</span><br><span class="line"> 1  0 1975536 315116 888372 2032876    1   13    58    88  912    6  4  2 94  0  0  0</span><br><span class="line"> 0  0 1975536 296724 888372 2032912    8    0     8     0 2845 3503  4  2 94  0  0  0</span><br><span class="line"> 3  0 1975536 294804 888372 2032916    0    0     0     0 2592 3581  1  2 97  0  0  0</span><br></pre></td></tr></table></figure><ul><li><p>procs：进程信息字段</p><ul><li>r：等待运行的进程数，数量越大，系统越繁忙。</li><li>b：不可被唤醒的进程数量，数量越大，系统越繁忙。</li></ul></li><li><p>memory：内存信息字段</p><ul><li>swpd：虚拟内存的使用情况，单位KB</li><li>free：空闲的内存容量，单位KB</li><li>buff：缓冲的内存容量，单位KB</li><li>cache：缓存的内存容量，单位KB</li></ul></li><li><p>swap：交换分区的信息字段</p><ul><li>si：从磁盘中交换到内存中数据的数量，单位KB</li><li>so：从内存中交换到磁盘中数据的数量，单位KB。此两个数越大，证明数据需要经常在磁盘和内存之间交换，系统性能越差。</li></ul></li><li><p>io：磁盘读写信息字段</p><ul><li>bi：从块设备读入数据的总量，单位是块</li><li>bo：写到块设备的数据的总量，单位是块。此两个数越大，代表系统的I&#x2F;O越繁忙。</li></ul></li><li><p>system：系统信息字段</p><ul><li>in：每秒被中断的进程次数</li><li>cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙。</li></ul></li><li><p>cpu：cpu信息字段</p><ul><li>us：非内核进程消耗cpu运算时间的百分比</li><li>sy：内核进程消耗cpu运算时间的百分比</li><li>id：空闲cpu的百分比</li><li>wa：等待I&#x2F;0所消耗的cpu百分比</li><li>st：被虚拟机所盗用的cpu百分比</li></ul></li></ul><h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>显示开机时内核检测信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看CPU信息</span></span><br><span class="line">[root@localhost ~]# dmesg | grep CPU</span><br></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>查看内存使用状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free [-b|-k|-m|-g]</span><br><span class="line">选项：</span><br><span class="line">  -b:以字节为单位显示</span><br><span class="line">  -k:以KB为单位显示，默认是以KB为单位显示</span><br><span class="line">  -m:以MB为单位显示</span><br><span class="line">  -g:以GB为单位显示</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">内存：         6.7Gi       4.2Gi       283Mi       277Mi       2.8Gi       2.5Gi</span><br><span class="line">交换：         2.0Gi       1.9Gi       122Mi</span><br></pre></td></tr></table></figure><ul><li><p>第一行</p><ul><li>total：总内存数。</li><li>used：已经使用的内存数。</li><li>free：空闲的内存数。</li><li>shared：多个进程共享的内存总数。</li><li>buff&#x2F;cache：缓冲&#x2F;缓存内存数。</li></ul></li><li><p>第二行</p><ul><li>total：swap的总数</li><li>used：已经使用的swap数</li><li>free：空闲的swap数。</li></ul></li></ul><h3 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h3><p>CPU的主要信息保存在&#x2F;proc&#x2F;cpuinfo这个文件中，只要查看这个文件，就可以知道cpu的相关信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/cpuinfo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑CPU编号</span></span><br><span class="line">processor: 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU制造厂商</span></span><br><span class="line">vendor_id: AuthenticAMD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">产品的系列代号</span></span><br><span class="line">cpu family: 23</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU系列代号</span></span><br><span class="line">model: 24</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU系列的名字，编号，主频</span></span><br><span class="line">model name: AMD Ryzen 7 3700U with Radeon Vega Mobile Gfx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新版本</span></span><br><span class="line">stepping: 1</span><br><span class="line">microcode: 0x8108109</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实际主频</span></span><br><span class="line">cpu MHz: 1372.114</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二级缓存</span></span><br><span class="line">cache size: 512 KB</span><br></pre></td></tr></table></figure><h3 id="查看本机登录用户信息"><a href="#查看本机登录用户信息" class="headerlink" title="查看本机登录用户信息"></a>查看本机登录用户信息</h3><p>如果我们想要知道Linux服务器上目前已经登录的用户信息，可以使用w或who命令来进行查询。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 17:54:27 up 2 days,  8:24,  1 user,  load average: 0.82, 0.89, 1.04</span><br><span class="line">USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU  WHAT</span><br><span class="line">ben               -                二09    2:27m  0.00s  0.04s lightdm --session-child 13 20</span><br></pre></td></tr></table></figure><ul><li>第一行：和top命令的第一行非常类似，主要显示了系统当前时间，开机多久(up)，有多少用户登录(users)，1分钟、5分钟、15分种前的平均负载(load average)。</li><li>第二行：项目的说明<ul><li>USER：登录的用户名</li><li>TTY：登录终端</li><li>FROM：从哪个IP地址登录</li><li>LOGIN@：登录时间</li><li>IDLE：用户闲置时间</li><li>JCPU：指的是和该终端连接的所有进程占用的CPU运算时间。这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间</li><li>PCPU：是指当前进程所占用的CPU运算时间</li><li>WHAT：当前正在运行的命令</li></ul></li><li>第三行：代表一个用户</li></ul><p>who命令比w命令稍微简单一点，也可以用来查看系统中已经登录的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# who</span><br><span class="line">ben      tty7         2025-03-04 09:29 (:0)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名  登录终端      登录时间(登录来源IP地址)</span></span><br></pre></td></tr></table></figure><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>uptime命令的作用就是显示系统的启动时间和平均负载，也就是top命令的第一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uptime</span><br><span class="line"> 18:05:21 up 2 days,  8:35,  1 user,  load average: 1.61, 1.24, 1.10</span><br></pre></td></tr></table></figure><h3 id="查看系统与内核相关信息"><a href="#查看系统与内核相关信息" class="headerlink" title="查看系统与内核相关信息"></a>查看系统与内核相关信息</h3><p>使用uname命令查看内核的相关信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uname [选项]</span><br><span class="line">选项：</span><br><span class="line">  -a:查看系统所有相关信息</span><br><span class="line">  -r:   查看内核版本</span><br><span class="line">  -s:   查看内核名称</span><br></pre></td></tr></table></figure><p>如果我们想要判断当前系统的位数，可以通过file命令来判断系统文件(主要系统命令)的位数来推断系统的位数。如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# file /bin/ls</span><br><span class="line">/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3eca7e3905b37d48cf0a88b576faa7b95cc3097b, for GNU/Linux 3.2.0, stripped</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">很明显，当前系统是64位的</span></span><br></pre></td></tr></table></figure><p>如果想要查询当前Linux系统的发行版本，可以使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsb_release -a </span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:Ubuntu</span><br><span class="line">Description:Ubuntu 24.04.1 LTS</span><br><span class="line">Release:24.04</span><br><span class="line">Codename:noble</span><br></pre></td></tr></table></figure><h2 id="系统定时任务"><a href="#系统定时任务" class="headerlink" title="系统定时任务"></a>系统定时任务</h2><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>循环执行定时任务。</p><p>1）crond服务管理与访问控制</p><p>crontab命令是需要crond服务支持的，crond服务同样是独立的服务，所以启动和自启动方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启动crond服务</span></span><br><span class="line">[root@localhost ~]# service crond restart</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设定crond服务为开机自启动</span></span><br><span class="line">[root@localhost ~]# systemctl enable crond</span><br></pre></td></tr></table></figure><p>crond服务默认是自启动的，如果服务器上有循环执行的系统定时任务，就不要关闭crond服务了。</p><p>2）用户的crontab设置</p><p>每个用户都可以实现自己的crontab定时任务，只要是使用这个用户身份执行“crontab -e”命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# crontab [选项]</span><br><span class="line">选项：</span><br><span class="line">  -e:编辑crontab定时任务</span><br><span class="line">  -l:查询crontab任务</span><br><span class="line">  -r:删除当前用户所有的crontab任务，如果有多个任务，只想删除一个，可以使用&quot;crontab -e&quot;</span><br><span class="line">  -u 用户名: 修改或删除其他用户的crontab任务。只有root可用</span><br></pre></td></tr></table></figure><p>进入crontab编辑界面，会打开vim编辑你的工作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">* * * * * 执行的任务</span><br></pre></td></tr></table></figure><table><thead><tr><th>项目</th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个“*”</td><td>一小时当中的第几分钟</td><td>0-59</td></tr><tr><td>第二个“*”</td><td>一天当中的第几个小时</td><td>0-23</td></tr><tr><td>第三个“*”</td><td>一个月当中的第几天</td><td>1-31</td></tr><tr><td>第四个“*”</td><td>一年当中的第几月</td><td>1-12</td></tr><tr><td>第五个“*”</td><td>一周当中的星期几</td><td>0-7(0和7都代表星期日)</td></tr></tbody></table><p>特殊符号：</p><table><thead><tr><th>特殊符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任何时间，比如第一个“*”就代表一小时中每分钟都执行一次。</td></tr><tr><td>，</td><td>代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。</td></tr><tr><td>~</td><td>代表连续的时间范围。比如“0 5 * * 1-6 命令”，代表在周一到周六的凌晨5点0分执行命令。</td></tr><tr><td>*&#x2F;n</td><td>代表每隔多久执行一次。比如“*&#x2F;10 * * * * 命令”，代表每隔10分钟就执行一次命令。</td></tr></tbody></table><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让系统每隔5分钟，就向/tmp/test文件中写入一行<span class="string">&quot;ll&quot;</span></span></span><br><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">*/5 * * * * /bin/echo &quot;ll&quot; &gt;&gt; /tmp/test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统在每周二的凌晨5点05分重启一次</span></span><br><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">5 5 * * 2 /sbin/shutdown -r now</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在每月的1号，10号，15号的凌晨3点30分都定时执行日志备份脚本autobak.sh</span></span><br><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">30 3 1,10,15 * * /root/sh/autobak.sh</span><br></pre></td></tr></table></figure><p>3）crontab的注意事项</p><p>在书写crontab定时任务时，需要注意几个注意事项：</p><ul><li>六个选项都不能为空，必须填写。如果不确定使用“*”代表任意时间。</li><li>crontab定时任务，最小有效时间是分钟，最大时间范围是月。</li><li>在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都是以天为单位，非常容易让管理员混乱。</li><li>在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都是用绝对路径。有时相对路径的命令会报错。</li></ul><p>4）系统的crontab设置</p><p>“crontab -e”是每个用户执行的命令，也就是说不同的用户身份可以执行自己的定时任务。可以是有些定时任务需要系统执行，这时就需要编辑&#x2F;etc&#x2F;crontab这个配置文件了。当然，并不是说写入&#x2F;etc&#x2F;crontab配置文件中的定时任务执行时，不需要用户身份，而是”crontab -e”命令定义定时任务时，默认用户身份是当前登录用户。而修改&#x2F;etc&#x2F;crontab配置文件时，定时任务的执行者身份是可以手工指定的。这样定时任务的执行会更加灵活，修改起来也更加方便。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/crontab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unlike any other crontab you don<span class="string">&#x27;t have to run the `crontab&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> to install the new version when you edit this file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and files <span class="keyword">in</span> /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that none of the other crontabs <span class="keyword">do</span>.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标识使用哪种shell</span></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can also override PATH, but by default, newer versions inherit it from the environment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example of job definition:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*  *  *  *  * user-name <span class="built_in">command</span> to be executed</span></span><br><span class="line">17 ** * *rootcd / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6* * *roottest -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.daily; &#125;</span><br><span class="line">47 6* * 7roottest -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.weekly; &#125;</span><br><span class="line">52 61 * *roottest -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.monthly; &#125;</span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure><p>修改&#x2F;etc&#x2F;crontab这个配置文件，加入自己的定时任务，不过需要注意指定脚本的执行者身份：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/crontab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unlike any other crontab you don<span class="string">&#x27;t have to run the `crontab&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> to install the new version when you edit this file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and files <span class="keyword">in</span> /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that none of the other crontabs <span class="keyword">do</span>.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标识使用哪种shell</span></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can also override PATH, but by default, newer versions inherit it from the environment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example of job definition:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*  *  *  *  * user-name <span class="built_in">command</span> to be executed</span></span><br><span class="line">17 ** * *rootcd / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6* * *roottest -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.daily; &#125;</span><br><span class="line">47 6* * 7roottest -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.weekly; &#125;</span><br><span class="line">52 61 * *roottest -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.monthly; &#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用run-parts脚本调用并执行/root/cron/目录中所有的可执行文件</span></span><br><span class="line">* * * * *       root    run-parts /root/cron/</span><br></pre></td></tr></table></figure><p>只要保存&#x2F;etc&#x2F;crontab文件，这个定时任务就可以执行了，当然要确定crond服务是运行的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h2&gt;&lt;h3 id=&quot;进程简介&quot;&gt;&lt;a href=&quot;#进程简介&quot; class=&quot;headerlink&quot; title=&quot;进程简介&quot;&gt;&lt;/a&gt;进程简介&lt;/h3&gt;&lt;p&gt;1）什么是进程&lt;/p&gt;
&lt;p&gt;进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。&lt;/p&gt;
&lt;p&gt;2）什么是程序&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bentech8.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>运维工具</title>
    <link href="https://bentech8.github.io/2025/03/05/%E8%BF%90%E7%BB%B4-%E5%B7%A5%E5%85%B7/"/>
    <id>https://bentech8.github.io/2025/03/05/%E8%BF%90%E7%BB%B4-%E5%B7%A5%E5%85%B7/</id>
    <published>2025-03-05T09:29:52.000Z</published>
    <updated>2025-06-16T15:46:12.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运维工具"><a href="#运维工具" class="headerlink" title="运维工具"></a>运维工具</h2><h3 id="tls续签"><a href="#tls续签" class="headerlink" title="tls续签"></a>tls续签</h3><ul><li>certimate: <a href="https://github.com/usual2970/certimate">https://github.com/usual2970/certimate</a></li></ul><h3 id="网址导航"><a href="#网址导航" class="headerlink" title="网址导航"></a>网址导航</h3><ul><li>WebsiteGuide: <a href="https://github.com/mizhexiaoxiao/WebsiteGuide">https://github.com/mizhexiaoxiao/WebsiteGuide</a></li></ul><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><ul><li>openproject: <a href="https://www.openproject.org/">https://www.openproject.org/</a></li></ul><h3 id="IP地址管理"><a href="#IP地址管理" class="headerlink" title="IP地址管理"></a>IP地址管理</h3><ul><li>IPAM: <a href="https://phpipam.net/">https://phpipam.net/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;运维工具&quot;&gt;&lt;a href=&quot;#运维工具&quot; class=&quot;headerlink&quot; title=&quot;运维工具&quot;&gt;&lt;/a&gt;运维工具&lt;/h2&gt;&lt;h3 id=&quot;tls续签&quot;&gt;&lt;a href=&quot;#tls续签&quot; class=&quot;headerlink&quot; title=&quot;tls续签&quot;&gt;&lt;/a&gt;tls续签&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;certimate: &lt;a href=&quot;https://github.com/usual2970/certimate&quot;&gt;https://github.com/usual2970/certimate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;网址导航&quot;&gt;&lt;a href=&quot;#网址导航&quot; class=&quot;headerlink&quot; title=&quot;网址导航&quot;&gt;&lt;/a&gt;网址导航&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;WebsiteGuide: &lt;a href=&quot;https://github.com/mizhexiaoxiao/WebsiteGuide&quot;&gt;https://github.com/mizhexiaoxiao/WebsiteGuide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="运维" scheme="https://bentech8.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="运维" scheme="https://bentech8.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>服务管理</title>
    <link href="https://bentech8.github.io/2025/03/05/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>https://bentech8.github.io/2025/03/05/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</id>
    <published>2025-03-05T07:31:39.000Z</published>
    <updated>2025-03-05T09:26:04.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务的简介与分类"><a href="#服务的简介与分类" class="headerlink" title="服务的简介与分类"></a>服务的简介与分类</h2><h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><p>Linux服务：</p><ul><li><p>RPM包默认安装的服务</p><ul><li><p>独立的服务</p><p>就是独立启动的意思，这类型的服务可以自行启动，而不用依赖其他的管理服务。不依赖其他管理服务，那么当客户端请求访问时，独立的服务响应请求更迅速。Linux中目前大多数服务都是独立的服务，比如apache服务，FTP服务，Samba服务等。</p></li><li><p>基于xinetd服务</p><p>这种服务就不能独立启动了，而是要依靠管理服务来调用这种服务。这个负责管理的服务就是xinetd服务，xinetd服务是系统的超级守护进程。xinetd服务的作用就是管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务云唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释放资源。这样做的好处是只需要持续启动xinetd服务，而其他基于xinetd的服务只有在需要时才启动，不会占用过多的服务器资源。但是这种服务由于在有客户端靖求时才会被唤醒，所以响应时间相对较慢。</p></li></ul></li><li><p>源码包安装的服务</p></li></ul><h3 id="查询已经安装的服务"><a href="#查询已经安装的服务" class="headerlink" title="查询已经安装的服务"></a>查询已经安装的服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --list [服务名]</span><br><span class="line">选项：</span><br><span class="line">  --list: 列出所有RPM默认安装服务的自启动状态</span><br></pre></td></tr></table></figure><h2 id="RPM包默认安装的服务管理"><a href="#RPM包默认安装的服务管理" class="headerlink" title="RPM包默认安装的服务管理"></a>RPM包默认安装的服务管理</h2><h3 id="独立服务管理"><a href="#独立服务管理" class="headerlink" title="独立服务管理"></a>独立服务管理</h3><h4 id="独立服务的启动管理"><a href="#独立服务的启动管理" class="headerlink" title="独立服务的启动管理"></a>独立服务的启动管理</h4><ul><li><p>使用&#x2F;etc&#x2F;init.d&#x2F;目录中的启动脚本启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /etc/init.d/httpd start</span><br></pre></td></tr></table></figure></li><li><p>使用service命令来启动独立的服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service [独立服务名] start|stop|restart|...</span><br></pre></td></tr></table></figure></li></ul><h4 id="独立服务的自启动管理"><a href="#独立服务的自启动管理" class="headerlink" title="独立服务的自启动管理"></a>独立服务的自启动管理</h4><ul><li><p>使用chkconfig服务自启动管理命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig [--level 运行级别] [独立服务名] [on|off]</span><br><span class="line">选项：</span><br><span class="line">  --level:    设定在哪个运行级别中开机自启动(on)，或是关闭自启动(off)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --level 2345 httpd on</span><br></pre></td></tr></table></figure></li><li><p>修改&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件，设置服务自启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/etc/rc.d/init.d/httpd start</span><br></pre></td></tr></table></figure></li><li><p>使用ntsysv命令管理自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ntsysv [--level 运行级别]</span><br><span class="line">选项：</span><br><span class="line">  --level 运行级别:  可以指定设定自启动的运行级别</span><br></pre></td></tr></table></figure><p>这个命令的操作是这样的：</p><ul><li>上下键：在不同服务之间移动</li><li>空格键：选定或取消服务的自启动，就是在服务之前是否打入“*”</li><li>tab键：在不同项目间切换</li><li>F1键：显示服务的说明</li></ul></li></ul><h3 id="基于xinetd服务的管理"><a href="#基于xinetd服务的管理" class="headerlink" title="基于xinetd服务的管理"></a>基于xinetd服务的管理</h3><h4 id="基于xinetd服务的启动"><a href="#基于xinetd服务的启动" class="headerlink" title="基于xinetd服务的启动"></a>基于xinetd服务的启动</h4><p>以telnet服务为例，telnet服务是用来进行系统远程管理的，端口是23。不过需要注意的是telnet的远程管理数据在网络中是明文传输，非常不安全。在生产服务器上不建议启动telnet服务。在生产服务器上，远程管理使用的是ssh协议，ssh是加密的，更加安全。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default: on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: The telnet server serves telnet sessions: it uses \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#       unencrypted username/password pairs for authentication.</span></span></span><br><span class="line">service telnet                                     # 服务的名称为telnet</span><br><span class="line">&#123;</span><br><span class="line">flags= REUSE                    # 标志为REUSE，设定TCP/IP socket可重用</span><br><span class="line">socket_type         = stream                   # 使用TCP协议数据包</span><br><span class="line">wait= no   # 允许多个连接同时连接</span><br><span class="line">user= root   # 启动服务的用户为root</span><br><span class="line">server= /usr/sbin/in.telnetd     # 服务的启动程序</span><br><span class="line">log_on_failure+= USERID                  # 登录失败后，记录用户的ID</span><br><span class="line">disable= yes   # 服务不启动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">disable= no</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# service xinetd restart</span><br></pre></td></tr></table></figure><h4 id="基于xinetd服务的自启动"><a href="#基于xinetd服务的自启动" class="headerlink" title="基于xinetd服务的自启动"></a>基于xinetd服务的自启动</h4><ul><li><p>使用chkconfig命令管理自启动</p></li><li><p>使用ntsysv命令管理自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig 服务名 on|off</span><br></pre></td></tr></table></figure></li></ul><h2 id="源码包安装的服务管理"><a href="#源码包安装的服务管理" class="headerlink" title="源码包安装的服务管理"></a>源码包安装的服务管理</h2><h3 id="源码包服务的启动管理"><a href="#源码包服务的启动管理" class="headerlink" title="源码包服务的启动管理"></a>源码包服务的启动管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/apache2/bin/apachectl start|stop|restart|...</span><br></pre></td></tr></table></figure><h3 id="源码包服务的自启动管理"><a href="#源码包服务的自启动管理" class="headerlink" title="源码包服务的自启动管理"></a>源码包服务的自启动管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/usr/local/apache2/bin/apachectl start</span><br></pre></td></tr></table></figure><h2 id="Linux中常见服务的作用"><a href="#Linux中常见服务的作用" class="headerlink" title="Linux中常见服务的作用"></a>Linux中常见服务的作用</h2><table><thead><tr><th>服务名称</th><th>功能简介</th><th>建议</th></tr></thead><tbody><tr><td>acpid</td><td>电源管理接口。如果是笔记本用户建立开启，可以监听内核层的相关电源事件</td><td>on</td></tr><tr><td>anacron</td><td>系统的定时任务程序。cron的一个子系统，如果定时任务错过了执行时间，可以通过anacron继续唤醒执行。</td><td>off</td></tr><tr><td>alsasound</td><td>Alsa声卡驱动。如果使用alsa声卡，开启</td><td>off</td></tr><tr><td>apmd</td><td>电源管理模块。如果支持acpid，就不需要apmd，可以关闭</td><td>off</td></tr><tr><td>atd</td><td>指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用crond来进行循环定时任务。</td><td>off</td></tr><tr><td>auditd</td><td>审核子系统。如果开启了此服务，SELinux的审核信息会写入&#x2F;var&#x2F;log&#x2F;audit&#x2F;audit.log文件，如果不开启，审核信息会记录在syslog中</td><td>on</td></tr><tr><td>autofs</td><td>让服务器可以自动挂载网络中的其他服务器的共享数据，一般用来自动挂载NFS服务。如果没有NFS服务建立关闭</td><td>off</td></tr><tr><td>avahi-daemon</td><td>Avahi是zeroconf协议的实现。它可以在没有DNS服务的局域网里发现基于zeroconf协议的设备和服务。除非有兼容设备或使用zeroconf协议，否则关闭</td><td>off</td></tr><tr><td>bluetooth</td><td>蓝牙设备支持。一般不会在服务器上启用蓝牙设备。</td><td>off</td></tr><tr><td>capi</td><td>仅对使用ISND设备的用户有用。</td><td>off</td></tr><tr><td>chargen-dgram</td><td>使用UDP协议的chargen server。主要功能是提供类似远程打字的功能。</td><td>off</td></tr><tr><td>chargen-stream</td><td>同上</td><td>off</td></tr><tr><td>cpuspeed</td><td>可以用来调整CPU的频率。当闲置时可以自动降低CPU频率来节省电量</td><td>on</td></tr><tr><td>crond</td><td>系统的定时任务，一般的Linux服务器都需要定时任务帮助系统维护</td><td>on</td></tr><tr><td>cvs</td><td>一个版本控制系统</td><td>off</td></tr><tr><td>daytime-dgram</td><td>daytime使用TCP协议的Daytime守护进程，该协议为客户机实现从远程服务器获取日期和时间的功能。</td><td>off</td></tr><tr><td>daytime-stream</td><td>同上</td><td>off</td></tr><tr><td>dovecot</td><td>邮件服务中POP3&#x2F;IMAP服务的守护进程。主要用来接收信件，如果启动了邮件服务则开启，否则关闭</td><td>off</td></tr><tr><td>echo-dgram</td><td>服务器回显客户服务的进程。</td><td>off</td></tr><tr><td>echo-stream</td><td>同上。</td><td>off</td></tr><tr><td>firstboot</td><td>系统安装完成之后，有个欢迎界面，需要对系统进程初始设定，就是这个进程的作用。既然不是第一次启动，可以关闭</td><td>off</td></tr><tr><td>gpm</td><td>在字符终端(tty1-tty6)中可以使用鼠标复制和粘贴。就是这个服务的功能。</td><td>on</td></tr><tr><td>haldaemon</td><td>检测盒支持USB设备。如果是服务器可以关闭，个人建议关闭</td><td>off</td></tr><tr><td>hidd</td><td>蓝牙鼠标、键盘等蓝牙设备检测。必须启动bluetooth服务。</td><td>off</td></tr><tr><td>hplip</td><td>HP打印机支持，如果没有HP打印机则关闭</td><td>off</td></tr><tr><td>httpd</td><td>apache服务的守护进程。如果需要启动apache，则开启</td><td>on</td></tr><tr><td>ip6tables</td><td>IPv6防火墙，目前IPv6协议并没有使用，可以关闭</td><td>off</td></tr><tr><td>iptables</td><td>防火墙功能，Linux中防火墙是内核支持功能，这是服务器的主要防护手段，必须开启</td><td>on</td></tr><tr><td>irda</td><td>IrDA提供红外线设备(笔记本、PDA’s，手机，计算器等等)间的通讯支持。</td><td>off</td></tr><tr><td>irqbalance</td><td>支持多核处理器，让CPU可以自动分配系统中断(IRQ)，提高系统性能。</td><td>on</td></tr><tr><td>isdn</td><td>使用ISDN设备连接网络。目前主流的联网方式是光纤接入和ADSL，ISDN已经非常少见</td><td>off</td></tr><tr><td>kudzu</td><td>该服务可以在开机时进行硬件检测，并会调用相关的设置软件。</td><td>off</td></tr><tr><td>lvm2-monitor</td><td>该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM方式，那么应该开启</td><td>on</td></tr><tr><td>mcstrans</td><td>SELinux的支持服务</td><td>on</td></tr><tr><td>mdmonitor</td><td>该服务用来监测Software RAID或LVM的信息。不是必须服务</td><td>off</td></tr><tr><td>mdmpd</td><td>该服务用来监测Multi-Path设备</td><td>off</td></tr><tr><td>messagebus</td><td>这是Linuxr IPC（Interprocess Communication, 进程间通讯）服务，用来在各个软件中交换信息</td><td>off</td></tr><tr><td>microcode_ctl</td><td>Intel系列的CPU可以通过这个服务支持额外的微指令集。</td><td>off</td></tr><tr><td>mysqld</td><td>mysql数据库服务器。如果需要就开启，</td><td>off</td></tr><tr><td>named</td><td>DNS服务的守护进程，用来进行域名解析。如果是DNS服务器则开启</td><td>off</td></tr><tr><td>netfs</td><td>该服务用于在系统启动时自动挂载网络中的共享文件空间，比如：NFS, Samba等。需要则开启</td><td>off</td></tr><tr><td>network</td><td>提供网络设置功能。通过这个服务来管理网络</td><td>on</td></tr><tr><td>nfs</td><td>NFS（Network File System）服务，Linux与Linux之间的文件共享服务。需要就开启</td><td>off</td></tr><tr><td>nfslock</td><td>在Linux中如果使用了NFS服务，为了避免同一个文件被不同的用户编辑，所以有了这个锁服务。有NFS是开启</td><td>off</td></tr><tr><td>ntpd</td><td>该服务可以通过互联网自动更新系统时间，使系统时间永远都准确。需要则开启</td><td>off</td></tr><tr><td>pcscd</td><td>智能卡检测服务</td><td>off</td></tr><tr><td>portmap</td><td>用在远程过程调用（RPC）的服务，如果没有任何RPC服务时，可以关闭，主要是NFS和NIS服务需要</td><td>off</td></tr><tr><td>psacct</td><td>该守护进程支持几个监控进程活动的工具。</td><td>off</td></tr><tr><td>rdisc</td><td>客户端ICMP路由协议</td><td>off</td></tr><tr><td>readahead_early</td><td>在系统开机的时候，先将某些进程加载如内存整理，可以加快一点启动速度。</td><td>off</td></tr><tr><td>readahead_later</td><td>同上</td><td>off</td></tr><tr><td>restorecond</td><td>用于给SELinux监测和重新加载正确的文件上下文。如果开启SELinux则需要开启。</td><td>off</td></tr><tr><td>rpcgssd</td><td>与NFS有关的客户端功能</td><td>off</td></tr><tr><td>rpcidmapd</td><td>同上</td><td>off</td></tr><tr><td>rsync</td><td>远程数据备份守护进程</td><td>off</td></tr><tr><td>sendmail</td><td>sendmail邮件服务的守护进程。如果有邮件服务就开启</td><td>off</td></tr><tr><td>setroubleshoot</td><td>该服务用于将SELinux相关信息记录在日志&#x2F;var&#x2F;log&#x2F;messages中</td><td>on</td></tr><tr><td>smartd</td><td>该服务用于自动检则硬盘状态</td><td>on</td></tr><tr><td>smb</td><td>网络服务samba守护进程。可以让Linux和Windows之间共享数据。如果需要则开启</td><td>off</td></tr><tr><td>squid</td><td>代理服务的守护进程。</td><td>off</td></tr><tr><td>sshd</td><td>ssh加密远程登录管理的服务。</td><td>on</td></tr><tr><td>syslog</td><td>日志的守护进程。</td><td>on</td></tr><tr><td>vsftpd</td><td>vsftpd服务的守护进程。如果需要FTP服务则开启</td><td>off</td></tr><tr><td>xfs</td><td>这个是X Window的字体守护进程。为图形界面提供字体服务，如果不启动图形界面就不用开启</td><td>off</td></tr><tr><td>xinetd</td><td>超级守护进程。如果有依赖xinetd的服务就必须开启</td><td>off</td></tr><tr><td>ypbind</td><td>为NIS(网络信息系统)客户机激活ypbind服务进程。</td><td>off</td></tr><tr><td>yum-updatesd</td><td>yum的在线升级服务</td><td>off</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;服务的简介与分类&quot;&gt;&lt;a href=&quot;#服务的简介与分类&quot; class=&quot;headerlink&quot; title=&quot;服务的简介与分类&quot;&gt;&lt;/a&gt;服务的简介与分类&lt;/h2&gt;&lt;h3 id=&quot;服务的分类&quot;&gt;&lt;a href=&quot;#服务的分类&quot; class=&quot;headerlink&quot; title=&quot;服务的分类&quot;&gt;&lt;/a&gt;服务的分类&lt;/h3&gt;&lt;p&gt;Linux服务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RPM包默认安装的服务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;独立的服务&lt;/p&gt;
&lt;p&gt;就是独立启动的意思，这类型的服务可以自行启动，而不用依赖其他的管理服务。不依赖其他管理服务，那么当客户端请求访问时，独立的服务响应请求更迅速。Linux中目前大多数服务都是独立的服务，比如apache服务，FTP服务，Samba服务等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基于xinetd服务&lt;/p&gt;
&lt;p&gt;这种服务就不能独立启动了，而是要依靠管理服务来调用这种服务。这个负责管理的服务就是xinetd服务，xinetd服务是系统的超级守护进程。xinetd服务的作用就是管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务云唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释放资源。这样做的好处是只需要持续启动xinetd服务，而其他基于xinetd的服务只有在需要时才启动，不会占用过多的服务器资源。但是这种服务由于在有客户端靖求时才会被唤醒，所以响应时间相对较慢。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;源码包安装的服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;查询已经安装的服务&quot;&gt;&lt;a href=&quot;#查询已经安装的服务&quot; class=&quot;headerlink&quot; title=&quot;查询已经安装的服务&quot;&gt;&lt;/a&gt;查询已经安装的服务&lt;/h3&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bentech8.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>启动引导与修复</title>
    <link href="https://bentech8.github.io/2025/03/04/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%BF%AE%E5%A4%8D/"/>
    <id>https://bentech8.github.io/2025/03/04/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%BF%AE%E5%A4%8D/</id>
    <published>2025-03-04T07:32:41.000Z</published>
    <updated>2025-03-05T09:27:30.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h2><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>Linux默认有7个运行级别</p><table><thead><tr><th>运行级别</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>关机</td></tr><tr><td>1</td><td>单用户模式，可以想象为windows的安全模式，主要用于系统修复</td></tr><tr><td>2</td><td>不完全的命令行模式，不含NFS服务</td></tr><tr><td>3</td><td>完全的命令行模式，就是标准字符界面</td></tr><tr><td>4</td><td>系统保留</td></tr><tr><td>5</td><td>图形模式</td></tr><tr><td>6</td><td>重启动</td></tr></tbody></table><p>在Linux系统中可以使用runlevel命令来查看系统的运行级别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">N 5</span><br></pre></td></tr></table></figure><p>在这个命令的结果中，”N 5”中的N代表进入这个级别前，上一个级别是什么，5代表当前级别。”N”就是None的意思，也就是说系统是开机直接进入的5运行级别，没有上一个运行级别。那如果是从图形界面切换到字符界面的话，再查看运行级别，应该是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure><p>使用init命令可以手工改变当前的运行级别：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入图形界面，当然要已经安装了图形界面才可以</span></span><br><span class="line">[root@localhost ~]# init 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关机</span></span><br><span class="line">[root@localhost ~]# init 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">[root@localhost ~]# init 6</span><br></pre></td></tr></table></figure><p>不过要注意使用init命令关机和重启并不是太安全，容易造成数据丢失。所以推荐还是使用shutdown命令进行关机和重启。</p><h3 id="系统默认运行级别"><a href="#系统默认运行级别" class="headerlink" title="系统默认运行级别"></a>系统默认运行级别</h3><p>&#x2F;etc&#x2F;init&#x2F;rcS.conf配置文件调用&#x2F;etc&#x2F;inittab配置文件的目的就是为了确定系统的默认运行级别。也就是系统一开机后会进入那个运行级别。</p><p>注意这里的默认运行级别只能写成3或5，其的级别要不就是关机重启，要不就是保留或单用户，都不能作为系统默认运行级别。</p><h3 id="etc-rc-d-rc-local文件"><a href="#etc-rc-d-rc-local文件" class="headerlink" title="&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件"></a>&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件</h3><p>这个配置文件会在用户登录之前读取，这个文件中写入什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动就运行的工作，只需要写入&#x2F;etc&#x2F;rc.d&#x2F;rc.local这个配置文件即可。</p><h2 id="启动引导程序-Boot-Loader"><a href="#启动引导程序-Boot-Loader" class="headerlink" title="启动引导程序(Boot Loader)"></a>启动引导程序(Boot Loader)</h2><p>早期的Lilo引导程序已经不是很常见了，grub相比有很多优势，主要有：</p><ul><li>支持更多的文件系统；</li><li>grub的主程序可以直接在文件系统中查找内核文件；</li><li>在系统启动时，可以利用grub的交互界面编辑和修改启动选项；</li><li>可以动态的修改grub的配置文件，这样在修改配置文件之后不需要重新安装grub，而只需要重新启动就可以生效了。</li></ul><p>a）&#x2F;boot&#x2F;grub目录</p><p>grub的作用有以下几个：</p><ul><li>加载操作系统的内核。</li><li>拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。</li><li>还可以调用其他的启动引导程序，来实现多系统引导。</li></ul><p>grub的配置文件主要是放置在&#x2F;boot&#x2F;grub&#x2F;目录中的。其实这个目录中主要就是grub的配置文件和各种文件系统的stage1.5文件。不过grub的配置文件有两个&#x2F;boot&#x2F;grub&#x2F;grub.conf和&#x2F;boot&#x2F;grub&#x2F;menu.lst，这两个配置文件是软链接，所以修改哪一个都可以，个人习惯改grub.conf。</p><p>b）grub的配置文件</p><p>在grub中分区的表示方法</p><table><thead><tr><th>硬盘</th><th>分区</th><th>Linux中设备文件名</th><th>grub中设备文件名</th></tr></thead><tbody><tr><td>第一块SCSI硬盘</td><td>第一个主分区</td><td>&#x2F;dev&#x2F;sda1</td><td>hd(0,0)</td></tr><tr><td></td><td>第二个主分区</td><td>&#x2F;dev&#x2F;sda2</td><td>hd(0,1)</td></tr><tr><td></td><td>扩展分区</td><td>&#x2F;dev&#x2F;sda3</td><td>hd(0,2)</td></tr><tr><td></td><td>第一个逻辑分区</td><td>&#x2F;dev&#x2F;sda5</td><td>hd(0,4)</td></tr><tr><td>第二块SCSI硬盘</td><td>第一个主分区</td><td>&#x2F;dev&#x2F;sdb1</td><td>hd(1,0)</td></tr><tr><td></td><td>第二个主分区</td><td>&#x2F;dev&#x2F;sdb2</td><td>hd(1,1)</td></tr><tr><td></td><td>扩展分区</td><td>&#x2F;dev&#x2F;sdb3</td><td>hd(1,2)</td></tr><tr><td></td><td>第一个逻辑分区</td><td>&#x2F;dev&#x2F;sdb5</td><td>hd(1,4)</td></tr></tbody></table><p>grub的配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">root (hd0,0)</span><br><span class="line">kernel/vmlinuz-2.6.32-279.el6.i686roroot=UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKSKEYBOARDTYPE=pcKEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</span><br><span class="line">initrd/initramfs-2.6.32-279.el6.i686.img</span><br></pre></td></tr></table></figure><ul><li><p>default&#x3D;0</p><p>默认启动第一个系统。也就是如蛤在等待时间结束后，用户没有选择进入哪一个系统，那么系统会默认进入第一个系统。如果有多系统并存，那么每个系统都会有自己的titile字段，如果想要默认进入第二个系统，可以设为default&#x3D;1。</p></li><li><p>timeout&#x3D;5</p><p>等待时间，默认是5秒。也就是进入系统时，如果5秒内用户没有按下任意键，那么系统会进入default字段定义的系统。当然可以手工修改这个等待时间，如果timeout&#x3D;0则不会等待直接进入系统，timeout&#x3D;-1则是一直等待用户输入，而不会自动进入系统。</p></li><li><p>splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz</p><p>这里是指定grub启动时的背景图像文件的保存位置。hd(0,0)代表第一个硬盘的第一个分区。</p></li><li><p>hiddenmenu</p><p>隐藏菜单。启动时默认只能看到读秒，而不能看到菜单，如果想要看到菜单需要按任意键。如果注释了这句话，那么启动时就能直接看到菜单了。</p></li></ul><p>Centos系统的启动配置：</p><ul><li><p>title Centos (2.6.32-279.el6.i686)</p><p>title就是标题的意思，也就是说在title后面写入的是什么，那么系统启动时在grub的启动菜单中看到的就是什么。</p></li><li><p>root (hd0,0)</p><p>是指启动程序的保存分区。这个root并不是管理员。在我的系统中，&#x2F;boot分区是独立划分的，而且设备文件名为&#x2F;dev&#x2F;sda1，所以在grub中，就被描述为hd（0,0）。</p></li><li><p>kernel&#x2F;vmlinuz-2.6.32-279.el6.i686roroot&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKSKEYBOARDTYPE&#x3D;pcKEYTABLE&#x3D;us rd_NO_MD crashkernel&#x3D;auto LANG&#x3D;zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</p><ul><li><p>&#x2F;vmlinuz-2.6.32-279.el6.i686</p><p>指定了内核文件的位置，这里的&#x2F;是指&#x2F;boot分区。</p></li><li><p>ro</p><p>启动时以只读方式挂载根文件系统，这是为了不让启动过程影响磁盘内的文件系统。</p></li><li><p>root&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS</p><p>指定根文件系统所在位置。</p></li><li><p>rd_NO_LUKS</p><p>禁用LUKS，LUKS用于给磁盘加密。</p></li><li><p>rd_NO_MD</p><p>禁用软RAID</p></li><li><p>rd_NO_DM</p><p>禁用硬RAID</p></li><li><p>rd_NO_LVM</p><p>禁用LVM。以上禁用都只是在启动过程中禁用，是为加速系统启动的。</p></li><li><p>KEYBOARDTYPE&#x3D;pc    KEYTABLE&#x3D;us</p><p>键盘类型</p></li><li><p>crashkernel&#x3D;auto</p><p>自动为crashkernel预留内存</p></li><li><p>LANG&#x3D;zh_CN.UTF-8</p><p>语言环境</p></li><li><p>rhgb</p><p>（redhat graphics boot）用图片来代替启动过程中的文字信息。启动完成之后可以使用dmesg命令来查看这些文字信息。</p></li><li><p>quiet</p><p>隐藏启动信息，只显示重要信息。</p></li><li><p>initrd    &#x2F;initramfs-2.6.32-279.el6.i686.img</p><p>指定了initramfs内存文件系统镜像文件的所在位置。</p></li></ul></li></ul><p>grub加密</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grub-mkpasswd-pbkdf2</span><br><span class="line">输入密码： </span><br><span class="line">重新输入口令： </span><br><span class="line">您的密码的 PBKDF2 哈希为 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br></pre></td></tr></table></figure><p>这样就可以生成加密密码字串，这个字串是采用md5加密的，就是你的密码经md5编码之后的。</p><p>grub菜单整体加密</p><p>如果只是加密单个启动菜单，grub的编辑模式是不能锁定的，还是可以按“e”键进入编辑模式。而且进入编辑模式后，是可以删除password字段的，再按“b”（boot启动）键就可以不用密码直接进入系统。这时就需要给grub菜单整体加密了，整体加密后，如果想进入grub编辑界面必须输入正确的密码。加密方法其实只是把password字段换个位置而已。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout=5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是这样加密，启动CentOS时，是不需要密码就能正常启动的。如果需要grub整体加密，又需要系统启动时输入正确的密码时，则需：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">lock</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在title字段加入lock。代表锁死，如果不输入正确的grub密码也不能启动。</p><h2 id="系统修复模式"><a href="#系统修复模式" class="headerlink" title="系统修复模式"></a>系统修复模式</h2><h3 id="单用户模式"><a href="#单用户模式" class="headerlink" title="单用户模式"></a>单用户模式</h3><p>Linux的单用户模式有些类似Windows的安全模式，只启动最少的程序用于系统修复。在单用户模式(运行级别为1)中，Linux引导进入根shell，网络被禁用，只有少数进程运行。单用户模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。</p><p>a）进入单用户模式</p><p>开机进入引导界面，按“e”进入。</p><p>b）单用户模式常见的错误修复</p><ul><li><p>遗忘root密码</p><p>进入单用户模式最大的特点就是不需要输入用户名和密码就能登录。既然已经登录了单用户模式，那么直接给root用户设定新密码即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# passwd root</span><br></pre></td></tr></table></figure></li><li><p>修改系统默认运行级别</p><p>如果把系统的默认运行级别修改错误，比如改为了0或6，系统就不能正常启动了。这时也可以利用单用户模式进行修复，只要直接修改默认运行级别配置文件&#x2F;etc&#x2F;inittab，把系统默认运行级别修改回来即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/inittab</span><br><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure><p>绝大多数系统错误都可以通过单用户模式进行修复，理论上是只要能够进入单用户模式，那么系统错误就可以被单用户模式修复。当然意判断系统到底是哪里出现了问题，是需要不断地经验积累。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;系统运行级别&quot;&gt;&lt;a href=&quot;#系统运行级别&quot; class=&quot;headerlink&quot; title=&quot;系统运行级别&quot;&gt;&lt;/a&gt;系统运行级别&lt;/h2&gt;&lt;h3 id=&quot;运行级别&quot;&gt;&lt;a href=&quot;#运行级别&quot; class=&quot;headerlink&quot; title=&quot;运行级别&quot;&gt;&lt;/a&gt;运行级别&lt;/h3&gt;&lt;p&gt;Linux默认有7个运行级别&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运行级别&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;关机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;单用户模式，可以想象为windows的安全模式，主要用于系统修复&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;不完全的命令行模式，不含NFS服务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;完全的命令行模式，就是标准字符界面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;系统保留&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;图形模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;重启动&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;在Linux系统中可以使用runlevel命令来查看系统的运行级别：&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bentech8.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Terraform</title>
    <link href="https://bentech8.github.io/2025/02/28/Terraform/"/>
    <id>https://bentech8.github.io/2025/02/28/Terraform/</id>
    <published>2025-02-28T12:48:38.000Z</published>
    <updated>2025-03-14T04:10:00.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Terraform工作流程"><a href="#Terraform工作流程" class="headerlink" title="Terraform工作流程"></a>Terraform工作流程</h2><p>Terraform是一个基础设施即代码(IaC)工具，通过以下几个步骤来管理基础设施：</p><ul><li><p>配置文件（.tf文件）</p><p>用户首先通过编写Terraform配置文件来定义所需的基础设施。这些文件使用HCL（HashiCorp Configuration Language）语言，描述资源的类型、属性和配置。</p></li><li><p>初始化（terraform init）</p><p>在开始Terraform之前，用户需要运行terraform init命令。这一步会初始化工作目录，下载所需的提供程序(如AWS、Azure等)，并准备后续的操作。</p></li><li><p>生成执行计划（terraform plan）</p><p>使用terraform plan命令，Terraform会读取配置文件并生成执行计划，展示将要执行的操作（如创建、更新或删除资源）。这一步允许用户预览即将进行的变更，避免意外操作。</p></li><li><p>应用变更（terraform apply）</p><p>在确认执行计划后，用户可以运行terraform apply命令，Terraform会根据生成的计划实际执行相应的操作，创建、更新或删除云资源。</p></li><li><p>状态管理</p><p>Terraform会维护一个状态文件（terraform.tfstate），记录当前基础设施的状态。这个文件用于跟踪资源的实际状态，以便在后续操作中进行对比和管理。</p></li><li><p>变更管理</p><p>当需要对基础设施进行更改时，用户只需要修改配置文件，然后重复执行plan和apply流程。Terraform会自动识别资源的变更，并进行相应的更新。</p></li><li><p>销毁资源（terraform destory）</p><p>当不再需要某些资源时，用户可以运行terraform destory命令，Terraform会删除所有配置文件中定义的资源，确保清理工作整洁。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Terraform工作流程&quot;&gt;&lt;a href=&quot;#Terraform工作流程&quot; class=&quot;headerlink&quot; title=&quot;Terraform工作流程&quot;&gt;&lt;/a&gt;Terraform工作流程&lt;/h2&gt;&lt;p&gt;Terraform是一个基础设施即代码(IaC)工具</summary>
      
    
    
    
    <category term="DevOps" scheme="https://bentech8.github.io/categories/DevOps/"/>
    
    
  </entry>
  
  <entry>
    <title>Shell编程</title>
    <link href="https://bentech8.github.io/2025/02/27/Shell%E7%BC%96%E7%A8%8B/"/>
    <id>https://bentech8.github.io/2025/02/27/Shell%E7%BC%96%E7%A8%8B/</id>
    <published>2025-02-27T03:12:53.000Z</published>
    <updated>2025-03-01T11:05:53.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>正则表达式用来在文件中匹配符合条件的字符串，通配符用来匹配符合条件的文件名。其实这种区别只在Shell当中适用，因为用来文件当中搜索字符串的命令如grep、awk、sed等命令可以支持正则表达式，而在系统当中搜索文件的命令如ls、find、cp这些命令不支持正则表达式，所以只能使用Shell自己的通配符来进行匹配了。</p><h4 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><table><thead><tr><th>元字符</th><th>作用</th></tr></thead><tbody><tr><td>*</td><td>前一个字符匹配0次或任意多次</td></tr><tr><td>.</td><td>匹配除了换行符外任意一个字符</td></tr><tr><td>^</td><td>匹配行首。例如^hello会匹配以hello开头的行</td></tr><tr><td>$</td><td>匹配行尾。例如hello$会匹配以hello结尾的行</td></tr><tr><td>[]</td><td>匹配中括号中指定的任意一个字符，只匹配一个字符。例如[aoeiu]匹配任意一个元音字母</td></tr><tr><td>[^]</td><td>匹配除中括号的字符以外的任意一个字符。例如[^0-9]匹配任意一位非数字字符</td></tr><tr><td>\</td><td>转义符。用于取消特殊符号的转义</td></tr><tr><td>\{n\}</td><td>表示其前面的字符恰好出现n次。例如[0-9]\{4\}匹配4位数字</td></tr><tr><td>\{n, \}</td><td>表示其前面的字符出现不小于n次。例如[0-9]\{2, \}表示两位及以上的数字</td></tr><tr><td>\{n,m\}</td><td>表示其前面的字符至少出现n次，最多出现m次。例如[a-z]\{6,8\}匹配6到8位的小写字母。</td></tr></tbody></table><p>练习文件建立：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure><p>“a*”前一个字符匹配0次，或任意多次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure><p>“aa*”代表这行字符串最少要有一个a</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;aa*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure><p>“.”匹配除了换行符外任意一个字符，只能匹配一个字符，这个字符可以是任意字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s..d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# grep &quot;s.*d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure><p>“^”代表匹配行首，比如“^M”会匹配以大写“M”开头的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^M&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure><p>“$”代表匹配行尾，比如“n$”会匹配以小写“n”结尾的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;n$&quot; test_rule.txt</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure><p>“^$”则会匹配空白行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^$&quot; test_rule.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>“[]”会匹配中括号中指定任意一个字符，注意只能匹配一个字符。比如[ao]会匹配a或o</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s[ao]id&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure><p>“[^]”匹配除中括号的字符以外的任意一个字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[^a-z]&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">5555nice!</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure><p>“\“转义符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;\.$&quot; test_rule.txt</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure><p>“\{n\}”表示其前面的字符恰好出现n次</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a\&#123;3\&#125;&quot; test_rule.txt</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br></pre></td></tr></table></figure><p>“\{n,\}”会匹配前面的字符出现最少n次。比如“^[0-9]\{3, \}[a-z]”这个正则就能匹配最少用连续三个数字开头的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[0-9]\&#123;3,\&#125;[a-z]&quot; test_rule.txt</span><br><span class="line">123despise him.</span><br><span class="line">5555nice!</span><br></pre></td></tr></table></figure><p>“\{n,m\}”匹配其前面的字符至少出现n次，最多出现m次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;sa\&#123;1,3\&#125;i&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br></pre></td></tr></table></figure><h4 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h4><p>在正则表达式中应该还可以支持一些元字符，比如“+”、“?”、“|”、“()”。其实Linux是支持这些元字符的，只是grep命令默认不支持而已。如果想要支持这些元字符，必须使用egrep命令或grep -E选项，所以我们又把这些元字符称作扩展元字符。</p><p>如果查询grep的帮助，对egrep的说明就是和grep -E选项一样的命令，所以我们可以把这两个命令当做别名来对待。</p><table><thead><tr><th>扩展元字符</th><th>作用</th></tr></thead><tbody><tr><td>+</td><td>前一个字符匹配1次或任意多次。如“go+gle”会匹配“gogle”、“google”或“gooogle”等。</td></tr><tr><td>?</td><td>前一个字符匹配0次或1次。如”colou?r”可以匹配“colour”或“color”。</td></tr><tr><td>|</td><td>匹配两个或多个分支的选择。如”was|his”会匹配既包含“was”的行，也匹配包含”his”的行。</td></tr><tr><td>()</td><td>匹配其整体为一个字符，即模式单元。可以理解为由多个单字符组成的大字符。如“(dog)+”会匹配“dog”、“dogdog”、“dogdogdog”等。因为被()包含的字符会当成一个整体。</td></tr></tbody></table><h3 id="字符截取和替换命令"><a href="#字符截取和替换命令" class="headerlink" title="字符截取和替换命令"></a>字符截取和替换命令</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f 列号：         提取第几列</span><br><span class="line">  -d 分隔号：       按照指定分隔符分割列</span><br><span class="line">  -c 字符范围：      不依赖分隔符来区分列，而是通过字符范围(行首为0)来进行字段提取。“n-”表示从第n个字符到行尾；&quot;n-m&quot;表示从第n个字符到第m个字符；&quot;-                     m&quot;表示从第1个字符到第m个字符。</span><br></pre></td></tr></table></figure><p>cut命令的默认分隔符是制表符，也就是“tab”键。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    Gender  Mark</span><br><span class="line">1       Liming  M       86</span><br><span class="line">2       Sc      M       90</span><br><span class="line">3       Tg      M       83</span><br></pre></td></tr></table></figure><p>提取第二列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2 test.txt</span><br><span class="line">Name</span><br><span class="line">Liming</span><br><span class="line">Sc</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure><p>提取多列：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2,3 test.txt</span><br><span class="line">NameGender</span><br><span class="line">LimingM</span><br><span class="line">ScM</span><br><span class="line">TgM</span><br></pre></td></tr></table></figure><p>按照字符进行提取：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -c 8- test.txt        # &quot;8-&quot;代表提取所有行的第8个字符到结尾</span><br><span class="line">GenderMark</span><br><span class="line">gM86</span><br><span class="line">90</span><br><span class="line">83</span><br></pre></td></tr></table></figure><p>以“:”作为分隔符提取：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -d &quot;:&quot; -f 1,3 /etc/passwd</span><br><span class="line">root:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>a）printf格式化输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;输出类型输出格式&#x27; 输出内容</span><br><span class="line">输出类型：</span><br><span class="line">  %ns:        输出字符串。n是数字指代输出几个字符</span><br><span class="line">  %ni:        输出整数。n是数字指代输出几个数字</span><br><span class="line">  %m.nf:      输出浮点数。m和n是数字，指代输出的整数位和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。</span><br><span class="line">输出格式：</span><br><span class="line">  \a：         输出警告声音</span><br><span class="line">  \b：         输出退格键，也就是Backspace键</span><br><span class="line">  \f：         清除屏幕</span><br><span class="line">  \n:          换行</span><br><span class="line">  \r:          回车，也就是Enter键</span><br><span class="line">  \t:          水平输出退格键，也就是Tab键</span><br><span class="line">  \v:          垂直输出退格键，也就是Tab键</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure><p>使用printf输出test.txt文件的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s&#x27; $(cat test.txt)</span><br><span class="line">IDNamePHPLinuxMySQLAverage1Liming82958687.662Sc74968785.663Tg99839391.66[root@localhost ~]#</span><br></pre></td></tr></table></figure><p>如果不指定输出格式，则会把所有输出内容连在一起输出。其实文本的输出本身就是这样的，cat等文本输出命令之所以可以按照格式漂亮的输出，那是因为cat命令已经设定了输出格式。为了用printf输出合理的格式，可以这样做：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意在<span class="built_in">printf</span>命令的单引号中，只能识别格式输出符号，而手工输入的空格是无效的</span></span><br><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %s\t %s\t %s\t %s\t \n&#x27; $(cat test.txt)</span><br><span class="line">ID Name PHP Linux MySQL Average </span><br><span class="line">1 Liming 82 95 86 87.66 </span><br><span class="line">2 Sc 74 96 87 85.66 </span><br><span class="line">3 Tg 99 83 93 91.66</span><br></pre></td></tr></table></figure><p>如果不想把成绩当成字符串输出，而是按照整形和浮点型输出，则要这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %i\t %i\t %i\t %8.2f\t \n&#x27; $(cat test.txt | grep -v Name)</span><br><span class="line">1 Liming 82 95 86    87.66 </span><br><span class="line">2 Sc 74 96 87    85.66 </span><br><span class="line">3 Tg 99 83 93    91.66</span><br></pre></td></tr></table></figure><p>b）awk基本使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;...&#x27; 文件名</span><br><span class="line">条件(Pattern)：</span><br><span class="line">    一般使用关系表达式作为条件。这些关系表达式非常多。如：</span><br><span class="line">    x &gt; 10    判断变量x是否大于10</span><br><span class="line">    x == y    判断变是x是否等于变量y</span><br><span class="line">    A`B       判断字符串A中是否包含能匹配B表达式的子字符串</span><br><span class="line">    A!`B      判断字符串A中是否不包含能匹配B表达式的子字符串</span><br><span class="line">动作(Action)：</span><br><span class="line">    格式化输出</span><br><span class="line">    流程控制语句</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出第二列和第六列</span></span><br><span class="line">[root@localhost ~]# awk &#x27;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">NameAverage</span><br><span class="line">Liming87.66</span><br><span class="line">Sc85.66</span><br><span class="line">Tg91.66</span><br></pre></td></tr></table></figure><p>c）awk的条件</p><table><thead><tr><th>条件的类型</th><th>条件</th><th>说明</th></tr></thead><tbody><tr><td>awk保留字</td><td>BEGIN</td><td>在awk程序一开始时，尚未读取任何数据之前执行。BEGIN后的动作只在程序开始时执行一次。</td></tr><tr><td></td><td>END</td><td>在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次</td></tr><tr><td>关系运算符</td><td>&gt;</td><td>大于</td></tr><tr><td></td><td>&lt;</td><td>小于</td></tr><tr><td></td><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td></td><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td></td><td>&#x3D;&#x3D;</td><td>等于。用于判断两个值是否相等，如果是给变量赋值，请使用“&#x3D;”号</td></tr><tr><td></td><td>!&#x3D;</td><td>不等于</td></tr><tr><td></td><td>A~B</td><td>判断字符串A中是否包含能匹配B表达式的子字符串</td></tr><tr><td></td><td>A!~B</td><td>判断字符串B中是否不包含能匹配B表达式的子字符串</td></tr><tr><td>正则表达式</td><td>&#x2F;正则&#x2F;</td><td>如果在“&#x2F;&#x2F;”中可以写入字符，也可以支持正则表达式</td></tr></tbody></table><ul><li><p>BEGIN</p><p>BEGIN是awk的保留字，是一种特殊的条件类型。BEGIN的执行时机是“在awk程序一开始时，尚未读取任何数据之前执行”。一旦BEGIN后的动作执行一次，当awk开始从文件中读入数据，BEGIN的条件就不再成立，所以BEGIN定义的动作只能被执行一次。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">awk命令只要检测不到完整的单引号不会执行，所以这个命令的换行不用加入<span class="string">&quot;\&quot;</span></span></span><br><span class="line">[root@localhost ~]# awk &#x27;BEGIN&#123;printf &quot;This is a transcript \n&quot;&#125; </span><br><span class="line">&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">This is a transcript </span><br><span class="line">NameAverage</span><br><span class="line">Liming87.66</span><br><span class="line">Sc85.66</span><br><span class="line">Tg91.66</span><br></pre></td></tr></table></figure></li><li><p>END</p><p>END也是awk保留字，不过刚好和BEGIN相反。END是在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;END&#123;printf &quot;The END \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">NameAverage</span><br><span class="line">Liming87.66</span><br><span class="line">Sc85.66</span><br><span class="line">Tg91.66</span><br><span class="line">The END</span><br></pre></td></tr></table></figure></li><li><p>关系运算符</p><p>查看平均成绩大于等于87分的学员是谁：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$6 &gt;= 87&#123;printf $2 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">Liming</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure><p>加入条件之后，只有条件成立动作才会执行，如果条件不满足，则运作不运行。通过这个实验，大家可以发现，虽然awk是列提取命令，但是也要按行来读入的。这个命令的执行过程是这样的：</p><p>1）如果有BEGIN条件，则先执行BEGIN定义的动作</p><p>2）如果没有BEGIN条件，则读入第一行，把第一行的数据依次赋予$0、$1、$2等变量。其中$0代表此行的整体数据，$1代表第一字段，$2代表第二字段。</p><p>3）依据条件类型判断动作是否执行。如果条件符合，则执行动作，否则读入下一行数据。如果没有条件，则每行都执行动作。</p><p>4）读入下一行数据，重复执行以上步骤。</p><p>查看Sc用户的平均成绩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$2 ~ &quot;Sc&quot;&#123;printf $6 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">85.66</span><br></pre></td></tr></table></figure></li><li><p>正则表达式</p><p>如果想让awk识别字符串，必须使用“&#x2F;&#x2F;”包含，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印LiMing的成绩</span></span><br><span class="line">[root@localhost ~]# awk &#x27;/Liming/ &#123;print&#125;&#x27; test.txt </span><br><span class="line">1Liming82958687.66</span><br></pre></td></tr></table></figure><p>当使用df命令查看分区使用情况时，如果只想看真正的系统分区的使用状况，而不想查看光盘和临时分区的使用状况，则可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -h | awk &#x27;/sda[0-9]/ &#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure></li></ul><p>4）awk内置变量</p><table><thead><tr><th>awk内置变量</th><th>作用</th></tr></thead><tbody><tr><td>$0</td><td>代表目前awk所读入的整行数据。我们已知awk是一行一行读入数据的，$0就代表当前读入行的整行数据。</td></tr><tr><td>$n</td><td>代表目前读入行的第n个字段。</td></tr><tr><td>NF</td><td>当前行拥有的字段(列)总数。</td></tr><tr><td>NR</td><td>当前awk所处理的行，是总数据的第几行。</td></tr><tr><td>FS</td><td>用户定义分隔符。awk的默认分隔符是任何空格，如果想要使用其他分隔符(如”：”)，就需要FS变量定义。</td></tr><tr><td>ARGC</td><td>命令行参数个数。</td></tr><tr><td>ARGV</td><td>命令行参数数组。</td></tr><tr><td>FNR</td><td>当前文件中的当前记录数(对输入文件起始为1)。</td></tr><tr><td>OFMT</td><td>数值的输出格式(默认为%.6g)。</td></tr><tr><td>OFS</td><td>输出字段的分隔符(默认为空格)。</td></tr><tr><td>ORS</td><td>输出记录分隔符(默认为换行符)。</td></tr><tr><td>RS</td><td>输入记录分隔符(默认为换行符)。</td></tr></tbody></table><p>查询可以登录的用户的用户名和UID：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root0</span><br><span class="line">ben1000</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号:&quot; NR &quot;\t 字段数: &quot; NF &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root0 行号:1 字段数: 7</span><br><span class="line">ben1000 行号:2 字段数: 7</span><br></pre></td></tr></table></figure><p>查看sshd这个伪用户的相关信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $1==&quot;sshd&quot; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号：&quot; NR &quot;\t 字段数：&quot; NF &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p>5）awk流程控制</p><p>统计PHP成绩的总分：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR==2&#123;php1=$3&#125; NR==3&#123;php2=$3&#125; NR==4&#123;php3=$3;total=php1+php2+php3;print &quot;total php is &quot; total&#125;&#x27; test.txt</span><br><span class="line">total php is 255</span><br></pre></td></tr></table></figure><ul><li>“NR&#x3D;&#x3D;2{php1&#x3D;$3}”：条件是NR&#x3D;&#x3D;2，动作是php1&#x3D;$3，指如果输入数据是第二行(第一行是标题行)，就把第二行的第三字段的值赋予变量“php1”。</li><li>“NR&#x3D;&#x3D;3{php2&#x3D;$3}”：如果输入数据是第三行，就把第三行的第三字段的值赋予变量“php2”。</li><li>‘NR&#x3D;&#x3D;4{php3&#x3D;$3;total&#x3D;php1+php2+php3;print “total php is “ total}’：如果输入数据是第四行，就把第四行的第三字段的值赋予变量“php3”；然后定义变量total的值为‘php1+php2+php3’；然后输出”total php is “关键字，后面加变量total的值。</li></ul><p>在awk编程中，因为命令语句非常长，在输入格式时需要注意以下内容：</p><ul><li>多个条件{动作}可以用空格分割，也可以用回车分割。</li><li>在一个动作中，如果需要执行多个命令，需要用“;”分割，或用回车分割。</li><li>在awk中，变量的赋值与调用都不需要加入“$”符。</li><li>条件中判断两个值是否相同，请使用”&#x3D;&#x3D;”，以便和变量赋值进行区分。</li></ul><p>如果Linux成绩大于90，就是一个好学生：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;&#123;if (NR&gt;=2)&#123;if ($3&gt;90) printf $2 &quot; is a good student!\n&quot;&#125;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure><p>其实awk中if判断语句，完全可以直接利用awk自带的条件来取代：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR&gt;=2&#123;test=$3&#125; test&gt;90&#123;printf $2 &quot; is a good student!\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure><p>6）awk函数</p><p>awk编程也允许在编程时使用函数，awk函数定义方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名 (参数列表) &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一简单的函数，使用函数来打印test.txt的学员姓名和平均成绩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;function test(a,b) &#123;printf a &quot;\t&quot; b &quot;\n&quot;&#125; &#123;test($2,$6)&#125;&#x27; test.txt</span><br><span class="line">NameAverage</span><br><span class="line">Liming87.66</span><br><span class="line">Sc85.66</span><br><span class="line">Tg91.66</span><br></pre></td></tr></table></figure><p>7）awk中调用脚本</p><p>对于小的单行程序来说，将脚本作为命令行自变量传递给awk是非常简单的，而对于多行程序就比较难处理。当程序是多行的时候，使用外部脚本是很适合的。首先在外部文件中写好脚本，然后可以使用awk的-f选项，使其读入脚本并且执行。</p><p>例如，我们可以先编写一个awk脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim pass.awk</span><br><span class="line">BEGIN&#123;FS=&quot;:&quot;&#125;</span><br><span class="line">&#123;print $1 &quot;\t&quot; $3&#125;</span><br></pre></td></tr></table></figure><p>然后可以使用”-f”选项来调用这个脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk -f pass.awk /etc/passwd</span><br><span class="line">root0</span><br><span class="line">daemon1</span><br><span class="line">bin2</span><br><span class="line">sys3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>sed主要是用来将数据进行选取、替换、删除和新增的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed [选项] &#x27;[动作]&#x27; 文件名</span><br><span class="line">选项：</span><br><span class="line">  -n:              一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。</span><br><span class="line">  -e:              允许对输入数据应用多条sed命令编辑。</span><br><span class="line">  -f 脚本文件名:    从sed脚本中读入sed操作。和awk命令的-f非常类似。</span><br><span class="line">  -r:              在sed中支持扩展正则表达式。</span><br><span class="line">  -i:              用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出</span><br><span class="line">动作：</span><br><span class="line">  a \n:             追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  c \n:             行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用&quot;\&quot;代表数据未完结。</span><br><span class="line">  i \n:             插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  d:               删除，删除指定的行。</span><br><span class="line">  p:               打印，输出指定的行。</span><br><span class="line">  s:               字串替换，用一个字符串替换另外一个字符串。格式为&quot;行范围 s/旧字串/新字串/g&quot;（和vim中的替换格式类似）</span><br></pre></td></tr></table></figure><p>对sed命令要注意，sed所做的修改并不会直接改变文件的内容(如果是用管道符接收的命令的输出，这种情况连文件都没有)，而是把修改结果只显示到屏幕上，除非使用“-i”选项才会直接修改文件。</p><ul><li><p>行数据操作</p><p>【查看】</p><p>查看test.txt的第二行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2p&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure><p>“p”命令确实输出了第二行数据，但是sed命令还会把所有数据都输出一次。如果想指定输出某行数据，需要”-n”选项的帮助：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -n &#x27;2p&#x27; test.txt</span><br><span class="line">1       Liming  82      95      86      87.66</span><br></pre></td></tr></table></figure><p>【删除】</p><p>删除第二行到第四行的数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,4d&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件本身并没有修改</span></span><br><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure><p>【追加】</p><p>“a“会在指定行后面追加入数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2a hello&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">hello</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure><p>【插入】</p><p>“i”会在指定行前面插入数据:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# sed -n &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p>【替换】</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2c No such person&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No such person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat test.txt | sed &#x27;2c No sucn person&#x27;</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No sucn person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure><p>sed命令默认情况下是不会修改文件内容的，如果确定需要让sed命令直接处理文件的内容，可以使用”-i”选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -i &#x27;2c No such person&#x27; test.txt</span><br></pre></td></tr></table></figure></li><li><p>字符串替换</p><p>“c”动作是进行整行替换的，如果仅仅想替换行中的部分数据，就要使用“s”动作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/旧字串/新字串/g&#x27; 文件名</span><br></pre></td></tr></table></figure><p>在第三行中，把74替换成99：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3s/74/99/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      99      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure><p>把第四行注释掉：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;4s/^/#/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3       Tg      99      83      93      91.66</span></span><br></pre></td></tr></table></figure><p>“-e”选项可以同时执行多个sed动作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -e &#x27;s/Liming//g;s/Tg//g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1         82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3             99      83      93      91.66</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f:        忽略大小写</span><br><span class="line">  -b:        忽略每行前面的空白部分</span><br><span class="line">  -n:        以数值型进行排序，默认使用字符串型排序</span><br><span class="line">  -r:        反向排序</span><br><span class="line">  -u:        删除重复行。就是uniq命令</span><br><span class="line">  -t:        指定分隔符，默认分隔符是制表符</span><br><span class="line">  -k n[,m]:  按照指定的字段范围排序。从第n字段开始，m字段结束(默认到行尾)</span><br></pre></td></tr></table></figure><p>sort命令默认是用每行开头第一个字符来进行排序的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort /etc/passwd</span><br><span class="line">_apt:x:105:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:109:116:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">avahi:x:115:121:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>反向排序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort -r /etc/passwd</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">whoopsie:x:120:125::/nonexistent:/bin/false</span><br><span class="line">uuidd:x:107:114::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果想要指定排序的字段，需要先使用“-t”选项指定分隔符，并使用“-k”选项指定字段号。例如按照UID字段排序&#x2F;etc&#x2F;passwd文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>当然“-k”选项可以直接使用“-k 3”，代表从第三字段到行尾排序（第一个字符先排序，如果一致，第二个字符再排序，直到行尾）。</p><h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>uniq命令是用来取消重复行的命令，其实和”sort -u”选项是一样的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uniq [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -i:        忽略大小写</span><br></pre></td></tr></table></figure><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>统计命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# wc [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -l:        只统计行数</span><br><span class="line">  -w:        只统计单词数</span><br><span class="line">  -m:        只统计字符数</span><br></pre></td></tr></table></figure><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="按照文件类型进行判断"><a href="#按照文件类型进行判断" class="headerlink" title="按照文件类型进行判断"></a>按照文件类型进行判断</h4><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-b 文件</td><td>判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）</td></tr><tr><td>-c 文件</td><td>判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真）</td></tr><tr><td>-d 文件</td><td>判断该文件是否存在，并且是否为目录文件（是目录为真）</td></tr><tr><td>-e 文件</td><td>判断该文件是否存在（存在为真）</td></tr><tr><td>-f 文件</td><td>判断该文件是否存在，并且是否为普通文件（是普通文件为真）</td></tr><tr><td>-L 文件</td><td>判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）</td></tr><tr><td>-p 文件</td><td>判断该文件是否存在，并且是否为管道文件（是管道文件为真）</td></tr><tr><td>-s 文件</td><td>判断该文件是否存在，并且是否为非空（非空为真）</td></tr><tr><td>-S 文件</td><td>判断该文件是否存在，并且是否为套接字文件（是套接字文件为真）</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# [ -e /root/sh/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">0        # 判断结果为0，/root/sh/目录是存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -e /root/test/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">1        # 判断结果为0，/root/test/目录是不存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -d /root/sh ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个判断命令如果正确执行，则打印<span class="string">&quot;yes&quot;</span>，否则打印<span class="string">&quot;no&quot;</span></span></span><br></pre></td></tr></table></figure><h4 id="按照文件权限进行判断"><a href="#按照文件权限进行判断" class="headerlink" title="按照文件权限进行判断"></a>按照文件权限进行判断</h4><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-r 文件</td><td>判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真）</td></tr><tr><td>-w 文件</td><td>判断该文件是否存在，并且是否该文件拥有写权限（有写权限为真）</td></tr><tr><td>-x 文件</td><td>判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）</td></tr><tr><td>-u 文件</td><td>判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真）</td></tr><tr><td>-g 文件</td><td>判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真）</td></tr><tr><td>-k 文件</td><td>判断该文件是否存在，并且是否该文件拥有SBIT权限（有SBIT权限为真）</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll test.txt</span><br><span class="line">-rw-rw-r-- 1 ben ben 187  2月 28 02:09 test.txt</span><br><span class="line">[root@localhost ~]# [ -w test.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure><h4 id="两个文件之间进行比较"><a href="#两个文件之间进行比较" class="headerlink" title="两个文件之间进行比较"></a>两个文件之间进行比较</h4><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>文件1 -nt 文件2</td><td>判断文件1的修改时间是否比文件2的新（如果新则为真）</td></tr><tr><td>文件1 -ot 文件2</td><td>判断文件1的修改时间是否比文件2的旧（如果旧则为真）</td></tr><tr><td>文件1 -ef 文件2</td><td>判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建个硬链接</span></span><br><span class="line">[root@localhost ~]# ln /tmp/test.txt /tmp/stu.txt</span><br><span class="line">[root@localhost ~]# [ /tmp/test.txt -ef /tmp/stu.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure><h4 id="两个整数之间比较"><a href="#两个整数之间比较" class="headerlink" title="两个整数之间比较"></a>两个整数之间比较</h4><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>整数1 -eq 整数2</td><td>判断整数1是否和整数2相等（相等为真）</td></tr><tr><td>整数1 -ne 整数2</td><td>判断整数1是否和整数2不相等（不相等为真）</td></tr><tr><td>整数1 -gt 整数2</td><td>判断整数1是否大于整数2（大于为真）</td></tr><tr><td>整数1 -lt 整数2</td><td>判断整数1是否小于整数2（小于为真）</td></tr><tr><td>整数1 -ge 整数2</td><td>判断整数1是否大于等于整数2（大于等于为真）</td></tr><tr><td>整数1 -le 整数2</td><td>判断整数1是否小于等于整数2（小于等于为真）</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# [ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br><span class="line">[root@localhost ~]# [ 23 -le 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure><h4 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h4><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>-z 字符串</td><td>判断字符串是否为空（为空返回真）</td></tr><tr><td>-n 字符串</td><td>判断字符串是否为非空（非空返回真）</td></tr><tr><td>字符串1 &#x3D;&#x3D; 字符串2</td><td>判断字符串1是否和字符串2相等（相等返回真）</td></tr><tr><td>字符串1 !&#x3D; 字符串2</td><td>判断字符串1 是否和字符串2不相等（不相等返回真）</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给name赋值</span></span><br><span class="line">[root@localhost ~]# name=ben</span><br><span class="line">[root@localhost ~]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# bb=22</span><br><span class="line">[root@localhost ~]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure><h4 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h4><table><thead><tr><th>测试选项</th><th>作用</th></tr></thead><tbody><tr><td>判断1 -a 判断2</td><td>逻辑与，判断1和判断2都成立，最终的结果为真</td></tr><tr><td>判断1 -o 判断2</td><td>逻辑或，判断1和判断2有一个成立，最终的结果就为真</td></tr><tr><td>! 判断</td><td>逻辑非，使原始的判断式取反</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line">[root@localhost ~]# [ ! -n &quot;$aa&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>“!”和“-n”之间必须加入空格，否则会报错的。</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h4><p>a）单分支if条件语句</p><p>单分支条件语句最为简单，就是只有一个判断条件，如果符合条件则执行某个程序，否则什么事情都不做。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>单分支条件语句需要注意几个点：</p><ul><li><p>if语句使用fi结尾，和一般语言使用大括号结尾不同。</p></li><li><p>[ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格。</p></li><li><p>then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">then</span><br><span class="line">程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda3&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f1)</span><br><span class="line">if [ $rate -ge 80 ];then</span><br><span class="line">echo &quot;Warning! /dev/sda3 is full!!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>b）双分支if条件语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]；then</span><br><span class="line">条件成立时，执行的程序</span><br><span class="line">else</span><br><span class="line">条件不成立时，执行的另一个程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步系统时间</span></span><br><span class="line">ntpdate asia.pool.ntp.org &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把当前系统时间按照<span class="string">&quot;年月日&quot;</span>格式赋予变量<span class="built_in">date</span></span></span><br><span class="line">date=$(date +%y%m%d)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计mysql数据库的大小，并把大小赋予size变量</span></span><br><span class="line">size=$(du -sh /var/lib/mysql)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断备份目录是否存在，是否为目录</span></span><br><span class="line">if [ -d  /tmp/dbak ];then</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入备份目录</span></span><br><span class="line">cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件</span></span><br><span class="line">rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果判断为假，则建立备份目录</span></span><br><span class="line">mkdir /tmp/dbbak</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入备份目录</span></span><br><span class="line">cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件</span></span><br><span class="line">rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>在工作中，服务器上的服务经常会宕机。如果我们对服务器监控不好，就会造成服务器中服务宕机了，而管理员却不知道的情况，这时我们可以写一个脚本来监听本机的服务，如果服务停止或宕机了，可以自动重启这些服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用nmap命令扫描服务器，并截取apache服务的状态，赋予变量port</span></span><br><span class="line">port=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">if [ &quot;$port&quot; == &quot;open&quot; ];then</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">则证明apache正常启动，在正常日志中写入一句话即可</span></span><br><span class="line">echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/autostart-acc.log</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">否则证明apache没有启动，自动启动apache</span></span><br><span class="line">/etc/rc.d/init.d/httpd start &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并在错误日志中记录自动启动apache的时间</span></span><br><span class="line">echo &quot;$(date) restart httpd!!&quot; &gt;&gt; /tmp/autostart-err.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>c）多分支if条件语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式1 ];then</span><br><span class="line">当条件判断式1成立时，执行程序1</span><br><span class="line">elif [ 条件判断式2 ];then</span><br><span class="line">当条件判断式2成立时，执行程序2</span><br><span class="line">else</span><br><span class="line">当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>判断用户输入的是什么文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">！/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email:17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接收键盘的输入，并赋予变量file</span></span><br><span class="line">read -p &quot;Please input a filename: &quot; file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file变量是否为空</span></span><br><span class="line">if [ -z &quot;$file&quot; ];then</span><br><span class="line">echo &quot;Error,please input a filename&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出程序，并返回1</span></span><br><span class="line">exit 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否存在</span></span><br><span class="line">elif [ ! -e &quot;$file&quot; ];then</span><br><span class="line">echo &quot;Your input is not a file!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出程序，并返回2</span></span><br><span class="line">exit 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为普通文件</span></span><br><span class="line">elif [ -f &quot;$file&quot; ];then</span><br><span class="line">echo &quot;$file is a regulare file!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为目录文件</span></span><br><span class="line">elif [ -d &quot;$file&quot; ];then</span><br><span class="line">echo &quot;$file is a directory!&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;$file is an other file!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="多分支case条件语句"><a href="#多分支case条件语句" class="headerlink" title="多分支case条件语句"></a>多分支case条件语句</h4><p>case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">&quot;值1&quot;)</span><br><span class="line">如果变量的值等于值1，则执行程序1</span><br><span class="line">;;</span><br><span class="line">&quot;值2&quot;)</span><br><span class="line">如果变量的值等于值2，则执行程序2</span><br><span class="line">;;</span><br><span class="line">...</span><br><span class="line">*)</span><br><span class="line">如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>这个语句需要注意以下内容：</p><ul><li><p>case语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行“*)”（“*”代表所有其他值）中的程序。</p></li><li><p>case语句以“case”开头，以“esac”结尾。</p></li><li><p>每个分支程序之后要通过“;;”双分号结尾，代表该程序段结束。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please choose yes/no: &quot; -t 30 cho</span><br><span class="line">case $cho in </span><br><span class="line">&quot;yes&quot;)</span><br><span class="line">echo &quot;Your choose is yes!&quot;</span><br><span class="line">;;</span><br><span class="line">&quot;no&quot;)</span><br><span class="line">echo &quot;Your choose is no!&quot;</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo &quot;Your choose is error!&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环是固定循环，也就是在循环时已经知道需要进行几次循环，有时也把for循环称为计数循环。</p><p>语法一：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这种语法中for循环的次数，取决于in后面值的个数（空格分隔），有几个值就循环几次，并且每次循环都把值赋予变量。</p><p>打印时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for time in morning noon afternoon evening</span><br><span class="line">do</span><br><span class="line">echo &quot;This time is $time&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>批量解压缩脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入压缩目录</span></span><br><span class="line">cd /lamp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把所有tar.gz结尾的文件的文件覆盖到ls.log临时文件中</span></span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line">for i in $(cat ls.log)</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压缩</span></span><br><span class="line">tar -zxf $i &amp;&gt;/dev/null</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件ls.log</span></span><br><span class="line">rm -rf /lamp/ls.log</span><br></pre></td></tr></table></figure><p>语法二：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这种语法需要注意：</p><ul><li>初始值：在循环开始时，需要给某个变量赋予初始值，如i&#x3D;1;</li><li>循环控制条件：用于指定变量循环的次数，如i&lt;&#x3D;100，则只要i的值小于等于100，循环就会继续;</li><li>变量变化：每次循环之后，变量该如何变化，如i&#x3D;i+1。代表每次循环之后，变量i的值都加1。</li></ul><p>从1加到100：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for (( i=1;i&lt;=100;i=i+1 ))</span><br><span class="line">do</span><br><span class="line">s=$(( $s+$i ))</span><br><span class="line">done</span><br><span class="line">echo &quot;The sum of 1+2+...+100 is : $s&quot;</span><br></pre></td></tr></table></figure><p>批量添加指定数量的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入用户名，把输入保存入变量name</span></span><br><span class="line">read -p &quot;Please input user name: &quot; -t 30 name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入添加用户的数量，把输入保存入变量num</span></span><br><span class="line">read -p &quot;Please input the number of users: &quot; -t num</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入初始密码，把输入保存入变量pass</span></span><br><span class="line">read -p &quot;Please input the password of users: &quot; -t pass</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断三个变量不为空</span></span><br><span class="line">if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;#pass&quot; ];then</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断变量num的值是否为数字</span></span><br><span class="line">y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line">if [ -z &quot;$y&quot; ];then</span><br><span class="line">for (( i=1;i&lt;=$num;i=i+1 ))</span><br><span class="line">do</span><br><span class="line"># 添加用户</span><br><span class="line">/usr/sbin/useradd $name$i &amp;&gt;/dev/null</span><br><span class="line"># 修改用户密码</span><br><span class="line">echo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null</span><br><span class="line">done</span><br><span class="line">fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>批量删除用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">user=$(cat /etc/passwd | grep &quot;/bin/bash&quot; | grep -v &quot;root&quot; | cut -d &quot;:&quot; -f 1)</span><br><span class="line">for i in $user</span><br><span class="line">do</span><br><span class="line">userdel -r $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>对while循环来讲，只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。</p><p>从1加到100：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">do</span><br><span class="line">s=$(( $s+$i ))</span><br><span class="line">i=$(( $i+ 1 ))</span><br><span class="line">done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><p>until循环和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ 条件判断式 ]</span><br><span class="line">do</span><br><span class="line">程序</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>从1加到100：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">until [ $i -gt 100 ]</span><br><span class="line">do</span><br><span class="line">s=$(( $s+$i ))</span><br><span class="line">i=$(( $i+1 ))</span><br><span class="line">done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名（）&#123;</span><br><span class="line">程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">function sum () &#123;</span><br><span class="line">s=0</span><br><span class="line">for (( i=0;i&lt;=$1;i=i+1 ))</span><br><span class="line">do</span><br><span class="line">s=$(( $i+$s ))</span><br><span class="line">done</span><br><span class="line">echo &quot;The sum of 1+2+3+...+$l is: $s&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line">y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line"></span><br><span class="line">if [ -z $y ];then</span><br><span class="line">sum $num</span><br><span class="line">else</span><br><span class="line">echo &quot;Error!! Please input a number!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="特殊流程控制语名"><a href="#特殊流程控制语名" class="headerlink" title="特殊流程控制语名"></a>特殊流程控制语名</h4><p>a）exit语句</p><p>系统是有exit命令的，用于退出当前用户的登录状态。可是在shell脚本中，exit语句是用来退出当前脚本的。也就是说，在Shell脚本中，只要碰到了exit语句，后续的程序就不再执行，而是直接退出脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit [返回值]</span><br></pre></td></tr></table></figure><p>如果exit命令之后定义了返回值，那么这个脚本执行之后的返回值就是我们自己定义的返回值。可以通过$?这个变量来查看返回值。如果exit之后没有定义返回值，脚本执行之后的返回值是执行exit语句之前，最后执行的一条命令的返回值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line"></span><br><span class="line">y=$(echo $num | sed &quot;s/[0-9]//g&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断变量num的值如果不为空，则输出报错信息，并且退出脚本，退出返回值为18</span></span><br><span class="line">[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18</span><br><span class="line"></span><br><span class="line">echo &quot;The number is: $num&quot;</span><br></pre></td></tr></table></figure><p>b）break语句</p><p>当程序执行到break语句时，会结束整个当前循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">do</span><br><span class="line">if [ $i -eq 4 ];then</span><br><span class="line">break</span><br><span class="line">fi</span><br><span class="line">echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>c）continue语句</p><p>continue也是结束流程控制的语句。continue语句只会结束单次当前循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">do</span><br><span class="line">if [ $i -eq 4 ];then</span><br><span class="line">continue</span><br><span class="line">fi</span><br><span class="line">echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Shell编程&quot;&gt;&lt;a href=&quot;#Shell编程&quot; class=&quot;headerlink&quot; title=&quot;Shell编程&quot;&gt;&lt;/a&gt;Shell编程&lt;/h2&gt;&lt;h3 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h4&gt;&lt;p&gt;正则表达式用来在文件中匹配符合条件的字符串，通配符用来匹配符合条件的文件名。其实这种区别只在Shell当中适用，因为用来文件当中搜索字符串的命令如grep、awk、sed等命令可以支持正则表达式，而在系统当中搜索文件的命令如ls、find、cp这些命令不支持正则表达式，所以只能使用Shell自己的通配符来进行匹配了。&lt;/p&gt;
&lt;h4 id=&quot;基础正则表达式&quot;&gt;&lt;a href=&quot;#基础正则表达式&quot; class=&quot;headerlink&quot; title=&quot;基础正则表达式&quot;&gt;&lt;/a&gt;基础正则表达式&lt;/h4&gt;</summary>
    
    
    
    <category term="Shell" scheme="https://bentech8.github.io/categories/Shell/"/>
    
    
  </entry>
  
  <entry>
    <title>高级文件系统管理</title>
    <link href="https://bentech8.github.io/2025/02/25/%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://bentech8.github.io/2025/02/25/%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</id>
    <published>2025-02-25T05:05:22.000Z</published>
    <updated>2025-02-25T05:10:07.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级文件系统管理"><a href="#高级文件系统管理" class="headerlink" title="高级文件系统管理"></a>高级文件系统管理</h1><h2 id="1-磁盘配额"><a href="#1-磁盘配额" class="headerlink" title="1. 磁盘配额"></a>1. 磁盘配额</h2><h3 id="1）磁盘配额条件"><a href="#1）磁盘配额条件" class="headerlink" title="1）磁盘配额条件"></a>1）磁盘配额条件</h3><ul><li><p>内核必须支持磁盘配额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep CONFIG_QUOTA /boot/config-2.6.32-279.el6.i686</span><br><span class="line">CONFIG_QUOTA=y</span><br><span class="line">CONFIG_QUOTA_NETLINK_INTERFACE=y</span><br><span class="line"># CONFIG_QUOTA_DEBUG is not set</span><br><span class="line">CONFIG_QUOTA_TREE=m</span><br><span class="line">CONFIG_QUOTACTL=y</span><br></pre></td></tr></table></figure></li><li><p>系统中必须安装了quota工具，Linux默认是安装了quota工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa | grep quota</span><br><span class="line">quota-3.17-16.el6.i686</span><br></pre></td></tr></table></figure><p>要支持磁盘配额的分区必须开启磁盘配额功能，这个功能需要手工开启，不再是默认就开启的。</p></li></ul><h3 id="2）概念"><a href="#2）概念" class="headerlink" title="2）概念"></a>2）概念</h3><ul><li>用户配额和组配额</li><li>磁盘容量限制和文件个数限制</li><li>软限制和硬限制</li><li>宽限时间</li></ul><p>如果用户的空间占用数处于软限制和硬限制之间，都会在用户登录时警告用户磁盘将满，这个时间就是宽限时间，默认是7天。如果达到了宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级为硬限制。</p><h3 id="3）磁盘配额规划"><a href="#3）磁盘配额规划" class="headerlink" title="3）磁盘配额规划"></a>3）磁盘配额规划</h3><p>磁盘配额实验：</p><ul><li>磁盘配额是限制普通用户在分区上使用磁盘空间和文件个数的，所以我们需要指定一个分区，那么我们手工建立一个5GB的&#x2F;dev&#x2F;sdb1分区，把它挂载到&#x2F;disk目录当中。</li><li>还有我们需要建立被限制的用户和用户组。那么我们假设需要限制user1、user2和user3用户，这三个用户属于test组。</li><li>其中test组磁盘容量硬限制为500MB，软限制450MB，文件个数不做限制。user1用户为了便于测试，磁盘容量硬限制为50MB，软限制为40MB，文件个数硬限制为10个，软限制为8个。user2和user3用户磁盘容量硬限制为250MB，软限制为200MB，文件个数不做限制。</li><li>user1、user2和user3用户加起来的磁盘容量限制为550MB，超过了test组的磁盘容量500MB。这样的话，某个用户可能达不到自己的用户限制，而达到组限制时就不能再写入数据了。也就是说，如果用户限制和组限制同时存在，那么哪个限制更小，哪个限制优先生效。</li><li>系统宽限时间改为8天。</li></ul><p>磁盘配额步骤：</p><ul><li><p>分配5GB的&#x2F;dev&#x2F;sdb1分区，并将它挂载到&#x2F;disk目录当中。</p></li><li><p>建立需要做限制的用户和用户组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd test</span><br><span class="line">[root@localhost ~]# useradd -G test user1</span><br><span class="line">[root@localhost ~]# useradd -G test user2</span><br><span class="line">[root@localhost ~]# useradd -G test user3</span><br><span class="line">[root@localhost ~]# passwd user1</span><br><span class="line">[root@localhost ~]# passwd user2</span><br><span class="line">[root@localhost ~]# passwd user3</span><br></pre></td></tr></table></figure></li><li><p>在分区上开启磁盘配额功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,usruota,grpquota /disk    # 重新挂载/disk分区，并加入用户和用户组的磁盘配额功能</span><br></pre></td></tr></table></figure><p>要想永久生效，则需要修改&#x2F;etc&#x2F;fstab文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1    /disk    ext4    defaults,usrquota,grpquota    0    0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /disk    # 修改配置文件如果想要生效，必须重启系统，否则也需要把分区重新挂载一遍</span><br></pre></td></tr></table></figure></li><li><p>建立磁盘配额的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：扫描/etc/mtab文件中所有启用磁盘配额功能的分区。如果加入此参数，命令后面就不需要加入分区名了</span><br><span class="line">  -c：不管原有的配置文件，重新扫描并建立新的配置文件</span><br><span class="line">  -u：建立用户配额的配置文件，也就是生成aquota.user文件</span><br><span class="line">  -g：建立组配额的配置文件，会生成aquota.group文件</span><br><span class="line">  -v：显示扫描过程</span><br><span class="line">  -m：强制以读写的方式扫描文件系统，和-M类似。一般扫描根分区时使用。</span><br><span class="line">  -f：强制扫描文件系统，并写入新的配置文件。一般扫描新添加的硬盘分区时使用。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck -avug</span><br></pre></td></tr></table></figure><p>需要关闭SELinux，否则会报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /disk/</span><br><span class="line">总计 24</span><br><span class="line">-rw-------   1 root root  6144  4月 31 19:30 aquota.group</span><br><span class="line">-rw-------   1 root root  6144  4月 18 19:30 aquota.user</span><br><span class="line"># /disk目录中两个配额配置文件已经建立</span><br></pre></td></tr></table></figure><p>如果需要给根分区开启配额功能，需要：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2    /    ext4    defaults,usrquota,grpquota    1    1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /</span><br><span class="line">[root@localhost ~]# quotacheck -avugm</span><br></pre></td></tr></table></figure><p>如果我们自动扫描&#x2F;分区建立配额文件时，因为&#x2F;分区已经挂载成读写系统，而quotacheck需要把分区先挂载成只读分区，然后建立配置文件，最后再挂载回来，所以不能直接在&#x2F;分区建立配置文件，这时就需要使用-m强制以读写方式扫描文件系统了。</p><ul><li><p>设置用户和组的配额限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：  设定用户配额</span><br><span class="line">  -g 组名：    设定组配额</span><br><span class="line">  -t：        设定宽限时间</span><br><span class="line">  -p：        复制配额限制。如果已经设定好某个用户的配额限制，其他用户的配额限制如果和这个用户相同，那么可以直接复制配额限制，而不用都手工指定</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota -u user1</span><br><span class="line"># edquota命令进入之后，就是标准的vi操作方法</span><br><span class="line">Disk quotas for user user1（uid 500）：</span><br><span class="line"># 磁盘配额是设定用户user1（UID是500）</span><br><span class="line">Filesystem    blocks        soft     hard     inodes        soft      hard</span><br><span class="line">/dev/sdb1       0           40000    50000      0            8         10</span><br><span class="line"># 分区名        已占用容量    软限制    硬限制     已占用文件数   软限制     硬限制</span><br></pre></td></tr></table></figure></li><li><p>配额复制</p><p>user3用户的配额值和user2用户完全一样，就可以使用user2用户作为模板进行复制，这样我们如果需要建立大量的配额值一致的用户时，就会非常方便，不用一个个手工建立了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota -p user2 -u user3</span><br></pre></td></tr></table></figure></li><li><p>修改宽限时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota -t</span><br><span class="line">Grace period before enforcing soft limits for users:</span><br><span class="line">Time units may be: days, hours, minutes, or seconds</span><br><span class="line">Filesystem    Block grace period    Inode grace period</span><br><span class="line">/dev/sdb1       8days                8days</span><br><span class="line"># 分区名        容量的宽限时间          个数的宽限时间</span><br></pre></td></tr></table></figure></li><li><p>启动和关闭配额</p><p>启动配额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotaon [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件启动所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：启动用户配额</span><br><span class="line">  -g：启动组配额</span><br><span class="line">  -v：显示启动过程的信息</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quotaon -vug /disk/        # 启动/disk分区的配额</span><br><span class="line">/dev/sdb1 [/disk]：group quotas turned on</span><br><span class="line">/dev/sdb1 [/disk]：user quotas turned on</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# quotaon -avug        # 这条命令也可以</span><br></pre></td></tr></table></figure><p>关闭配额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotaoff [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件关闭所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：关闭用户配额</span><br><span class="line">  -g：关闭组配额</span><br><span class="line">  </span><br><span class="line"> [root@localhost ~]# quotaoff -a        # 依据/etc/mtab文件关闭配额分区</span><br></pre></td></tr></table></figure></li></ul><h3 id="4）磁盘配额查询"><a href="#4）磁盘配额查询" class="headerlink" title="4）磁盘配额查询"></a>4）磁盘配额查询</h3><ul><li><p>quota查询用户或用户组配额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：   查询用户配额</span><br><span class="line">  -g 组名：     查询组配额</span><br><span class="line">  -v：          显示详细信息</span><br><span class="line">  -s：          以习惯单位显示容量大小，如M,G</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quota -uvs user1</span><br></pre></td></tr></table></figure></li><li><p>repquota查询文件系统配额</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# repquota [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：    依据/etc/mtab文件查询配额，如果不加-a选项，就一定要加分区名</span><br><span class="line">  -u：    查询用户配额</span><br><span class="line">  -g:     查询组配额</span><br><span class="line">  -v：    显示详细信息</span><br><span class="line">  -s：    以习惯单位显示容量大小</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# repquota -augvs</span><br></pre></td></tr></table></figure></li></ul><h3 id="5）测试"><a href="#5）测试" class="headerlink" title="5）测试"></a>5）测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[user1@localhost disk]$ dd if=/dev/zero of=/disk/testfile bs=1M count=60    # 建立testfile文件，指定大小60MB</span><br></pre></td></tr></table></figure><h3 id="6）非交互设定用户磁盘配额"><a href="#6）非交互设定用户磁盘配额" class="headerlink" title="6）非交互设定用户磁盘配额"></a>6）非交互设定用户磁盘配额</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">[root@localhost ~]# setquota -u user4 10000 20000 5 8 /disk</span><br></pre></td></tr></table></figure><h2 id="2-LVM逻辑卷管理"><a href="#2-LVM逻辑卷管理" class="headerlink" title="2. LVM逻辑卷管理"></a>2. LVM逻辑卷管理</h2><h3 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h3><p>LVM是Logical Volume Manager的简称，中文就是逻辑卷管理。</p><ul><li>物理卷(PV, Physical Volume)：就是真正的物理硬盘或分区。</li><li>卷组(VG, Volume Group)：将多个物理卷合起来就组成了卷组，组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘上的不同分区，可以把卷组想象为一个逻辑硬盘。</li><li>逻辑卷(LV, Logical Volume)：卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区称作逻辑卷，逻辑卷可以格式化和写入数据。可以把逻辑卷想象成为分区。</li><li>物理扩展(PE, Physical Extend)：PE是用来保存数据的最小单元，数据实际上都是写入PE当中，PE的大小是可以配置的，默认是4MB。</li></ul><h3 id="2）建立LVM的步骤"><a href="#2）建立LVM的步骤" class="headerlink" title="2）建立LVM的步骤"></a>2）建立LVM的步骤</h3><ul><li>首先需要把物理硬盘分成分区，当然也可以是整块物理硬盘。</li><li>然后把物理分区建立成为物理卷(PV)，也可以直接把整块硬盘都建立为物理卷。</li><li>接下来把物理卷整合成为卷组(VG)。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。</li><li>最后就是把卷组再划分成为逻辑卷(LV)，当然逻辑卷也是可以直接调整大小的。逻辑卷可以想象成为分区，所以也需要格式化和挂载。</li></ul><h3 id="3）物理卷管理"><a href="#3）物理卷管理" class="headerlink" title="3）物理卷管理"></a>3）物理卷管理</h3><p>a）硬盘分区</p><p>创建方式就是使用fdisk交互命令，不过需要注意的是分区的系统ID不再是Linux默认的分区ID号(83)了，而要改为LVM的ID号8e。</p><p>b）建立物理卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate [设备文件名]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"># 把整块硬盘都建立成物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb</span><br><span class="line"></span><br><span class="line"># 把分区建立成为物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb5</span><br></pre></td></tr></table></figure><p>c）查看物理卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvscan</span><br><span class="line">[root@localhost ~]# pvdisplay        # 更详细的物理卷信息</span><br></pre></td></tr></table></figure><p>d）删除物理卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvremove /dev/sdb5</span><br></pre></td></tr></table></figure><h3 id="4）卷组管理"><a href="#4）卷组管理" class="headerlink" title="4）卷组管理"></a>4）卷组管理</h3><p>a）建立卷组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate [选项] 卷组名 物理卷名</span><br><span class="line">[选项]：</span><br><span class="line">  -s PE大小    指定PE的大小，单位可以是MB,GB,TB等。如是不写默认PE大小为4MB</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6</span><br></pre></td></tr></table></figure><p>b）查看卷组</p><p>查看卷组的命令有两个：</p><ul><li><p>vgscan</p><p>vgscan主要是查看系统中是否有卷组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgscan</span><br></pre></td></tr></table></figure></li><li><p>vgdisplay</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgdisplay</span><br></pre></td></tr></table></figure></li></ul><p>c）增加卷组容量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgextend scvg /dev/sdb7</span><br></pre></td></tr></table></figure><p>d）减小卷组容量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在卷组中删除/dev/sdb7物理卷</span><br><span class="line">[root@localhost ~]# vgreduce scvg /dev/sdb7</span><br><span class="line"># 删除所有的未使用物理卷</span><br><span class="line">[root@localhost ~]# vgreduce -a</span><br></pre></td></tr></table></figure><p>e）删除卷组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgremove scvg</span><br></pre></td></tr></table></figure><p>卷组删除之后，才能删除物理卷，要注意的是scvg卷组还没有添加任何的逻辑卷，如果拥有了逻辑卷，得先删除逻辑卷再删除卷组。</p><h3 id="5）逻辑卷管理"><a href="#5）逻辑卷管理" class="headerlink" title="5）逻辑卷管理"></a>5）逻辑卷管理</h3><p>a）建立逻辑卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate [选项] [-n 逻辑卷名] 卷组名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：指定逻辑卷大小，单位MB，GB，TB等</span><br><span class="line">  -l 个数：按照PE个数指定逻辑卷大小，这个参数需要换算容量，太麻烦</span><br><span class="line">  -n 逻辑卷名：指定逻辑卷名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate -L 1.5G -n userlv scvg    # 在scvg卷组中建立1.5GB的userlv逻辑卷</span><br></pre></td></tr></table></figure><p>建立完成逻辑卷之后，还要格式化和挂载之后逻辑卷才能正常使用。不过需要注意的是逻辑卷的设备文件名是&#x2F;dev&#x2F;卷组名&#x2F;逻辑卷名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t ext4 /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# mkdir /disklvm</span><br><span class="line">[root@localhost ~]# mount /dev/scvg/userlv /disklvm/</span><br><span class="line">[root@localhost ~]# mount      # 查看挂载</span><br></pre></td></tr></table></figure><p>如果需要开机自动挂载，也要修改&#x2F;etc&#x2F;fstab文件。</p><p>b）查看逻辑卷</p><p>查看命令有两个：</p><ul><li><p>lvscan</p><p>lvscan只能看到系统中是否拥有逻辑卷。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvscan</span><br></pre></td></tr></table></figure></li><li><p>lvdisplay</p><p>lvdisplay可以看到逻辑卷的详细信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvdisplay</span><br></pre></td></tr></table></figure></li></ul><p>c）调整逻辑卷大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvresize [选项] 逻辑卷设备文件名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：安装容量调整大小，单位KB,GB,TB等。使用+代表增加空间，-号代表减少空间。如果直接写容量，代表设定逻辑卷大小为指定大小。</span><br><span class="line">  -l 个数：按照PE个数调整逻辑卷大小</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvresize -L 2.5.G /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# lvdisplay               # 逻辑卷的大小已经改变了</span><br><span class="line">[root@localhost ~]# df -h /disklvm/         # 大小没有变化</span><br></pre></td></tr></table></figure><p>lvresize只能改变逻辑卷的大小，如果需要让分区使用这个新逻辑卷，还要使用resize2fs命令来调整分区的大小。不过这里体现了LVM的优势，不需要卸载分区，直接就能调整分区的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs [选项] [设备文件名] [调整的大小]</span><br><span class="line">选项：</span><br><span class="line">  -f：    强制调整</span><br><span class="line">  设备文件名：指定调整哪个分区的大小</span><br><span class="line">  调整的大小：指定把分区调整到多大，要加M,G等单位。如果不加大小，会使用整个分区</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# df -h /disklvm/       # 已经调整过来了</span><br></pre></td></tr></table></figure><h3 id="4）删除逻辑卷"><a href="#4）删除逻辑卷" class="headerlink" title="4）删除逻辑卷"></a>4）删除逻辑卷</h3><p>删除逻辑卷前要先卸载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvremove 逻辑卷设备文件名</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;高级文件系统管理&quot;&gt;&lt;a href=&quot;#高级文件系统管理&quot; class=&quot;headerlink&quot; title=&quot;高级文件系统管理&quot;&gt;&lt;/a&gt;高级文件系统管理&lt;/h1&gt;&lt;h2 id=&quot;1-磁盘配额&quot;&gt;&lt;a href=&quot;#1-磁盘配额&quot; class=&quot;headerlink&quot; title=&quot;1. 磁盘配额&quot;&gt;&lt;/a&gt;1. 磁盘配额&lt;/h2&gt;&lt;h3 id=&quot;1）磁盘配额条件&quot;&gt;&lt;a href=&quot;#1）磁盘配额条件&quot; class=&quot;headerlink&quot; title=&quot;1）磁盘配额条件&quot;&gt;&lt;/a&gt;1）磁盘配额条件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内核必须支持磁盘配额&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]# grep CONFIG_QUOTA /boot/config-2.6.32-279.el6.i686&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CONFIG_QUOTA=y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CONFIG_QUOTA_NETLINK_INTERFACE=y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# CONFIG_QUOTA_DEBUG is not set&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CONFIG_QUOTA_TREE=m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CONFIG_QUOTACTL=y&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;系统中必须安装了quota工具，Linux默认是安装了quota工具&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]# rpm -qa | grep quota&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;quota-3.17-16.el6.i686&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;要支持磁盘配额的分区必须开启磁盘配额功能，这个功能需要手工开启，不再是默认就开启的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2）概念&quot;&gt;&lt;a href=&quot;#2）概念&quot; class=&quot;headerlink&quot; title=&quot;2）概念&quot;&gt;&lt;/a&gt;2）概念&lt;/h3&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bentech8.github.io/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>文件系统管理</title>
    <link href="https://bentech8.github.io/2025/02/25/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>https://bentech8.github.io/2025/02/25/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</id>
    <published>2025-02-25T05:05:05.000Z</published>
    <updated>2025-02-25T05:09:36.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h1><h2 id="1-硬盘结构"><a href="#1-硬盘结构" class="headerlink" title="1. 硬盘结构"></a>1. 硬盘结构</h2><h3 id="1）硬盘的逻辑结构"><a href="#1）硬盘的逻辑结构" class="headerlink" title="1）硬盘的逻辑结构"></a>1）硬盘的逻辑结构</h3><p>每个扇区的大小是固定的，为512Byte。扇区也是磁盘的最小存储单位。</p><p>硬盘的大小是用”磁头数X柱面数X扇区数X每个扇区的大小”这样的公式来计算的。其中磁头数(Heads)表示硬盘总共有几个磁头，也可以理解成硬盘有几个盘面，然后乘以2；柱面数(Cylinders)表示硬盘每一面盘片有几条磁道；扇区数(Sectors)表示每条磁道上有几个扇区；每个扇区的大小一般是512Byte。</p><h3 id="2）硬盘接口"><a href="#2）硬盘接口" class="headerlink" title="2）硬盘接口"></a>2）硬盘接口</h3><ul><li><p>IDE硬盘接口(Integrated Drive Electronics，并口，即电子集成驱动器)</p><p>也称作”ATA硬盘”或”PATA硬盘”，是早期机械硬盘的主要接口，ATA133硬盘的理论速度可以达到133MB&#x2F;s(此速度为理论平均值)。</p></li><li><p>SATA接口(Serial ATA，串口)</p><p>是速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力。目前已经是SATA三代，理论传输速度达到600MB&#x2F;s(此速度为理论平均值)。</p></li><li><p>SCSI接口(Small Computer System Interface，小型计算机系统接口)广泛用在服务器上，具有应用范围广、多任务、带宽大、CPU占用率低及支持执插拔等优点，理论传输速度达到320MB&#x2F;s。</p></li></ul><h2 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2. 文件系统"></a>2. 文件系统</h2><h3 id="1）Linux文件系统的特性"><a href="#1）Linux文件系统的特性" class="headerlink" title="1）Linux文件系统的特性"></a>1）Linux文件系统的特性</h3><ul><li><p>super block（超级块）</p><p>记录整个文件系统的信息，包括：</p><ul><li>block与inode的总量</li><li>已经使用的inode和block的数量</li><li>未使用的inode和block的数量</li><li>block与inode的大小</li><li>文件系统的挂载时间</li><li>最近一次的写入时间</li><li>最近一次的磁盘检验时间等</li></ul></li><li><p>data block（数据块，也称作block）</p><p>用来实际保存数据的，block的大小(1KB|2KB|4KB)和数量在格式化后就已经决定，不能改变，除非重新格式化。每个block只能保存一个文件的数据，要是文件数据小于一个block块，那么这个block的剩余空间不能被其他文件使用；要是文件数据大于一个block块，则占用多个block块。Windows中磁盘碎片整理工具的原理就是把一个文件占用的多个block块尽量整理到一起，这样可以加快读写速度。</p></li><li><p>inode（i节点）</p><p>用来记录文件的权限(r、w、x)，文件的所有者和属组，文件的大小，文件的状态改变时间(ctime)，文件的最近一次读取时间(atime)，文件的最近一次修改时间(mtime)，文件的数据真正保存的block编号。每个文件需要占一个inode。</p></li></ul><h3 id="2）Linux常见文件系统"><a href="#2）Linux常见文件系统" class="headerlink" title="2）Linux常见文件系统"></a>2）Linux常见文件系统</h3><table><thead><tr><th>文件系统</th><th>描述</th></tr></thead><tbody><tr><td>ext</td><td>Linux中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用。</td></tr><tr><td>ext2</td><td>是ext文件系统的升级版本，Red Hat Linux 7.2版本以前的系统默认都是ext2文件系统。于1993年发布，支持最大16TB的分区和最大2TB的文件</td></tr><tr><td>ext3</td><td>是ext2文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大16TB的分区和最大2TB的文件</td></tr><tr><td>ext4</td><td>是ext3文件系统的升级版。ext4在性能、伸缩性和可靠性方面进行了大量改进。ext4的变化可以说是翻天覆地的，比如向下兼容ext3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等。它是CentOS 6.x的默认文件系统</td></tr><tr><td>xfs</td><td>XFS最早针对IRIX操作系统开发，是一个高性能的日志型文件系统，能够在断电以及操作系统崩溃的情况下保证文件系统数据的一致性。它是一个64位的文件系统，后来进行开源并且移植到了Linux操作系统中，目前CentOS 7.x将XFS+LVM作为默认的文件系统，据官方所称，XFS对于大文件的读写性能较好。</td></tr><tr><td>swap</td><td>swap是Linux中用于交换分区的文件系统(类似于Windows中的虚拟内存)，当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的2倍，但不要超2GB。它是Linux的必需分区。</td></tr><tr><td>NFS</td><td>NFS是网络文件系统(Network File System)的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源</td></tr><tr><td>ISO9660</td><td>光盘的标准文件系统，Linux要想使用光盘，必须支持iso9660文件系统</td></tr><tr><td>fat</td><td>就是Windows下的fat16文件系统，在Linux中识别为fat</td></tr><tr><td>vfat</td><td>就是Windows下的fat32文件系统，在Linux中识别为vfat。支持最大32GB的分区和最大4GB的文件。</td></tr><tr><td>NTFS</td><td>就是Windows下的NTFS文件系统，不过Linux默认是不能识别NTFS文件系统的，如果需要识别，则需要重新编译内核才能支持。它比fat32文件系统更加安全，速度更快，支持最大2TB的分区和最大64GB的文件。</td></tr></tbody></table><h2 id="3-常用的硬盘管理命令"><a href="#3-常用的硬盘管理命令" class="headerlink" title="3. 常用的硬盘管理命令"></a>3. 常用的硬盘管理命令</h2><h3 id="1）df命令"><a href="#1）df命令" class="headerlink" title="1）df命令"></a>1）df命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -ahT</span><br><span class="line">选项：</span><br><span class="line">  -a:    显示特殊文件系统，这些文件系统几乎都是保存在内存中的。如/proc,因为挂载在内存中，所以占用量都是0</span><br><span class="line">  -h:    单位不是只用KB，而是换算成习惯单位</span><br><span class="line">  -T:    多出了文件系统类型一列</span><br></pre></td></tr></table></figure><h3 id="2）du命令"><a href="#2）du命令" class="headerlink" title="2）du命令"></a>2）du命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du [选项] [目录或文件名]</span><br><span class="line">选项：</span><br><span class="line">  -a 显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量</span><br><span class="line">  -h 使用习惯单位显示磁盘占用量，如KB，MB或GB等</span><br><span class="line">  -s 统计总占用量，而不列出子目录和子文件的占用量</span><br></pre></td></tr></table></figure><p>du与df的区别：du是用于统计文件大小的，统计的文件大小是准确的；df是用于统计空间大小的，统计的剩余空间是准确的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -Th</span><br><span class="line">文件系统        类型      大小  已用  可用 已用% 挂载点</span><br><span class="line">tmpfs           tmpfs     687M  2.5M  685M    1% /run</span><br><span class="line">/dev/nvme0n1p10 ext4      187G  144G   34G   82% /</span><br><span class="line">tmpfs           tmpfs     3.4G  5.4M  3.4G    1% /dev/shm</span><br><span class="line">tmpfs           tmpfs     5.0M   12K  5.0M    1% /run/lock</span><br><span class="line">efivarfs        efivarfs  148K  112K   32K   79% /sys/firmware/efi/efivars</span><br><span class="line">/dev/nvme0n1p1  vfat       96M   53M   44M   56% /boot/efi</span><br><span class="line">tmpfs           tmpfs     687M  172K  687M    1% /run/user/1000</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# du -sh /</span><br><span class="line">113G/</span><br></pre></td></tr></table></figure><p>df和du统计的根目录大小有差异，是因为du统计的是根目录文件大小，df统计的不仅只有根目录文件大小，还有临时文件的大小。</p><h3 id="3）fsck文件系统修复命令"><a href="#3）fsck文件系统修复命令" class="headerlink" title="3）fsck文件系统修复命令"></a>3）fsck文件系统修复命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fsck -y 分区                  # 开机重启自动修复</span><br></pre></td></tr></table></figure><h3 id="4）显示磁盘状态"><a href="#4）显示磁盘状态" class="headerlink" title="4）显示磁盘状态"></a>4）显示磁盘状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs -h 分区</span><br></pre></td></tr></table></figure><h3 id="5）查看文件的详细时间"><a href="#5）查看文件的详细时间" class="headerlink" title="5）查看文件的详细时间"></a>5）查看文件的详细时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# stat 文件名</span><br></pre></td></tr></table></figure><h3 id="6）判断文件类型"><a href="#6）判断文件类型" class="headerlink" title="6）判断文件类型"></a>6）判断文件类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# file 文件名</span><br></pre></td></tr></table></figure><h3 id="7）判断命令类型"><a href="#7）判断命令类型" class="headerlink" title="7）判断命令类型"></a>7）判断命令类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# type 命令名</span><br></pre></td></tr></table></figure><h2 id="4-fdisk命令手工分区"><a href="#4-fdisk命令手工分区" class="headerlink" title="4. fdisk命令手工分区"></a>4. fdisk命令手工分区</h2><h3 id="1）查看系统所有硬盘及分区"><a href="#1）查看系统所有硬盘及分区" class="headerlink" title="1）查看系统所有硬盘及分区"></a>1）查看系统所有硬盘及分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk -l</span><br></pre></td></tr></table></figure><h3 id="2）磁盘分区"><a href="#2）磁盘分区" class="headerlink" title="2）磁盘分区"></a>2）磁盘分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk 磁盘</span><br></pre></td></tr></table></figure><p>fdisk交互指令说明：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>a</td><td>设置可引导标记</td></tr><tr><td>b</td><td>编辑bsd磁盘标签</td></tr><tr><td>c</td><td>设置DOS操作系统兼容标记</td></tr><tr><td>d</td><td>删除一个分区</td></tr><tr><td>l</td><td>显示已知的文件系统类型。82为Linux swap分区，83为Linux分区</td></tr><tr><td>m</td><td>显示帮助菜单</td></tr><tr><td>n</td><td>新建分区</td></tr><tr><td>o</td><td>建立空白DOS分区表</td></tr><tr><td>p</td><td>显示分区列表</td></tr><tr><td>q</td><td>不保存退出</td></tr><tr><td>s</td><td>新建空白SUN磁盘标签</td></tr><tr><td>t</td><td>改变一个分区的系统ID</td></tr><tr><td>u</td><td>改变显示记录单位</td></tr><tr><td>v</td><td>验证分区表</td></tr><tr><td>w</td><td>保存退出</td></tr><tr><td>x</td><td>附加功能</td></tr></tbody></table><p>新建主分区：n—p—1—1分区号—分区大小+100M—w</p><p>新建扩展分区：n—e—2分区号—124起始柱面—1024柱面(所有剩余空间都分配给扩展分区)</p><p>新建逻辑分区：n—l—不用指定分区号—124起始柱面—+100M(指定大小)—w</p><h3 id="3）格式化"><a href="#3）格式化" class="headerlink" title="3）格式化"></a>3）格式化</h3><p>a）mkfs</p><p>mkfs命令非常简单易用，不过是不能调整分区的默认参数的（比如块大小是4096），这些默认参数除非特殊情况，否则不能调整。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t 文件系统类型 分区</span><br></pre></td></tr></table></figure><p>b）mke2fs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mke2fs [选项] 分区</span><br><span class="line">[选项]：</span><br><span class="line">  -t 文件系统：    指定格式化成哪个文件系统，如ext4, xfs</span><br><span class="line">  -b 字节:        指定block块的大小</span><br><span class="line">  -i 字切:        指定&quot;字节/inode&quot;的比例，也就是多少个字节分配一个inode</span><br><span class="line">  -j：            建立带有ext3日志功能的文件系统</span><br><span class="line">  -L 卷标名:      给文件系统设置卷标名，就不使用e2label命令设定了</span><br></pre></td></tr></table></figure><h3 id="4）建立挂载点"><a href="#4）建立挂载点" class="headerlink" title="4）建立挂载点"></a>4）建立挂载点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /disk1</span><br></pre></td></tr></table></figure><h3 id="5）挂载"><a href="#5）挂载" class="headerlink" title="5）挂载"></a>5）挂载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount 分区 挂载点</span><br></pre></td></tr></table></figure><h3 id="6）查看"><a href="#6）查看" class="headerlink" title="6）查看"></a>6）查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有已经挂载的分区和光盘</span><br><span class="line">[root@localhost ~]# mount</span><br><span class="line"></span><br><span class="line"># 查看系统分区</span><br><span class="line">[root@localhost ~]# fdisk -l</span><br><span class="line"></span><br><span class="line"># 查看分区占用百分比</span><br><span class="line">[root@Loaclhost ~]# df -Th</span><br></pre></td></tr></table></figure><h3 id="7）自动挂载"><a href="#7）自动挂载" class="headerlink" title="7）自动挂载"></a>7）自动挂载</h3><p>修改分区自动挂载文件(&#x2F;etc&#x2F;fstab)。此文件直接参与系统启动，如果修改错误，系统启动报错。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1              /disk1               ext4            defaults            1                  2</span><br></pre></td></tr></table></figure><ul><li>第一列：设备文件名</li><li>第二列：挂载点</li><li>第三列：文件系统</li><li>第四列：挂载选项</li><li>第五列：是否可以被备份。0（不备份） 1（每天备份） 2（不定期备份）</li><li>第六列：是否检测磁盘。0（不检测） 1（启动时检测） 2（启动后检测）</li></ul><p>也可以使用UUID进行挂载，UUID（硬盘通用唯一识别码，可以理解为硬盘的ID）。</p><ul><li>这个字段在CentOS 5.5的系统当中是写入分区的卷标名或分区设备文件名的，现在变更成硬盘的UUID。这样做的好处是当硬盘增加了新的分区，或者分区的顺序改变，再或者内核升级后，仍然能够保证分区能够正确的加载，而不至于造成启动障碍。</li><li>dumpe2fs命令可以查看磁盘状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs /dev/sdb5</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /dev/disk/by-uuid/</span><br></pre></td></tr></table></figure><h3 id="8）重启测试"><a href="#8）重启测试" class="headerlink" title="8）重启测试"></a>8）重启测试</h3><p>或者使用”mount -a”重新挂载所有内容，用它进行测试。</p><h2 id="5-etc-fstab文件修复"><a href="#5-etc-fstab文件修复" class="headerlink" title="5. &#x2F;etc&#x2F;fstab文件修复"></a>5. &#x2F;etc&#x2F;fstab文件修复</h2><ul><li><p>服务器连接显示器输入root密码登录系统。</p></li><li><p>此时根目录为只读文件系统，需要重新挂载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,rw /</span><br></pre></td></tr></table></figure></li><li><p>修改&#x2F;etc&#x2F;fstab文件内容至正确。</p></li><li><p>重启服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# reboot</span><br></pre></td></tr></table></figure></li></ul><h2 id="6-parted命令分区"><a href="#6-parted命令分区" class="headerlink" title="6 parted命令分区"></a>6 parted命令分区</h2><p>Linux系统中有两种常见的分区表：</p><ul><li><p>MBR分区表（主引导记录分区表）</p><p>支持的最大分区是2TB，最多支持4个主分区，或3个主分区1个扩展分区。</p></li><li><p>GPT分区表（GUID分区表）</p><p>支持最大18EB分区，最多支持128个分区，其中1个系统保留分区，127个用户自定义分区。</p></li></ul><p>不过parted命令也有点小问题，就是命令自身分区的时候只能格式化成ext2文件系统，不支持ext3和ext4文件系统。不过这没有太多的影响，因为我们可以先分区再用mkfs进行格式化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted 硬盘</span><br></pre></td></tr></table></figure><table><thead><tr><th>parted交互命令</th><th>说明</th></tr></thead><tbody><tr><td>check NUMBER</td><td>做一次简单的文件系统检测</td></tr><tr><td>cp [FROM-DEVICE] FROM-NUMBER TO NUMBER</td><td>复制文件系统到另一个分区</td></tr><tr><td>help [COMMAND]</td><td>显示所有的命令帮助</td></tr><tr><td>mklabel,mktable LABEL-TYPE</td><td>创建新的磁盘卷标(分区表)</td></tr><tr><td>mkfs NUMBER FS-TYPE</td><td>在分区上建立文件系统</td></tr><tr><td>mkpart PART-TYPE [FS-TYPE] START END</td><td>创建一个分区</td></tr><tr><td>mkpartfs PART-TYPE FS-TYPE START END</td><td>创建分区，并建立文件系统</td></tr><tr><td>move NUMBER START END</td><td>移动分区</td></tr><tr><td>name NUMBER NAME</td><td>给分区命名</td></tr><tr><td>print [devices|free|list,all|NUMBER]</td><td>显示分区表，活动设备，空闲空间，所有分区</td></tr><tr><td>quit</td><td>退出</td></tr><tr><td>rescue START END</td><td>修复丢失的分区</td></tr><tr><td>resize NUMBER START END</td><td>修改分区大小</td></tr><tr><td>rm NUMBER</td><td>删除分区</td></tr><tr><td>select DEVICE</td><td>选择需要编辑的设备</td></tr><tr><td>set NUMBER FLAG STATE</td><td>改变分区标记</td></tr><tr><td>toggle [NUMBER [FLAG]]</td><td>切换分区表的状态</td></tr><tr><td>unit UNIT</td><td>设置默认的单位</td></tr><tr><td>Version</td><td>显示版本</td></tr></tbody></table><h3 id="1）查看分区"><a href="#1）查看分区" class="headerlink" title="1）查看分区"></a>1）查看分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">(parted) print                                 # 输入print指令</span><br><span class="line">Model： VMware, VMware Virtual S（scsi）        # 硬盘参数</span><br><span class="line">Disk /dev/sdb：21.5GB                           # 硬盘大小</span><br><span class="line">Sector size (logical/physical)：512B/512B       # 扇区大小</span><br><span class="line">Partition Table：msdos                          # 分区表类型，就是MBR分区表</span><br><span class="line">Number      Start    End     Size    Type    File system    标志</span><br><span class="line">1           32.3kB   5379MB  5379MB   primary</span><br></pre></td></tr></table></figure><h3 id="2）修改成GPT分区表"><a href="#2）修改成GPT分区表" class="headerlink" title="2）修改成GPT分区表"></a>2）修改成GPT分区表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">（parted）mklabel gpt</span><br><span class="line">警告：正在使用/dev/sdb上的分区                            # 由于/dev/sdb分区已经挂载，所以有警告</span><br><span class="line"></span><br><span class="line">忽略/Ingore/放弃/Cancel? ignore                         # 输入ignore忽略报错</span><br><span class="line">警告：The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost, Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes                                       # 输入yes</span><br><span class="line">警告：WARNING：the kernel failed to re-read the partition table on /dev/sdb（设备或资源忙）. As a result,it may not reflect all of your changes until after reboot.                        # 下次重启后，才能生效</span><br><span class="line"></span><br><span class="line">（parted）print                                          # 查看分区表</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt                                     # 分区表已经变成GPT</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志          # 所有的分区都消失了</span><br></pre></td></tr></table></figure><p>修改了分区表，如果这块硬盘已经有分区了，那么原有分区和分区中的数据都会消失，而且需要重启系统才会生效。</p><p>转换分区表的目的是为了支持大于2TB的分区，如果分区并没有大于2TB，那么这步是可以不执行的。</p><p>**注意：**一定要把&#x2F;etc&#x2F;fstab文件中和原有分区的内容删除掉，才能重启，不然系统重启一定会报错。</p><h3 id="3）建立分区"><a href="#3）建立分区" class="headerlink" title="3）建立分区"></a>3）建立分区</h3><p>因为修改过分区表，所以&#x2F;dev&#x2F;sdb中的所有数据丢失了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">（parted）mkpart                                    # 输入创建分区命令</span><br><span class="line">分区名称?  []? disk1                                 # 分区名称</span><br><span class="line">文件系统类型？  [ext2]?                               # 文件系统类型，直接回车，使用默认ext2</span><br><span class="line">起始点? 1MB                                          # 分区从1MB开始</span><br><span class="line">结束点? 5GB                                          # 分区到5GB结束</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br><span class="line">1         1049kB   5000MB  4999MB                disk1</span><br></pre></td></tr></table></figure><h3 id="4）建立文件系统"><a href="#4）建立文件系统" class="headerlink" title="4）建立文件系统"></a>4）建立文件系统</h3><p>分区分完了，还需要格式化。不过如果使用parted交互命令格式化的话，只能格式化成ext2文件系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（parted）mkfs</span><br><span class="line">WARNING：you are attempting to use parted to operate on （mkfs） a file system. parted&#x27;s file system manipulation code is not as rebust as what you&#x27;ll find in dedicated, file-system-specific packages like e2fsprogs. We recommand you use parted only to manipulate partition tables, whenever possible. Support for performing most operations on most types of file systems will be removed in an upcoming release.</span><br><span class="line">警告：The existing file system will be destoryed and all data on the partition will be lost.</span><br><span class="line">Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes                                # 警告你格式化数据会丢失</span><br><span class="line">分区编号? 1</span><br><span class="line">文件系统类型?  [ext2]?                             # 指定文件系统类型</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br><span class="line">1         1049kB   5000MB  4999MB    ext2        disk1</span><br></pre></td></tr></table></figure><p>如果要格式化成ext4文件系统，需要使用Linux的mkfs命令。</p><h3 id="5）删除分区"><a href="#5）删除分区" class="headerlink" title="5）删除分区"></a>5）删除分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(parted) rm                                     # 删除分区命令</span><br><span class="line">分区编号? 1                                      # 指定分区号</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br></pre></td></tr></table></figure><p>parted中的所有操作都是立即生效，没有保存生效的概念，这点和fdisk交互命令明显不同。</p><p>至于到底使用fdisk还是parted进行分区？推荐分区大小小于2GB，使用fdisk分区；分区大小大于2GB，使用parted分区。 </p><h2 id="7-swap分区"><a href="#7-swap分区" class="headerlink" title="7. swap分区"></a>7. swap分区</h2><h3 id="1）分区"><a href="#1）分区" class="headerlink" title="1）分区"></a>1）分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk /dev/sdb</span><br><span class="line">Command (m for help): t                               # 修改分区的系统id</span><br><span class="line">Selected partition 1                                  # 选择分区</span><br><span class="line">Hex code (type L to list codes)：82                    # 改为swap的id</span><br><span class="line">Changed system type of partition 1 to 82 (Linux swap / Solaris)</span><br></pre></td></tr></table></figure><h3 id="2）格式化"><a href="#2）格式化" class="headerlink" title="2）格式化"></a>2）格式化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkswap /dev/sdb1</span><br><span class="line">Setting up swapspace version 1, size = 522076 KiB</span><br><span class="line">no label, UUID=C3351dc3-f403-419a-9666-c24615e170fb</span><br></pre></td></tr></table></figure><h3 id="3）挂载"><a href="#3）挂载" class="headerlink" title="3）挂载"></a>3）挂载</h3><p>swap空间支持扩容。扩容也使用swapon命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# swapon /dev/sdb1</span><br></pre></td></tr></table></figure><p>开机自动挂载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1      swap      swap      defaults      0      0</span><br></pre></td></tr></table></figure><p>也可以使用uuid。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;文件系统管理&quot;&gt;&lt;a href=&quot;#文件系统管理&quot; class=&quot;headerlink&quot; title=&quot;文件系统管理&quot;&gt;&lt;/a&gt;文件系统管理&lt;/h1&gt;&lt;h2 id=&quot;1-硬盘结构&quot;&gt;&lt;a href=&quot;#1-硬盘结构&quot; class=&quot;headerlink&quot; title=&quot;1. 硬盘结构&quot;&gt;&lt;/a&gt;1. 硬盘结构&lt;/h2&gt;&lt;h3 id=&quot;1）硬盘的逻辑结构&quot;&gt;&lt;a href=&quot;#1）硬盘的逻辑结构&quot; class=&quot;headerlink&quot; title=&quot;1）硬盘的逻辑结构&quot;&gt;&lt;/a&gt;1）硬盘的逻辑结构&lt;/h3&gt;&lt;p&gt;每个扇区的大小是固定的，为512Byte。扇区也是磁盘的最小存储单位。&lt;/p&gt;
&lt;p&gt;硬盘的大小是用”磁头数X柱面数X扇区数X每个扇区的大小”这样的公式来计算的。其中磁头数(Heads)表示硬盘总共有几个磁头，也可以理解成硬盘有几个盘面，然后乘以2；柱面数(Cylinders)表示硬盘每一面盘片有几条磁道；扇区数(Sectors)表示每条磁道上有几个扇区；每个扇区的大小一般是512Byte。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://bentech8.github.io/categories/Linux/"/>
    
    
  </entry>
  
</feed>
