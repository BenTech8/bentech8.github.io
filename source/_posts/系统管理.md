---
title: 系统管理
date: 2025-03-05 17:29:52
tags:
categories: Linux
---

## 进程管理

### 进程简介

1）什么是进程

进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。

2）什么是程序

程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。



程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。

进程是正在执行当中的程序。程序被执行时，执行人的权限和属性、以及程序的代码都会被加载如内存，操作系统给这个进程分配一个ID号，称为PID（进程ID）。



3）进程管理的作用

- 判断服务器健康状态

  运维工程师最主要的工作就是保证服务器安全稳定的运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服务器的CPU占用率、内存占用率过高，就需要人为介入解决问题了。

- 查看系统中所有的进程

  我们需要查看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务，是否有非法服务运行。

- 杀死进程

  这是进程管理中最不常用的手段，当需要停止服务时，会通过正确关闭命令来停止服务（如apache服务可以通过service httpd sotp来关闭）。只有当正确终止进程的手段失效的情况下，才会考虑使用kill命令杀死进程（你不是杀手，不要什么进程都用kill来终止，否则非常容易导致服务器崩溃）。



### 进程的查看

#### ps命令

ps命令是用来静态显示系统中进程的命令。不过这个命令有些特殊，它的部分命令的选项不能加入“-”，比如“ps aux”，这是因为ps命令的部分选项需要遵守BSD操作系统的格式，所以ps命令的常用选项的组合是固定的。

```shell
# 查看系统中所有进程，使用BSD操作系统格式
[root@localhost ~]# pa aux
# 查看系统中所有进程，使用Linux标准命令格式
[root@localhost ~]# ps -le
选项：
  a:		显示一个终端的所有进程，除了会话引线
  u:		显示进程的归属用户及内存的使用情况
  x:		显示没有控制终端的进程
  -l:		长格式显示。显示更加详细的信息
  -e:		显示所有进程，和-A作用一致
```



```shell
[root@localhost ~]# ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.0  0.2  24104 15260 ?        Ss   3月04   0:10 /sbin/init splash
root           2  0.0  0.0      0     0 ?        S    3月04   0:00 [kthreadd]
```

- USER：该进程是由哪个用户产生的
- PID：进程的ID号
- %CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源
- %MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源
- VSZ：该进程占用虚拟内存的大小，单位KB
- RSS：该进程占用实际物理内存的大小，单位KB
- TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端(可以通过alt+F1-F7键切换不同的终端)，tty1-tty6是本地的字符界面终端，tty7是图形终端。pts/0-255代表虚拟终端，一般是远程连接终端，第一个远程连接占用的是pts/0终端，第二个远程连接占用pts/1，依次增长。
- STAT：进程状态。常见状态有：
  - D：不可被唤醒的睡眠状态，通常用于I/O情况
  - R：该进程正在运行
  - S：该进程在睡眠状态，可被唤醒
  - T：停止状态，可能是在后台暂停或进程在除错状态
  - W：内存交互状态（从2.6内核开始无效）
  - X：死掉的进程（应该不会出现）
  - Z：僵尸进程。进程已经终止，但是部分程序还在内存当中。
  - <：高优先级（以下状态在BSD格式当中出现）
  - N：低优先级
  - L：被锁入内存
  - s：包含子进程
  - l：多线程
  - +：位于后台
- START：该进程的启动时间
- TIME：该进程占用CPU的运算时间，注意不是系统时间
- COMMAND：产生此进程的命令名

```shell
[root@localhost ~]# ps -le
F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0       1       0  0  80   0 -  6026 -      ?        00:00:10 systemd
1 S     0       2       0  0  80   0 -     0 -      ?        00:00:00 kthreadd
```

- F：进程标志，说明进程的权限，常见标志有：
  - 1：进程可以复制，但是不能执行
  - 4：进程使用超级用户权限
- S：进程状态。具体的状态和“ps aux”命令中STAT状态一致
- UID：进程是哪个UID用户调用运行的
- PID：进程的ID号
- PPID：代进程的ID号
- C：该进程的CPU使用率，单位是百分比
- PRI：进程的优先级，数值越小该进程优先级越高，越快被CPU执行
- NI：进程的优先级，也是数值越小越早被执行
- ADDR：该进程在内存的哪个位置
- SZ：该进程占用多大内存
- WCHAN：该进程是否运行。“-”代表正在运行
- TTY：该进程由哪个终端产生
- TIME：该进程占用CPU的运算时间，注意不是系统时间
- CMD：产生此进程的命令名



#### top命令

```shell
[root@localhost ~]# top [选项]
选项：
  -d 秒数：    指定top命令每隔几秒更新。默认是3秒。
  -b:  		  使用批处理模式输出。一般和"-n"选项合用，用于把top命令重定向到文件中 
  -n 次数:	 指定top命令执行的次数。一般和"-b"选项合用
  -p:		   指定PID。只查看某个PID的进程
  -s:          使top在安全模式运行，避免在交互模式中出现错误
  -u 用户名:    只监听某个用户的进程
在top命令的交互模式当中可以执行的命令：
  ？或h:	   显示交互模式的帮助
  P:		以CPU使用率排序，默认就是此项
  M:		以内存的使用率排序
  N:		以PID排序
  T:		按照CPU的累积运算时间排序，也就是用于TIME+项排序
  k:		按照PID号，给予某个进程一个信号，一般用于终止某个进程，信号9是强制终止的信号
  r:		按照PID号，给某个进程重设优先级（Nice）值
  q:		退出top
```

top执行结果：

```
[root@localhost ~]# top
top - 20:40:42 up 1 day, 11:10,  1 user,  load average: 0.62, 0.43, 0.45
任务: 394 total,   1 running, 385 sleeping,   8 stopped,   0 zombie
%Cpu(s):  1.9 us,  3.9 sy,  0.0 ni, 94.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st 
MiB Mem :   6865.1 total,    245.4 free,   4582.3 used,   2676.1 buff/cache     
MiB Swap:   2048.0 total,    789.7 free,   1258.3 used.   2282.8 avail Mem 
 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND                                                     
 231207 ben       20   0   17672   5632   3456 R  23.1   0.1   0:00.06 top                                                       
      1 root      20   0   24104  14620   9348 S   0.0   0.2   0:11.09 systemd                                                   
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.06 kthreadd                                                   
      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_workqueue_release        
```

top命令的输出内容是动态的，默认每3秒刷新一次。命令的输出主要分为两大部分；第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出判断服务器的健康状态；第二部分从第六行开始，显示的是系统中进程的信息。

- 第一部分内容

  - 第一行信息为任务队列信息

    | 内容                           | 说明                                                         |
    | ------------------------------ | ------------------------------------------------------------ |
    | 20:40:42                       | 系统当前时间                                                 |
    | up 1 day, 11:10                | 系统的运行时间，本机已经运行1天11小时10分钟                  |
    | 1 user                         | 当前登录了1个用户                                            |
    | load average: 0.62, 0.43, 0.45 | 系统在之前1分钟，5分钟，15分钟的平均负载。如果CPU是单核，则这个数超过1，就是高负载。如果CPU是四核，则这个数超过4，就是高负载。（这个平均负载完全是个人经验来进行判断的，一般认为不应该超过服务器CPU的核数。） |

  - 第二行为进程信息

    | 内容            | 说明                                      |
    | --------------- | ----------------------------------------- |
    | 任务: 394 total | 系统中的进程总数                          |
    | 1 running       | 正在运行的进程数                          |
    | 385 sleeping    | 睡眠的进程                                |
    | 8 stopped       | 正在停止的进程                            |
    | 0 zombie        | 僵尸进程。如果不是0，需要手工检查僵尸进程 |

  - 第三行为CPU信息

    | 内容             | 说明                                                         |
    | ---------------- | ------------------------------------------------------------ |
    | %Cpu(s):  1.9 us | 用户模式占用的CPU百分比                                      |
    | 3.9 sy           | 系统模式占用的CPU百分比                                      |
    | 0.0 ni           | 改变过优先级的用户进程占用的CPU百分比                        |
    | 94.2 id          | 空闲CPU的CPU百分比                                           |
    | 0.0 wa           | 等待输入/输出的进程的占用CPU百分比                           |
    | 0.0 hi           | 硬中断请求服务占用的CPU百分比                                |
    | 0.0 si           | 软中断请求服务占用的CPU百分比                                |
    | 0.0 st           | st（Steal time）虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比 |

  - 第四行为物理内存信息

    | 内容                 | 说明                    |
    | -------------------- | ----------------------- |
    | Mem :   6865.1 total | 物理内存的总量          |
    | 245.4 free           | 空闲的物理内存数量      |
    | 4582.3 used          | 已经使用的物理内存数量  |
    | 2676.1 buff/cache    | 作为缓冲/缓存的内存数量 |

  - 第五行为交换分区（swap）信息

    | 内容                 | 说明                         |
    | -------------------- | ---------------------------- |
    | Swap:   2048.0 total | 交换分区（虚拟分区）的总大小 |
    | 789.7 free           | 空闲交换分区的大小           |
    | 1258.3 used          | 已经使用的交互分区的大小     |
    | 2282.8 avail Mem     | 可利用的交互分区的大小       |



- 第二部分内容

  主要是系统进程信息。这部分和ps命令的输出比较类似，只是如果在终端中执行top命令不能看到所有的进程，而只能看到占比靠前的进程。

  - PID: 进程ID
  - USER: 该进程所属的用户
  - PR: 优先级，数值越小优先级越高
  - NI: 优先级，数值越小优先级越高
  - VIRT: 该进程使用的虚拟内存的大小，单位KB
  - RES: 该进程使用的物理内存的大小，单位KB
  - SHR: 共享内存大小，单位KB
  - %CPU: 该进程占用CPU的百分比
  - %MEM: 该进程占用内存的百分比
  - TIME+: 该进程总共占用的CPU时间
  - COMMAND: 进程的命令名



top命令查看某一个进程:

```shell
# 只查看PID为15273的apache进程
[root@localhost ~]# top -p 15273
```

在top命令的交互界面中按“q”键会退出top命令。也可以按“?”或“h”得到top命令交互界面的帮助信息。也可以按“k”键终止某个进程。

```shell
[root@localhost ~]# top
top - 21:30:33 up 1 day, 12:00,  1 user,  load average: 2.53, 1.43, 1.12
任务: 391 total,   1 running, 382 sleeping,   8 stopped,   0 zombie
%Cpu(s):  5.5 us,  3.1 sy,  0.0 ni, 91.2 id,  0.2 wa,  0.0 hi,  0.1 si,  0.0 st 
MiB Mem :   6865.1 total,    196.3 free,   4604.8 used,   2714.5 buff/cache     
MiB Swap:   2048.0 total,    742.7 free,   1305.3 used.   2260.2 avail Mem 
PID to signal/kill [default pid = 166294]                               # 按"k"键，会提示输入要杀死进程的PID
```

如果在操作终端执行top命令，并不能看到系统中所有的进程，默认看到的只是CPU占比靠前的进程。如果我们想要看到所有的进程可以把top命令的结果重定向到文件当中即可：

```shell
# 让top命令只执行一次，然后把结果保存到top.log文件中。这样就能看到所有的进程了
[root@localhost ~]# top -b -n 1 > /root/top.log
```



#### pstree命令

```
[root@localhost ~]# pstree [选项]
选项：
  -p:		显示进程的PID
  -u:		显示进程的所属用户
```



### 进程的管理

系统中可以识别的信号较多，可以使用命令“kill -l”或“man 7 signal”来查询：

```shell
[root@localhost ~]# kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX
```

主要信号：

| 信号代号 | 信号名称 | 说明                                                         |
| -------- | -------- | ------------------------------------------------------------ |
| 1        | SIGHUP   | 该信号让进程立即关闭，然后重新读取配置文件之后重启。         |
| 2        | SIGINT   | 程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键。     |
| 8        | SIGFPE   | 在发生致命的算术运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术的错误。 |
| 9        | SIGKILL  | 用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。一般用于强制终止进程。 |
| 14       | SIGALRM  | 时钟定时信号，计算的是实际的时间或时钟时间. alarm函数使用该信号。 |
| 15       | SIGTERM  | 正常结束进程的信号，kill命令的默认信号。有时如果进程已经发生问题，这个信号是无法正常终止进程的，我们才会尝试SIGKILL信号，也就是信号9。 |
| 18       | SIGCONT  | 该信号可以让暂停的进程恢复执行，本信号不能被阻断。           |
| 19       | SIGSTOP  | 该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号不能被阻断。 |



#### kill命令

```
[root@localhost ~]# kill [信号] PID
```

使用“-1”信号，让进程重启：

```
[root@localhost ~]# kill -1 2246
```

使用“-19”信号，让进程暂停：

```shell
# 使用vim命令编辑一个文件，不要退出
[root@localhost ~]# vim /tmp/test.txt

# 换不同的终端，查看下这个进程的状态
[root@localhost ~]# ps aux | grep "vim" | grep -v "grep"
ben       271840  0.2  0.1  31228 13568 pts/0    Sl+  16:00   0:00 vim /tmp/test.txt

# 使用-19信号，让PID是271840的进程暂停。相当于在vim界面按"ctrl+z"快捷键
[root@localhost ~]# kill -19 271840

# 271840进程的状态变成为T(暂停)状态。271840进程会卡在后台，如果想要恢复可以使用"kill -9 271840"强制终止进程。
[root@localhost ~]# ps aux | grep "vim" | grep -v "grep"
ben       271840  0.0  0.1  31228 13568 pts/0    Tl   16:00   0:00 vim /tmp/test.txt
```



#### killall命令

```
[root@localhost ~]# killall [选项][信号] 进程名
选项：
  -i:	交互式，询问是否要杀死某个进程
  -l:	忽略进程名的大小写
```

交互式杀死docker进程：

```shell
[root@localhost ~]# ps aux | grep "docker-proxy"
root        5331  0.0  0.0 1746028 2160 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 127.0.0.1 -host-port 9090 -container-ip 172.23.0.2 -container-port 9090
root        5345  0.0  0.0 1746028 2076 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 7891 -container-ip 172.23.0.2 -container-port 7891
root        5352  0.0  0.0 1819504 2008 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 7891 -container-ip 172.23.0.2 -container-port 7891
root        5366  0.0  0.0 1745772 2152 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891
root        5373  0.0  0.0 1746028 2088 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891
root        5388  0.0  0.0 1894260 4148 ?        Sl   3月04   0:02 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891
root        5395  0.0  0.0 1745772 2104 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891
root        5409  0.0  0.0 1671784 2204 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 7890 -container-ip 172.23.0.2 -container-port 7890
root        5416  0.0  0.0 1671784 2168 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 7890 -container-ip 172.23.0.2 -container-port 7890

# 交互式杀死docker进程
[root@localhost ~]# killall -i docker-proxy
杀死 docker-proxy(5331) ? (y/N) n
杀死 docker-proxy(5345) ? (y/N) n
杀死 docker-proxy(5352) ? (y/N) n
杀死 docker-proxy(5366) ? (y/N) n
杀死 docker-proxy(5373) ? (y/N) n
杀死 docker-proxy(5388) ? (y/N) n
杀死 docker-proxy(5395) ? (y/N) n
杀死 docker-proxy(5409) ? (y/N) n
杀死 docker-proxy(5416) ? (y/N) n
```



#### pkill命令

pkill命令和killall命令非常类似，也是按照进程名来杀死进程。

```shell
[root@localhost ~]# pkill [选项] [信号] 进程名
选项：
  -t 终端号:	按照终端号踢出用户
```

```shell
# 强制杀死从pts/1虚拟终端登录的进程
[root@localhost ~]# pkill -9 -t pts/1
```



## 工作管理

### 工作管理简介

后台管理有个事项需要注意：

- 前台是指当前可以操控和执行命令的这个操作环境，后台是指工作可以自行运行，但是不能直接用ctrl+c来终止它，只能使用fg/bg来调用工作；
- 当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作。如tty1登录终端是不能管理tty2终端中的工作的；
- 放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作。如果把1s命令放入后台执行，它很快就会执行完成，我们很难操作它。
- 放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行。比如vim命令放入后台只能暂停，而不能执行，因为vim需要前台输入信息。top命令也不能放入后台执行，而只能放入后台暂停，因为top命令需要和前台有交互。



### 如何把命令放入后台

#### 命令 &

第一种方法把命令放入后台的方法是在命令后面加入“空格&”，这种方法放入后台的命令，在后台是执行状态。但是注意，放入后台执行的命令不能与前台有交互，否则这个命令是不能在后台执行的。

```shell
# find命令放入后台执行，每个后台命令会分配一个工作号，命令既然可以执行，就会有进程产生，所以也会有进程号。
[root@localhost ~]# find / -name install.log &
[2] 284313
# [工作号] 进程号
```

虽然find命令在执行，但是当前操作还是可以进行其他命令操作的。如果在终端出现：

```shell
```

证明后台这个任务已经完成了，当然命令如果有执行结果的话，也会显示到操作终端上。[2]是这个命令的工作号，+号代表这个任务是最近一个被放入后台的工作。



#### ctrl+z

第二种方法是在命令执行过程中按ctrl+z快捷键，命令在后台是暂停状态。

使用这种方法放入后台的命令，就算是不和前台有交互，能在后台执行的命令，也是暂停状态，ctrl+z快捷键就是暂停的快捷键。

```shell
# 在top命令执行的过程中，按下ctrl+z快捷键
[root@localhost ~]# top
[1]+  已停止               top
# 提示命令被放入后台，工作号是1，状态是暂停。而且虽然top命令没有结束，也能取得控制台权限
```

```shell
# 压缩一下/etc/目录
[root@localhost ~]# tar -zcf etc.tar.gz /etc
tar: 从成员名中删除开头的"/"
tar: 从硬连接目标中删除开头的"/"
^Z                              # 执行过程中，按下ctrl+z快捷键
[2]+   Stopped    tar -zcf etc.tar.gz /etc
# 命令被放入后台，工作号是2，状态是暂停
```



### 后台命令管理

#### 查看后台的工作

```shell
[root@localhost ~]# jobs [-l]
选项：
  -l:	显示工作的PID
```

#### 将后台暂停的工作恢复到前台执行

```
[root@localhost ~]# fg %工作号
参数：
  %工作号:		%号可以省略，但是注意工作号和PID的区别
```

#### 把后台暂停的工作恢复到后台执行

```
[root@localhost ~]# bg %工作号
```

#### 后台命令脱离登录终端运行

我们已经知道把命令放入后台，只能在当前登录终端执行。那如果我是远程管理的服务器，在远程终端中执行了后台命令，这时我退出终端，这个后台命令还能继续执行吗？当然是不行的， 这个后台命令会被终止。如果确实需要在远程终端中执行某些后台命令，可以这么做：

- 把需要后台执行的命令加入/etc/rc.local文件，让系统在启动时执行这个后台程序。这种方法的问题是，服务器是不能随便重启的，万一有临时后台任务，就不能执行。
- 使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的。
- 使用nohup命令。

nohup命令的作用就是让后台工作在离开操作终端时，也能够正确的在后台执行。

```shell
[root@localhost ~]# nohup [命令] & 
```

用find命令打印/下所有文件，放入后台执行：

```shell
[root@localhost ~]# nohup find / -print > /root/file.log &
[3] 2349
# 有提示信息
[root@localhost ~]# nohup：忽略输入并把输出追加到"nohup.out"
```



## 系统资源查看

### vmstat

监控系统资源

```
[root@localhost ~]# vmstat [刷新延时 刷新次数]
```

使用vmstat检测，每1秒刷新一次，共刷新3次：

```shell
[root@localhost ~]# vmstat 1 3
procs -----------memory---------- ---swap-- -----io---- -system-- -------cpu-------
 r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st gu
 1  0 1975536 315116 888372 2032876    1   13    58    88  912    6  4  2 94  0  0  0
 0  0 1975536 296724 888372 2032912    8    0     8     0 2845 3503  4  2 94  0  0  0
 3  0 1975536 294804 888372 2032916    0    0     0     0 2592 3581  1  2 97  0  0  0
```

- procs：进程信息字段
  - r：等待运行的进程数，数量越大，系统越繁忙。
  - b：不可被唤醒的进程数量，数量越大，系统越繁忙。

- memory：内存信息字段
  - swpd：虚拟内存的使用情况，单位KB
  - free：空闲的内存容量，单位KB
  - buff：缓冲的内存容量，单位KB
  - cache：缓存的内存容量，单位KB

- swap：交换分区的信息字段
  - si：从磁盘中交换到内存中数据的数量，单位KB
  - so：从内存中交换到磁盘中数据的数量，单位KB。此两个数越大，证明数据需要经常在磁盘和内存之间交换，系统性能越差。

- io：磁盘读写信息字段
  - bi：从块设备读入数据的总量，单位是块
  - bo：写到块设备的数据的总量，单位是块。此两个数越大，代表系统的I/O越繁忙。
- system：系统信息字段
  - in：每秒被中断的进程次数
  - cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙。

- cpu：cpu信息字段
  - us：非内核进程消耗cpu运算时间的百分比
  - sy：内核进程消耗cpu运算时间的百分比
  - id：空闲cpu的百分比
  - wa：等待I/0所消耗的cpu百分比
  - st：被虚拟机所盗用的cpu百分比

### dmesg

显示开机时内核检测信息

```shell
# 查看CPU信息
[root@localhost ~]# dmesg | grep CPU
```



### free

查看内存使用状态

```shell
[root@localhost ~]# free [-b|-k|-m|-g]
选项：
  -b:	以字节为单位显示
  -k:	以KB为单位显示，默认是以KB为单位显示
  -m:	以MB为单位显示
  -g:	以GB为单位显示
```

```shell
[root@localhost ~]# free -h
               total        used        free      shared  buff/cache   available
内存：         6.7Gi       4.2Gi       283Mi       277Mi       2.8Gi       2.5Gi
交换：         2.0Gi       1.9Gi       122Mi
```

- 第一行
  - total：总内存数。
  - used：已经使用的内存数。
  - free：空闲的内存数。
  - shared：多个进程共享的内存总数。
  - buff/cache：缓冲/缓存内存数。

- 第二行
  - total：swap的总数
  - used：已经使用的swap数
  - free：空闲的swap数。



### 查看CPU信息

CPU的主要信息保存在/proc/cpuinfo这个文件中，只要查看这个文件，就可以知道cpu的相关信息：

```shell
[root@localhost ~]# cat /proc/cpuinfo
# 逻辑CPU编号
processor	: 0
# CPU制造厂商
vendor_id	: AuthenticAMD
# 产品的系列代号
cpu family	: 23
# CPU系列代号
model		: 24
# CPU系列的名字，编号，主频
model name	: AMD Ryzen 7 3700U with Radeon Vega Mobile Gfx
# 更新版本
stepping	: 1
microcode	: 0x8108109
# 实际主频
cpu MHz		: 1372.114
# 二级缓存
cache size	: 512 KB
```



### 查看本机登录用户信息

如果我们想要知道Linux服务器上目前已经登录的用户信息，可以使用w或who命令来进行查询。

```shell
[root@localhost ~]# w
 17:54:27 up 2 days,  8:24,  1 user,  load average: 0.82, 0.89, 1.04
USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU  WHAT
ben               -                二09    2:27m  0.00s  0.04s lightdm --session-child 13 20
```

- 第一行：和top命令的第一行非常类似，主要显示了系统当前时间，开机多久(up)，有多少用户登录(users)，1分钟、5分钟、15分种前的平均负载(load average)。
- 第二行：项目的说明
  - USER：登录的用户名
  - TTY：登录终端
  - FROM：从哪个IP地址登录
  - LOGIN@：登录时间
  - IDLE：用户闲置时间
  - JCPU：指的是和该终端连接的所有进程占用的CPU运算时间。这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间
  - PCPU：是指当前进程所占用的CPU运算时间
  - WHAT：当前正在运行的命令
- 第三行：代表一个用户



who命令比w命令稍微简单一点，也可以用来查看系统中已经登录的用户：

```shell
[root@localhost ~]# who
ben      tty7         2025-03-04 09:29 (:0)
# 用户名  登录终端      登录时间(登录来源IP地址)
```



### uptime

uptime命令的作用就是显示系统的启动时间和平均负载，也就是top命令的第一行：

```shell
[root@localhost ~]# uptime
 18:05:21 up 2 days,  8:35,  1 user,  load average: 1.61, 1.24, 1.10
```



### 查看系统与内核相关信息

使用uname命令查看内核的相关信息。

```
[root@localhost ~]# uname [选项]
选项：
  -a:	查看系统所有相关信息
  -r:   查看内核版本
  -s:   查看内核名称
```

如果我们想要判断当前系统的位数，可以通过file命令来判断系统文件(主要系统命令)的位数来推断系统的位数。如：

```shell
[root@localhost ~]# file /bin/ls
/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3eca7e3905b37d48cf0a88b576faa7b95cc3097b, for GNU/Linux 3.2.0, stripped
# 很明显，当前系统是64位的
```

如果想要查询当前Linux系统的发行版本，可以使用：

```shell
[root@localhost ~]# lsb_release -a 
No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 24.04.1 LTS
Release:	24.04
Codename:	noble
```



## 系统定时任务

### crontab

循环执行定时任务。

1）crond服务管理与访问控制

crontab命令是需要crond服务支持的，crond服务同样是独立的服务，所以启动和自启动方法如下：

```shell
# 重启动crond服务
[root@localhost ~]# service crond restart
# 设定crond服务为开机自启动
[root@localhost ~]# systemctl enable crond
```

crond服务默认是自启动的，如果服务器上有循环执行的系统定时任务，就不要关闭crond服务了。



2）用户的crontab设置

每个用户都可以实现自己的crontab定时任务，只要是使用这个用户身份执行“crontab -e”命令即可。

```
[root@localhost ~]# crontab [选项]
选项：
  -e:		编辑crontab定时任务
  -l:		查询crontab任务
  -r:		删除当前用户所有的crontab任务，如果有多个任务，只想删除一个，可以使用"crontab -e"
  -u 用户名: 修改或删除其他用户的crontab任务。只有root可用	
```

进入crontab编辑界面，会打开vim编辑你的工作：

```shell
[root@localhost ~]# crontab -e
* * * * * 执行的任务
```

| 项目      | 含义                 | 范围                  |
| --------- | -------------------- | --------------------- |
| 第一个“*” | 一小时当中的第几分钟 | 0-59                  |
| 第二个“*” | 一天当中的第几个小时 | 0-23                  |
| 第三个“*” | 一个月当中的第几天   | 1-31                  |
| 第四个“*” | 一年当中的第几月     | 1-12                  |
| 第五个“*” | 一周当中的星期几     | 0-7(0和7都代表星期日) |

特殊符号：

| 特殊符号 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| *        | 代表任何时间，比如第一个“*”就代表一小时中每分钟都执行一次。  |
| ，       | 代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。 |
| ~        | 代表连续的时间范围。比如“0 5 * * 1-6 命令”，代表在周一到周六的凌晨5点0分执行命令。 |
| */n      | 代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一次命令。 |

例如：

```shell
# 让系统每隔5分钟，就向/tmp/test文件中写入一行"ll"
[root@localhost ~]# crontab -e
*/5 * * * * /bin/echo "ll" >> /tmp/test

# 系统在每周二的凌晨5点05分重启一次
[root@localhost ~]# crontab -e
5 5 * * 2 /sbin/shutdown -r now

# 在每月的1号，10号，15号的凌晨3点30分都定时执行日志备份脚本autobak.sh
[root@localhost ~]# crontab -e
30 3 1,10,15 * * /root/sh/autobak.sh
```



3）crontab的注意事项

在书写crontab定时任务时，需要注意几个注意事项：

- 六个选项都不能为空，必须填写。如果不确定使用“*”代表任意时间。
- crontab定时任务，最小有效时间是分钟，最大时间范围是月。
- 在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都是以天为单位，非常容易让管理员混乱。
- 在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都是用绝对路径。有时相对路径的命令会报错。



4）系统的crontab设置

“crontab -e”是每个用户执行的命令，也就是说不同的用户身份可以执行自己的定时任务。可以是有些定时任务需要系统执行，这时就需要编辑/etc/crontab这个配置文件了。当然，并不是说写入/etc/crontab配置文件中的定时任务执行时，不需要用户身份，而是"crontab -e"命令定义定时任务时，默认用户身份是当前登录用户。而修改/etc/crontab配置文件时，定时任务的执行者身份是可以手工指定的。这样定时任务的执行会更加灵活，修改起来也更加方便。

```shell
[root@localhost ~]# vim /etc/crontab
# /etc/crontab: system-wide crontab
# Unlike any other crontab you don't have to run the `crontab'
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

# 标识使用哪种shell
SHELL=/bin/sh
# You can also override PATH, but by default, newer versions inherit it from the environment
#PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *	* * *	root	cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || { cd / && run-parts --report /etc/cron.daily; }
47 6	* * 7	root	test -x /usr/sbin/anacron || { cd / && run-parts --report /etc/cron.weekly; }
52 6	1 * *	root	test -x /usr/sbin/anacron || { cd / && run-parts --report /etc/cron.monthly; }
#
```

修改/etc/crontab这个配置文件，加入自己的定时任务，不过需要注意指定脚本的执行者身份：

```shell
[root@localhost ~]# vim /etc/crontab
# /etc/crontab: system-wide crontab
# Unlike any other crontab you don't have to run the `crontab'
# command to install the new version when you edit this file
# and files in /etc/cron.d. These files also have username fields,
# that none of the other crontabs do.

# 标识使用哪种shell
SHELL=/bin/sh
# You can also override PATH, but by default, newer versions inherit it from the environment
#PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name command to be executed
17 *	* * *	root	cd / && run-parts --report /etc/cron.hourly
25 6	* * *	root	test -x /usr/sbin/anacron || { cd / && run-parts --report /etc/cron.daily; }
47 6	* * 7	root	test -x /usr/sbin/anacron || { cd / && run-parts --report /etc/cron.weekly; }
52 6	1 * *	root	test -x /usr/sbin/anacron || { cd / && run-parts --report /etc/cron.monthly; }
# 使用run-parts脚本调用并执行/root/cron/目录中所有的可执行文件
* * * * *       root    run-parts /root/cron/
```

只要保存/etc/crontab文件，这个定时任务就可以执行了，当然要确定crond服务是运行的。
