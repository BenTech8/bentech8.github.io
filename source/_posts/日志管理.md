---
title: 日志管理
date: 2025-03-07 19:48:29
tags:
categories: Linux
---

## 日志简介

### 日志相关服务

在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。Redhat认为syslogd已经不能满足在工作中的需求，rsyslogd相比syslogd具有一些新的特点：

- 基于TCP网络协议传输日志信息；
- 更安全的网络传输方式；
- 有日志消息的及时分析框架；
- 后台数据库；
- 配置文件中可以写简单的逻辑判断；
- 与syslog配置文件相兼容。



### 系统中常见的日志文件

| 日志文件         | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| /var/log/cron    | 记录了系统定时任务相关的日志。                               |
| /var/log/cups/   | 记录打印信息的日志。                                         |
| /var/log/dmesg   | 记录了系统在开机时内核自检的信息。也可以使用dmesg命令直接查看内核自检信息。 |
| /var/log/btmp    | 记录错误登录的日志。这个文件是二进制文件，不能直接vim查看，而要使用lastb命令查看。 |
| /var/log/lastlog | 记录系统中所有用户最后一次登录时间的日志。这个文件也是二进制文件，不能直接vim查看，而要使用lastlog命令查看。 |
| /var/log/mailog  | 记录邮件信息。                                               |
| /var/log/message | 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件。 |
| /var/log/secure  | 记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录。比如说系统的登录，ssh的登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中。 |
| /var/log/wtmp    | 永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vim，而需要使用last命令来查看。 |
| /var/run/utmp    | 记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样这个文件不能直接vim，而要使用w,who,users等命令来查询。 |

除了系统默认的日志之外，采用RPM方式安装的系统服务也会默认把日志记录在/var/log/目录中(源码包安装的服务日志是在源码包指定目录中)。不过这些日志不是由rsyslogd服务来记录和管理的，而是各个服务器使用自己的日志管理文档来记录自身日志。

| 日志文件        | 说明                                |
| --------------- | ----------------------------------- |
| /var/log/httpd/ | RPM包安装的apache服务的默认日志目录 |
| /var/log/mail/  | RPM包安装的邮件服务的额外日志目录   |
| /var/log/samba/ | RPM包安装的samba服务的日志目录      |
| /var/log/sssd/  | 守护进程安全服务目录                |



## 日志服务(rsyslogd)

### 日志文件格式

只要是由日志服务rsyslogd记录的日志文件，他们的格式是一样的。基本日志格式包含以下四列：

- 事件产生的时间
- 发生事件的服务器的主机名
- 产生事件的服务名或程序名
- 事件的具体信息



### rsyslogd服务的配置文件

#### /etc/rsyslog.d/50-default.conf

```shell
auth,authpriv.*			/var/log/auth.log
# 服务名称[连接符号]日志等级    日志记录位置
# 认证相关服务.所有日志等级     记录在/var/log/auth.log日志中
```

- 服务名称

  我们首先需要确定rsyslogd服务可以识别哪些服务的日志，也可以理解为以下这些服务委托了rsyslogd服务来代为管理日志。这些服务如下表所示：

  | 服务名称                      | 说明                                                         |
  | ----------------------------- | ------------------------------------------------------------ |
  | auth（LOG_AUTH）              | 安全和认证相关消息(不推荐使用authpriv替代)                   |
  | authpriv（LOG_AUTHPRIV）      | 安全和认证相关消息（私有的）                                 |
  | cron（LOG_CRON）              | 系统定时任务cront和at产生的日志                              |
  | daemon（LOG_DAEMON）          | 和各个守护进程相关的日志                                     |
  | ftp（LOG_FTP）                | ftp守护进程产生的日志                                        |
  | kern（LOG_KERN）              | 内核产生的日志（不是用户进程产生的）                         |
  | local0-local7（LOG_LOCAL0-7） | 为本地使用预留的服务                                         |
  | lpr（LOG_LPR）                | 打印产生的日志                                               |
  | Mail（LOG_MAIL）              | 邮件收发信息                                                 |
  | news（LOG_NEWS）              | 与新闻服务器相关的日志                                       |
  | syslog（LOG_SYSLOG）          | 有syslogd服务产生的日志信息（虽然服务名称已经改为rsyslogd，但是很多配置都还是沿用了syslogd的，这里并没有修改服务名）。 |
  | user（LOG_USER）              | 用户等级类别的日志信息                                       |
  | uucp（LOG_UUCP）              | uucp子系统的日志信息，uucp是早期linux系统进行数据传递的协议，后来也常用在新闻组服务中 |

- 连接符号

  日志服务连接日志等级的格式为：

  ```
  日志服务[连接符号]日志等级			日志记录位置
  ```

  在这里连接符号可以识别为：

  - "."代表只要比后面的等级高的（包含该等级）日志都记录下来。比如："cron.info"代表cron服务产生的日志只要日志等级大于等于info级别，就记录。
  - “.=”代表只记录所需等级的日志，其他等级的都不记录。比如：“*.=emerg”代表任何日志服务产生的日志，只要等级是emerg等级就记录。这种用法极少见，了解就好。
  - “.!”代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。

- 日志等级

  | 等级名称               | 说明                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | debug（LOG_DEBUG）     | 一般的调试信息说明                                           |
  | info（LOG_INFO）       | 基本的通知信息                                               |
  | notice（LOG_NOTICE）   | 普通信息，但是有一定的重要性                                 |
  | warning（LOG_WARNING） | 警告信息，但是还不会影响到服务或系统的运行                   |
  | err（LOG_ERR）         | 错误信息，一般达到err等级的信息以及可以影响到服务或系统的运行了 |
  | crit（LOG_CRIT）       | 临界状况信息，比err等级还要严重                              |
  | alert（LOG_ALERT）     | 警告状态信息，比crit还要严重。必须立即采取行动               |
  | emerg（LOG_EMERG）     | 疼痛等级信息，系统已经无法使用了                             |
  | *                      | 代表所有日志等级，比如：“authpriv.*”代表authpriv认证信息服务产生的日志，所有的日志等级都记录 |

  日志等这里还可以识别"none"，如果日志等级是none，就说明忽略这个日志服务，该服务的所有日志都不再记录。

- 日志记录位置

  日志记录位置就是当前日志输出到哪个日志文件中保存，当然也可以把日志输出到印机打印，或者输出到远程日志服务器上（当然日志服务器要允许接收才行）。日志的记录位置也是固定的：

  - 日志文件的绝对路径

    这是最常见的日志保存方法，如“/var/log/secure”就是保存系统验证和授权信息日志的。

  - 系统设备文件

    如“/dev/lp0”代表第一台打印机，如果日志保存位置是打印机设备的话，当有日志时就会在打印机打印（不太符合可持续发展战略）。

  - 转发给远程主机

    因为可以选择使用TCP协议和UDP协议传输日志信息，所以有两种发送格式。如使用“@192.168.0.210:514”，就会把日志内容使用UDP协议发送到192.168.0.210的UDP 514端口上；如果使用"@@192.168.0.210:514"就会把日志内容使用TCP协议发送到192.168.0.210的TCP 514端口上，其中514是日志服务默认端口。当然只要192.168.0.210同意接收此日志，就可以把日志内容保存在日志服务器上。
  
  - 用户名
  
    如“root”，就会把日志发送给root用户，当然root要在线，否则就收不到日志信息了。发送日志给用户时，可以使用“*”代表发送给所有在线用户，如“mail.\* *”就会把mail服务产生的所有级别的日志发送给所有在线用户。如果需要把日志发送给多个在线用户，用户名之间用“,”分隔。

忽略或丢弃日志。如果接受日志的对象是“~”，代表这个日志不会记录，而被直接丢弃。如“local3.* ~”代表忽略local3服务类型所有的日志都不记录。



#### /etc/rsyslog.conf配置文件内容

```shell
[root@localhost ~]# vim /etc/rsyslog.conf
# /etc/rsyslog.conf configuration file for rsyslog
#
# For more information install rsyslog-doc and see
# /usr/share/doc/rsyslog-doc/html/configuration/index.html
#
# Default logging rules can be found in /etc/rsyslog.d/50-default.conf

# 加载模块
#################
#### MODULES ####
#################

# 加载imuxsock模块，为本地系统登录提供支持
module(load="imuxsock") # provides support for local system logging
# 加载immark模块，提供标记信息的能力
#module(load="immark")  # provides --MARK-- message capability

# 加载UDP模块，允许使用UDP的514端口接收采用UDP协议转发的日志
# provides UDP syslog reception
#module(load="imudp")
#input(type="imudp" port="514")

# 加载TCP模块，允许使用TCP的514端口接收采用TCP协议转发的日志
# provides TCP syslog reception
#module(load="imtcp")
#input(type="imtcp" port="514")

# provides kernel logging support and enable non-kernel klog messages
module(load="imklog" permitnonkernelfacility="on")

# 定义全局设置
###########################
#### GLOBAL DIRECTIVES ####
###########################

# Filter duplicated messages
$RepeatedMsgReduction on

#
# Set the default permissions for all log files.
#
$FileOwner syslog
$FileGroup adm
$FileCreateMode 0640
$DirCreateMode 0755
$Umask 0022
$PrivDropToUser syslog
$PrivDropToGroup syslog

#
# Where to place spool and state files
#
$WorkDirectory /var/spool/rsyslog

#
# Include all config files in /etc/rsyslog.d/
#
# 包含/etc/rsyslog.d/目录中所有的".conf"子配置文件。也就是说这个目录中的所有子配置文件也同时生效
$IncludeConfig /etc/rsyslog.d/*.conf
```

### 定义自己的日志

```shell
[root@localhost ~]# vim /etc/rsyslog.d/60-custom.conf
*.crit				/var/log/alert.log
# 把所有服务的"临界点"以上的错误都保存在/var/log/alert.log日志中

[root@localhost ~]# systemctl restart syslog

[root@localhost ~]# ll /var/log/alert.log
```



## 日志轮替

### 日志文件的命名规则

日志轮替最主要的作用就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除。那么旧的日志文件改名之后，如何命名呢？主要依靠/etc/logrotate.conf配置文件中“dateext”参数：

- 如果配置文件中拥有"dateext"参数，那么日志会用日期来作为日志文件的后缀，例如“secure-20180605"。这样的话日志文件名不会重叠，所以也就不需要日志文件的改名，只需要保存指定的日志个数，删除多余的日志文件即可。
- 如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为"secure.1"，然后新建"secure"日志，用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为"secure.1"，然后也会新建"secure"日志，用来保存新的日志，以此类推。



### logrotate配置文件

```shell
[root@localhost ~]# vim /etc/logrotate.conf
# see "man logrotate" for details

# global options do not affect preceding include directives

# 每周对日志文件进行一次轮替
# rotate log files weekly
weekly

# use the adm group by default, since this is the owning group
# of /var/log/.
su root adm

# 保存4个日志文件，也就是说如果进行了5次日志轮替，就会删除第一个备份日志
# keep 4 weeks worth of backlogs
rotate 4

# 在日志轮替时，自动创建新的日志文件
# create new (empty) log files after rotating old ones
create

# 使用日期作为日志轮替文件的后缀
# use date as a suffix of the rotated file
#dateext

# 日志文件是否压缩，如果取消注释，则日志会在转储的同时进行压缩
# uncomment this if you want your log files compressed
#compress

# 包含/etc/logrotate.d/目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来，进行日志轮替。
# packages drop log rotation information into this directory
include /etc/logrotate.d

# system-specific logs may also be configured here. 
```

以上日志配置为默认配置，如果需要轮替的日志没有设定独立的参数，那么都会遵守以上参数。如果轮替日志配置了独立参数，那么独立参数优先级更高。

```shell
[root@localhost ~]# vim /etc/logrotate.d/wtmp
# no packages own wtmp -- we'll rotate it here
# 以下参数仅对此目录有效
/var/log/wtmp {
    missingok
    # 每月对日志文件进行一次轮替
    monthly
    # 建立的新日志文件,权限是0664,所有者是root，所属组是utmp组
    create 0664 root utmp
    # 日志文件最小轮替大小是1MB。也就是日志一定要超过1MB才会轮替，否则就算时间达到一个月，也不进行日志转储
    minsize 1M
    # 仅保留一个日志备份。也就是只有wtmp和wtmp.1日志保留而已
    rotate 1
}
```

logrotate配置文件的主要参数，通过如下表说明：

| 参数                    | 参数说明                                                     |
| ----------------------- | ------------------------------------------------------------ |
| daily                   | 日志的轮替周期是每天                                         |
| weekly                  | 日志的轮替周期是每周                                         |
| monthly                 | 日志的轮替周期是每月                                         |
| rotate 数字             | 保留的日志文件的个数。0指没有备份                            |
| compress                | 日志轮替时，旧的日志进行压缩                                 |
| create mode owner group | 建立新日志，同时指定新日志的权限与所有者和所属组。如create 0600 root utmp |
| mail address            | 当日志轮替时，输出内容通过邮件发送到指定的邮件地址。如mail aaa@163.com |
| missingok               | 如果日志不存在，则忽略该日志的警告信息                       |
| notifempty              | 如果日志为空文件，则不进行日志轮替                           |
| minsize 大小            | 日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替 |
| size 大小               | 日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。如size 100k |
| dateext                 | 使用日期作为日志轮替文件的后缀。如secure-20180605            |
| sharedscripts           | 在此关键字之后的脚本只执行一次                               |
| prerotate/endscript     | 在日志轮替之前执行脚本命令。endscript标示prerotate脚本结束。 |
| postrotate/endscript    | 在日志轮替之后执行脚本命令。endscript标示postrotate脚本结束。 |

这些参数中较为不好理解的应该就是prerotate/endscript和postrotate/endscript参数了。例如：

```shell
/var/log/httpd/error.log {
    rotate 5
    mail www@my.org
    size 100k
    # 以下脚本只执行一次
    sharedscripts
    # 在日志轮替结束之后，执行以下脚本
    postrotate
    	# 重启apache服务
        /usr/bin/killall -HUP httpd
    endscript
    # 脚本结束
}
```

prerotate和postrotate主要用于在日志轮替的同时，执行指定的脚本，一般用于日志轮替之后重启服务。这里强调，如果你的日志是写入rsyslog服务的配置文件的，那么把新日志加入logrotate后，一定要重启rsyslog服务，否则你会发现虽然新日志建立了，但是数据还是写入了旧的日志当中。那是因为虽然logrotate知道日志轮替了，但是rsyslog服务并不知道。同理，如果你的日志不是被rsyslog管理，如源码包安装的Apache、Nginx等服务，则需要重启Apache或Nginx服务，否则日志也不能正常轮替。



### 把自己的日志加入日志轮替

1）方法一

直接在/etc/logrotate.conf配置文件中写入该日志的轮替策略，从而把日志加入轮替。



2）方法二

在/etc/logrotate.d/目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可以把日志加入轮替。推荐使用此方法，因为系统中需要轮替的日志非常多，如果全部直接写入/etc/logrotate.conf配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。



举个例子，如果需要把Nginx服务的日志加入日志轮替，则也需要重启Nginx服务。如：

```
/date/logs/nginx/access/access.log /date/logs/nginx/access/default.log {
	daily
	rotate 15
	sharedscripts
	postrotate
		# 重启rsyslog服务
		/bin/kill -HUP $(/bin/cat /var/run/syslogd.pid) &>/dev/null
		# 重启nginx服务
		/bin/kill -HUP $(/bin/cat /usr/local/nginx/logs/nginx.pid) &>/dev/null
	endscript
}
```



### logrotate命令

日志轮替之所以可以在指定的时间备份日志，其实也要依赖系统定时任务。如果大家还记录/etc/cron/daily/目录，就会发现这个目录中是有logrotate文件，logrotate通过这个文件依赖定时任务执行的。

```
[root@localhost ~]# logrotate [选项] 配置文件名
选项：
	如果此命令没有选项，则会按照配置文件中的条件进行日志轮替
	-v:		显示日志轮替过程。加了-v选项，会显示日志的轮替的过程
	-f:		强制进行日志轮替。不管日志轮替的条件是否已经符合，强制配置文件中所有的日志进行轮替
```

执行logrotate命令，并查看下执行过程：

```shell
[root@localhost ~]# logrotate -v /etc/logrotate.conf
...
rotating pattern: /var/log/wtmp  monthly (1 rotations)
empty log files are rotated, only log files >= 1048576 bytes are rotated, old logs are removed
switching euid from 0 to 0 and egid from 0 to 4 (pid 39834)
considering log /var/log/wtmp
  Now: 2025-03-10 19:45
  Last rotated at 2024-08-26 09:05
  log does not need rotating ('minsize' directive is used and the log size is smaller than the minsize value)
switching euid from 0 to 0 and egid from 4 to 0 (pid 39834)
```

强制进行一次日志轮替，看看有什么效果：

```shell
[root@localhost ~]# logrotate -vf /etc/logrotate.conf
...
rotating pattern: /var/log/wtmp  forced from command line (1 rotations)
empty log files are rotated, only log files >= 1048576 bytes are rotated, old logs are removed
switching euid from 0 to 0 and egid from 0 to 4 (pid 40773)
considering log /var/log/wtmp
  Now: 2025-03-10 19:48
  Last rotated at 2024-08-26 09:05
  log needs rotating                                 # 日志需要轮替
rotating log /var/log/wtmp, log->rotateCount is 1
dateext suffix '-20250310'                           # 提取日期参数
glob pattern '-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]'
renaming /var/log/wtmp.1 to /var/log/wtmp.2 (rotatecount 1, logstart 1, i 1), 
# 旧的日志被重命名
renaming /var/log/wtmp to /var/log/wtmp.1
# 创建新日志文件
creating new /var/log/wtmp mode = 0664 uid = 0 gid = 43
removing old log /var/log/wtmp.2
switching euid from 0 to 0 and egid from 4 to 0 (pid 40773)
```

logrotate命令使用“-f”选项之后，就不管日志是否已经符合了日志轮替条件，而强制把所有的日志都进行了轮替。
