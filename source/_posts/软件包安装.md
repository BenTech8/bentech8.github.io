---
title: 软件包安装
date: 2025-02-25 13:04:20
tags:
categories: Linux
---

# 软件包安装

## 1. 软件包分类

- 源码包
- 二进制包



## 2. 源码包

### 1）源码包优点

- 开源，如果有足够的能力，可以修改源码包。
- 可以自由选择所需的功能
- 软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高
- 卸载方便



### 2）源码包缺点

- 安装过程步骤较多，尤其安装较大的软件集合时(如LAMP环境搭建)，容易出现拼写错误
- 编译过程时间较长，安装比二进制安装时间长
- 因为是编译安装，安装过程中一旦报错新手很难解决



## 3. 二进制包

Linux系列：Debian和RedHat。

### 1）二进制包分类

a）DPKG包

是由Debian Linux所开发出来的包管理机制，通过DPKG包，Debian Linux就可以进行软件包管理。主要应用在Debian和Ubuntu中。



b）RPM包

是由Red Hat公司所开发的包管理系统。功能强大，安装、升级、查询和卸载都非常简单和方便。目前很多Linux都在使用这种包管理方式，包括Fedora、CentOS、SuSE等。



### 2）RPM包特点

RPM包优点：

- 包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载
- 安装速度比源码包安装快的多



RPM包缺点：

- 经过编译，不再可以看到源代码
- 功能选择不如源码包灵活
- 依赖性。有时我们会发现需要安装软件包a时需要先安装b和c，而安装b时需要安装d和e。这时需要先安装d和e，再安装b和c，最后才能安装a包。



### 3）RPM包依赖

a）树形依赖

a------>b------>c



b）环形依赖

a------>b------>c------>a



c）模块依赖

什么是模块依赖？例如：

```
rpm -ivh mysql-connector-odbc-5.2.5-7.el7.x86_64.rpm
错误：依赖检测失败：
    libodbc.so.2()(64bit) 被 mysql-connector-odbc-5.2.5-7.el7.x86_64 需要
    libodbcinst.so.2()(64bit) 被 mysql-connector-odbc-5.2.5-7.el7.x86_64 需要
```

发现报错，需要安装"libodbc.so.2"函数库文件，这时会发现在光盘中根本找不到这个文件，那是因为函数库没有单独成包，是包含在某一个软件包中的，而如果知道在哪个软件包中，需要查询网站www.rpmfind.net。



### 4）RPM包安装方法

- 手工安装
- yum在线安装



## 4. 软件包选择建议

- 源码包：如果软件包是给大量客户端提供访问，建议使用源码包安装，源码包效率更高(LAMP)。
- RPM包：如果软件包是给Linux底层使用，或只给少量客户访问，建议使用RPM包安装，因为RPM包简单。



## 5. RPM手工安装

rpm数据库路径：/var/lib/rpm/

### 1）RPM包命名规则

```
httpd-2.2.15-15.el6.centos.1.i686.rpm
```

- httpd：软件包名
- 2.2.15：软件版本
- 15：软件发布的次数
- el6：软件发行商。el6是RedHat公司发布，适合RHEL6.x(Red Hat Enterprise Linux)和CentOS6.x下使用
- i686：适合的硬件平台。RPM包可以在不同的硬件平台安装，选择适合不同CPU的软件版本，可以最大化的发挥CPU性能，所以出现了所谓的i386（386以上计算机都可以安装）、i586（586以上的计算机都可以安装）、i686（奔腾II以上计算机都可以安装，目前所有的CPU都是奔腾II以上，所以这个软件版本居多）、x86_64（64位CPU可以安装）和noarch（没有硬件限制）等文件名了。
- rpm：rpm包的扩展名，我们说过Linux下文件不是靠扩展名区分文件类型，也就是Linux中扩展名没有任何意义。可是这里怎么又出现了扩展名呢？如果RPM包不用“rpm”作为扩展名，系统可以正确识别没有问题，可是管理员很难识别这是个什么样的软件。



### 2）RPM包手工命令安装

a）默认安装位置

| 路径            | 说明                       |
| --------------- | -------------------------- |
| /etc/           | 配置文件安装目录           |
| /usr/bin/       | 可执行的命令安装目录       |
| /usr/lib/       | 程序所使用的函数库保存位置 |
| /usr/share/doc/ | 基本的软件使用手册保存位置 |
| /usr/share/man/ | 帮助文件保存位置           |



b）安装命令

```
rpm -ivh 包全名
选项：
  -i    install安装(install)
  -v    显示更详细的信息(verbose)
  -h    打印#显示安装进度(hash)
```

其他选项：

- --nodeps：不检测依赖性安装。安装软件时会检测依赖性，确定所需的底层软件是否安装。如果没有安装则会报错。如果我不管依赖性，想强行安装，可以使用这个选项。这样不检测依赖性安装的软件是不能使用的，所以不建议这样做。
- --replacefiles：替换文件安装。如果安装软件包，可是包中部分文件已经存在，那么正常安装时，会报错"某个文件已经存在"从而导致软件无法安装，使用这个选项可以忽视这个报错，而覆盖安装。
- --replacepkgs：替换软件包安装。如果软件包已经安装，此选项可以把软件包重复安装一遍。
- --force：强制安装。不管是否已经安装，都重新安装。就是--replacefiles和--replacepkgs的综合。
- --test：测试安装。不会实际安装，只是检测一下依赖性。
- --prefix：指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。如果指定了安装路径，软件没有安装到系统默认路径中的话，系统会找不到这些安装的软件，需要进行手工配置才能被系统识别。所以rpm包我们一般都采用默认路径安装：1）默认安装位置是系统的习惯位置。2）RPM包管理系统是有卸载命令的(数据库记录安装位置)



c）服务启动

```
# service启动
service 服务名 start|stop|restart|status
参数：
  start:    启动服务
  stop:     停止服务
  restart:  重启服务
  status:   查看服务状态
  
  # 标准启动
  /etc/init.d/服务名 start|stop|restart|status
```



### 3）RPM包升级

```
rpm -Uvh 包全名
选项：
  -U      升级安装，如果没有安装过，系统直接安装。如果安装过的版本较旧，则升级到新版本(upgrade)
 
rpm -Fvh 包全名
选项：
  -F      升级安装，如果没有安装过，则不会安装，必须安装有较旧版本，才能升级(freshen)
```



### 4）RPM包卸载

```
rpm -e 包名
选项：
  --nodeps      不检查依赖性
  -e            卸载
```



### 5）RPM包查询

a）查询软件包是否安装

```
rpm -q 包名
选项：
  -q：查询(query)
```



b）查询系统中的所有安装软件包

可以查询Linux系统中所有已经安装的软件包。

```
rpm -qa
选项：
  -a：所有(all)
```

可以用管道符来查看所需内容

```
rpm -qa | grep 包名
```



c）查询软件包的详细信息

可以查询已经安装的某个软件包的详细信息

```
rpm -qi 包名
选项：
  -i：查询软件信息(information)
```

也可以查询还没有安装的软件包的详细信息

```
rpm -qip 包全名
选项：
  -p：查询没有安装的软件包(package)
```



d）查询软件包中的文件列表

可以查询已经安装的软件包中的文件列表和安装的完整目录

```
rpm -ql 包名
选项：
  -l：列出软件包中所有的文件列表和软件所安装的目录(list)
```

查询未安装的软件包中的文件列表和打算安装的位置

```
rpm -qlp 包全名
选项：
  -p：查询没有安装的软件包信息(package)
```



e）查询系统文件属于哪个RPM包

```
rpm -qf 系统文件名
选项：
  -f：查询系统文件属于哪个软件包(file)
```



f）查询软件包所依赖的软件包

查询系统中和已经安装的软件包有依赖关系的软件包

```
rpm -qR 包名
选项：
  -R：查询软件包的依赖性(requires)
```

查询未安装的软件包的依赖包

```
rpm -qRp 包全名
```



### 6）验证

```shell
# 校验本机已经安装的所有软件包
rpm -Va

# 校验指定RPM包中的文件(verify)
rpm -V 已安装的名包

# 校验某个系统文件是否被修改
rpm -Vf 系统文件名
```

示例：

```
rpm -V httpd
S.5....T.    c             /etc/httpd/conf/httpd.conf
验证内容    文件类型          文件名
```

验证内容详情：

- S：文件大小是否改变
- M：文件的类型或文件的权限(rwx)是否被改变
- 5：文件MD5校验和是否改变(可以看成文件内容是否改变)
- D：设备的主从代码是否改变
- L：文件路径是否改变
- U：文件的属主(所有者)是否改变
- G：文件的属组是否改变
- T：文件的修改时间是否改变

文件类型：

- c：配置文件(config file)
- d：普通文档(documention)
- g：“鬼”文件(ghost file)，很少见，就是该文件不应该被这个RPM包包含 
- l：授权文件(license file)
- r：描述文件(readme)



### 7）数字证书

前面的校验方法只能对已经安装的RPM包中的文件进行校验，但是如果RPM包本身就被动过手脚，那么校验就不能解决问题了，我们就必须使用数字证书验证了。

数字证书特点：

- 首先必须找到原厂的公钥文件，然后进行安装
- 再安装RPM包时会提取RPM包中的证书信息，然后和本机安装的原厂证书进行验证
- 如果验证通过，则允许安装；如果验证不通过，则不允许安装并警告



 a）数字证书导入

```
rpm --import 数字证书文件
选项：
  --import：导入数字证书
```



b）查询系统中安装好的数字证书

```
rpm -qa | grep gpg-pubkey
```



### 8）RPM包中文件的提取

```
rpm2cpio 包全名 | cpio -idv . 文件的绝对路径
```

rpm2cpio：将rpm包转换为cpio格式的命令。

cpio：是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件。



## 6. RPM包在线安装(yum)

### 1）yum源文件解析

yum源配置文件保存在/etc/yum.repos.d/目录中，文件的扩展名一定是"*.repo"。也就是说，yum源配置文件只要扩展名是"\*.repo"就会生效。

```shell
ls /etc/yum.repos.d/
CentOS-Base.repo    CentOS-Debuginfo.repo    CentOS-fasttrack.repo    CentOS-Media.repo    CentOS-Vault.repo
```

这个目录中有5个yum源配置文件，默认情况下CentOS-Base.repo文件生效。

CentOS-Base.repo中有5个yum源容器，以base容器解释其内容详情：

- [base]：容器名称，一定要放在[]中。
- name：容器说明，可以自己随便写。
- mirrorlist：镜像站点，这个可以注释掉。
- baseurl：yum源服务器的地址。默认是CentOS官方的yum源服务器，是可以使用的。如果觉得慢，可以改成国内yum源地址。
- enabled：此容器是否生效，如果不写或写成enabled=1则表示此容器生效，写成enabled=0则表示此容器不生效。
- gpgcheck：如果为1则表示RPM的数字证书生效，如果为0则表示RPM的数字证书不生效。
- gpgkey：数字证书的公钥文件保存位置，不用修改。



### 2）搭建本地光盘yum源

a）放入CentOS安装光盘，并挂载光盘到指定位置。

```shell
# 创建cdrom目录，作为光盘的挂载点
mkdir /mnt/cdrom

# 挂载光盘到/mnt/cdrom
mount /dev/cdrom /mnt/cdrom/
```

b）修改其他几个yum源配置文件的扩展名，让它们失效，因为只有扩展名是"*.repo"的文件才能作为yum源配置文件。

```
cd /etc/yum.repo.d
mv CentOS-Base.repo CentOS-Base.repo.bak
```

c）修改光盘yum源配置文件CentOS-Media.repo

```
vim CentOS-Media.repo
[c6-media]
name=CentOS-$releasever - Media
baseurl=file:///mnt/cdrom/
gpgcheck=1
enabled=1   # 让配置生效
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6
```

d）查看是否生效

```shell
# 查询yum源所有可安装的软件包列表
yum list
```



### 3）yum命令

a）查询

```shell
# 查询yum所有安装包
yum list

# 查询yum源服务器中是否包含某个软件包
yum list 包名

# 搜索yum源服务器上所有和关键字相关的软件包
yum search 关键字

# 查询指定软件包的信息
yum info samba
```

yum search搜索可以用于确定某个软件在哪个相关包当中。



b）安装

```
yum -y install 包名
选项：
  install：    安装
  -y：         自动回答yes。如果不加-y，那么每个安装的软件都需要手工回答yes
```



c）升级

```shell
yum -y update 包名
选项：
  update:    升级
  -y：       自动回答yes
  
# 升级本机所有软件包（包括内核，不常用）
yum -y update
```



d）卸载

除非你确定卸载的软件的依赖包不会对系统产生影响，否则不要执行yum的卸载，因为很有可能在卸载软件包的同时卸载的依赖包也是重要的系统文件，这就可能导致系统崩溃。

```
yum remove 包名
```



### 4）yum组管理命令

```shell
# 列出所有可用的软件组列表
yum grouplist

# 列出软件组中包含的软件
yum groupinfo 软件组名

# 安装指定软件组
yum groupinstall 软件组名

# 卸载指定软件组
yum groupremove 软件组名
```



## 7.源码包安装

### 1）注意事项

a）源码包是从哪里来的？

源码包是通过官方网站下载的，如果需要使用，是需要单独下载的。



b）是否可以在系统中既安装rpm包的Apache，又安装源码包的Apache？

可以，因为两种安装方法安装的Apache，安装位置是不一样的：

- 源码包必须指定安装位置(源码包没有安装数据库，没有删除命令)
- RPM包不建议指定安装位置，建议安装在默认位置(RPM包安装的服务有标准卸载命令，不怕文件到处安装)



### 2）安装过程

a）下载软件包

b）解压缩

c）进入解压目录

d）./configure（编译前准备）

这一步主要有三个作用：

- 在安装之前需要检测系统环境是否符合安装要求。
- 定义需要的功能选项。"./configure"支持的功能选项较多，可以执行“./configure --help”命令查询其支持的功能，一般都会通过"./configure --prefix=安装路径"来指定安装路径。
- 把系统环境的检测结果和定义好的功能选项写入Makefile文件，后续的编译和安装需要依赖这个文件的内容。

需要注意的是，configure不是系统命令，而是源码包软件自带的一个脚本程序，所以必须采用“./configure”方式执行。

e）make（编译）

make会调用gcc编译器，并读取Makefile文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被Linux识别的可执行文件，这些可执行文件保存在当前目录下。编译过程较为耗时，需要有足够的耐心。

f）make clean（清空编译内容，非必需步骤）

如果在"./configure"或“make”编译中报错，那么我们在重新执行命令前一定要记得执行make clean命令，它会清空Makefile文件或编译产生的“.o”文件。

g）make install（编译安装）

这才是真正的安装过程，一般会写清楚程序的安装位置。如果忘记指定安装目录，则可以把这个命令的执行过程保存下来，以备将来删除使用。



### 3）删除

源码包没有删除命令，如果需要删除，直接删除安装目录即可。



### 4）打入补丁

a）补丁的生成

```
# 比较old和new文件的不同
diff 选项 old new
选项：
  -a    将任何文档当做文本文档处理
  -b    忽略空格造成的不同
  -B    忽略空白行造成的不同
  -I    忽略大小写造成的不同
  -N    当比较两个目录时，如果某个文件只在一个目录中，则另一个目录中视作空文件。
  -r    当比较目录时，递归比较子目录
  -u    使用统一的输出格式
```

比较两个文件的不同，并生成补丁文件"txt.patch"：

```
# 比较两个文件的不同，同时生成txt.patch补丁文件
diff -Naur /root/test/old.txt /root/test/new.txt > txt.patch
```



b）打入补丁

```
# 按照补丁文件进行更新
patch -pn < 补丁文件
选项：
  -pn    n为数字。代表按照补丁文件中的路径，指定更新文件的位置。
```

“-pn”不好理解，补丁文件是要打入旧文件的，但是你当前所在的目录和补丁文件中的记录是不一定匹配的，所以就需要"-pn"来同步两个目录。

比如我当前在“/root/test”目录下，补丁文件中记录的文件目录是为“/root/test/old.txt”。这时如果写入“p1”，那么补丁文件就会打入"/root/test/root/test/old.txt"。如果写入的是“p2”，那么补丁文件就会打入"/root/test/test/old.txt"。如果写入的是“p3”，那么补丁文件就会打入"/root/test/old.txt"。即n表示删除补丁文件中记录的文件目录的路径。

```
patch -p3 < txt.patch
```



## 8. 脚本安装程序

以Webmin安装为例。

a）下载webmin软件，地址：http://sourceforge.net/projects/webadmin/files/webmin/

b）解压软件

```
tar -zxvf webmin-1.610.tar.gz
```

c）进入解压目录

```
cd webmin-1.610
```

d）执行安装程序setup.sh，并指定功能选项。

```
./setup.sh
```

