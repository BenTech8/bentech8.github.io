---
title: 权限管理
date: 2025-02-25 13:04:53
tags:
categories: Linux
---

# 权限管理

## 1. ACL权限

### 1）ACL概述

ACL是用于解决用户对文件身份不足问题的。



### 2）开启ACL

查询acl是否开启：

```shell
# dumpe2fs命令是查询指定分区详细文件系统信息的命令
dumpe2fs -h <根分区>
选项：
  -h:    仅显示超级地中信息，而不显示磁盘块组的详细信息。
 
 ...
 Default mount options:     user_xattr acl
 ...
```

如果没有开启，手工开启分区的ACL权限：

```shell
# 重新挂载根分区，并挂载加入acl权限
mount -o remount,acl /
```

也可以通过修改/etc/fstab文件，永久开启ACL权限：

```
vim /etc/fstab
UUID=6f9a4f35-3b8f-425e-b8f3-4d46dbca87ad /               ext4       defaults.acl 0       1
```

验证目录ACL权限存在

```
ls -ahl /
drwxrwx---+   2 sc   tg         4096  2月 14 20:19 www/
# “+”代表有ACL权限
```



### 3）ACL基本命令

a）查询文件的ACL权限

```
getfacl 文件名
```



b）设定ACL权限

```
setfacl [选项] 文件名
选项：
  -m    设定ACL权限
  -b    删除ACL权限
  -x    删除单个用户的ACL权限
  -R    递归(只能赋予目录，且只对已经存在的文件生效)

setfacl -m u:用户名:权限(1|2|4|5|7) 文件名
setfacl -m g:组名:权限(1|2|4|5|7) 文件名

# 赋予ACL默认权限。默认权限只能赋予目录，且只对以后新建的文件生效
setfacl -m d:u:用户名|组名:权限(1|2|4|5|7) 目录
```

示例：

```
# 给test目录赋予aa用户读写执行的ACL权限
setfacl -m u:aa:rwx /test

# 赋予递归ACL权限
setfacl -m u:cc:rx -R soft/

# ACL默认权限
setfacl -m d:u:aa:rwx -R soft/
```

**注意：**ACL权限，一旦递归后，不可避免的出现权限溢出。因为x权限对目录来说相当于cd，而对文件是最大权限。所以ACL权限能不用则不用。



### 4）最大有效权限(mask)

即最大ACL权限。设定用户或组ACL权限后，该用户或组最终权限是最大ACL权限(mask权限)与该用户或组权限逻辑与的结果的权限。

```
# 设定mask权限为r-x,使用“m:权限”格式
setfacl -m m:rx project/

# 查询project/目录权限
# file: project/
# owner: root
# group: tgroup
user::rwx              #effective:r-x
group::rwx             #effective:r-x
mask::r-x
other::---
```



### 5）删除ACL权限

```
# 删除指定用户和用户组的ACL权限
setfacl -x u:st /project/

# 删除文件的所有ACL权限
setfacl -b /project/
```



## 2. sudo授权

给普通用户赋予部分管理员权限。

在/sbin/和/usr/sbin/目录下的命令只有超级用户才能使用。



### 1）root身份

```
# 执行visudo命令，赋予普通用户权限命令，命令执行后和vi一样使用
visudo

root     ALL=(ALL)                         ALL
#用户名   被管理主机的地址=(可使用的身份)       授权命令(绝对路径)
# %wheel        ALL=(ALL)                              ALL
#%组名           被管理主机的地址=(可使用的身份)            授权命令(绝对路径)
```

- 用户名/组名：代表root给哪个用户或用户组赋予命令，注意组名前加“%”。

- 用户可以用指定的命令管理指定IP地址的服务器。如果写ALL，代表可以管理任务主机，如果写固定IP，代表用户可以管理指定的服务器。(这里的IP指定的是用户可以管理哪个IP地址的服务器，那么如果你是一台独立的服务器，这里写ALL和你服务器的IP地址，作用是一样的。而写入网段，只有对NIS服务这样用户和密码集中管理的服务器才有意义)。如果我们这里写本机的IP地址，不代表只允许本机的用户使用指定命令，而代表指定的用户可以从任何IP地址来管理当前服务器。
- 可使用身份：就是把来源用户切换成什么身份使用，(ALL)代表可以切换成任意身份。这个字段可以省略。
- 授权命令：代表root把什么命令授权给普通用户。默认是ALL，代表任何命令，这个当然不行，如果需要给哪个命令授权，写入命令名即可。不过需要注意一定要命令写成绝对路径。



【示例1】：授权用户user1可以重启服务器。

则由root用户添加如下行：

```
[root@localhost ~]# visudo
user1         ALL=/sbin/shutdown -r now

# 查看可用的授权
[user1@localhost ~]$ sudo -l

# 执行授权命令
[user1@localhost ~]$ sudo /sbin/shutdown -r now
```



【示例2】：授权一个用户管理web服务器。

首先要分析授权用户管理Apache至少要实现哪些基本授权：

- 可以使用Apache管理脚本
- 可以修改Apache配置文件
- 可以更新网页内容

假设Apache管理脚本程序为/etc/rc.d/init.d/httpd。

```
# visudo授权
[root@loaclhost ~]# visudo
user1      192.168.0.156=/etc/rc.d/init.d/httpd reload,/etc/rc.d/init.d/httpd configtest
```

授权用户user1可以连接192.168.0.156上的Apache服务器，通过Apache管理脚本重新读取配置文件让更改的设置生效(reload)和可以检测Apache配置文件语法错误(configtest)。

为满足条件二：

```
[root@localhost ~]# visudo
user1      192.168.0.156=/usr/bin/vim /etc/httpd/conf/httpd.conf
```

授权用户user1可以用root身份使用vi编辑Apache配置文件。

为满足条件三，假设网页存放目录为/var/www/html，则只需要授权user1对此目录具有写权限或者索性更改目录所有者为user1即可。如果需要，还可以设置user1可以通过FTP等文件共享服务更新网页。



【示例3】：授权aa用户可以添加其他普通用户。

```
[root@localhost ~]# visudo
aa    ALL=/usr/sbin/useradd
aa    ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd "", !/usr/bin/passwd root    # 不能改root用户密码
```



## 3.文件特殊权限

### 1）SetUID

a）SetUID概念

SetUID的功能可以这样理解：

- 只有可以执行的文件才能设定SUID权限
- 命令执行者要对该程序拥有x（执行）权限
- 命令执行者在执行该程序时获得该程序文件属主的身份(在执行程序的过程中灵魂附体为文件的属主)
- SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效

```
[root@localhost ~]# ll /etc/passwd
-rw-r--r-- 1 root root 3626  2月 15 11:38 /etc/passwd

[root@localhost ~]# ll /etc/shadow
-rw-r----- 1 root shadow 2092  2月 15 11:37 /etc/shadow

[root@localhost ~]# ll /usr/bin/passwd
-rwsr-xr-x 1 root root 64152  5月 30  2024 /usr/bin/passwd
```

/usr/bin/passwd命令拥有特殊权限SetUID，也就是在属主的权限位的执行权限上是s。可以这样来理解它：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。/usr/bin/passwd命令具有SetUID权限，所有者为root（Linux中的命令默认所有者都是root），也就是说当普通用户使用passwd更改自己密码的时候，那一瞬间突然灵魂附体了，实际是用passwd命令所有者root的身份在执行passwd命令，root当然可以将密码写入/etc/shadow文件，所以普通用户也可以修改/etc/shadow文件，命令执行完成后该身份也随之消失。如果取消SetUID权限，则普通用户就不能修改自己的密码了。



b）设置SetUID权限

```
# 设置SetUID权限
[root@localhost ~]# chmod u+s /usr/bin/vim      # 极其危险，意味着把服务器送给别人了，别人可以打开、修改任何文件了

# 查看SetUID权限
[root@localhost ~]# ll /usr/bin/vim
-rwsr-xr-x 1 root root 1847752 4月 5 2012 /usr/bin/vim 
```



c）建议

- 关键目录应严格控制写权限，比如“/”、“/usr”等；
- 用户的密码设置要严格遵守密码三原则；
- 对系统中默认应该具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限。



d）检测SetUID的脚本

```shell
#!/bin/bash
# Author: ben (E-main: 326525276@qq.com)

# 搜索系统中所有拥有SUID和SGID的文件，并保存到临时目录中
find / -perm -4000 -o -perm -2000 > /tmp/setuid.check
# 做循环，每次循环取出临时文件中的文件名
for i in $(cat /tmp/setuid.check)
do
	# 比对这个文件名是否在模板文件中
	grep $i /root/suid.list > /dev/null
	if ["$?" != "0"]
		# 如果在，不报错
	then
		# 如果文件不在模板文件中，则报错，并把报错存在日志中
		echo "$i isn't in listfile!" >> /root/suid_log_$(date +%F)
	fi
done

# 删除临时文件
rm -rf /tmp/setuid.check
```



### 2）SetGID

SGID既可以针对文件生效，也可以针对目录生效。这和SUID明显不同。

a）针对文件的作用

针对文件，SGID的含义如下：

- 只有可执行的文件才能设置SGID权限
- 命令执行者要对该文件拥有x（执行）权限
- 命令执行者在执行文件的时候，组身份升级为该文件的属组
- SetGID权限同样只在该文件执行过程中有效，也就是说组身份改变只在文件执行过程中有效

```
[root@localhost ~]# ll /var/lib/mlocate/mlocate.db
-rw-r----- 1 root slocate 1838850 1月    20 04：29 /var/lib/mlocate/mlocate.db
```

属主权限是r、w，属组权限是r，其他人权限是0；

```
[root@localhost ~]# ll /usr/bin/locate
-rwx--s--x. 1 root slocate 38464  8月 24 2010 /usr/bin/locate    # 所属组s代表SetGID权限
```

当普通用户user1执行locate命令时，会发生如下事情：

- /usr/bin/locate是可执行二进制程序，可以赋予SGID
- 执行用户user1对/usr/bin/locate命令拥有执行权限
- 执行/usr/bin/locate命令时，组身份会升级为slocate组，而slocate组对/var/lib/mlocate/mlocate.db数据库拥有r权限，所以普通用户可以使用locate

命令查询mlocate.db数据库

- 命令结束，user1用户的组身份返回为user1组



b）针对目录的作用

如果SGID针对目录设置，含义如下：

- 普通用户必须对此目录拥有r和x权限，才能进入此目录
- 普通用户在此目录中的有效组会变成此目录的属组
- 若普通用户对此目录拥有w权限时，新建的文件的默认属组就是这个目录的属组

```
# 进入临时目录
[root@localhost ~]# cd /tmp
# 建立测试目录
[root@localhost tmp]# mkdir dtest
# 给测试目录赋予SGID
[root@localhost tmp]# chmod g+s dtest
# 查询SGID是否生效
[root@localhost tmp]# ll -d dtest/
drwxr-sr-x 2 root root 4096 1月 20 06：04 dtest/
# 给测试目录权限，让普通用户可以写
[root@localhost tmp]# chmod 777 dtest/
# 切换成普通用户user1
[root@localhost tmp]# su - user1
# 普通用户进入测试目录
[user1@localhost ~]$ cd /tmp/dtest/
# 普通用户建立abc文件
[user1@localhost ~]$ touch abc
# abc文件的默认属组是root, 说明SGID生效
[user1@localhost ~]$ ll
总用量 0
-rw-rw-r-- 1 user1 root 0 1月 20 06：07 abc
```



### 3）Sticky BIT

Sticky BIT粘着位，也简称为SBIT，SBIT目前仅针对目录有效。

SBIT作用如下：

- 粘着位目录只对目录有效
- 普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限
- 如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件，一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。



### 4）设定文件特殊权限

特殊权限：

- 4代表SUID
- 2代表SGID
- 1代表SBIT

```
# 赋予SUID权限
[root@localhost ~]# chmod 4755 ftest              # 或者chmod u+s ftest

# 赋予SGID权限
[root@localhost ~]# chmod 2755 ftest              # 或者chmod g+s ftest

# 赋予SBIT权限
[root@localhost ~]# mkdir dtest
[root@localhost ~]# chmod 1755 dtest/             # 或者chmod o+t ftest
```



## 4. 文件系统属性chattr权限

a）命令格式

```
[root@localhost ~]chattr [+-=] [选项] 文件或目录名
选项：
  +：    增加权限
  -：    删除权限
  =：    等于某权限
  i：    如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和          删除文件
  a：    如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许          删除
  e：    Linux中绝大多数的文件都默认拥有e属性。表示该文件是使用ext文件系统进行存储的，而且不能使用“chattr -e”命令取消e属性
  
```

示例：

```
# 赋予文件i属性
chattr +i abc

# 取消文件i属性
chattr -i abc

# 赋予目录i属性
chattr +i bcd/

# 取消目录i属性
chattr -i bcd/
```



b) 查看文件系统属性(lsattr)

```
[root@localhost ~]# lsattr 选项 文件名
选项：
  -a:    显示所有文件和目录
  -d:    若目标是目录，仅列出目录本身的属性，而不是子文件
```



