<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bentech8.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="E-mail:17620170099@163.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Ben">
<meta property="og:url" content="https://bentech8.github.io/index.html">
<meta property="og:site_name" content="Ben">
<meta property="og:description" content="E-mail:17620170099@163.com">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ben">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bentech8.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ben</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Ben" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ben</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人学习笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/BenTech8/bentech8.github.io.git" class="github-corner" title="BenTech8 GitHub" aria-label="BenTech8 GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/03/13/nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/13/nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">nginx配置详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-03-13 17:54:28 / 修改时间：18:48:38" itemprop="dateCreated datePublished" datetime="2025-03-13T17:54:28+08:00">2025-03-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>	www www;</span><br><span class="line"><span class="comment"># 程序运行用户和组</span></span><br><span class="line"><span class="attribute">worker_processes</span>	auto;</span><br><span class="line"><span class="comment"># 启动进程，指定nginx启动的工作进程数量，建议按照cpu数目来指定，一般等于cpu核心数目</span></span><br><span class="line"><span class="attribute">error_log</span>	/home/wwwlogs/nginx_error.log	<span class="literal">crit</span>;</span><br><span class="line"><span class="comment"># 全局错误日志</span></span><br><span class="line"><span class="attribute">pid</span>		/usr/local/nginx/logs/nginx.pid;</span><br><span class="line"><span class="comment"># 主进程PID保存文件</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span>	<span class="number">51200</span>;</span><br><span class="line"><span class="comment"># 文件描述符数量</span></span><br><span class="line">events&#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="comment"># 使用expoll模型，对于2.6以上的内核，建议使用epoll模型以提高性能</span></span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">51200</span>;</span><br><span class="line">    <span class="comment"># 工作进程的最大连接数量</span></span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">    <span class="comment"># 网站优化参数</span></span><br><span class="line">    server&#123;								<span class="comment"># 具体的某一网站的配置信息</span></span><br><span class="line">        <span class="attribute">listen</span>	<span class="number">80</span>;						<span class="comment"># 监听端口</span></span><br><span class="line">        <span class="attribute">root</span> 	html;					<span class="comment"># 网页根目录(/usr/local/nginx/html)</span></span><br><span class="line">        <span class="attribute">server_name</span>	www.atguigu.com;	<span class="comment"># 服务器域名</span></span><br><span class="line">        <span class="attribute">index</span>	index.html;				<span class="comment"># 默认加载页面</span></span><br><span class="line">        <span class="attribute">access_log</span>	logs/access.log;	<span class="comment"># 访问日志保存位置</span></span><br><span class="line">        ......;</span><br><span class="line">        <span class="section">location</span> (.*)\.php$ &#123;</span><br><span class="line">            用于正则匹配具体的访问对象；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="section">location</span> &#123;</span><br><span class="line">            跳转等规则；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        虚拟主机;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>注意配置文件中的结尾有“;”作为结束。</p>
</li>
<li><p>每次实验修改完配置文件后需要重启nginx才会生效。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -HUP nginx</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="nginx状态统计"><a href="#nginx状态统计" class="headerlink" title="nginx状态统计"></a>nginx状态统计</h3><ul>
<li><p>安装nginx时将–with-http_stub_status_module模块开启。</p>
</li>
<li><p>修改nginx配置文件(写入要访问的server标签中)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /nginx_status &#123;</span><br><span class="line">    <span class="attribute">stub_status</span>	<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">access_log</span>	<span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端访问网址：<a target="_blank" rel="noopener" href="http://ip/nginx_status">http://IP/nginx_status</a></p>
<ul>
<li>Active connections：表示当前的活动连接数；</li>
<li>server accetps handled request：表示已经处理的连接信息。三个数字依次表示已处理的连接数、成功的TCP握手次数、已处理的请求数。</li>
</ul>
</li>
</ul>
<h3 id="目录保护"><a href="#目录保护" class="headerlink" title="目录保护"></a>目录保护</h3><ul>
<li><p>原理和apache的目录保护原理一样。</p>
</li>
<li><p>在状态统计的location中添加：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auth_basic</span> <span class="string">&quot;Welcome to nginx_status!&quot;</span>;</span><br><span class="line"><span class="attribute">auth_basic_user_file</span>	/usr/local/nginx/html/htpasswd.nginx;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用http的命令htpasswd进行用户密码文件的创建</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -c /usr/local/nginx/html/htpasswd.nginx user</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启nginx并再次访问统计页面</p>
</li>
</ul>
<h3 id="基于IP的身份验证-访问控制"><a href="#基于IP的身份验证-访问控制" class="headerlink" title="基于IP的身份验证(访问控制)"></a>基于IP的身份验证(访问控制)</h3><ul>
<li><p>在状态统计的location中添加：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">allow</span>	<span class="number">192.168.88.1</span>;</span><br><span class="line"><span class="attribute">deny</span>	<span class="number">192.168.88.0</span>/<span class="number">24</span>;</span><br><span class="line"><span class="comment"># 仅允许192.168.88.1访问服务器</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="nginx的虚拟主机-基于域名"><a href="#nginx的虚拟主机-基于域名" class="headerlink" title="nginx的虚拟主机(基于域名)"></a>nginx的虚拟主机(基于域名)</h3><ul>
<li><p>提前准备好两个网站的域名，并且规划好两个网站网页存放目录</p>
</li>
<li><p>在Nginx主配置文件中并列编写两个server标签，并分别写好各自信息</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> 			<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>		blog.atguigu.com;</span><br><span class="line">    <span class="attribute">index</span> 			index.html index htm index.php;</span><br><span class="line">    <span class="attribute">root</span> 			html/blog;</span><br><span class="line">    <span class="attribute">access_log</span>		logs/blog-access.log main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>		bbs.atguigu.com;</span><br><span class="line">    <span class="attribute">index</span> 			index.html index.htm index.php;</span><br><span class="line">    <span class="attribute">root</span>			html/bbs;</span><br><span class="line">    <span class="attribute">access_log</span>		logs/bbs-access.log main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别访问两个不同的域名验证结果</p>
</li>
</ul>
<h3 id="nginx的反向代理"><a href="#nginx的反向代理" class="headerlink" title="nginx的反向代理"></a>nginx的反向代理</h3><p>代理：找别人代替你去完成一件你完成不成的事(代购)，代理的对象是客户端</p>
<p>反向代理：替成厂家卖东西的人就叫反向代理(烟酒代理)，代理的对象是服务器端</p>
<ul>
<li><p>在另外一台机器上安装apache，启动并填写测试页面</p>
</li>
<li><p>在nginx服务器的配置文件中添加（写在某一个网站的server标签内）</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.88.100:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启nginx，并使用客户端访问测试</p>
</li>
</ul>
<h3 id="负载调度-负载均衡"><a href="#负载调度-负载均衡" class="headerlink" title="负载调度(负载均衡)"></a>负载调度(负载均衡)</h3><p>负载均衡（Load Balance）其意思就是将任务分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其他关键任务服务器等，从而共同完成工作任务。</p>
<ul>
<li><p>使用默认的rr轮询算法，修改nginx配置文件</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bbs &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.88.100:80</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.88.200:80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>		http://bbs;			<span class="comment"># 添加反向代理，代理地址填写upstream声明的名字</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;		<span class="comment"># 重写请求头部，保证网站所有页面都可访问成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启并设置两台88.100和88.200的主机</p>
<p>安装apache并设置不同的index.html页面内容(设置不同页面是为了看实验效果)</p>
</li>
<li><p>重启nginx，并使用客户端访问测试</p>
</li>
</ul>
<p>rr算法实现加权轮询</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bbs &#123;</span><br><span class="line">    <span class="attribute">server</span>	<span class="number">192.168.88.100:80</span> weight=<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">server</span>	<span class="number">192.168.88.200:80</span> weight=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nginx实现https（证书-rewrite）"><a href="#nginx实现https（证书-rewrite）" class="headerlink" title="nginx实现https（证书+rewrite）"></a>nginx实现https（证书+rewrite）</h3><ul>
<li><p>安装nginx时，需要将–with-http_ssl_module模块开启</p>
</li>
<li><p>在对应要进行加密的server标签中添加以下内容开启SSL</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="attribute">ssl</span>							<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>				/usr/local/nginx/conf/ssl/atguigu.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>			/usr/local/nginx/conf/ssl/atguigu.key;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>			<span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> 				TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>	<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> 				<span class="string">&quot;......&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成证书和密钥文件</p>
</li>
<li><p>设置http自动跳转https功能</p>
<p>原有的server标签修改监听端口</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="attribute">listen</span>	<span class="number">443</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增以下server标签(利用虚拟主机+rewrite的功能)</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>		bbs.atguigu.com;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://bbs.atguigu.com permancent;</span><br><span class="line">    <span class="attribute">root</span>			html;</span><br><span class="line">    <span class="attribute">index</span>			index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启nginx，并测试</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/03/12/nginx%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/12/nginx%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">nginx原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-12 06:03:50" itemprop="dateCreated datePublished" datetime="2025-03-12T06:03:50+08:00">2025-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-13 17:55:12" itemprop="dateModified" datetime="2025-03-13T17:55:12+08:00">2025-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/" itemprop="url" rel="index"><span itemprop="name">Nginx</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Nginx概述"><a href="#Nginx概述" class="headerlink" title="Nginx概述"></a>Nginx概述</h2><p>Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔、赛索耶夫为俄罗斯访问第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>
<p>Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件(IMAP&#x2F;POP3)代理服务器，在BSD-like协议下发行。其特点是占有内存少，并发能力强。</p>
<h2 id="Nginx工作原理"><a href="#Nginx工作原理" class="headerlink" title="Nginx工作原理"></a>Nginx工作原理</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步与异步的重点在消息通知的方式上，也就是调用结果的通知方式不同。</p>
<p>同步：当一个同步调用发出去后，调用者要一直等待调用的结果通知后，才能进行后续的执行。</p>
<p>异步：当一个异步调用发出去后，调用者不必一直等待调用结果的返回，异步调用要想获得结果，一般有两种方式：</p>
<ul>
<li>主动轮询异步调用的结果；</li>
<li>被调用方通过callback(回调通知)来通知调用方调用结果。</li>
</ul>
<p>实例解释：</p>
<p>同步取快递：小明收到快递将送达的短信，在楼下一直等到快递送达。</p>
<p>异步取快递：小时收到快递将送达的短信，快递到楼下后，小明再下楼去取。</p>
<p>异步取快递，小明知道快递到达楼下有两种方式：</p>
<ul>
<li>不停的电话问快递小哥到了没有，即主动轮询；</li>
<li>快递小哥到楼下后，打电话通知小明，然后小明下楼取快递，既定回调通知。</li>
</ul>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞的重点在于进&#x2F;线程等待消息时候的行为，也就是在等待消息的时候，当前进&#x2F;线程是挂起状态，还是非挂起状态。</p>
<p>阻塞：调用在发出去后，在消息返回之前，当前进&#x2F;线程会被挂起，直到有消息返回，当前进&#x2F;线程才会被激活。</p>
<p>非阻塞：调用在发出去后，不会阻塞当前进&#x2F;线程，而会立即返回。</p>
<p>同步与异步，重点在于消息通知的方式；阻塞与非阻塞，重点在于等消息时候的行为。所以，就出现了四种重合方式：</p>
<ul>
<li><p>同步阻塞</p>
<p>小明收到信息后，啥都不干，等快递。</p>
</li>
<li><p>同步非阻塞</p>
<p>小明收到信息后，边刷微博，边等着取快递。</p>
</li>
<li><p>异步阻塞</p>
<p>小明收到信息后，啥都不干，一直等着快递员通知他取快递。</p>
</li>
<li><p>异步非阻塞</p>
<p>小明收到信息后，边刷着微博，边等快递员通知他取快递。</p>
</li>
</ul>
<p>大部分程序的I&#x2F;O模型都是同步阻塞的，单个进程每次只在一个文件描述符上执行I&#x2F;O操作，每次I&#x2F;O系统调用都会阻塞，直到完成数据传输，传统的服务器采用的就是同步阻塞的多进程模型。一个server采用一个进程负责一个request的方式，一个进程负责一个request，直到会话结束。进程数就是并发数，而操作系统支持的进程数是有限的，且进程数越多，调度的开销也越大，因此无法面对高并发。</p>
<h3 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h3><p>Nginx采用了异步非阻塞的方式工作。先了解一下I&#x2F;O多路复用中的epoll模型：</p>
<p>当连接有I&#x2F;O事件产生的时候，epoll就会去告诉进程哪个连接有I&#x2F;O事件产生，然后进程就去处理这个事件。</p>
<p>例如：小明家楼下有一个收发室，每次有快递到了，门卫就先代收并做了标记；然后通知小明去取送给小明的快递。</p>
<h3 id="Nginx工作原理-1"><a href="#Nginx工作原理-1" class="headerlink" title="Nginx工作原理"></a>Nginx工作原理</h3><p>Nginx配置use epoll后，以异步非阻塞方式工作，能够轻松处理百万级的并发连接。</p>
<p>处理过程：</p>
<p>每进来一个request，会有一个worker进程去处理。但不是全程的处理，处理到可能发生阻塞的地方。比如向后端服务器转发request，并等待请求返回。那么，这个处理的worker不会这么傻等着，他会在发送完请求后，注册一个事件：“如果后端服务器返回了，告诉我一声，我再接着干”。于是他就休息去了。此时如果再有新的request进来，他就可以很快再按这种方式处理。而一旦后端服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。通过这种快速处理，快速释放请求的方式，达到同样的配置可以处理更大并发量的目的。</p>
<h2 id="Nginx工作模式"><a href="#Nginx工作模式" class="headerlink" title="Nginx工作模式"></a>Nginx工作模式</h2><h3 id="master-worker模式"><a href="#master-worker模式" class="headerlink" title="master-worker模式"></a>master-worker模式</h3><p>该模式下，nginx启动成功后，会有一个master进程和至少一个worker进程。master进程负责处理系统信号，加载配置，管理worker进程(启动，杀死，监控，发送消息&#x2F;信号等)。worker进程负责处理具体的业务逻辑，也就是说，对外部来说，真正提供服务的是worker进程。生产环境下一般使用这种模式，这个模式有以下优点：</p>
<ul>
<li>稳定性高，只要还有worker进程存活，就能够提供服务，并且一个worker进程挂掉master进程会立即启动一个新的worker进程，保证worker进程数量不变，降低服务中断的概率。</li>
<li>配合linux的cpu亲和性配置，可以充分利用多核cpu的优势，提升性能。</li>
<li>处理信号&#x2F;配置重新加载&#x2F;升级时可以做到尽可能少或者不中断服务(热重启)。</li>
</ul>
<h3 id="单进程模式"><a href="#单进程模式" class="headerlink" title="单进程模式"></a>单进程模式</h3><p>单进程模式下，nginx启动后只有一个进程，nginx的所有工作都由这个进程负责。由于只有一个进程，因此可以很方便地利用gdb等工具进行调试。该模式下不支持nginx的平滑升级功能，任何的信号处理都可能造成服务中断，并且由于是单进程，进程挂掉后，在没有外部监控的情况下，无法重启服务。因此，该模式一般只在开发阶段和调试时使用，生产环境下不会使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/03/07/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/07/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">日志管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-07 19:48:29" itemprop="dateCreated datePublished" datetime="2025-03-07T19:48:29+08:00">2025-03-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-10 19:51:58" itemprop="dateModified" datetime="2025-03-10T19:51:58+08:00">2025-03-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="日志简介"><a href="#日志简介" class="headerlink" title="日志简介"></a>日志简介</h2><h3 id="日志相关服务"><a href="#日志相关服务" class="headerlink" title="日志相关服务"></a>日志相关服务</h3><p>在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。Redhat认为syslogd已经不能满足在工作中的需求，rsyslogd相比syslogd具有一些新的特点：</p>
<ul>
<li>基于TCP网络协议传输日志信息；</li>
<li>更安全的网络传输方式；</li>
<li>有日志消息的及时分析框架；</li>
<li>后台数据库；</li>
<li>配置文件中可以写简单的逻辑判断；</li>
<li>与syslog配置文件相兼容。</li>
</ul>
<h3 id="系统中常见的日志文件"><a href="#系统中常见的日志文件" class="headerlink" title="系统中常见的日志文件"></a>系统中常见的日志文件</h3><table>
<thead>
<tr>
<th>日志文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;var&#x2F;log&#x2F;cron</td>
<td>记录了系统定时任务相关的日志。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;cups&#x2F;</td>
<td>记录打印信息的日志。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;dmesg</td>
<td>记录了系统在开机时内核自检的信息。也可以使用dmesg命令直接查看内核自检信息。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;btmp</td>
<td>记录错误登录的日志。这个文件是二进制文件，不能直接vim查看，而要使用lastb命令查看。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;lastlog</td>
<td>记录系统中所有用户最后一次登录时间的日志。这个文件也是二进制文件，不能直接vim查看，而要使用lastlog命令查看。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;mailog</td>
<td>记录邮件信息。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;message</td>
<td>记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;secure</td>
<td>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录。比如说系统的登录，ssh的登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;wtmp</td>
<td>永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vim，而需要使用last命令来查看。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;run&#x2F;utmp</td>
<td>记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样这个文件不能直接vim，而要使用w,who,users等命令来查询。</td>
</tr>
</tbody></table>
<p>除了系统默认的日志之外，采用RPM方式安装的系统服务也会默认把日志记录在&#x2F;var&#x2F;log&#x2F;目录中(源码包安装的服务日志是在源码包指定目录中)。不过这些日志不是由rsyslogd服务来记录和管理的，而是各个服务器使用自己的日志管理文档来记录自身日志。</p>
<table>
<thead>
<tr>
<th>日志文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;var&#x2F;log&#x2F;httpd&#x2F;</td>
<td>RPM包安装的apache服务的默认日志目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;mail&#x2F;</td>
<td>RPM包安装的邮件服务的额外日志目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;samba&#x2F;</td>
<td>RPM包安装的samba服务的日志目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;sssd&#x2F;</td>
<td>守护进程安全服务目录</td>
</tr>
</tbody></table>
<h2 id="日志服务-rsyslogd"><a href="#日志服务-rsyslogd" class="headerlink" title="日志服务(rsyslogd)"></a>日志服务(rsyslogd)</h2><h3 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h3><p>只要是由日志服务rsyslogd记录的日志文件，他们的格式是一样的。基本日志格式包含以下四列：</p>
<ul>
<li>事件产生的时间</li>
<li>发生事件的服务器的主机名</li>
<li>产生事件的服务名或程序名</li>
<li>事件的具体信息</li>
</ul>
<h3 id="rsyslogd服务的配置文件"><a href="#rsyslogd服务的配置文件" class="headerlink" title="rsyslogd服务的配置文件"></a>rsyslogd服务的配置文件</h3><h4 id="etc-rsyslog-d-50-default-conf"><a href="#etc-rsyslog-d-50-default-conf" class="headerlink" title="&#x2F;etc&#x2F;rsyslog.d&#x2F;50-default.conf"></a>&#x2F;etc&#x2F;rsyslog.d&#x2F;50-default.conf</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auth,authpriv.*			/var/log/auth.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务名称[连接符号]日志等级    日志记录位置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">认证相关服务.所有日志等级     记录在/var/log/auth.log日志中</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>服务名称</p>
<p>我们首先需要确定rsyslogd服务可以识别哪些服务的日志，也可以理解为以下这些服务委托了rsyslogd服务来代为管理日志。这些服务如下表所示：</p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>auth（LOG_AUTH）</td>
<td>安全和认证相关消息(不推荐使用authpriv替代)</td>
</tr>
<tr>
<td>authpriv（LOG_AUTHPRIV）</td>
<td>安全和认证相关消息（私有的）</td>
</tr>
<tr>
<td>cron（LOG_CRON）</td>
<td>系统定时任务cront和at产生的日志</td>
</tr>
<tr>
<td>daemon（LOG_DAEMON）</td>
<td>和各个守护进程相关的日志</td>
</tr>
<tr>
<td>ftp（LOG_FTP）</td>
<td>ftp守护进程产生的日志</td>
</tr>
<tr>
<td>kern（LOG_KERN）</td>
<td>内核产生的日志（不是用户进程产生的）</td>
</tr>
<tr>
<td>local0-local7（LOG_LOCAL0-7）</td>
<td>为本地使用预留的服务</td>
</tr>
<tr>
<td>lpr（LOG_LPR）</td>
<td>打印产生的日志</td>
</tr>
<tr>
<td>Mail（LOG_MAIL）</td>
<td>邮件收发信息</td>
</tr>
<tr>
<td>news（LOG_NEWS）</td>
<td>与新闻服务器相关的日志</td>
</tr>
<tr>
<td>syslog（LOG_SYSLOG）</td>
<td>有syslogd服务产生的日志信息（虽然服务名称已经改为rsyslogd，但是很多配置都还是沿用了syslogd的，这里并没有修改服务名）。</td>
</tr>
<tr>
<td>user（LOG_USER）</td>
<td>用户等级类别的日志信息</td>
</tr>
<tr>
<td>uucp（LOG_UUCP）</td>
<td>uucp子系统的日志信息，uucp是早期linux系统进行数据传递的协议，后来也常用在新闻组服务中</td>
</tr>
</tbody></table>
</li>
<li><p>连接符号</p>
<p>日志服务连接日志等级的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志服务[连接符号]日志等级			日志记录位置</span><br></pre></td></tr></table></figure>

<p>在这里连接符号可以识别为：</p>
<ul>
<li>“.”代表只要比后面的等级高的（包含该等级）日志都记录下来。比如：”cron.info”代表cron服务产生的日志只要日志等级大于等于info级别，就记录。</li>
<li>“.&#x3D;”代表只记录所需等级的日志，其他等级的都不记录。比如：“*.&#x3D;emerg”代表任何日志服务产生的日志，只要等级是emerg等级就记录。这种用法极少见，了解就好。</li>
<li>“.!”代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。</li>
</ul>
</li>
<li><p>日志等级</p>
<table>
<thead>
<tr>
<th>等级名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>debug（LOG_DEBUG）</td>
<td>一般的调试信息说明</td>
</tr>
<tr>
<td>info（LOG_INFO）</td>
<td>基本的通知信息</td>
</tr>
<tr>
<td>notice（LOG_NOTICE）</td>
<td>普通信息，但是有一定的重要性</td>
</tr>
<tr>
<td>warning（LOG_WARNING）</td>
<td>警告信息，但是还不会影响到服务或系统的运行</td>
</tr>
<tr>
<td>err（LOG_ERR）</td>
<td>错误信息，一般达到err等级的信息以及可以影响到服务或系统的运行了</td>
</tr>
<tr>
<td>crit（LOG_CRIT）</td>
<td>临界状况信息，比err等级还要严重</td>
</tr>
<tr>
<td>alert（LOG_ALERT）</td>
<td>警告状态信息，比crit还要严重。必须立即采取行动</td>
</tr>
<tr>
<td>emerg（LOG_EMERG）</td>
<td>疼痛等级信息，系统已经无法使用了</td>
</tr>
<tr>
<td>*</td>
<td>代表所有日志等级，比如：“authpriv.*”代表authpriv认证信息服务产生的日志，所有的日志等级都记录</td>
</tr>
</tbody></table>
<p>日志等这里还可以识别”none”，如果日志等级是none，就说明忽略这个日志服务，该服务的所有日志都不再记录。</p>
</li>
<li><p>日志记录位置</p>
<p>日志记录位置就是当前日志输出到哪个日志文件中保存，当然也可以把日志输出到印机打印，或者输出到远程日志服务器上（当然日志服务器要允许接收才行）。日志的记录位置也是固定的：</p>
<ul>
<li><p>日志文件的绝对路径</p>
<p>这是最常见的日志保存方法，如“&#x2F;var&#x2F;log&#x2F;secure”就是保存系统验证和授权信息日志的。</p>
</li>
<li><p>系统设备文件</p>
<p>如“&#x2F;dev&#x2F;lp0”代表第一台打印机，如果日志保存位置是打印机设备的话，当有日志时就会在打印机打印（不太符合可持续发展战略）。</p>
</li>
<li><p>转发给远程主机</p>
<p>因为可以选择使用TCP协议和UDP协议传输日志信息，所以有两种发送格式。如使用“@192.168.0.210:514”，就会把日志内容使用UDP协议发送到192.168.0.210的UDP 514端口上；如果使用”@@192.168.0.210:514”就会把日志内容使用TCP协议发送到192.168.0.210的TCP 514端口上，其中514是日志服务默认端口。当然只要192.168.0.210同意接收此日志，就可以把日志内容保存在日志服务器上。</p>
</li>
<li><p>用户名</p>
<p>如“root”，就会把日志发送给root用户，当然root要在线，否则就收不到日志信息了。发送日志给用户时，可以使用“*”代表发送给所有在线用户，如“mail.* *”就会把mail服务产生的所有级别的日志发送给所有在线用户。如果需要把日志发送给多个在线用户，用户名之间用“,”分隔。</p>
</li>
</ul>
</li>
</ul>
<p>忽略或丢弃日志。如果接受日志的对象是“~”，代表这个日志不会记录，而被直接丢弃。如“local3.* ~”代表忽略local3服务类型所有的日志都不记录。</p>
<h4 id="etc-rsyslog-conf配置文件内容"><a href="#etc-rsyslog-conf配置文件内容" class="headerlink" title="&#x2F;etc&#x2F;rsyslog.conf配置文件内容"></a>&#x2F;etc&#x2F;rsyslog.conf配置文件内容</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rsyslog.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/rsyslog.conf configuration file <span class="keyword">for</span> rsyslog</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># For more information install rsyslog-doc and see</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/share/doc/rsyslog-doc/html/configuration/index.html</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default logging rules can be found in /etc/rsyslog.d/50-default.conf</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载模块</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### MODULES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载imuxsock模块，为本地系统登录提供支持</span></span><br><span class="line">module(load=&quot;imuxsock&quot;) # provides support for local system logging</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载immark模块，提供标记信息的能力</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">module(load=<span class="string">&quot;immark&quot;</span>)  <span class="comment"># provides --MARK-- message capability</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载UDP模块，允许使用UDP的514端口接收采用UDP协议转发的日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides UDP syslog reception</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">module(load=<span class="string">&quot;imudp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imudp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载TCP模块，允许使用TCP的514端口接收采用TCP协议转发的日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides TCP syslog reception</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">module(load=<span class="string">&quot;imtcp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imtcp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides kernel logging support and <span class="built_in">enable</span> non-kernel klog messages</span></span><br><span class="line">module(load=&quot;imklog&quot; permitnonkernelfacility=&quot;on&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义全局设置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### GLOBAL DIRECTIVES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Filter duplicated messages</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">RepeatedMsgReduction on</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Set the default permissions for all log files.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$FileOwner</span> syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileGroup adm</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileCreateMode 0640</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DirCreateMode 0755</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Umask 0022</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToUser syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToGroup syslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Where to place spool and state files</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Include all config files in /etc/rsyslog.d/</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 包含/etc/rsyslog.d/目录中所有的&quot;.conf&quot;子配置文件。也就是说这个目录中的所有子配置文件也同时生效</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IncludeConfig /etc/rsyslog.d/*.conf</span></span><br></pre></td></tr></table></figure>

<h3 id="定义自己的日志"><a href="#定义自己的日志" class="headerlink" title="定义自己的日志"></a>定义自己的日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rsyslog.d/60-custom.conf</span><br><span class="line">*.crit				/var/log/alert.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把所有服务的<span class="string">&quot;临界点&quot;</span>以上的错误都保存在/var/log/alert.log日志中</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# systemctl restart syslog</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll /var/log/alert.log</span><br></pre></td></tr></table></figure>



<h2 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h2><h3 id="日志文件的命名规则"><a href="#日志文件的命名规则" class="headerlink" title="日志文件的命名规则"></a>日志文件的命名规则</h3><p>日志轮替最主要的作用就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除。那么旧的日志文件改名之后，如何命名呢？主要依靠&#x2F;etc&#x2F;logrotate.conf配置文件中“dateext”参数：</p>
<ul>
<li>如果配置文件中拥有”dateext”参数，那么日志会用日期来作为日志文件的后缀，例如“secure-20180605”。这样的话日志文件名不会重叠，所以也就不需要日志文件的改名，只需要保存指定的日志个数，删除多余的日志文件即可。</li>
<li>如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为”secure.1”，然后新建”secure”日志，用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为”secure.1”，然后也会新建”secure”日志，用来保存新的日志，以此类推。</li>
</ul>
<h3 id="logrotate配置文件"><a href="#logrotate配置文件" class="headerlink" title="logrotate配置文件"></a>logrotate配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/logrotate.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see <span class="string">&quot;man logrotate&quot;</span> <span class="keyword">for</span> details</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">global options <span class="keyword">do</span> not affect preceding include directives</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每周对日志文件进行一次轮替</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rotate <span class="built_in">log</span> files weekly</span></span><br><span class="line">weekly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use the adm group by default, since this is the owning group</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">of /var/log/.</span></span><br><span class="line">su root adm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存4个日志文件，也就是说如果进行了5次日志轮替，就会删除第一个备份日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">keep 4 weeks worth of backlogs</span></span><br><span class="line">rotate 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在日志轮替时，自动创建新的日志文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create new (empty) <span class="built_in">log</span> files after rotating old ones</span></span><br><span class="line">create</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用日期作为日志轮替文件的后缀</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use <span class="built_in">date</span> as a suffix of the rotated file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">dateext</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志文件是否压缩，如果取消注释，则日志会在转储的同时进行压缩</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment this <span class="keyword">if</span> you want your <span class="built_in">log</span> files compressed</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">compress</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含/etc/logrotate.d/目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来，进行日志轮替。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">packages drop <span class="built_in">log</span> rotation information into this directory</span></span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">system-specific logs may also be configured here.</span> </span><br></pre></td></tr></table></figure>

<p>以上日志配置为默认配置，如果需要轮替的日志没有设定独立的参数，那么都会遵守以上参数。如果轮替日志配置了独立参数，那么独立参数优先级更高。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/logrotate.d/wtmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">no packages own wtmp -- we<span class="string">&#x27;ll rotate it here</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">以下参数仅对此目录有效</span></span></span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line">    missingok</span><br><span class="line">    # 每月对日志文件进行一次轮替</span><br><span class="line">    monthly</span><br><span class="line">    # 建立的新日志文件,权限是0664,所有者是root，所属组是utmp组</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    # 日志文件最小轮替大小是1MB。也就是日志一定要超过1MB才会轮替，否则就算时间达到一个月，也不进行日志转储</span><br><span class="line">    minsize 1M</span><br><span class="line">    # 仅保留一个日志备份。也就是只有wtmp和wtmp.1日志保留而已</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>logrotate配置文件的主要参数，通过如下表说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>daily</td>
<td>日志的轮替周期是每天</td>
</tr>
<tr>
<td>weekly</td>
<td>日志的轮替周期是每周</td>
</tr>
<tr>
<td>monthly</td>
<td>日志的轮替周期是每月</td>
</tr>
<tr>
<td>rotate 数字</td>
<td>保留的日志文件的个数。0指没有备份</td>
</tr>
<tr>
<td>compress</td>
<td>日志轮替时，旧的日志进行压缩</td>
</tr>
<tr>
<td>create mode owner group</td>
<td>建立新日志，同时指定新日志的权限与所有者和所属组。如create 0600 root utmp</td>
</tr>
<tr>
<td>mail address</td>
<td>当日志轮替时，输出内容通过邮件发送到指定的邮件地址。如mail <a href="mailto:&#x61;&#97;&#97;&#x40;&#49;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;">aaa@163.com</a></td>
</tr>
<tr>
<td>missingok</td>
<td>如果日志不存在，则忽略该日志的警告信息</td>
</tr>
<tr>
<td>notifempty</td>
<td>如果日志为空文件，则不进行日志轮替</td>
</tr>
<tr>
<td>minsize 大小</td>
<td>日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替</td>
</tr>
<tr>
<td>size 大小</td>
<td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。如size 100k</td>
</tr>
<tr>
<td>dateext</td>
<td>使用日期作为日志轮替文件的后缀。如secure-20180605</td>
</tr>
<tr>
<td>sharedscripts</td>
<td>在此关键字之后的脚本只执行一次</td>
</tr>
<tr>
<td>prerotate&#x2F;endscript</td>
<td>在日志轮替之前执行脚本命令。endscript标示prerotate脚本结束。</td>
</tr>
<tr>
<td>postrotate&#x2F;endscript</td>
<td>在日志轮替之后执行脚本命令。endscript标示postrotate脚本结束。</td>
</tr>
</tbody></table>
<p>这些参数中较为不好理解的应该就是prerotate&#x2F;endscript和postrotate&#x2F;endscript参数了。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/var/log/httpd/error.log &#123;</span><br><span class="line">    rotate 5</span><br><span class="line">    mail www@my.org</span><br><span class="line">    size 100k</span><br><span class="line">    # 以下脚本只执行一次</span><br><span class="line">    sharedscripts</span><br><span class="line">    # 在日志轮替结束之后，执行以下脚本</span><br><span class="line">    postrotate</span><br><span class="line">    	# 重启apache服务</span><br><span class="line">        /usr/bin/killall -HUP httpd</span><br><span class="line">    endscript</span><br><span class="line">    # 脚本结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prerotate和postrotate主要用于在日志轮替的同时，执行指定的脚本，一般用于日志轮替之后重启服务。这里强调，如果你的日志是写入rsyslog服务的配置文件的，那么把新日志加入logrotate后，一定要重启rsyslog服务，否则你会发现虽然新日志建立了，但是数据还是写入了旧的日志当中。那是因为虽然logrotate知道日志轮替了，但是rsyslog服务并不知道。同理，如果你的日志不是被rsyslog管理，如源码包安装的Apache、Nginx等服务，则需要重启Apache或Nginx服务，否则日志也不能正常轮替。</p>
<h3 id="把自己的日志加入日志轮替"><a href="#把自己的日志加入日志轮替" class="headerlink" title="把自己的日志加入日志轮替"></a>把自己的日志加入日志轮替</h3><p>1）方法一</p>
<p>直接在&#x2F;etc&#x2F;logrotate.conf配置文件中写入该日志的轮替策略，从而把日志加入轮替。</p>
<p>2）方法二</p>
<p>在&#x2F;etc&#x2F;logrotate.d&#x2F;目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可以把日志加入轮替。推荐使用此方法，因为系统中需要轮替的日志非常多，如果全部直接写入&#x2F;etc&#x2F;logrotate.conf配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。</p>
<p>举个例子，如果需要把Nginx服务的日志加入日志轮替，则也需要重启Nginx服务。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/date/logs/nginx/access/access.log /date/logs/nginx/access/default.log &#123;</span><br><span class="line">	daily</span><br><span class="line">	rotate 15</span><br><span class="line">	sharedscripts</span><br><span class="line">	postrotate</span><br><span class="line">		# 重启rsyslog服务</span><br><span class="line">		/bin/kill -HUP $(/bin/cat /var/run/syslogd.pid) &amp;&gt;/dev/null</span><br><span class="line">		# 重启nginx服务</span><br><span class="line">		/bin/kill -HUP $(/bin/cat /usr/local/nginx/logs/nginx.pid) &amp;&gt;/dev/null</span><br><span class="line">	endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="logrotate命令"><a href="#logrotate命令" class="headerlink" title="logrotate命令"></a>logrotate命令</h3><p>日志轮替之所以可以在指定的时间备份日志，其实也要依赖系统定时任务。如果大家还记录&#x2F;etc&#x2F;cron&#x2F;daily&#x2F;目录，就会发现这个目录中是有logrotate文件，logrotate通过这个文件依赖定时任务执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# logrotate [选项] 配置文件名</span><br><span class="line">选项：</span><br><span class="line">	如果此命令没有选项，则会按照配置文件中的条件进行日志轮替</span><br><span class="line">	-v:		显示日志轮替过程。加了-v选项，会显示日志的轮替的过程</span><br><span class="line">	-f:		强制进行日志轮替。不管日志轮替的条件是否已经符合，强制配置文件中所有的日志进行轮替</span><br></pre></td></tr></table></figure>

<p>执行logrotate命令，并查看下执行过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# logrotate -v /etc/logrotate.conf</span><br><span class="line">...</span><br><span class="line">rotating pattern: /var/log/wtmp  monthly (1 rotations)</span><br><span class="line">empty log files are rotated, only log files &gt;= 1048576 bytes are rotated, old logs are removed</span><br><span class="line">switching euid from 0 to 0 and egid from 0 to 4 (pid 39834)</span><br><span class="line">considering log /var/log/wtmp</span><br><span class="line">  Now: 2025-03-10 19:45</span><br><span class="line">  Last rotated at 2024-08-26 09:05</span><br><span class="line">  log does not need rotating (&#x27;minsize&#x27; directive is used and the log size is smaller than the minsize value)</span><br><span class="line">switching euid from 0 to 0 and egid from 4 to 0 (pid 39834)</span><br></pre></td></tr></table></figure>

<p>强制进行一次日志轮替，看看有什么效果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# logrotate -vf /etc/logrotate.conf</span><br><span class="line">...</span><br><span class="line">rotating pattern: /var/log/wtmp  forced from command line (1 rotations)</span><br><span class="line">empty log files are rotated, only log files &gt;= 1048576 bytes are rotated, old logs are removed</span><br><span class="line">switching euid from 0 to 0 and egid from 0 to 4 (pid 40773)</span><br><span class="line">considering log /var/log/wtmp</span><br><span class="line">  Now: 2025-03-10 19:48</span><br><span class="line">  Last rotated at 2024-08-26 09:05</span><br><span class="line">  log needs rotating                                 # 日志需要轮替</span><br><span class="line">rotating log /var/log/wtmp, log-&gt;rotateCount is 1</span><br><span class="line">dateext suffix &#x27;-20250310&#x27;                           # 提取日期参数</span><br><span class="line">glob pattern &#x27;-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]&#x27;</span><br><span class="line">renaming /var/log/wtmp.1 to /var/log/wtmp.2 (rotatecount 1, logstart 1, i 1), </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">旧的日志被重命名</span></span><br><span class="line">renaming /var/log/wtmp to /var/log/wtmp.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新日志文件</span></span><br><span class="line">creating new /var/log/wtmp mode = 0664 uid = 0 gid = 43</span><br><span class="line">removing old log /var/log/wtmp.2</span><br><span class="line">switching euid from 0 to 0 and egid from 4 to 0 (pid 40773)</span><br></pre></td></tr></table></figure>

<p>logrotate命令使用“-f”选项之后，就不管日志是否已经符合了日志轮替条件，而强制把所有的日志都进行了轮替。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/03/06/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/06/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" class="post-title-link" itemprop="url">Linux操作系统性能调优</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-06 23:13:48" itemprop="dateCreated datePublished" datetime="2025-03-06T23:13:48+08:00">2025-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-07 00:44:00" itemprop="dateModified" datetime="2025-03-07T00:44:00+08:00">2025-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CPU调优"><a href="#CPU调优" class="headerlink" title="CPU调优"></a>CPU调优</h2><p>目标：最大化CPU利用率，减少上下文切换和延迟。</p>
<h3 id="调整CPU频率策略"><a href="#调整CPU频率策略" class="headerlink" title="调整CPU频率策略"></a>调整CPU频率策略</h3><p>将CPU频率设置为’performance’模式，确保CPU始终以最高频率运行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cpufrequtils工具</span></span><br><span class="line">sudo apt install cpufrequtils</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置为performance模式</span></span><br><span class="line">sudo cpufreq-set -g performance</span><br></pre></td></tr></table></figure>



<h3 id="绑定进程到特定CPU核心"><a href="#绑定进程到特定CPU核心" class="headerlink" title="绑定进程到特定CPU核心"></a>绑定进程到特定CPU核心</h3><p>使用’taskset’将关键进程绑定到特定CPU核心，减少上下文切换。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskset -cp 0,1 &lt;pid&gt;</span><br></pre></td></tr></table></figure>



<h3 id="优化中断处理"><a href="#优化中断处理" class="headerlink" title="优化中断处理"></a>优化中断处理</h3><p>将中断处理分散到多个CPU核心，避免单个CPU过载。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 2 | sudo tree /proc/irq/&lt;irq_number&gt;/smp_affinity</span><br></pre></td></tr></table></figure>



<h2 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h2><p>目标：减少内存碎片化，降低交换分区使用频率。</p>
<h3 id="调整Swappiness"><a href="#调整Swappiness" class="headerlink" title="调整Swappiness"></a>调整Swappiness</h3><p>降低swappiness值，减少系统使用交换分区（swap）的频率。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时生效</span></span><br><span class="line">sudo sysctl vm.swappiness=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久生效,在/etc/sysctl.conf下添加</span></span><br><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure>

<p>在读取swap交换分区中的数据时，由于数据需要从磁盘中读取，因此可能会比物理内存中读取慢得多。</p>
<p>Linux中的swap交换分区是类似于Windows的虚拟内存，它的作用是在物理内存使用完之后，将磁盘空间(也就是swap分区)虚拟成内存来使用。它的功能就是在内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出来让别的程序运行。</p>
<h3 id="调整内存分配策略"><a href="#调整内存分配策略" class="headerlink" title="调整内存分配策略"></a>调整内存分配策略</h3><p>设置vm.overcommit_memory为1，允许系统超额分配内存。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl vm.overcommit_memory=1</span><br></pre></td></tr></table></figure>

<p>可选值：</p>
<ul>
<li>0：表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</li>
<li>1：表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</li>
<li>2：表示内核允许分配超过所有物理内存和交换空间总和的内存。</li>
</ul>
<p>Linux对大部分申请的内存的请求都回复“yes”，以便能跑更多更大的程序。因为申请内存后，并不会马上使用内存。这种技术叫做overcommit。当Linux发现内存不足时，会发生OOM killer(OOM&#x3D;out-of-memory)。它会选择杀死一些进程(用户态进程，不是内核线程)，以便释放内存。</p>
<h3 id="调整透明大页-THP"><a href="#调整透明大页-THP" class="headerlink" title="调整透明大页(THP)"></a>调整透明大页(THP)</h3><p>对于某些工作负载(如数据库)，禁用透明大页可能更有利。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo never | sudo tree /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>



<h2 id="磁盘I-O调优"><a href="#磁盘I-O调优" class="headerlink" title="磁盘I&#x2F;O调优"></a>磁盘I&#x2F;O调优</h2><p>目标：优化磁盘读写性能，减少I&#x2F;O延迟。</p>
<h3 id="选择合适的I-O调度器"><a href="#选择合适的I-O调度器" class="headerlink" title="选择合适的I&#x2F;O调度器"></a>选择合适的I&#x2F;O调度器</h3><p>对于SSD，建议使用noop或deadline调度器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo noop | sudo tree /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>

<p>对于HDD，建议使用deadline调度器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo deadline | sudo tree /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>



<h3 id="调整文件系统挂载选项"><a href="#调整文件系统挂载选项" class="headerlink" title="调整文件系统挂载选项"></a>调整文件系统挂载选项</h3><p>对于ext4文件系统，启用noatime和data&#x3D;writeback选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o remount,noatime,data=writeback /</span><br></pre></td></tr></table></figure>

<p>默认的方式下linux会把文件访问的时间(atime)做记录，因为系统运行的时候要访问大量文件，如果能减少一些动作(比如减少时间戳的记录次数等)将会显著提高磁盘IO效率、提升文件系统的性能。</p>
<p>data&#x3D;ordered模式是ext4文件系统默认日志格式。在data&#x3D;writeback模式下，当元数据提交到日志后，data可以直接被提交到磁盘。即会做元数据日志，数据不做日志，并且不保证数据比元数据先落盘。writeback是ext4提供的性能最好的模式。</p>
<h3 id="优化磁盘队列深度"><a href="#优化磁盘队列深度" class="headerlink" title="优化磁盘队列深度"></a>优化磁盘队列深度</h3><p>增加磁盘队列深度以提高I&#x2F;O吞吐量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 256 | sudo tree /sys/block/sdX/queue/nr_requests</span><br></pre></td></tr></table></figure>

<p>队列深度决定了给块设备写I&#x2F;O的最大并发数，对于Linux系统，默认值为128。一般情况下不建议用户修改此参数。当对系统进行极限性能测试时，为了增大主机写I&#x2F;O的压力及I&#x2F;O在队列中被合并的概率，可以适当的增大此参数。</p>
<h2 id="网络调优"><a href="#网络调优" class="headerlink" title="网络调优"></a>网络调优</h2><p>目标：提高网络吞吐量，降低延迟。</p>
<h3 id="调整TCP缓冲区大小"><a href="#调整TCP缓冲区大小" class="headerlink" title="调整TCP缓冲区大小"></a>调整TCP缓冲区大小</h3><p>增加TCP接收和发送缓冲区大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.core.rmem_max=16777216</span><br><span class="line">sudo sysctl -w net.core.wmem_max=16777216</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_rmem=&quot;4096 87380 16777216&quot;</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_wmem=&quot;4096 65536 16777216&quot;</span><br></pre></td></tr></table></figure>



<h3 id="启用TCP快速打开"><a href="#启用TCP快速打开" class="headerlink" title="启用TCP快速打开"></a>启用TCP快速打开</h3><p>减少TCP连接的建立时间。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.tcp_fastopen=3</span><br></pre></td></tr></table></figure>



<h3 id="调整连接队列大小"><a href="#调整连接队列大小" class="headerlink" title="调整连接队列大小"></a>调整连接队列大小</h3><p>增加连接队列大小以应对高并发连接。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w net.core.somaxconn=65535</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_max_syn_backlog=65535</span><br></pre></td></tr></table></figure>



<h2 id="文件系统调优"><a href="#文件系统调优" class="headerlink" title="文件系统调优"></a>文件系统调优</h2><p>目标：提高文件系统性能，减少元数据操作开销。</p>
<h3 id="调整文件描述符限制"><a href="#调整文件描述符限制" class="headerlink" title="调整文件描述符限制"></a>调整文件描述符限制</h3><p>增加系统允许打开的文件描述符数量。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w fs.file-max=100000</span><br><span class="line">ulimit -n 100000</span><br></pre></td></tr></table></figure>



<h3 id="优化inode缓存"><a href="#优化inode缓存" class="headerlink" title="优化inode缓存"></a>优化inode缓存</h3><p>增加inode缓存大小以提高文件系统性能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w vm.vfs_cache_pressure=50</span><br></pre></td></tr></table></figure>



<h2 id="内核参数调优"><a href="#内核参数调优" class="headerlink" title="内核参数调优"></a>内核参数调优</h2><p>目标：优化内核行为，提升系统整体性能。</p>
<h3 id="调整进程调度策略"><a href="#调整进程调度策略" class="headerlink" title="调整进程调度策略"></a>调整进程调度策略</h3><p>对于实时性要求高的任务，使用SCHED_FIFO或SCHED_RR调度策略。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chrt -f -p 99 &lt;pid&gt;</span><br></pre></td></tr></table></figure>



<h3 id="优化虚拟内存管理"><a href="#优化虚拟内存管理" class="headerlink" title="优化虚拟内存管理"></a>优化虚拟内存管理</h3><p>调整vm.dirty_ratio和vm.dirty_background_ratio，控制脏页写回行为。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -w vm.dirty_ratio=10</span><br><span class="line">sudo sysctl -w vm.dirty_background_ratio=5</span><br></pre></td></tr></table></figure>



<h2 id="监控与维护"><a href="#监控与维护" class="headerlink" title="监控与维护"></a>监控与维护</h2><p>目标：持续监控系统性能，及时发现瓶颈。</p>
<h3 id="使用性能监控工具"><a href="#使用性能监控工具" class="headerlink" title="使用性能监控工具"></a>使用性能监控工具</h3><ul>
<li>top、htop：监控CPU和内存的使用情况。</li>
<li>vmstat：监控虚拟内存、CPU和I&#x2F;O状态。</li>
<li>iostat：监控磁盘I&#x2F;O性能。</li>
<li>netstat、ss：监控网络连接状态。</li>
</ul>
<h3 id="定期清理系统"><a href="#定期清理系统" class="headerlink" title="定期清理系统"></a>定期清理系统</h3><ul>
<li>清理不必要的日志文件和缓存。</li>
<li>使用logrotate管理日志文件大小。</li>
</ul>
<h2 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h2><p>目标：充分利用硬件资源</p>
<h3 id="升级硬件"><a href="#升级硬件" class="headerlink" title="升级硬件"></a>升级硬件</h3><ul>
<li>使用SSD替代HDD以提高I&#x2F;O性能。</li>
<li>增加内存容量以减少交换分区的使用。</li>
<li>使用多核CPU以提高并发处理能力。</li>
</ul>
<h2 id="持久化调优配置"><a href="#持久化调优配置" class="headerlink" title="持久化调优配置"></a>持久化调优配置</h2><p>将调优参数写入&#x2F;etc&#x2F;sysctl.conf，确保重启后生效。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness=10</span><br><span class="line">vm.overcommit_memory=1</span><br><span class="line">net.core.somaxconn=65535</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=65535</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/03/05/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/05/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">系统管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-05 17:29:52" itemprop="dateCreated datePublished" datetime="2025-03-05T17:29:52+08:00">2025-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-07 19:45:41" itemprop="dateModified" datetime="2025-03-07T19:45:41+08:00">2025-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h3><p>1）什么是进程</p>
<p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</p>
<p>2）什么是程序</p>
<p>程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。</p>
<p>程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。</p>
<p>进程是正在执行当中的程序。程序被执行时，执行人的权限和属性、以及程序的代码都会被加载如内存，操作系统给这个进程分配一个ID号，称为PID（进程ID）。</p>
<p>3）进程管理的作用</p>
<ul>
<li><p>判断服务器健康状态</p>
<p>运维工程师最主要的工作就是保证服务器安全稳定的运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服务器的CPU占用率、内存占用率过高，就需要人为介入解决问题了。</p>
</li>
<li><p>查看系统中所有的进程</p>
<p>我们需要查看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务，是否有非法服务运行。</p>
</li>
<li><p>杀死进程</p>
<p>这是进程管理中最不常用的手段，当需要停止服务时，会通过正确关闭命令来停止服务（如apache服务可以通过service httpd sotp来关闭）。只有当正确终止进程的手段失效的情况下，才会考虑使用kill命令杀死进程（你不是杀手，不要什么进程都用kill来终止，否则非常容易导致服务器崩溃）。</p>
</li>
</ul>
<h3 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h3><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令是用来静态显示系统中进程的命令。不过这个命令有些特殊，它的部分命令的选项不能加入“-”，比如“ps aux”，这是因为ps命令的部分选项需要遵守BSD操作系统的格式，所以ps命令的常用选项的组合是固定的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统中所有进程，使用BSD操作系统格式</span></span><br><span class="line">[root@localhost ~]# pa aux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统中所有进程，使用Linux标准命令格式</span></span><br><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">选项：</span><br><span class="line">  a:		显示一个终端的所有进程，除了会话引线</span><br><span class="line">  u:		显示进程的归属用户及内存的使用情况</span><br><span class="line">  x:		显示没有控制终端的进程</span><br><span class="line">  -l:		长格式显示。显示更加详细的信息</span><br><span class="line">  -e:		显示所有进程，和-A作用一致</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.2  24104 15260 ?        Ss   3月04   0:10 /sbin/init splash</span><br><span class="line">root           2  0.0  0.0      0     0 ?        S    3月04   0:00 [kthreadd]</span><br></pre></td></tr></table></figure>

<ul>
<li>USER：该进程是由哪个用户产生的</li>
<li>PID：进程的ID号</li>
<li>%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源</li>
<li>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源</li>
<li>VSZ：该进程占用虚拟内存的大小，单位KB</li>
<li>RSS：该进程占用实际物理内存的大小，单位KB</li>
<li>TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端(可以通过alt+F1-F7键切换不同的终端)，tty1-tty6是本地的字符界面终端，tty7是图形终端。pts&#x2F;0-255代表虚拟终端，一般是远程连接终端，第一个远程连接占用的是pts&#x2F;0终端，第二个远程连接占用pts&#x2F;1，依次增长。</li>
<li>STAT：进程状态。常见状态有：<ul>
<li>D：不可被唤醒的睡眠状态，通常用于I&#x2F;O情况</li>
<li>R：该进程正在运行</li>
<li>S：该进程在睡眠状态，可被唤醒</li>
<li>T：停止状态，可能是在后台暂停或进程在除错状态</li>
<li>W：内存交互状态（从2.6内核开始无效）</li>
<li>X：死掉的进程（应该不会出现）</li>
<li>Z：僵尸进程。进程已经终止，但是部分程序还在内存当中。</li>
<li>&lt;：高优先级（以下状态在BSD格式当中出现）</li>
<li>N：低优先级</li>
<li>L：被锁入内存</li>
<li>s：包含子进程</li>
<li>l：多线程</li>
<li>+：位于后台</li>
</ul>
</li>
<li>START：该进程的启动时间</li>
<li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li>
<li>COMMAND：产生此进程的命令名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0       1       0  0  80   0 -  6026 -      ?        00:00:10 systemd</span><br><span class="line">1 S     0       2       0  0  80   0 -     0 -      ?        00:00:00 kthreadd</span><br></pre></td></tr></table></figure>

<ul>
<li>F：进程标志，说明进程的权限，常见标志有：<ul>
<li>1：进程可以复制，但是不能执行</li>
<li>4：进程使用超级用户权限</li>
</ul>
</li>
<li>S：进程状态。具体的状态和“ps aux”命令中STAT状态一致</li>
<li>UID：进程是哪个UID用户调用运行的</li>
<li>PID：进程的ID号</li>
<li>PPID：代进程的ID号</li>
<li>C：该进程的CPU使用率，单位是百分比</li>
<li>PRI：进程的优先级，数值越小该进程优先级越高，越快被CPU执行</li>
<li>NI：进程的优先级，也是数值越小越早被执行</li>
<li>ADDR：该进程在内存的哪个位置</li>
<li>SZ：该进程占用多大内存</li>
<li>WCHAN：该进程是否运行。“-”代表正在运行</li>
<li>TTY：该进程由哪个终端产生</li>
<li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li>
<li>CMD：产生此进程的命令名</li>
</ul>
<h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top [选项]</span><br><span class="line">选项：</span><br><span class="line">  -d 秒数：    指定top命令每隔几秒更新。默认是3秒。</span><br><span class="line">  -b:  		  使用批处理模式输出。一般和&quot;-n&quot;选项合用，用于把top命令重定向到文件中 </span><br><span class="line">  -n 次数:	 指定top命令执行的次数。一般和&quot;-b&quot;选项合用</span><br><span class="line">  -p:		   指定PID。只查看某个PID的进程</span><br><span class="line">  -s:          使top在安全模式运行，避免在交互模式中出现错误</span><br><span class="line">  -u 用户名:    只监听某个用户的进程</span><br><span class="line">在top命令的交互模式当中可以执行的命令：</span><br><span class="line">  ？或h:	   显示交互模式的帮助</span><br><span class="line">  P:		以CPU使用率排序，默认就是此项</span><br><span class="line">  M:		以内存的使用率排序</span><br><span class="line">  N:		以PID排序</span><br><span class="line">  T:		按照CPU的累积运算时间排序，也就是用于TIME+项排序</span><br><span class="line">  k:		按照PID号，给予某个进程一个信号，一般用于终止某个进程，信号9是强制终止的信号</span><br><span class="line">  r:		按照PID号，给某个进程重设优先级（Nice）值</span><br><span class="line">  q:		退出top</span><br></pre></td></tr></table></figure>

<p>top执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 20:40:42 up 1 day, 11:10,  1 user,  load average: 0.62, 0.43, 0.45</span><br><span class="line">任务: 394 total,   1 running, 385 sleeping,   8 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.9 us,  3.9 sy,  0.0 ni, 94.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st </span><br><span class="line">MiB Mem :   6865.1 total,    245.4 free,   4582.3 used,   2676.1 buff/cache     </span><br><span class="line">MiB Swap:   2048.0 total,    789.7 free,   1258.3 used.   2282.8 avail Mem </span><br><span class="line"> 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND                                                     </span><br><span class="line"> 231207 ben       20   0   17672   5632   3456 R  23.1   0.1   0:00.06 top                                                       </span><br><span class="line">      1 root      20   0   24104  14620   9348 S   0.0   0.2   0:11.09 systemd                                                   </span><br><span class="line">      2 root      20   0       0      0      0 S   0.0   0.0   0:00.06 kthreadd                                                   </span><br><span class="line">      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_workqueue_release        </span><br></pre></td></tr></table></figure>

<p>top命令的输出内容是动态的，默认每3秒刷新一次。命令的输出主要分为两大部分；第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出判断服务器的健康状态；第二部分从第六行开始，显示的是系统中进程的信息。</p>
<ul>
<li><p>第一部分内容</p>
<ul>
<li><p>第一行信息为任务队列信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>20:40:42</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 1 day, 11:10</td>
<td>系统的运行时间，本机已经运行1天11小时10分钟</td>
</tr>
<tr>
<td>1 user</td>
<td>当前登录了1个用户</td>
</tr>
<tr>
<td>load average: 0.62, 0.43, 0.45</td>
<td>系统在之前1分钟，5分钟，15分钟的平均负载。如果CPU是单核，则这个数超过1，就是高负载。如果CPU是四核，则这个数超过4，就是高负载。（这个平均负载完全是个人经验来进行判断的，一般认为不应该超过服务器CPU的核数。）</td>
</tr>
</tbody></table>
</li>
<li><p>第二行为进程信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>任务: 394 total</td>
<td>系统中的进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>385 sleeping</td>
<td>睡眠的进程</td>
</tr>
<tr>
<td>8 stopped</td>
<td>正在停止的进程</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程。如果不是0，需要手工检查僵尸进程</td>
</tr>
</tbody></table>
</li>
<li><p>第三行为CPU信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%Cpu(s):  1.9 us</td>
<td>用户模式占用的CPU百分比</td>
</tr>
<tr>
<td>3.9 sy</td>
<td>系统模式占用的CPU百分比</td>
</tr>
<tr>
<td>0.0 ni</td>
<td>改变过优先级的用户进程占用的CPU百分比</td>
</tr>
<tr>
<td>94.2 id</td>
<td>空闲CPU的CPU百分比</td>
</tr>
<tr>
<td>0.0 wa</td>
<td>等待输入&#x2F;输出的进程的占用CPU百分比</td>
</tr>
<tr>
<td>0.0 hi</td>
<td>硬中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td>0.0 si</td>
<td>软中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td>0.0 st</td>
<td>st（Steal time）虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比</td>
</tr>
</tbody></table>
</li>
<li><p>第四行为物理内存信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Mem :   6865.1 total</td>
<td>物理内存的总量</td>
</tr>
<tr>
<td>245.4 free</td>
<td>空闲的物理内存数量</td>
</tr>
<tr>
<td>4582.3 used</td>
<td>已经使用的物理内存数量</td>
</tr>
<tr>
<td>2676.1 buff&#x2F;cache</td>
<td>作为缓冲&#x2F;缓存的内存数量</td>
</tr>
</tbody></table>
</li>
<li><p>第五行为交换分区（swap）信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Swap:   2048.0 total</td>
<td>交换分区（虚拟分区）的总大小</td>
</tr>
<tr>
<td>789.7 free</td>
<td>空闲交换分区的大小</td>
</tr>
<tr>
<td>1258.3 used</td>
<td>已经使用的交互分区的大小</td>
</tr>
<tr>
<td>2282.8 avail Mem</td>
<td>可利用的交互分区的大小</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>第二部分内容</p>
<p>主要是系统进程信息。这部分和ps命令的输出比较类似，只是如果在终端中执行top命令不能看到所有的进程，而只能看到占比靠前的进程。</p>
<ul>
<li>PID: 进程ID</li>
<li>USER: 该进程所属的用户</li>
<li>PR: 优先级，数值越小优先级越高</li>
<li>NI: 优先级，数值越小优先级越高</li>
<li>VIRT: 该进程使用的虚拟内存的大小，单位KB</li>
<li>RES: 该进程使用的物理内存的大小，单位KB</li>
<li>SHR: 共享内存大小，单位KB</li>
<li>%CPU: 该进程占用CPU的百分比</li>
<li>%MEM: 该进程占用内存的百分比</li>
<li>TIME+: 该进程总共占用的CPU时间</li>
<li>COMMAND: 进程的命令名</li>
</ul>
</li>
</ul>
<p>top命令查看某一个进程:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只查看PID为15273的apache进程</span></span><br><span class="line">[root@localhost ~]# top -p 15273</span><br></pre></td></tr></table></figure>

<p>在top命令的交互界面中按“q”键会退出top命令。也可以按“?”或“h”得到top命令交互界面的帮助信息。也可以按“k”键终止某个进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 21:30:33 up 1 day, 12:00,  1 user,  load average: 2.53, 1.43, 1.12</span><br><span class="line">任务: 391 total,   1 running, 382 sleeping,   8 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  5.5 us,  3.1 sy,  0.0 ni, 91.2 <span class="built_in">id</span>,  0.2 wa,  0.0 hi,  0.1 si,  0.0 st</span> </span><br><span class="line">MiB Mem :   6865.1 total,    196.3 free,   4604.8 used,   2714.5 buff/cache     </span><br><span class="line">MiB Swap:   2048.0 total,    742.7 free,   1305.3 used.   2260.2 avail Mem </span><br><span class="line">PID to signal/kill [default pid = 166294]                               # 按&quot;k&quot;键，会提示输入要杀死进程的PID</span><br></pre></td></tr></table></figure>

<p>如果在操作终端执行top命令，并不能看到系统中所有的进程，默认看到的只是CPU占比靠前的进程。如果我们想要看到所有的进程可以把top命令的结果重定向到文件当中即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让top命令只执行一次，然后把结果保存到top.log文件中。这样就能看到所有的进程了</span></span><br><span class="line">[root@localhost ~]# top -b -n 1 &gt; /root/top.log</span><br></pre></td></tr></table></figure>



<h4 id="pstree命令"><a href="#pstree命令" class="headerlink" title="pstree命令"></a>pstree命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pstree [选项]</span><br><span class="line">选项：</span><br><span class="line">  -p:		显示进程的PID</span><br><span class="line">  -u:		显示进程的所属用户</span><br></pre></td></tr></table></figure>



<h3 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h3><p>系统中可以识别的信号较多，可以使用命令“kill -l”或“man 7 signal”来查询：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>主要信号：</p>
<table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭，然后重新读取配置文件之后重启。</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键。</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术的错误。</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。一般用于强制终止进程。</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间. alarm函数使用该信号。</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill命令的默认信号。有时如果进程已经发生问题，这个信号是无法正常终止进程的，我们才会尝试SIGKILL信号，也就是信号9。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行，本信号不能被阻断。</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号不能被阻断。</td>
</tr>
</tbody></table>
<h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill [信号] PID</span><br></pre></td></tr></table></figure>

<p>使用“-1”信号，让进程重启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# kill -1 2246</span><br></pre></td></tr></table></figure>

<p>使用“-19”信号，让进程暂停：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用vim命令编辑一个文件，不要退出</span></span><br><span class="line">[root@localhost ~]# vim /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">换不同的终端，查看下这个进程的状态</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vim&quot; | grep -v &quot;grep&quot;</span><br><span class="line">ben       271840  0.2  0.1  31228 13568 pts/0    Sl+  16:00   0:00 vim /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用-19信号，让PID是271840的进程暂停。相当于在vim界面按<span class="string">&quot;ctrl+z&quot;</span>快捷键</span></span><br><span class="line">[root@localhost ~]# kill -19 271840</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">271840进程的状态变成为T(暂停)状态。271840进程会卡在后台，如果想要恢复可以使用<span class="string">&quot;kill -9 271840&quot;</span>强制终止进程。</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vim&quot; | grep -v &quot;grep&quot;</span><br><span class="line">ben       271840  0.0  0.1  31228 13568 pts/0    Tl   16:00   0:00 vim /tmp/test.txt</span><br></pre></td></tr></table></figure>



<h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# killall [选项][信号] 进程名</span><br><span class="line">选项：</span><br><span class="line">  -i:	交互式，询问是否要杀死某个进程</span><br><span class="line">  -l:	忽略进程名的大小写</span><br></pre></td></tr></table></figure>

<p>交互式杀死docker进程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps aux | grep &quot;docker-proxy&quot;</span><br><span class="line">root        5331  0.0  0.0 1746028 2160 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 127.0.0.1 -host-port 9090 -container-ip 172.23.0.2 -container-port 9090</span><br><span class="line">root        5345  0.0  0.0 1746028 2076 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 7891 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5352  0.0  0.0 1819504 2008 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 7891 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5366  0.0  0.0 1745772 2152 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5373  0.0  0.0 1746028 2088 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5388  0.0  0.0 1894260 4148 ?        Sl   3月04   0:02 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5395  0.0  0.0 1745772 2104 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5409  0.0  0.0 1671784 2204 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 7890 -container-ip 172.23.0.2 -container-port 7890</span><br><span class="line">root        5416  0.0  0.0 1671784 2168 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 7890 -container-ip 172.23.0.2 -container-port 7890</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式杀死docker进程</span></span><br><span class="line">[root@localhost ~]# killall -i docker-proxy</span><br><span class="line">杀死 docker-proxy(5331) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5345) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5352) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5366) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5373) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5388) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5395) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5409) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5416) ? (y/N) n</span><br></pre></td></tr></table></figure>



<h4 id="pkill命令"><a href="#pkill命令" class="headerlink" title="pkill命令"></a>pkill命令</h4><p>pkill命令和killall命令非常类似，也是按照进程名来杀死进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pkill [选项] [信号] 进程名</span><br><span class="line">选项：</span><br><span class="line">  -t 终端号:	按照终端号踢出用户</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制杀死从pts/1虚拟终端登录的进程</span></span><br><span class="line">[root@localhost ~]# pkill -9 -t pts/1</span><br></pre></td></tr></table></figure>



<h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><h3 id="工作管理简介"><a href="#工作管理简介" class="headerlink" title="工作管理简介"></a>工作管理简介</h3><p>后台管理有个事项需要注意：</p>
<ul>
<li>前台是指当前可以操控和执行命令的这个操作环境，后台是指工作可以自行运行，但是不能直接用ctrl+c来终止它，只能使用fg&#x2F;bg来调用工作；</li>
<li>当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作。如tty1登录终端是不能管理tty2终端中的工作的；</li>
<li>放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作。如果把1s命令放入后台执行，它很快就会执行完成，我们很难操作它。</li>
<li>放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行。比如vim命令放入后台只能暂停，而不能执行，因为vim需要前台输入信息。top命令也不能放入后台执行，而只能放入后台暂停，因为top命令需要和前台有交互。</li>
</ul>
<h3 id="如何把命令放入后台"><a href="#如何把命令放入后台" class="headerlink" title="如何把命令放入后台"></a>如何把命令放入后台</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令 &amp;"></a>命令 &amp;</h4><p>第一种方法把命令放入后台的方法是在命令后面加入“空格&amp;”，这种方法放入后台的命令，在后台是执行状态。但是注意，放入后台执行的命令不能与前台有交互，否则这个命令是不能在后台执行的。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find命令放入后台执行，每个后台命令会分配一个工作号，命令既然可以执行，就会有进程产生，所以也会有进程号。</span></span><br><span class="line">[root@localhost ~]# find / -name install.log &amp;</span><br><span class="line">[2] 284313</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[工作号] 进程号</span></span><br></pre></td></tr></table></figure>

<p>虽然find命令在执行，但是当前操作还是可以进行其他命令操作的。如果在终端出现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">证明后台这个任务已经完成了，当然命令如果有执行结果的话，也会显示到操作终端上。[2]是这个命令的工作号，+号代表这个任务是最近一个被放入后台的工作。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### ctrl+z</span></span></span><br><span class="line"></span><br><span class="line">第二种方法是在命令执行过程中按ctrl+z快捷键，命令在后台是暂停状态。</span><br><span class="line"></span><br><span class="line">使用这种方法放入后台的命令，就算是不和前台有交互，能在后台执行的命令，也是暂停状态，ctrl+z快捷键就是暂停的快捷键。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在top命令执行的过程中，按下ctrl+z快捷键</span></span><br><span class="line">[root@localhost ~]# top</span><br><span class="line">[1]+  已停止               top</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提示命令被放入后台，工作号是1，状态是暂停。而且虽然top命令没有结束，也能取得控制台权限</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩一下/etc/目录</span></span><br><span class="line">[root@localhost ~]# tar -zcf etc.tar.gz /etc</span><br><span class="line">tar: 从成员名中删除开头的&quot;/&quot;</span><br><span class="line">tar: 从硬连接目标中删除开头的&quot;/&quot;</span><br><span class="line">^Z                              # 执行过程中，按下ctrl+z快捷键</span><br><span class="line">[2]+   Stopped    tar -zcf etc.tar.gz /etc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令被放入后台，工作号是2，状态是暂停</span></span><br></pre></td></tr></table></figure>



<h3 id="后台命令管理"><a href="#后台命令管理" class="headerlink" title="后台命令管理"></a>后台命令管理</h3><h4 id="查看后台的工作"><a href="#查看后台的工作" class="headerlink" title="查看后台的工作"></a>查看后台的工作</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# jobs [-l]</span><br><span class="line">选项：</span><br><span class="line">  -l:	显示工作的PID</span><br></pre></td></tr></table></figure>

<h4 id="将后台暂停的工作恢复到前台执行"><a href="#将后台暂停的工作恢复到前台执行" class="headerlink" title="将后台暂停的工作恢复到前台执行"></a>将后台暂停的工作恢复到前台执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fg %工作号</span><br><span class="line">参数：</span><br><span class="line">  %工作号:		%号可以省略，但是注意工作号和PID的区别</span><br></pre></td></tr></table></figure>

<h4 id="把后台暂停的工作恢复到后台执行"><a href="#把后台暂停的工作恢复到后台执行" class="headerlink" title="把后台暂停的工作恢复到后台执行"></a>把后台暂停的工作恢复到后台执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# bg %工作号</span><br></pre></td></tr></table></figure>

<h4 id="后台命令脱离登录终端运行"><a href="#后台命令脱离登录终端运行" class="headerlink" title="后台命令脱离登录终端运行"></a>后台命令脱离登录终端运行</h4><p>我们已经知道把命令放入后台，只能在当前登录终端执行。那如果我是远程管理的服务器，在远程终端中执行了后台命令，这时我退出终端，这个后台命令还能继续执行吗？当然是不行的， 这个后台命令会被终止。如果确实需要在远程终端中执行某些后台命令，可以这么做：</p>
<ul>
<li>把需要后台执行的命令加入&#x2F;etc&#x2F;rc.local文件，让系统在启动时执行这个后台程序。这种方法的问题是，服务器是不能随便重启的，万一有临时后台任务，就不能执行。</li>
<li>使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的。</li>
<li>使用nohup命令。</li>
</ul>
<p>nohup命令的作用就是让后台工作在离开操作终端时，也能够正确的在后台执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nohup [命令] &amp; </span><br></pre></td></tr></table></figure>

<p>用find命令打印&#x2F;下所有文件，放入后台执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nohup find / -print &gt; /root/file.log &amp;</span><br><span class="line">[3] 2349</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有提示信息</span></span><br><span class="line">[root@localhost ~]# nohup：忽略输入并把输出追加到&quot;nohup.out&quot;</span><br></pre></td></tr></table></figure>



<h2 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>监控系统资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat [刷新延时 刷新次数]</span><br></pre></td></tr></table></figure>

<p>使用vmstat检测，每1秒刷新一次，共刷新3次：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat 1 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- -------cpu-------</span><br><span class="line"> r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st gu</span><br><span class="line"> 1  0 1975536 315116 888372 2032876    1   13    58    88  912    6  4  2 94  0  0  0</span><br><span class="line"> 0  0 1975536 296724 888372 2032912    8    0     8     0 2845 3503  4  2 94  0  0  0</span><br><span class="line"> 3  0 1975536 294804 888372 2032916    0    0     0     0 2592 3581  1  2 97  0  0  0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>procs：进程信息字段</p>
<ul>
<li>r：等待运行的进程数，数量越大，系统越繁忙。</li>
<li>b：不可被唤醒的进程数量，数量越大，系统越繁忙。</li>
</ul>
</li>
<li><p>memory：内存信息字段</p>
<ul>
<li>swpd：虚拟内存的使用情况，单位KB</li>
<li>free：空闲的内存容量，单位KB</li>
<li>buff：缓冲的内存容量，单位KB</li>
<li>cache：缓存的内存容量，单位KB</li>
</ul>
</li>
<li><p>swap：交换分区的信息字段</p>
<ul>
<li>si：从磁盘中交换到内存中数据的数量，单位KB</li>
<li>so：从内存中交换到磁盘中数据的数量，单位KB。此两个数越大，证明数据需要经常在磁盘和内存之间交换，系统性能越差。</li>
</ul>
</li>
<li><p>io：磁盘读写信息字段</p>
<ul>
<li>bi：从块设备读入数据的总量，单位是块</li>
<li>bo：写到块设备的数据的总量，单位是块。此两个数越大，代表系统的I&#x2F;O越繁忙。</li>
</ul>
</li>
<li><p>system：系统信息字段</p>
<ul>
<li>in：每秒被中断的进程次数</li>
<li>cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙。</li>
</ul>
</li>
<li><p>cpu：cpu信息字段</p>
<ul>
<li>us：非内核进程消耗cpu运算时间的百分比</li>
<li>sy：内核进程消耗cpu运算时间的百分比</li>
<li>id：空闲cpu的百分比</li>
<li>wa：等待I&#x2F;0所消耗的cpu百分比</li>
<li>st：被虚拟机所盗用的cpu百分比</li>
</ul>
</li>
</ul>
<h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>显示开机时内核检测信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看CPU信息</span></span><br><span class="line">[root@localhost ~]# dmesg | grep CPU</span><br></pre></td></tr></table></figure>



<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>查看内存使用状态</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free [-b|-k|-m|-g]</span><br><span class="line">选项：</span><br><span class="line">  -b:	以字节为单位显示</span><br><span class="line">  -k:	以KB为单位显示，默认是以KB为单位显示</span><br><span class="line">  -m:	以MB为单位显示</span><br><span class="line">  -g:	以GB为单位显示</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">内存：         6.7Gi       4.2Gi       283Mi       277Mi       2.8Gi       2.5Gi</span><br><span class="line">交换：         2.0Gi       1.9Gi       122Mi</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行</p>
<ul>
<li>total：总内存数。</li>
<li>used：已经使用的内存数。</li>
<li>free：空闲的内存数。</li>
<li>shared：多个进程共享的内存总数。</li>
<li>buff&#x2F;cache：缓冲&#x2F;缓存内存数。</li>
</ul>
</li>
<li><p>第二行</p>
<ul>
<li>total：swap的总数</li>
<li>used：已经使用的swap数</li>
<li>free：空闲的swap数。</li>
</ul>
</li>
</ul>
<h3 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h3><p>CPU的主要信息保存在&#x2F;proc&#x2F;cpuinfo这个文件中，只要查看这个文件，就可以知道cpu的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/cpuinfo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑CPU编号</span></span><br><span class="line">processor	: 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU制造厂商</span></span><br><span class="line">vendor_id	: AuthenticAMD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">产品的系列代号</span></span><br><span class="line">cpu family	: 23</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU系列代号</span></span><br><span class="line">model		: 24</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU系列的名字，编号，主频</span></span><br><span class="line">model name	: AMD Ryzen 7 3700U with Radeon Vega Mobile Gfx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新版本</span></span><br><span class="line">stepping	: 1</span><br><span class="line">microcode	: 0x8108109</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实际主频</span></span><br><span class="line">cpu MHz		: 1372.114</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二级缓存</span></span><br><span class="line">cache size	: 512 KB</span><br></pre></td></tr></table></figure>



<h3 id="查看本机登录用户信息"><a href="#查看本机登录用户信息" class="headerlink" title="查看本机登录用户信息"></a>查看本机登录用户信息</h3><p>如果我们想要知道Linux服务器上目前已经登录的用户信息，可以使用w或who命令来进行查询。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 17:54:27 up 2 days,  8:24,  1 user,  load average: 0.82, 0.89, 1.04</span><br><span class="line">USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU  WHAT</span><br><span class="line">ben               -                二09    2:27m  0.00s  0.04s lightdm --session-child 13 20</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行：和top命令的第一行非常类似，主要显示了系统当前时间，开机多久(up)，有多少用户登录(users)，1分钟、5分钟、15分种前的平均负载(load average)。</li>
<li>第二行：项目的说明<ul>
<li>USER：登录的用户名</li>
<li>TTY：登录终端</li>
<li>FROM：从哪个IP地址登录</li>
<li>LOGIN@：登录时间</li>
<li>IDLE：用户闲置时间</li>
<li>JCPU：指的是和该终端连接的所有进程占用的CPU运算时间。这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间</li>
<li>PCPU：是指当前进程所占用的CPU运算时间</li>
<li>WHAT：当前正在运行的命令</li>
</ul>
</li>
<li>第三行：代表一个用户</li>
</ul>
<p>who命令比w命令稍微简单一点，也可以用来查看系统中已经登录的用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# who</span><br><span class="line">ben      tty7         2025-03-04 09:29 (:0)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名  登录终端      登录时间(登录来源IP地址)</span></span><br></pre></td></tr></table></figure>



<h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>uptime命令的作用就是显示系统的启动时间和平均负载，也就是top命令的第一行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uptime</span><br><span class="line"> 18:05:21 up 2 days,  8:35,  1 user,  load average: 1.61, 1.24, 1.10</span><br></pre></td></tr></table></figure>



<h3 id="查看系统与内核相关信息"><a href="#查看系统与内核相关信息" class="headerlink" title="查看系统与内核相关信息"></a>查看系统与内核相关信息</h3><p>使用uname命令查看内核的相关信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uname [选项]</span><br><span class="line">选项：</span><br><span class="line">  -a:	查看系统所有相关信息</span><br><span class="line">  -r:   查看内核版本</span><br><span class="line">  -s:   查看内核名称</span><br></pre></td></tr></table></figure>

<p>如果我们想要判断当前系统的位数，可以通过file命令来判断系统文件(主要系统命令)的位数来推断系统的位数。如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# file /bin/ls</span><br><span class="line">/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3eca7e3905b37d48cf0a88b576faa7b95cc3097b, for GNU/Linux 3.2.0, stripped</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">很明显，当前系统是64位的</span></span><br></pre></td></tr></table></figure>

<p>如果想要查询当前Linux系统的发行版本，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsb_release -a </span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 24.04.1 LTS</span><br><span class="line">Release:	24.04</span><br><span class="line">Codename:	noble</span><br></pre></td></tr></table></figure>



<h2 id="系统定时任务"><a href="#系统定时任务" class="headerlink" title="系统定时任务"></a>系统定时任务</h2><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>循环执行定时任务。</p>
<p>1）crond服务管理与访问控制</p>
<p>crontab命令是需要crond服务支持的，crond服务同样是独立的服务，所以启动和自启动方法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启动crond服务</span></span><br><span class="line">[root@localhost ~]# service crond restart</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设定crond服务为开机自启动</span></span><br><span class="line">[root@localhost ~]# systemctl enable crond</span><br></pre></td></tr></table></figure>

<p>crond服务默认是自启动的，如果服务器上有循环执行的系统定时任务，就不要关闭crond服务了。</p>
<p>2）用户的crontab设置</p>
<p>每个用户都可以实现自己的crontab定时任务，只要是使用这个用户身份执行“crontab -e”命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# crontab [选项]</span><br><span class="line">选项：</span><br><span class="line">  -e:		编辑crontab定时任务</span><br><span class="line">  -l:		查询crontab任务</span><br><span class="line">  -r:		删除当前用户所有的crontab任务，如果有多个任务，只想删除一个，可以使用&quot;crontab -e&quot;</span><br><span class="line">  -u 用户名: 修改或删除其他用户的crontab任务。只有root可用	</span><br></pre></td></tr></table></figure>

<p>进入crontab编辑界面，会打开vim编辑你的工作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">* * * * * 执行的任务</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几个小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0-7(0和7都代表星期日)</td>
</tr>
</tbody></table>
<p>特殊符号：</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间，比如第一个“*”就代表一小时中每分钟都执行一次。</td>
</tr>
<tr>
<td>，</td>
<td>代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。</td>
</tr>
<tr>
<td>~</td>
<td>代表连续的时间范围。比如“0 5 * * 1-6 命令”，代表在周一到周六的凌晨5点0分执行命令。</td>
</tr>
<tr>
<td>*&#x2F;n</td>
<td>代表每隔多久执行一次。比如“*&#x2F;10 * * * * 命令”，代表每隔10分钟就执行一次命令。</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让系统每隔5分钟，就向/tmp/test文件中写入一行<span class="string">&quot;ll&quot;</span></span></span><br><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">*/5 * * * * /bin/echo &quot;ll&quot; &gt;&gt; /tmp/test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统在每周二的凌晨5点05分重启一次</span></span><br><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">5 5 * * 2 /sbin/shutdown -r now</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在每月的1号，10号，15号的凌晨3点30分都定时执行日志备份脚本autobak.sh</span></span><br><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">30 3 1,10,15 * * /root/sh/autobak.sh</span><br></pre></td></tr></table></figure>



<p>3）crontab的注意事项</p>
<p>在书写crontab定时任务时，需要注意几个注意事项：</p>
<ul>
<li>六个选项都不能为空，必须填写。如果不确定使用“*”代表任意时间。</li>
<li>crontab定时任务，最小有效时间是分钟，最大时间范围是月。</li>
<li>在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都是以天为单位，非常容易让管理员混乱。</li>
<li>在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都是用绝对路径。有时相对路径的命令会报错。</li>
</ul>
<p>4）系统的crontab设置</p>
<p>“crontab -e”是每个用户执行的命令，也就是说不同的用户身份可以执行自己的定时任务。可以是有些定时任务需要系统执行，这时就需要编辑&#x2F;etc&#x2F;crontab这个配置文件了。当然，并不是说写入&#x2F;etc&#x2F;crontab配置文件中的定时任务执行时，不需要用户身份，而是”crontab -e”命令定义定时任务时，默认用户身份是当前登录用户。而修改&#x2F;etc&#x2F;crontab配置文件时，定时任务的执行者身份是可以手工指定的。这样定时任务的执行会更加灵活，修改起来也更加方便。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/crontab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unlike any other crontab you don<span class="string">&#x27;t have to run the `crontab&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> to install the new version when you edit this file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and files <span class="keyword">in</span> /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that none of the other crontabs <span class="keyword">do</span>.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标识使用哪种shell</span></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can also override PATH, but by default, newer versions inherit it from the environment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example of job definition:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*  *  *  *  * user-name <span class="built_in">command</span> to be executed</span></span><br><span class="line">17 *	* * *	root	cd / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6	* * *	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.daily; &#125;</span><br><span class="line">47 6	* * 7	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.weekly; &#125;</span><br><span class="line">52 6	1 * *	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.monthly; &#125;</span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;crontab这个配置文件，加入自己的定时任务，不过需要注意指定脚本的执行者身份：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/crontab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unlike any other crontab you don<span class="string">&#x27;t have to run the `crontab&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> to install the new version when you edit this file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and files <span class="keyword">in</span> /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that none of the other crontabs <span class="keyword">do</span>.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标识使用哪种shell</span></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can also override PATH, but by default, newer versions inherit it from the environment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example of job definition:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*  *  *  *  * user-name <span class="built_in">command</span> to be executed</span></span><br><span class="line">17 *	* * *	root	cd / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6	* * *	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.daily; &#125;</span><br><span class="line">47 6	* * 7	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.weekly; &#125;</span><br><span class="line">52 6	1 * *	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.monthly; &#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用run-parts脚本调用并执行/root/cron/目录中所有的可执行文件</span></span><br><span class="line">* * * * *       root    run-parts /root/cron/</span><br></pre></td></tr></table></figure>

<p>只要保存&#x2F;etc&#x2F;crontab文件，这个定时任务就可以执行了，当然要确定crond服务是运行的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/03/05/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/05/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">服务管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-03-05 15:31:39 / 修改时间：17:26:04" itemprop="dateCreated datePublished" datetime="2025-03-05T15:31:39+08:00">2025-03-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="服务的简介与分类"><a href="#服务的简介与分类" class="headerlink" title="服务的简介与分类"></a>服务的简介与分类</h2><h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><p>Linux服务：</p>
<ul>
<li><p>RPM包默认安装的服务</p>
<ul>
<li><p>独立的服务</p>
<p>就是独立启动的意思，这类型的服务可以自行启动，而不用依赖其他的管理服务。不依赖其他管理服务，那么当客户端请求访问时，独立的服务响应请求更迅速。Linux中目前大多数服务都是独立的服务，比如apache服务，FTP服务，Samba服务等。</p>
</li>
<li><p>基于xinetd服务</p>
<p>这种服务就不能独立启动了，而是要依靠管理服务来调用这种服务。这个负责管理的服务就是xinetd服务，xinetd服务是系统的超级守护进程。xinetd服务的作用就是管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务云唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释放资源。这样做的好处是只需要持续启动xinetd服务，而其他基于xinetd的服务只有在需要时才启动，不会占用过多的服务器资源。但是这种服务由于在有客户端靖求时才会被唤醒，所以响应时间相对较慢。</p>
</li>
</ul>
</li>
<li><p>源码包安装的服务</p>
</li>
</ul>
<h3 id="查询已经安装的服务"><a href="#查询已经安装的服务" class="headerlink" title="查询已经安装的服务"></a>查询已经安装的服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --list [服务名]</span><br><span class="line">选项：</span><br><span class="line">  --list: 列出所有RPM默认安装服务的自启动状态</span><br></pre></td></tr></table></figure>



<h2 id="RPM包默认安装的服务管理"><a href="#RPM包默认安装的服务管理" class="headerlink" title="RPM包默认安装的服务管理"></a>RPM包默认安装的服务管理</h2><h3 id="独立服务管理"><a href="#独立服务管理" class="headerlink" title="独立服务管理"></a>独立服务管理</h3><h4 id="独立服务的启动管理"><a href="#独立服务的启动管理" class="headerlink" title="独立服务的启动管理"></a>独立服务的启动管理</h4><ul>
<li><p>使用&#x2F;etc&#x2F;init.d&#x2F;目录中的启动脚本启动服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /etc/init.d/httpd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用service命令来启动独立的服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service [独立服务名] start|stop|restart|...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="独立服务的自启动管理"><a href="#独立服务的自启动管理" class="headerlink" title="独立服务的自启动管理"></a>独立服务的自启动管理</h4><ul>
<li><p>使用chkconfig服务自启动管理命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig [--level 运行级别] [独立服务名] [on|off]</span><br><span class="line">选项：</span><br><span class="line">  --level:    设定在哪个运行级别中开机自启动(on)，或是关闭自启动(off)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --level 2345 httpd on</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件，设置服务自启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/etc/rc.d/init.d/httpd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ntsysv命令管理自启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ntsysv [--level 运行级别]</span><br><span class="line">选项：</span><br><span class="line">  --level 运行级别:  可以指定设定自启动的运行级别</span><br></pre></td></tr></table></figure>

<p>这个命令的操作是这样的：</p>
<ul>
<li>上下键：在不同服务之间移动</li>
<li>空格键：选定或取消服务的自启动，就是在服务之前是否打入“*”</li>
<li>tab键：在不同项目间切换</li>
<li>F1键：显示服务的说明</li>
</ul>
</li>
</ul>
<h3 id="基于xinetd服务的管理"><a href="#基于xinetd服务的管理" class="headerlink" title="基于xinetd服务的管理"></a>基于xinetd服务的管理</h3><h4 id="基于xinetd服务的启动"><a href="#基于xinetd服务的启动" class="headerlink" title="基于xinetd服务的启动"></a>基于xinetd服务的启动</h4><p>以telnet服务为例，telnet服务是用来进行系统远程管理的，端口是23。不过需要注意的是telnet的远程管理数据在网络中是明文传输，非常不安全。在生产服务器上不建议启动telnet服务。在生产服务器上，远程管理使用的是ssh协议，ssh是加密的，更加安全。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default: on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: The telnet server serves telnet sessions: it uses \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#       unencrypted username/password pairs for authentication.</span></span></span><br><span class="line">service telnet                                     # 服务的名称为telnet</span><br><span class="line">&#123;</span><br><span class="line">	flags				= REUSE                    # 标志为REUSE，设定TCP/IP socket可重用</span><br><span class="line">	socket_type         = stream                   # 使用TCP协议数据包</span><br><span class="line">	wait				= no					   # 允许多个连接同时连接</span><br><span class="line">	user				= root					   # 启动服务的用户为root</span><br><span class="line">	server				= /usr/sbin/in.telnetd     # 服务的启动程序</span><br><span class="line">	log_on_failure		+= USERID                  # 登录失败后，记录用户的ID</span><br><span class="line">	disable				= yes					   # 服务不启动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	disable				= no</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# service xinetd restart</span><br></pre></td></tr></table></figure>



<h4 id="基于xinetd服务的自启动"><a href="#基于xinetd服务的自启动" class="headerlink" title="基于xinetd服务的自启动"></a>基于xinetd服务的自启动</h4><ul>
<li><p>使用chkconfig命令管理自启动</p>
</li>
<li><p>使用ntsysv命令管理自启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig 服务名 on|off</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码包安装的服务管理"><a href="#源码包安装的服务管理" class="headerlink" title="源码包安装的服务管理"></a>源码包安装的服务管理</h2><h3 id="源码包服务的启动管理"><a href="#源码包服务的启动管理" class="headerlink" title="源码包服务的启动管理"></a>源码包服务的启动管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/apache2/bin/apachectl start|stop|restart|...</span><br></pre></td></tr></table></figure>



<h3 id="源码包服务的自启动管理"><a href="#源码包服务的自启动管理" class="headerlink" title="源码包服务的自启动管理"></a>源码包服务的自启动管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/usr/local/apache2/bin/apachectl start</span><br></pre></td></tr></table></figure>



<h2 id="Linux中常见服务的作用"><a href="#Linux中常见服务的作用" class="headerlink" title="Linux中常见服务的作用"></a>Linux中常见服务的作用</h2><table>
<thead>
<tr>
<th>服务名称</th>
<th>功能简介</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>acpid</td>
<td>电源管理接口。如果是笔记本用户建立开启，可以监听内核层的相关电源事件</td>
<td>on</td>
</tr>
<tr>
<td>anacron</td>
<td>系统的定时任务程序。cron的一个子系统，如果定时任务错过了执行时间，可以通过anacron继续唤醒执行。</td>
<td>off</td>
</tr>
<tr>
<td>alsasound</td>
<td>Alsa声卡驱动。如果使用alsa声卡，开启</td>
<td>off</td>
</tr>
<tr>
<td>apmd</td>
<td>电源管理模块。如果支持acpid，就不需要apmd，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>atd</td>
<td>指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用crond来进行循环定时任务。</td>
<td>off</td>
</tr>
<tr>
<td>auditd</td>
<td>审核子系统。如果开启了此服务，SELinux的审核信息会写入&#x2F;var&#x2F;log&#x2F;audit&#x2F;audit.log文件，如果不开启，审核信息会记录在syslog中</td>
<td>on</td>
</tr>
<tr>
<td>autofs</td>
<td>让服务器可以自动挂载网络中的其他服务器的共享数据，一般用来自动挂载NFS服务。如果没有NFS服务建立关闭</td>
<td>off</td>
</tr>
<tr>
<td>avahi-daemon</td>
<td>Avahi是zeroconf协议的实现。它可以在没有DNS服务的局域网里发现基于zeroconf协议的设备和服务。除非有兼容设备或使用zeroconf协议，否则关闭</td>
<td>off</td>
</tr>
<tr>
<td>bluetooth</td>
<td>蓝牙设备支持。一般不会在服务器上启用蓝牙设备。</td>
<td>off</td>
</tr>
<tr>
<td>capi</td>
<td>仅对使用ISND设备的用户有用。</td>
<td>off</td>
</tr>
<tr>
<td>chargen-dgram</td>
<td>使用UDP协议的chargen server。主要功能是提供类似远程打字的功能。</td>
<td>off</td>
</tr>
<tr>
<td>chargen-stream</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>cpuspeed</td>
<td>可以用来调整CPU的频率。当闲置时可以自动降低CPU频率来节省电量</td>
<td>on</td>
</tr>
<tr>
<td>crond</td>
<td>系统的定时任务，一般的Linux服务器都需要定时任务帮助系统维护</td>
<td>on</td>
</tr>
<tr>
<td>cvs</td>
<td>一个版本控制系统</td>
<td>off</td>
</tr>
<tr>
<td>daytime-dgram</td>
<td>daytime使用TCP协议的Daytime守护进程，该协议为客户机实现从远程服务器获取日期和时间的功能。</td>
<td>off</td>
</tr>
<tr>
<td>daytime-stream</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>dovecot</td>
<td>邮件服务中POP3&#x2F;IMAP服务的守护进程。主要用来接收信件，如果启动了邮件服务则开启，否则关闭</td>
<td>off</td>
</tr>
<tr>
<td>echo-dgram</td>
<td>服务器回显客户服务的进程。</td>
<td>off</td>
</tr>
<tr>
<td>echo-stream</td>
<td>同上。</td>
<td>off</td>
</tr>
<tr>
<td>firstboot</td>
<td>系统安装完成之后，有个欢迎界面，需要对系统进程初始设定，就是这个进程的作用。既然不是第一次启动，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>gpm</td>
<td>在字符终端(tty1-tty6)中可以使用鼠标复制和粘贴。就是这个服务的功能。</td>
<td>on</td>
</tr>
<tr>
<td>haldaemon</td>
<td>检测盒支持USB设备。如果是服务器可以关闭，个人建议关闭</td>
<td>off</td>
</tr>
<tr>
<td>hidd</td>
<td>蓝牙鼠标、键盘等蓝牙设备检测。必须启动bluetooth服务。</td>
<td>off</td>
</tr>
<tr>
<td>hplip</td>
<td>HP打印机支持，如果没有HP打印机则关闭</td>
<td>off</td>
</tr>
<tr>
<td>httpd</td>
<td>apache服务的守护进程。如果需要启动apache，则开启</td>
<td>on</td>
</tr>
<tr>
<td>ip6tables</td>
<td>IPv6防火墙，目前IPv6协议并没有使用，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>iptables</td>
<td>防火墙功能，Linux中防火墙是内核支持功能，这是服务器的主要防护手段，必须开启</td>
<td>on</td>
</tr>
<tr>
<td>irda</td>
<td>IrDA提供红外线设备(笔记本、PDA’s，手机，计算器等等)间的通讯支持。</td>
<td>off</td>
</tr>
<tr>
<td>irqbalance</td>
<td>支持多核处理器，让CPU可以自动分配系统中断(IRQ)，提高系统性能。</td>
<td>on</td>
</tr>
<tr>
<td>isdn</td>
<td>使用ISDN设备连接网络。目前主流的联网方式是光纤接入和ADSL，ISDN已经非常少见</td>
<td>off</td>
</tr>
<tr>
<td>kudzu</td>
<td>该服务可以在开机时进行硬件检测，并会调用相关的设置软件。</td>
<td>off</td>
</tr>
<tr>
<td>lvm2-monitor</td>
<td>该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM方式，那么应该开启</td>
<td>on</td>
</tr>
<tr>
<td>mcstrans</td>
<td>SELinux的支持服务</td>
<td>on</td>
</tr>
<tr>
<td>mdmonitor</td>
<td>该服务用来监测Software RAID或LVM的信息。不是必须服务</td>
<td>off</td>
</tr>
<tr>
<td>mdmpd</td>
<td>该服务用来监测Multi-Path设备</td>
<td>off</td>
</tr>
<tr>
<td>messagebus</td>
<td>这是Linuxr IPC（Interprocess Communication, 进程间通讯）服务，用来在各个软件中交换信息</td>
<td>off</td>
</tr>
<tr>
<td>microcode_ctl</td>
<td>Intel系列的CPU可以通过这个服务支持额外的微指令集。</td>
<td>off</td>
</tr>
<tr>
<td>mysqld</td>
<td>mysql数据库服务器。如果需要就开启，</td>
<td>off</td>
</tr>
<tr>
<td>named</td>
<td>DNS服务的守护进程，用来进行域名解析。如果是DNS服务器则开启</td>
<td>off</td>
</tr>
<tr>
<td>netfs</td>
<td>该服务用于在系统启动时自动挂载网络中的共享文件空间，比如：NFS, Samba等。需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>network</td>
<td>提供网络设置功能。通过这个服务来管理网络</td>
<td>on</td>
</tr>
<tr>
<td>nfs</td>
<td>NFS（Network File System）服务，Linux与Linux之间的文件共享服务。需要就开启</td>
<td>off</td>
</tr>
<tr>
<td>nfslock</td>
<td>在Linux中如果使用了NFS服务，为了避免同一个文件被不同的用户编辑，所以有了这个锁服务。有NFS是开启</td>
<td>off</td>
</tr>
<tr>
<td>ntpd</td>
<td>该服务可以通过互联网自动更新系统时间，使系统时间永远都准确。需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>pcscd</td>
<td>智能卡检测服务</td>
<td>off</td>
</tr>
<tr>
<td>portmap</td>
<td>用在远程过程调用（RPC）的服务，如果没有任何RPC服务时，可以关闭，主要是NFS和NIS服务需要</td>
<td>off</td>
</tr>
<tr>
<td>psacct</td>
<td>该守护进程支持几个监控进程活动的工具。</td>
<td>off</td>
</tr>
<tr>
<td>rdisc</td>
<td>客户端ICMP路由协议</td>
<td>off</td>
</tr>
<tr>
<td>readahead_early</td>
<td>在系统开机的时候，先将某些进程加载如内存整理，可以加快一点启动速度。</td>
<td>off</td>
</tr>
<tr>
<td>readahead_later</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>restorecond</td>
<td>用于给SELinux监测和重新加载正确的文件上下文。如果开启SELinux则需要开启。</td>
<td>off</td>
</tr>
<tr>
<td>rpcgssd</td>
<td>与NFS有关的客户端功能</td>
<td>off</td>
</tr>
<tr>
<td>rpcidmapd</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>rsync</td>
<td>远程数据备份守护进程</td>
<td>off</td>
</tr>
<tr>
<td>sendmail</td>
<td>sendmail邮件服务的守护进程。如果有邮件服务就开启</td>
<td>off</td>
</tr>
<tr>
<td>setroubleshoot</td>
<td>该服务用于将SELinux相关信息记录在日志&#x2F;var&#x2F;log&#x2F;messages中</td>
<td>on</td>
</tr>
<tr>
<td>smartd</td>
<td>该服务用于自动检则硬盘状态</td>
<td>on</td>
</tr>
<tr>
<td>smb</td>
<td>网络服务samba守护进程。可以让Linux和Windows之间共享数据。如果需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>squid</td>
<td>代理服务的守护进程。</td>
<td>off</td>
</tr>
<tr>
<td>sshd</td>
<td>ssh加密远程登录管理的服务。</td>
<td>on</td>
</tr>
<tr>
<td>syslog</td>
<td>日志的守护进程。</td>
<td>on</td>
</tr>
<tr>
<td>vsftpd</td>
<td>vsftpd服务的守护进程。如果需要FTP服务则开启</td>
<td>off</td>
</tr>
<tr>
<td>xfs</td>
<td>这个是X Window的字体守护进程。为图形界面提供字体服务，如果不启动图形界面就不用开启</td>
<td>off</td>
</tr>
<tr>
<td>xinetd</td>
<td>超级守护进程。如果有依赖xinetd的服务就必须开启</td>
<td>off</td>
</tr>
<tr>
<td>ypbind</td>
<td>为NIS(网络信息系统)客户机激活ypbind服务进程。</td>
<td>off</td>
</tr>
<tr>
<td>yum-updatesd</td>
<td>yum的在线升级服务</td>
<td>off</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/03/04/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%BF%AE%E5%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/04/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%BF%AE%E5%A4%8D/" class="post-title-link" itemprop="url">启动引导与修复</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-04 15:32:41" itemprop="dateCreated datePublished" datetime="2025-03-04T15:32:41+08:00">2025-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-05 17:27:30" itemprop="dateModified" datetime="2025-03-05T17:27:30+08:00">2025-03-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h2><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>Linux默认有7个运行级别</p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式，可以想象为windows的安全模式，主要用于系统修复</td>
</tr>
<tr>
<td>2</td>
<td>不完全的命令行模式，不含NFS服务</td>
</tr>
<tr>
<td>3</td>
<td>完全的命令行模式，就是标准字符界面</td>
</tr>
<tr>
<td>4</td>
<td>系统保留</td>
</tr>
<tr>
<td>5</td>
<td>图形模式</td>
</tr>
<tr>
<td>6</td>
<td>重启动</td>
</tr>
</tbody></table>
<p>在Linux系统中可以使用runlevel命令来查看系统的运行级别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">N 5</span><br></pre></td></tr></table></figure>

<p>在这个命令的结果中，”N 5”中的N代表进入这个级别前，上一个级别是什么，5代表当前级别。”N”就是None的意思，也就是说系统是开机直接进入的5运行级别，没有上一个运行级别。那如果是从图形界面切换到字符界面的话，再查看运行级别，应该是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure>

<p>使用init命令可以手工改变当前的运行级别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入图形界面，当然要已经安装了图形界面才可以</span></span><br><span class="line">[root@localhost ~]# init 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关机</span></span><br><span class="line">[root@localhost ~]# init 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">[root@localhost ~]# init 6</span><br></pre></td></tr></table></figure>

<p>不过要注意使用init命令关机和重启并不是太安全，容易造成数据丢失。所以推荐还是使用shutdown命令进行关机和重启。</p>
<h3 id="系统默认运行级别"><a href="#系统默认运行级别" class="headerlink" title="系统默认运行级别"></a>系统默认运行级别</h3><p>&#x2F;etc&#x2F;init&#x2F;rcS.conf配置文件调用&#x2F;etc&#x2F;inittab配置文件的目的就是为了确定系统的默认运行级别。也就是系统一开机后会进入那个运行级别。</p>
<p>注意这里的默认运行级别只能写成3或5，其的级别要不就是关机重启，要不就是保留或单用户，都不能作为系统默认运行级别。</p>
<h3 id="etc-rc-d-rc-local文件"><a href="#etc-rc-d-rc-local文件" class="headerlink" title="&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件"></a>&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件</h3><p>这个配置文件会在用户登录之前读取，这个文件中写入什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动就运行的工作，只需要写入&#x2F;etc&#x2F;rc.d&#x2F;rc.local这个配置文件即可。</p>
<h2 id="启动引导程序-Boot-Loader"><a href="#启动引导程序-Boot-Loader" class="headerlink" title="启动引导程序(Boot Loader)"></a>启动引导程序(Boot Loader)</h2><p>早期的Lilo引导程序已经不是很常见了，grub相比有很多优势，主要有：</p>
<ul>
<li>支持更多的文件系统；</li>
<li>grub的主程序可以直接在文件系统中查找内核文件；</li>
<li>在系统启动时，可以利用grub的交互界面编辑和修改启动选项；</li>
<li>可以动态的修改grub的配置文件，这样在修改配置文件之后不需要重新安装grub，而只需要重新启动就可以生效了。</li>
</ul>
<p>a）&#x2F;boot&#x2F;grub目录</p>
<p>grub的作用有以下几个：</p>
<ul>
<li>加载操作系统的内核。</li>
<li>拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。</li>
<li>还可以调用其他的启动引导程序，来实现多系统引导。</li>
</ul>
<p>grub的配置文件主要是放置在&#x2F;boot&#x2F;grub&#x2F;目录中的。其实这个目录中主要就是grub的配置文件和各种文件系统的stage1.5文件。不过grub的配置文件有两个&#x2F;boot&#x2F;grub&#x2F;grub.conf和&#x2F;boot&#x2F;grub&#x2F;menu.lst，这两个配置文件是软链接，所以修改哪一个都可以，个人习惯改grub.conf。</p>
<p>b）grub的配置文件</p>
<p>在grub中分区的表示方法</p>
<table>
<thead>
<tr>
<th>硬盘</th>
<th>分区</th>
<th>Linux中设备文件名</th>
<th>grub中设备文件名</th>
</tr>
</thead>
<tbody><tr>
<td>第一块SCSI硬盘</td>
<td>第一个主分区</td>
<td>&#x2F;dev&#x2F;sda1</td>
<td>hd(0,0)</td>
</tr>
<tr>
<td></td>
<td>第二个主分区</td>
<td>&#x2F;dev&#x2F;sda2</td>
<td>hd(0,1)</td>
</tr>
<tr>
<td></td>
<td>扩展分区</td>
<td>&#x2F;dev&#x2F;sda3</td>
<td>hd(0,2)</td>
</tr>
<tr>
<td></td>
<td>第一个逻辑分区</td>
<td>&#x2F;dev&#x2F;sda5</td>
<td>hd(0,4)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第一个主分区</td>
<td>&#x2F;dev&#x2F;sdb1</td>
<td>hd(1,0)</td>
</tr>
<tr>
<td></td>
<td>第二个主分区</td>
<td>&#x2F;dev&#x2F;sdb2</td>
<td>hd(1,1)</td>
</tr>
<tr>
<td></td>
<td>扩展分区</td>
<td>&#x2F;dev&#x2F;sdb3</td>
<td>hd(1,2)</td>
</tr>
<tr>
<td></td>
<td>第一个逻辑分区</td>
<td>&#x2F;dev&#x2F;sdb5</td>
<td>hd(1,4)</td>
</tr>
</tbody></table>
<p>grub的配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">		root (hd0,0)</span><br><span class="line">		kernel				/vmlinuz-2.6.32-279.el6.i686			ro		root=UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS	KEYBOARDTYPE=pc	KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</span><br><span class="line">		initrd	/initramfs-2.6.32-279.el6.i686.img</span><br></pre></td></tr></table></figure>

<ul>
<li><p>default&#x3D;0</p>
<p>默认启动第一个系统。也就是如蛤在等待时间结束后，用户没有选择进入哪一个系统，那么系统会默认进入第一个系统。如果有多系统并存，那么每个系统都会有自己的titile字段，如果想要默认进入第二个系统，可以设为default&#x3D;1。</p>
</li>
<li><p>timeout&#x3D;5</p>
<p>等待时间，默认是5秒。也就是进入系统时，如果5秒内用户没有按下任意键，那么系统会进入default字段定义的系统。当然可以手工修改这个等待时间，如果timeout&#x3D;0则不会等待直接进入系统，timeout&#x3D;-1则是一直等待用户输入，而不会自动进入系统。</p>
</li>
<li><p>splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz</p>
<p>这里是指定grub启动时的背景图像文件的保存位置。hd(0,0)代表第一个硬盘的第一个分区。</p>
</li>
<li><p>hiddenmenu</p>
<p>隐藏菜单。启动时默认只能看到读秒，而不能看到菜单，如果想要看到菜单需要按任意键。如果注释了这句话，那么启动时就能直接看到菜单了。</p>
</li>
</ul>
<p>Centos系统的启动配置：</p>
<ul>
<li><p>title Centos (2.6.32-279.el6.i686)</p>
<p>title就是标题的意思，也就是说在title后面写入的是什么，那么系统启动时在grub的启动菜单中看到的就是什么。</p>
</li>
<li><p>root (hd0,0)</p>
<p>是指启动程序的保存分区。这个root并不是管理员。在我的系统中，&#x2F;boot分区是独立划分的，而且设备文件名为&#x2F;dev&#x2F;sda1，所以在grub中，就被描述为hd（0,0）。</p>
</li>
<li><p>kernel				&#x2F;vmlinuz-2.6.32-279.el6.i686			ro		root&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS	KEYBOARDTYPE&#x3D;pc	KEYTABLE&#x3D;us rd_NO_MD crashkernel&#x3D;auto LANG&#x3D;zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</p>
<ul>
<li><p>&#x2F;vmlinuz-2.6.32-279.el6.i686</p>
<p>指定了内核文件的位置，这里的&#x2F;是指&#x2F;boot分区。</p>
</li>
<li><p>ro</p>
<p>启动时以只读方式挂载根文件系统，这是为了不让启动过程影响磁盘内的文件系统。</p>
</li>
<li><p>root&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS</p>
<p>指定根文件系统所在位置。</p>
</li>
<li><p>rd_NO_LUKS</p>
<p>禁用LUKS，LUKS用于给磁盘加密。</p>
</li>
<li><p>rd_NO_MD</p>
<p>禁用软RAID</p>
</li>
<li><p>rd_NO_DM</p>
<p>禁用硬RAID</p>
</li>
<li><p>rd_NO_LVM</p>
<p>禁用LVM。以上禁用都只是在启动过程中禁用，是为加速系统启动的。</p>
</li>
<li><p>KEYBOARDTYPE&#x3D;pc    KEYTABLE&#x3D;us</p>
<p>键盘类型</p>
</li>
<li><p>crashkernel&#x3D;auto</p>
<p>自动为crashkernel预留内存</p>
</li>
<li><p>LANG&#x3D;zh_CN.UTF-8</p>
<p>语言环境</p>
</li>
<li><p>rhgb</p>
<p>（redhat graphics boot）用图片来代替启动过程中的文字信息。启动完成之后可以使用dmesg命令来查看这些文字信息。</p>
</li>
<li><p>quiet</p>
<p>隐藏启动信息，只显示重要信息。</p>
</li>
<li><p>initrd    &#x2F;initramfs-2.6.32-279.el6.i686.img</p>
<p>指定了initramfs内存文件系统镜像文件的所在位置。</p>
</li>
</ul>
</li>
</ul>
<p>grub加密</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grub-mkpasswd-pbkdf2</span><br><span class="line">输入密码： </span><br><span class="line">重新输入口令： </span><br><span class="line">您的密码的 PBKDF2 哈希为 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br></pre></td></tr></table></figure>

<p>这样就可以生成加密密码字串，这个字串是采用md5加密的，就是你的密码经md5编码之后的。</p>
<p>grub菜单整体加密</p>
<p>如果只是加密单个启动菜单，grub的编辑模式是不能锁定的，还是可以按“e”键进入编辑模式。而且进入编辑模式后，是可以删除password字段的，再按“b”（boot启动）键就可以不用密码直接进入系统。这时就需要给grub菜单整体加密了，整体加密后，如果想进入grub编辑界面必须输入正确的密码。加密方法其实只是把password字段换个位置而已。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout=5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但是这样加密，启动CentOS时，是不需要密码就能正常启动的。如果需要grub整体加密，又需要系统启动时输入正确的密码时，则需：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">		lock</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<p>在title字段加入lock。代表锁死，如果不输入正确的grub密码也不能启动。</p>
<h2 id="系统修复模式"><a href="#系统修复模式" class="headerlink" title="系统修复模式"></a>系统修复模式</h2><h3 id="单用户模式"><a href="#单用户模式" class="headerlink" title="单用户模式"></a>单用户模式</h3><p>Linux的单用户模式有些类似Windows的安全模式，只启动最少的程序用于系统修复。在单用户模式(运行级别为1)中，Linux引导进入根shell，网络被禁用，只有少数进程运行。单用户模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。</p>
<p>a）进入单用户模式</p>
<p>开机进入引导界面，按“e”进入。</p>
<p>b）单用户模式常见的错误修复</p>
<ul>
<li><p>遗忘root密码</p>
<p>进入单用户模式最大的特点就是不需要输入用户名和密码就能登录。既然已经登录了单用户模式，那么直接给root用户设定新密码即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# passwd root</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改系统默认运行级别</p>
<p>如果把系统的默认运行级别修改错误，比如改为了0或6，系统就不能正常启动了。这时也可以利用单用户模式进行修复，只要直接修改默认运行级别配置文件&#x2F;etc&#x2F;inittab，把系统默认运行级别修改回来即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/inittab</span><br><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure>

<p>绝大多数系统错误都可以通过单用户模式进行修复，理论上是只要能够进入单用户模式，那么系统错误就可以被单用户模式修复。当然意判断系统到底是哪里出现了问题，是需要不断地经验积累。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/28/Terraform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/28/Terraform/" class="post-title-link" itemprop="url">Terraform</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-28 20:48:38" itemprop="dateCreated datePublished" datetime="2025-02-28T20:48:38+08:00">2025-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-01 14:56:00" itemprop="dateModified" datetime="2025-03-01T14:56:00+08:00">2025-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/terraform/" itemprop="url" rel="index"><span itemprop="name">terraform</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Terraform工作流程"><a href="#Terraform工作流程" class="headerlink" title="Terraform工作流程"></a>Terraform工作流程</h2><p>Terraform是一个基础设施即代码(IaC)工具，通过以下几个步骤来管理基础设施：</p>
<ul>
<li><p>配置文件（.tf文件）</p>
<p>用户首先通过编写Terraform配置文件来定义所需的基础设施。这些文件使用HCL（HashiCorp Configuration Language）语言，描述资源的类型、属性和配置。</p>
</li>
<li><p>初始化（terraform init）</p>
<p>在开始Terraform之前，用户需要运行terraform init命令。这一步会初始化工作目录，下载所需的提供程序(如AWS、Azure等)，并准备后续的操作。</p>
</li>
<li><p>生成执行计划（terraform plan）</p>
<p>使用terraform plan命令，Terraform会读取配置文件并生成执行计划，展示将要执行的操作（如创建、更新或删除资源）。这一步允许用户预览即将进行的变更，避免意外操作。</p>
</li>
<li><p>应用变更（terraform apply）</p>
<p>在确认执行计划后，用户可以运行terraform apply命令，Terraform会根据生成的计划实际执行相应的操作，创建、更新或删除云资源。</p>
</li>
<li><p>状态管理</p>
<p>Terraform会维护一个状态文件（terraform.tfstate），记录当前基础设施的状态。这个文件用于跟踪资源的实际状态，以便在后续操作中进行对比和管理。</p>
</li>
<li><p>变更管理</p>
<p>当需要对基础设施进行更改时，用户只需要修改配置文件，然后重复执行plan和apply流程。Terraform会自动识别资源的变更，并进行相应的更新。</p>
</li>
<li><p>销毁资源（terraform destory）</p>
<p>当不再需要某些资源时，用户可以运行terraform destory命令，Terraform会删除所有配置文件中定义的资源，确保清理工作整洁。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/27/Shell%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/27/Shell%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Shell编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 11:12:53" itemprop="dateCreated datePublished" datetime="2025-02-27T11:12:53+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-01 19:05:53" itemprop="dateModified" datetime="2025-03-01T19:05:53+08:00">2025-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Shell/" itemprop="url" rel="index"><span itemprop="name">Shell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>正则表达式用来在文件中匹配符合条件的字符串，通配符用来匹配符合条件的文件名。其实这种区别只在Shell当中适用，因为用来文件当中搜索字符串的命令如grep、awk、sed等命令可以支持正则表达式，而在系统当中搜索文件的命令如ls、find、cp这些命令不支持正则表达式，所以只能使用Shell自己的通配符来进行匹配了。</p>
<h4 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>前一个字符匹配0次或任意多次</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符外任意一个字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配行首。例如^hello会匹配以hello开头的行</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾。例如hello$会匹配以hello结尾的行</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中指定的任意一个字符，只匹配一个字符。例如[aoeiu]匹配任意一个元音字母</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配除中括号的字符以外的任意一个字符。例如[^0-9]匹配任意一位非数字字符</td>
</tr>
<tr>
<td>\</td>
<td>转义符。用于取消特殊符号的转义</td>
</tr>
<tr>
<td>\{n\}</td>
<td>表示其前面的字符恰好出现n次。例如[0-9]\{4\}匹配4位数字</td>
</tr>
<tr>
<td>\{n, \}</td>
<td>表示其前面的字符出现不小于n次。例如[0-9]\{2, \}表示两位及以上的数字</td>
</tr>
<tr>
<td>\{n,m\}</td>
<td>表示其前面的字符至少出现n次，最多出现m次。例如[a-z]\{6,8\}匹配6到8位的小写字母。</td>
</tr>
</tbody></table>
<p>练习文件建立：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“a*”前一个字符匹配0次，或任意多次</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“aa*”代表这行字符串最少要有一个a</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;aa*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“.”匹配除了换行符外任意一个字符，只能匹配一个字符，这个字符可以是任意字符</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s..d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# grep &quot;s.*d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“^”代表匹配行首，比如“^M”会匹配以大写“M”开头的行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^M&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure>

<p>“$”代表匹配行尾，比如“n$”会匹配以小写“n”结尾的行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;n$&quot; test_rule.txt</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure>

<p>“^$”则会匹配空白行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^$&quot; test_rule.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“[]”会匹配中括号中指定任意一个字符，注意只能匹配一个字符。比如[ao]会匹配a或o</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s[ao]id&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“[^]”匹配除中括号的字符以外的任意一个字符</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[^a-z]&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">5555nice!</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“\“转义符</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;\.$&quot; test_rule.txt</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“\{n\}”表示其前面的字符恰好出现n次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a\&#123;3\&#125;&quot; test_rule.txt</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br></pre></td></tr></table></figure>

<p>“\{n,\}”会匹配前面的字符出现最少n次。比如“^[0-9]\{3, \}[a-z]”这个正则就能匹配最少用连续三个数字开头的字符串</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[0-9]\&#123;3,\&#125;[a-z]&quot; test_rule.txt</span><br><span class="line">123despise him.</span><br><span class="line">5555nice!</span><br></pre></td></tr></table></figure>

<p>“\{n,m\}”匹配其前面的字符至少出现n次，最多出现m次</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;sa\&#123;1,3\&#125;i&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br></pre></td></tr></table></figure>



<h4 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h4><p>在正则表达式中应该还可以支持一些元字符，比如“+”、“?”、“|”、“()”。其实Linux是支持这些元字符的，只是grep命令默认不支持而已。如果想要支持这些元字符，必须使用egrep命令或grep -E选项，所以我们又把这些元字符称作扩展元字符。</p>
<p>如果查询grep的帮助，对egrep的说明就是和grep -E选项一样的命令，所以我们可以把这两个命令当做别名来对待。</p>
<table>
<thead>
<tr>
<th>扩展元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>前一个字符匹配1次或任意多次。如“go+gle”会匹配“gogle”、“google”或“gooogle”等。</td>
</tr>
<tr>
<td>?</td>
<td>前一个字符匹配0次或1次。如”colou?r”可以匹配“colour”或“color”。</td>
</tr>
<tr>
<td>|</td>
<td>匹配两个或多个分支的选择。如”was|his”会匹配既包含“was”的行，也匹配包含”his”的行。</td>
</tr>
<tr>
<td>()</td>
<td>匹配其整体为一个字符，即模式单元。可以理解为由多个单字符组成的大字符。如“(dog)+”会匹配“dog”、“dogdog”、“dogdogdog”等。因为被()包含的字符会当成一个整体。</td>
</tr>
</tbody></table>
<h3 id="字符截取和替换命令"><a href="#字符截取和替换命令" class="headerlink" title="字符截取和替换命令"></a>字符截取和替换命令</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f 列号：         提取第几列</span><br><span class="line">  -d 分隔号：       按照指定分隔符分割列</span><br><span class="line">  -c 字符范围：      不依赖分隔符来区分列，而是通过字符范围(行首为0)来进行字段提取。“n-”表示从第n个字符到行尾；&quot;n-m&quot;表示从第n个字符到第m个字符；&quot;-                     m&quot;表示从第1个字符到第m个字符。</span><br></pre></td></tr></table></figure>

<p>cut命令的默认分隔符是制表符，也就是“tab”键。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    Gender  Mark</span><br><span class="line">1       Liming  M       86</span><br><span class="line">2       Sc      M       90</span><br><span class="line">3       Tg      M       83</span><br></pre></td></tr></table></figure>

<p>提取第二列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2 test.txt</span><br><span class="line">Name</span><br><span class="line">Liming</span><br><span class="line">Sc</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure>

<p>提取多列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2,3 test.txt</span><br><span class="line">Name	Gender</span><br><span class="line">Liming	M</span><br><span class="line">Sc	M</span><br><span class="line">Tg	M</span><br></pre></td></tr></table></figure>

<p>按照字符进行提取：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -c 8- test.txt        # &quot;8-&quot;代表提取所有行的第8个字符到结尾</span><br><span class="line">	Gender	Mark</span><br><span class="line">g	M	86</span><br><span class="line">90</span><br><span class="line">83</span><br></pre></td></tr></table></figure>

<p>以“:”作为分隔符提取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -d &quot;:&quot; -f 1,3 /etc/passwd</span><br><span class="line">root:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>a）printf格式化输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;输出类型输出格式&#x27; 输出内容</span><br><span class="line">输出类型：</span><br><span class="line">  %ns:        输出字符串。n是数字指代输出几个字符</span><br><span class="line">  %ni:        输出整数。n是数字指代输出几个数字</span><br><span class="line">  %m.nf:      输出浮点数。m和n是数字，指代输出的整数位和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。</span><br><span class="line">输出格式：</span><br><span class="line">  \a：         输出警告声音</span><br><span class="line">  \b：         输出退格键，也就是Backspace键</span><br><span class="line">  \f：         清除屏幕</span><br><span class="line">  \n:          换行</span><br><span class="line">  \r:          回车，也就是Enter键</span><br><span class="line">  \t:          水平输出退格键，也就是Tab键</span><br><span class="line">  \v:          垂直输出退格键，也就是Tab键</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>使用printf输出test.txt文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s&#x27; $(cat test.txt)</span><br><span class="line">IDNamePHPLinuxMySQLAverage1Liming82958687.662Sc74968785.663Tg99839391.66[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>如果不指定输出格式，则会把所有输出内容连在一起输出。其实文本的输出本身就是这样的，cat等文本输出命令之所以可以按照格式漂亮的输出，那是因为cat命令已经设定了输出格式。为了用printf输出合理的格式，可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意在<span class="built_in">printf</span>命令的单引号中，只能识别格式输出符号，而手工输入的空格是无效的</span></span><br><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %s\t %s\t %s\t %s\t \n&#x27; $(cat test.txt)</span><br><span class="line">ID	 Name	 PHP	 Linux	 MySQL	 Average	 </span><br><span class="line">1	 Liming	 82	 95	 86	 87.66	 </span><br><span class="line">2	 Sc	 74	 96	 87	 85.66	 </span><br><span class="line">3	 Tg	 99	 83	 93	 91.66</span><br></pre></td></tr></table></figure>

<p>如果不想把成绩当成字符串输出，而是按照整形和浮点型输出，则要这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %i\t %i\t %i\t %8.2f\t \n&#x27; $(cat test.txt | grep -v Name)</span><br><span class="line">1	 Liming	 82	 95	 86	    87.66	 </span><br><span class="line">2	 Sc	 74	 96	 87	    85.66	 </span><br><span class="line">3	 Tg	 99	 83	 93	    91.66</span><br></pre></td></tr></table></figure>



<p>b）awk基本使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;...&#x27; 文件名</span><br><span class="line">条件(Pattern)：</span><br><span class="line">    一般使用关系表达式作为条件。这些关系表达式非常多。如：</span><br><span class="line">    x &gt; 10    判断变量x是否大于10</span><br><span class="line">    x == y    判断变是x是否等于变量y</span><br><span class="line">    A`B       判断字符串A中是否包含能匹配B表达式的子字符串</span><br><span class="line">    A!`B      判断字符串A中是否不包含能匹配B表达式的子字符串</span><br><span class="line">动作(Action)：</span><br><span class="line">    格式化输出</span><br><span class="line">    流程控制语句</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出第二列和第六列</span></span><br><span class="line">[root@localhost ~]# awk &#x27;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>



<p>c）awk的条件</p>
<table>
<thead>
<tr>
<th>条件的类型</th>
<th>条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>awk保留字</td>
<td>BEGIN</td>
<td>在awk程序一开始时，尚未读取任何数据之前执行。BEGIN后的动作只在程序开始时执行一次。</td>
</tr>
<tr>
<td></td>
<td>END</td>
<td>在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td></td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td></td>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td></td>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td></td>
<td>&#x3D;&#x3D;</td>
<td>等于。用于判断两个值是否相等，如果是给变量赋值，请使用“&#x3D;”号</td>
</tr>
<tr>
<td></td>
<td>!&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td></td>
<td>A~B</td>
<td>判断字符串A中是否包含能匹配B表达式的子字符串</td>
</tr>
<tr>
<td></td>
<td>A!~B</td>
<td>判断字符串B中是否不包含能匹配B表达式的子字符串</td>
</tr>
<tr>
<td>正则表达式</td>
<td>&#x2F;正则&#x2F;</td>
<td>如果在“&#x2F;&#x2F;”中可以写入字符，也可以支持正则表达式</td>
</tr>
</tbody></table>
<ul>
<li><p>BEGIN</p>
<p>BEGIN是awk的保留字，是一种特殊的条件类型。BEGIN的执行时机是“在awk程序一开始时，尚未读取任何数据之前执行”。一旦BEGIN后的动作执行一次，当awk开始从文件中读入数据，BEGIN的条件就不再成立，所以BEGIN定义的动作只能被执行一次。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">awk命令只要检测不到完整的单引号不会执行，所以这个命令的换行不用加入<span class="string">&quot;\&quot;</span></span></span><br><span class="line">[root@localhost ~]# awk &#x27;BEGIN&#123;printf &quot;This is a transcript \n&quot;&#125; </span><br><span class="line">&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">This is a transcript </span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>
</li>
<li><p>END</p>
<p>END也是awk保留字，不过刚好和BEGIN相反。END是在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;END&#123;printf &quot;The END \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br><span class="line">The END</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算符</p>
<p>查看平均成绩大于等于87分的学员是谁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$6 &gt;= 87&#123;printf $2 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">Liming</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure>

<p>加入条件之后，只有条件成立动作才会执行，如果条件不满足，则运作不运行。通过这个实验，大家可以发现，虽然awk是列提取命令，但是也要按行来读入的。这个命令的执行过程是这样的：</p>
<p>1）如果有BEGIN条件，则先执行BEGIN定义的动作</p>
<p>2）如果没有BEGIN条件，则读入第一行，把第一行的数据依次赋予$0、$1、$2等变量。其中$0代表此行的整体数据，$1代表第一字段，$2代表第二字段。</p>
<p>3）依据条件类型判断动作是否执行。如果条件符合，则执行动作，否则读入下一行数据。如果没有条件，则每行都执行动作。</p>
<p>4）读入下一行数据，重复执行以上步骤。</p>
<p>查看Sc用户的平均成绩：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$2 ~ &quot;Sc&quot;&#123;printf $6 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">85.66</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式</p>
<p>如果想让awk识别字符串，必须使用“&#x2F;&#x2F;”包含，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印LiMing的成绩</span></span><br><span class="line">[root@localhost ~]# awk &#x27;/Liming/ &#123;print&#125;&#x27; test.txt </span><br><span class="line">1	Liming	82	95	86	87.66</span><br></pre></td></tr></table></figure>

<p>当使用df命令查看分区使用情况时，如果只想看真正的系统分区的使用状况，而不想查看光盘和临时分区的使用状况，则可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -h | awk &#x27;/sda[0-9]/ &#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>4）awk内置变量</p>
<table>
<thead>
<tr>
<th>awk内置变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>代表目前awk所读入的整行数据。我们已知awk是一行一行读入数据的，$0就代表当前读入行的整行数据。</td>
</tr>
<tr>
<td>$n</td>
<td>代表目前读入行的第n个字段。</td>
</tr>
<tr>
<td>NF</td>
<td>当前行拥有的字段(列)总数。</td>
</tr>
<tr>
<td>NR</td>
<td>当前awk所处理的行，是总数据的第几行。</td>
</tr>
<tr>
<td>FS</td>
<td>用户定义分隔符。awk的默认分隔符是任何空格，如果想要使用其他分隔符(如”：”)，就需要FS变量定义。</td>
</tr>
<tr>
<td>ARGC</td>
<td>命令行参数个数。</td>
</tr>
<tr>
<td>ARGV</td>
<td>命令行参数数组。</td>
</tr>
<tr>
<td>FNR</td>
<td>当前文件中的当前记录数(对输入文件起始为1)。</td>
</tr>
<tr>
<td>OFMT</td>
<td>数值的输出格式(默认为%.6g)。</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段的分隔符(默认为空格)。</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符(默认为换行符)。</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符(默认为换行符)。</td>
</tr>
</tbody></table>
<p>查询可以登录的用户的用户名和UID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root	0</span><br><span class="line">ben	1000</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号:&quot; NR &quot;\t 字段数: &quot; NF &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root	0	 行号:1	 字段数: 7</span><br><span class="line">ben	1000	 行号:2	 字段数: 7</span><br></pre></td></tr></table></figure>

<p>查看sshd这个伪用户的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $1==&quot;sshd&quot; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号：&quot; NR &quot;\t 字段数：&quot; NF &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>5）awk流程控制</p>
<p>统计PHP成绩的总分：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR==2&#123;php1=$3&#125; NR==3&#123;php2=$3&#125; NR==4&#123;php3=$3;total=php1+php2+php3;print &quot;total php is &quot; total&#125;&#x27; test.txt</span><br><span class="line">total php is 255</span><br></pre></td></tr></table></figure>

<ul>
<li>“NR&#x3D;&#x3D;2{php1&#x3D;$3}”：条件是NR&#x3D;&#x3D;2，动作是php1&#x3D;$3，指如果输入数据是第二行(第一行是标题行)，就把第二行的第三字段的值赋予变量“php1”。</li>
<li>“NR&#x3D;&#x3D;3{php2&#x3D;$3}”：如果输入数据是第三行，就把第三行的第三字段的值赋予变量“php2”。</li>
<li>‘NR&#x3D;&#x3D;4{php3&#x3D;$3;total&#x3D;php1+php2+php3;print “total php is “ total}’：如果输入数据是第四行，就把第四行的第三字段的值赋予变量“php3”；然后定义变量total的值为‘php1+php2+php3’；然后输出”total php is “关键字，后面加变量total的值。</li>
</ul>
<p>在awk编程中，因为命令语句非常长，在输入格式时需要注意以下内容：</p>
<ul>
<li>多个条件{动作}可以用空格分割，也可以用回车分割。</li>
<li>在一个动作中，如果需要执行多个命令，需要用“;”分割，或用回车分割。</li>
<li>在awk中，变量的赋值与调用都不需要加入“$”符。</li>
<li>条件中判断两个值是否相同，请使用”&#x3D;&#x3D;”，以便和变量赋值进行区分。</li>
</ul>
<p>如果Linux成绩大于90，就是一个好学生：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;&#123;if (NR&gt;=2)&#123;if ($3&gt;90) printf $2 &quot; is a good student!\n&quot;&#125;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure>

<p>其实awk中if判断语句，完全可以直接利用awk自带的条件来取代：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR&gt;=2&#123;test=$3&#125; test&gt;90&#123;printf $2 &quot; is a good student!\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure>



<p>6）awk函数</p>
<p>awk编程也允许在编程时使用函数，awk函数定义方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名 (参数列表) &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一简单的函数，使用函数来打印test.txt的学员姓名和平均成绩：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;function test(a,b) &#123;printf a &quot;\t&quot; b &quot;\n&quot;&#125; &#123;test($2,$6)&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>



<p>7）awk中调用脚本</p>
<p>对于小的单行程序来说，将脚本作为命令行自变量传递给awk是非常简单的，而对于多行程序就比较难处理。当程序是多行的时候，使用外部脚本是很适合的。首先在外部文件中写好脚本，然后可以使用awk的-f选项，使其读入脚本并且执行。</p>
<p>例如，我们可以先编写一个awk脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim pass.awk</span><br><span class="line">BEGIN	&#123;FS=&quot;:&quot;&#125;</span><br><span class="line">&#123;print $1 &quot;\t&quot; $3&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以使用”-f”选项来调用这个脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk -f pass.awk /etc/passwd</span><br><span class="line">root	0</span><br><span class="line">daemon	1</span><br><span class="line">bin	2</span><br><span class="line">sys	3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>sed主要是用来将数据进行选取、替换、删除和新增的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed [选项] &#x27;[动作]&#x27; 文件名</span><br><span class="line">选项：</span><br><span class="line">  -n:              一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。</span><br><span class="line">  -e:              允许对输入数据应用多条sed命令编辑。</span><br><span class="line">  -f 脚本文件名:    从sed脚本中读入sed操作。和awk命令的-f非常类似。</span><br><span class="line">  -r:              在sed中支持扩展正则表达式。</span><br><span class="line">  -i:              用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出</span><br><span class="line">动作：</span><br><span class="line">  a \n:             追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  c \n:             行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用&quot;\&quot;代表数据未完结。</span><br><span class="line">  i \n:             插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  d:               删除，删除指定的行。</span><br><span class="line">  p:               打印，输出指定的行。</span><br><span class="line">  s:               字串替换，用一个字符串替换另外一个字符串。格式为&quot;行范围 s/旧字串/新字串/g&quot;（和vim中的替换格式类似）</span><br></pre></td></tr></table></figure>

<p>对sed命令要注意，sed所做的修改并不会直接改变文件的内容(如果是用管道符接收的命令的输出，这种情况连文件都没有)，而是把修改结果只显示到屏幕上，除非使用“-i”选项才会直接修改文件。</p>
<ul>
<li><p>行数据操作</p>
<p>【查看】</p>
<p>查看test.txt的第二行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2p&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>“p”命令确实输出了第二行数据，但是sed命令还会把所有数据都输出一次。如果想指定输出某行数据，需要”-n”选项的帮助：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -n &#x27;2p&#x27; test.txt</span><br><span class="line">1       Liming  82      95      86      87.66</span><br></pre></td></tr></table></figure>



<p>【删除】</p>
<p>删除第二行到第四行的数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,4d&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件本身并没有修改</span></span><br><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>



<p>【追加】</p>
<p>“a“会在指定行后面追加入数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2a hello&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">hello</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>



<p>【插入】</p>
<p>“i”会在指定行前面插入数据:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# sed -n &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>



<p>【替换】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2c No such person&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No such person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat test.txt | sed &#x27;2c No sucn person&#x27;</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No sucn person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>sed命令默认情况下是不会修改文件内容的，如果确定需要让sed命令直接处理文件的内容，可以使用”-i”选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -i &#x27;2c No such person&#x27; test.txt</span><br></pre></td></tr></table></figure>


</li>
<li><p>字符串替换</p>
<p>“c”动作是进行整行替换的，如果仅仅想替换行中的部分数据，就要使用“s”动作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/旧字串/新字串/g&#x27; 文件名</span><br></pre></td></tr></table></figure>

<p>在第三行中，把74替换成99：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3s/74/99/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      99      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>把第四行注释掉：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;4s/^/#/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3       Tg      99      83      93      91.66</span></span><br></pre></td></tr></table></figure>

<p>“-e”选项可以同时执行多个sed动作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -e &#x27;s/Liming//g;s/Tg//g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1         82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3             99      83      93      91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f:        忽略大小写</span><br><span class="line">  -b:        忽略每行前面的空白部分</span><br><span class="line">  -n:        以数值型进行排序，默认使用字符串型排序</span><br><span class="line">  -r:        反向排序</span><br><span class="line">  -u:        删除重复行。就是uniq命令</span><br><span class="line">  -t:        指定分隔符，默认分隔符是制表符</span><br><span class="line">  -k n[,m]:  按照指定的字段范围排序。从第n字段开始，m字段结束(默认到行尾)</span><br></pre></td></tr></table></figure>

<p>sort命令默认是用每行开头第一个字符来进行排序的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort /etc/passwd</span><br><span class="line">_apt:x:105:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:109:116:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">avahi:x:115:121:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>反向排序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort -r /etc/passwd</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">whoopsie:x:120:125::/nonexistent:/bin/false</span><br><span class="line">uuidd:x:107:114::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果想要指定排序的字段，需要先使用“-t”选项指定分隔符，并使用“-k”选项指定字段号。例如按照UID字段排序&#x2F;etc&#x2F;passwd文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然“-k”选项可以直接使用“-k 3”，代表从第三字段到行尾排序（第一个字符先排序，如果一致，第二个字符再排序，直到行尾）。</p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>uniq命令是用来取消重复行的命令，其实和”sort -u”选项是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uniq [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -i:        忽略大小写</span><br></pre></td></tr></table></figure>



<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>统计命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# wc [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -l:        只统计行数</span><br><span class="line">  -w:        只统计单词数</span><br><span class="line">  -m:        只统计字符数</span><br></pre></td></tr></table></figure>



<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="按照文件类型进行判断"><a href="#按照文件类型进行判断" class="headerlink" title="按照文件类型进行判断"></a>按照文件类型进行判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b 文件</td>
<td>判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）</td>
</tr>
<tr>
<td>-c 文件</td>
<td>判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真）</td>
</tr>
<tr>
<td>-d 文件</td>
<td>判断该文件是否存在，并且是否为目录文件（是目录为真）</td>
</tr>
<tr>
<td>-e 文件</td>
<td>判断该文件是否存在（存在为真）</td>
</tr>
<tr>
<td>-f 文件</td>
<td>判断该文件是否存在，并且是否为普通文件（是普通文件为真）</td>
</tr>
<tr>
<td>-L 文件</td>
<td>判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）</td>
</tr>
<tr>
<td>-p 文件</td>
<td>判断该文件是否存在，并且是否为管道文件（是管道文件为真）</td>
</tr>
<tr>
<td>-s 文件</td>
<td>判断该文件是否存在，并且是否为非空（非空为真）</td>
</tr>
<tr>
<td>-S 文件</td>
<td>判断该文件是否存在，并且是否为套接字文件（是套接字文件为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# [ -e /root/sh/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">0        # 判断结果为0，/root/sh/目录是存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -e /root/test/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">1        # 判断结果为0，/root/test/目录是不存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -d /root/sh ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个判断命令如果正确执行，则打印<span class="string">&quot;yes&quot;</span>，否则打印<span class="string">&quot;no&quot;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="按照文件权限进行判断"><a href="#按照文件权限进行判断" class="headerlink" title="按照文件权限进行判断"></a>按照文件权限进行判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-r 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真）</td>
</tr>
<tr>
<td>-w 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有写权限（有写权限为真）</td>
</tr>
<tr>
<td>-x 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）</td>
</tr>
<tr>
<td>-u 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真）</td>
</tr>
<tr>
<td>-g 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真）</td>
</tr>
<tr>
<td>-k 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SBIT权限（有SBIT权限为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll test.txt</span><br><span class="line">-rw-rw-r-- 1 ben ben 187  2月 28 02:09 test.txt</span><br><span class="line">[root@localhost ~]# [ -w test.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="两个文件之间进行比较"><a href="#两个文件之间进行比较" class="headerlink" title="两个文件之间进行比较"></a>两个文件之间进行比较</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>文件1 -nt 文件2</td>
<td>判断文件1的修改时间是否比文件2的新（如果新则为真）</td>
</tr>
<tr>
<td>文件1 -ot 文件2</td>
<td>判断文件1的修改时间是否比文件2的旧（如果旧则为真）</td>
</tr>
<tr>
<td>文件1 -ef 文件2</td>
<td>判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建个硬链接</span></span><br><span class="line">[root@localhost ~]# ln /tmp/test.txt /tmp/stu.txt</span><br><span class="line">[root@localhost ~]# [ /tmp/test.txt -ef /tmp/stu.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="两个整数之间比较"><a href="#两个整数之间比较" class="headerlink" title="两个整数之间比较"></a>两个整数之间比较</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>整数1 -eq 整数2</td>
<td>判断整数1是否和整数2相等（相等为真）</td>
</tr>
<tr>
<td>整数1 -ne 整数2</td>
<td>判断整数1是否和整数2不相等（不相等为真）</td>
</tr>
<tr>
<td>整数1 -gt 整数2</td>
<td>判断整数1是否大于整数2（大于为真）</td>
</tr>
<tr>
<td>整数1 -lt 整数2</td>
<td>判断整数1是否小于整数2（小于为真）</td>
</tr>
<tr>
<td>整数1 -ge 整数2</td>
<td>判断整数1是否大于等于整数2（大于等于为真）</td>
</tr>
<tr>
<td>整数1 -le 整数2</td>
<td>判断整数1是否小于等于整数2（小于等于为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# [ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br><span class="line">[root@localhost ~]# [ 23 -le 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-z 字符串</td>
<td>判断字符串是否为空（为空返回真）</td>
</tr>
<tr>
<td>-n 字符串</td>
<td>判断字符串是否为非空（非空返回真）</td>
</tr>
<tr>
<td>字符串1 &#x3D;&#x3D; 字符串2</td>
<td>判断字符串1是否和字符串2相等（相等返回真）</td>
</tr>
<tr>
<td>字符串1 !&#x3D; 字符串2</td>
<td>判断字符串1 是否和字符串2不相等（不相等返回真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给name赋值</span></span><br><span class="line">[root@localhost ~]# name=ben</span><br><span class="line">[root@localhost ~]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# bb=22</span><br><span class="line">[root@localhost ~]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>判断1 -a 判断2</td>
<td>逻辑与，判断1和判断2都成立，最终的结果为真</td>
</tr>
<tr>
<td>判断1 -o 判断2</td>
<td>逻辑或，判断1和判断2有一个成立，最终的结果就为真</td>
</tr>
<tr>
<td>! 判断</td>
<td>逻辑非，使原始的判断式取反</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line">[root@localhost ~]# [ ! -n &quot;$aa&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>“!”和“-n”之间必须加入空格，否则会报错的。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h4><p>a）单分支if条件语句</p>
<p>单分支条件语句最为简单，就是只有一个判断条件，如果符合条件则执行某个程序，否则什么事情都不做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>单分支条件语句需要注意几个点：</p>
<ul>
<li><p>if语句使用fi结尾，和一般语言使用大括号结尾不同。</p>
</li>
<li><p>[ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格。</p>
</li>
<li><p>then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">	then</span><br><span class="line">		程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda3&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f1)</span><br><span class="line">if [ $rate -ge 80 ];then</span><br><span class="line">	echo &quot;Warning! /dev/sda3 is full!!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>b）双分支if条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]；then</span><br><span class="line">	条件成立时，执行的程序</span><br><span class="line">else</span><br><span class="line">	条件不成立时，执行的另一个程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步系统时间</span></span><br><span class="line">ntpdate asia.pool.ntp.org &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把当前系统时间按照<span class="string">&quot;年月日&quot;</span>格式赋予变量<span class="built_in">date</span></span></span><br><span class="line">date=$(date +%y%m%d)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计mysql数据库的大小，并把大小赋予size变量</span></span><br><span class="line">size=$(du -sh /var/lib/mysql)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断备份目录是否存在，是否为目录</span></span><br><span class="line">if [ -d  /tmp/dbak ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">	echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">	echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入备份目录</span></span><br><span class="line">	cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">	tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除临时文件</span></span><br><span class="line">	rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果判断为假，则建立备份目录</span></span><br><span class="line">	mkdir /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">	echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">	echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入备份目录</span></span><br><span class="line">	cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">	tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除临时文件</span></span><br><span class="line">	rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>在工作中，服务器上的服务经常会宕机。如果我们对服务器监控不好，就会造成服务器中服务宕机了，而管理员却不知道的情况，这时我们可以写一个脚本来监听本机的服务，如果服务停止或宕机了，可以自动重启这些服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用nmap命令扫描服务器，并截取apache服务的状态，赋予变量port</span></span><br><span class="line">port=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">if [ &quot;$port&quot; == &quot;open&quot; ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">则证明apache正常启动，在正常日志中写入一句话即可</span></span><br><span class="line">	echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/autostart-acc.log</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">否则证明apache没有启动，自动启动apache</span></span><br><span class="line">	/etc/rc.d/init.d/httpd start &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">并在错误日志中记录自动启动apache的时间</span></span><br><span class="line">	echo &quot;$(date) restart httpd!!&quot; &gt;&gt; /tmp/autostart-err.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>c）多分支if条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式1 ];then</span><br><span class="line">	当条件判断式1成立时，执行程序1</span><br><span class="line">elif [ 条件判断式2 ];then</span><br><span class="line">	当条件判断式2成立时，执行程序2</span><br><span class="line">else</span><br><span class="line">	当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>判断用户输入的是什么文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">！/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email:17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接收键盘的输入，并赋予变量file</span></span><br><span class="line">read -p &quot;Please input a filename: &quot; file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file变量是否为空</span></span><br><span class="line">if [ -z &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;Error,please input a filename&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出程序，并返回1</span></span><br><span class="line">	exit 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否存在</span></span><br><span class="line">elif [ ! -e &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;Your input is not a file!&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出程序，并返回2</span></span><br><span class="line">	exit 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为普通文件</span></span><br><span class="line">elif [ -f &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;$file is a regulare file!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为目录文件</span></span><br><span class="line">elif [ -d &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;$file is a directory!&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;$file is an other file!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="多分支case条件语句"><a href="#多分支case条件语句" class="headerlink" title="多分支case条件语句"></a>多分支case条件语句</h4><p>case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">	&quot;值1&quot;)</span><br><span class="line">		如果变量的值等于值1，则执行程序1</span><br><span class="line">		;;</span><br><span class="line">	&quot;值2&quot;)</span><br><span class="line">		如果变量的值等于值2，则执行程序2</span><br><span class="line">		;;</span><br><span class="line">	...</span><br><span class="line">	*)</span><br><span class="line">		如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">		;;</span><br><span class="line">esac	</span><br></pre></td></tr></table></figure>

<p>这个语句需要注意以下内容：</p>
<ul>
<li><p>case语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行“*)”（“*”代表所有其他值）中的程序。</p>
</li>
<li><p>case语句以“case”开头，以“esac”结尾。</p>
</li>
<li><p>每个分支程序之后要通过“;;”双分号结尾，代表该程序段结束。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please choose yes/no: &quot; -t 30 cho</span><br><span class="line">case $cho in </span><br><span class="line">	&quot;yes&quot;)</span><br><span class="line">		echo &quot;Your choose is yes!&quot;</span><br><span class="line">		;;</span><br><span class="line">	&quot;no&quot;)</span><br><span class="line">		echo &quot;Your choose is no!&quot;</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		echo &quot;Your choose is error!&quot;</span><br><span class="line">		;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环是固定循环，也就是在循环时已经知道需要进行几次循环，有时也把for循环称为计数循环。</p>
<p>语法一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>这种语法中for循环的次数，取决于in后面值的个数（空格分隔），有几个值就循环几次，并且每次循环都把值赋予变量。</p>
<p>打印时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for time in morning noon afternoon evening</span><br><span class="line">	do</span><br><span class="line">		echo &quot;This time is $time&quot;</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>批量解压缩脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入压缩目录</span></span><br><span class="line">cd /lamp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把所有tar.gz结尾的文件的文件覆盖到ls.log临时文件中</span></span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line">for i in $(cat ls.log)</span><br><span class="line">	do</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">解压缩</span></span><br><span class="line">		tar -zxf $i &amp;&gt;/dev/null</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件ls.log</span></span><br><span class="line">rm -rf /lamp/ls.log</span><br></pre></td></tr></table></figure>



<p>语法二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>这种语法需要注意：</p>
<ul>
<li>初始值：在循环开始时，需要给某个变量赋予初始值，如i&#x3D;1;</li>
<li>循环控制条件：用于指定变量循环的次数，如i&lt;&#x3D;100，则只要i的值小于等于100，循环就会继续;</li>
<li>变量变化：每次循环之后，变量该如何变化，如i&#x3D;i+1。代表每次循环之后，变量i的值都加1。</li>
</ul>
<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for (( i=1;i&lt;=100;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum of 1+2+...+100 is : $s&quot;</span><br></pre></td></tr></table></figure>

<p>批量添加指定数量的用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入用户名，把输入保存入变量name</span></span><br><span class="line">read -p &quot;Please input user name: &quot; -t 30 name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入添加用户的数量，把输入保存入变量num</span></span><br><span class="line">read -p &quot;Please input the number of users: &quot; -t num</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入初始密码，把输入保存入变量pass</span></span><br><span class="line">read -p &quot;Please input the password of users: &quot; -t pass</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断三个变量不为空</span></span><br><span class="line">if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;#pass&quot; ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">判断变量num的值是否为数字</span></span><br><span class="line">	y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line">	if [ -z &quot;$y&quot; ];then</span><br><span class="line">		for (( i=1;i&lt;=$num;i=i+1 ))</span><br><span class="line">			do</span><br><span class="line">				# 添加用户</span><br><span class="line">				/usr/sbin/useradd $name$i &amp;&gt;/dev/null</span><br><span class="line">				# 修改用户密码</span><br><span class="line">				echo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null</span><br><span class="line">			done</span><br><span class="line">	fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>批量删除用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">user=$(cat /etc/passwd | grep &quot;/bin/bash&quot; | grep -v &quot;root&quot; | cut -d &quot;:&quot; -f 1)</span><br><span class="line">for i in $user</span><br><span class="line">	do</span><br><span class="line">		userdel -r $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>对while循环来讲，只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。</p>
<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+ 1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure>



<h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><p>until循环和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ 条件判断式 ]</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">until [ $i -gt 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure>



<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名（）&#123;</span><br><span class="line">	程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">function sum () &#123;</span><br><span class="line">	s=0</span><br><span class="line">	for (( i=0;i&lt;=$1;i=i+1 ))</span><br><span class="line">		do</span><br><span class="line">			s=$(( $i+$s ))</span><br><span class="line">		done</span><br><span class="line">	echo &quot;The sum of 1+2+3+...+$l is: $s&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line">y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line"></span><br><span class="line">if [ -z $y ];then</span><br><span class="line">	sum $num</span><br><span class="line">else</span><br><span class="line">	echo &quot;Error!! Please input a number!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="特殊流程控制语名"><a href="#特殊流程控制语名" class="headerlink" title="特殊流程控制语名"></a>特殊流程控制语名</h4><p>a）exit语句</p>
<p>系统是有exit命令的，用于退出当前用户的登录状态。可是在shell脚本中，exit语句是用来退出当前脚本的。也就是说，在Shell脚本中，只要碰到了exit语句，后续的程序就不再执行，而是直接退出脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit [返回值]</span><br></pre></td></tr></table></figure>

<p>如果exit命令之后定义了返回值，那么这个脚本执行之后的返回值就是我们自己定义的返回值。可以通过$?这个变量来查看返回值。如果exit之后没有定义返回值，脚本执行之后的返回值是执行exit语句之前，最后执行的一条命令的返回值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line"></span><br><span class="line">y=$(echo $num | sed &quot;s/[0-9]//g&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断变量num的值如果不为空，则输出报错信息，并且退出脚本，退出返回值为18</span></span><br><span class="line">[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18</span><br><span class="line"></span><br><span class="line">echo &quot;The number is: $num&quot;</span><br></pre></td></tr></table></figure>



<p>b）break语句</p>
<p>当程序执行到break语句时，会结束整个当前循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		if [ $i -eq 4 ];then</span><br><span class="line">			break</span><br><span class="line">		fi</span><br><span class="line">		echo $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<p>c）continue语句</p>
<p>continue也是结束流程控制的语句。continue语句只会结束单次当前循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		if [ $i -eq 4 ];then</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		echo $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/25/%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="E-mail:17620170099@163.com">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/25/%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">高级文件系统管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-25 13:05:22 / 修改时间：13:10:07" itemprop="dateCreated datePublished" datetime="2025-02-25T13:05:22+08:00">2025-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高级文件系统管理"><a href="#高级文件系统管理" class="headerlink" title="高级文件系统管理"></a>高级文件系统管理</h1><h2 id="1-磁盘配额"><a href="#1-磁盘配额" class="headerlink" title="1. 磁盘配额"></a>1. 磁盘配额</h2><h3 id="1）磁盘配额条件"><a href="#1）磁盘配额条件" class="headerlink" title="1）磁盘配额条件"></a>1）磁盘配额条件</h3><ul>
<li><p>内核必须支持磁盘配额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep CONFIG_QUOTA /boot/config-2.6.32-279.el6.i686</span><br><span class="line">CONFIG_QUOTA=y</span><br><span class="line">CONFIG_QUOTA_NETLINK_INTERFACE=y</span><br><span class="line"># CONFIG_QUOTA_DEBUG is not set</span><br><span class="line">CONFIG_QUOTA_TREE=m</span><br><span class="line">CONFIG_QUOTACTL=y</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统中必须安装了quota工具，Linux默认是安装了quota工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa | grep quota</span><br><span class="line">quota-3.17-16.el6.i686</span><br></pre></td></tr></table></figure>

<p>要支持磁盘配额的分区必须开启磁盘配额功能，这个功能需要手工开启，不再是默认就开启的。</p>
</li>
</ul>
<h3 id="2）概念"><a href="#2）概念" class="headerlink" title="2）概念"></a>2）概念</h3><ul>
<li>用户配额和组配额</li>
<li>磁盘容量限制和文件个数限制</li>
<li>软限制和硬限制</li>
<li>宽限时间</li>
</ul>
<p>如果用户的空间占用数处于软限制和硬限制之间，都会在用户登录时警告用户磁盘将满，这个时间就是宽限时间，默认是7天。如果达到了宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级为硬限制。</p>
<h3 id="3）磁盘配额规划"><a href="#3）磁盘配额规划" class="headerlink" title="3）磁盘配额规划"></a>3）磁盘配额规划</h3><p>磁盘配额实验：</p>
<ul>
<li>磁盘配额是限制普通用户在分区上使用磁盘空间和文件个数的，所以我们需要指定一个分区，那么我们手工建立一个5GB的&#x2F;dev&#x2F;sdb1分区，把它挂载到&#x2F;disk目录当中。</li>
<li>还有我们需要建立被限制的用户和用户组。那么我们假设需要限制user1、user2和user3用户，这三个用户属于test组。</li>
<li>其中test组磁盘容量硬限制为500MB，软限制450MB，文件个数不做限制。user1用户为了便于测试，磁盘容量硬限制为50MB，软限制为40MB，文件个数硬限制为10个，软限制为8个。user2和user3用户磁盘容量硬限制为250MB，软限制为200MB，文件个数不做限制。</li>
<li>user1、user2和user3用户加起来的磁盘容量限制为550MB，超过了test组的磁盘容量500MB。这样的话，某个用户可能达不到自己的用户限制，而达到组限制时就不能再写入数据了。也就是说，如果用户限制和组限制同时存在，那么哪个限制更小，哪个限制优先生效。</li>
<li>系统宽限时间改为8天。</li>
</ul>
<p>磁盘配额步骤：</p>
<ul>
<li><p>分配5GB的&#x2F;dev&#x2F;sdb1分区，并将它挂载到&#x2F;disk目录当中。</p>
</li>
<li><p>建立需要做限制的用户和用户组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd test</span><br><span class="line">[root@localhost ~]# useradd -G test user1</span><br><span class="line">[root@localhost ~]# useradd -G test user2</span><br><span class="line">[root@localhost ~]# useradd -G test user3</span><br><span class="line">[root@localhost ~]# passwd user1</span><br><span class="line">[root@localhost ~]# passwd user2</span><br><span class="line">[root@localhost ~]# passwd user3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在分区上开启磁盘配额功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,usruota,grpquota /disk    # 重新挂载/disk分区，并加入用户和用户组的磁盘配额功能</span><br></pre></td></tr></table></figure>

<p>要想永久生效，则需要修改&#x2F;etc&#x2F;fstab文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1    /disk    ext4    defaults,usrquota,grpquota    0    0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /disk    # 修改配置文件如果想要生效，必须重启系统，否则也需要把分区重新挂载一遍</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立磁盘配额的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：扫描/etc/mtab文件中所有启用磁盘配额功能的分区。如果加入此参数，命令后面就不需要加入分区名了</span><br><span class="line">  -c：不管原有的配置文件，重新扫描并建立新的配置文件</span><br><span class="line">  -u：建立用户配额的配置文件，也就是生成aquota.user文件</span><br><span class="line">  -g：建立组配额的配置文件，会生成aquota.group文件</span><br><span class="line">  -v：显示扫描过程</span><br><span class="line">  -m：强制以读写的方式扫描文件系统，和-M类似。一般扫描根分区时使用。</span><br><span class="line">  -f：强制扫描文件系统，并写入新的配置文件。一般扫描新添加的硬盘分区时使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck -avug</span><br></pre></td></tr></table></figure>

<p>需要关闭SELinux，否则会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /disk/</span><br><span class="line">总计 24</span><br><span class="line">-rw-------   1 root root  6144  4月 31 19:30 aquota.group</span><br><span class="line">-rw-------   1 root root  6144  4月 18 19:30 aquota.user</span><br><span class="line"># /disk目录中两个配额配置文件已经建立</span><br></pre></td></tr></table></figure>

<p>如果需要给根分区开启配额功能，需要：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2    /    ext4    defaults,usrquota,grpquota    1    1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /</span><br><span class="line">[root@localhost ~]# quotacheck -avugm</span><br></pre></td></tr></table></figure>

<p>如果我们自动扫描&#x2F;分区建立配额文件时，因为&#x2F;分区已经挂载成读写系统，而quotacheck需要把分区先挂载成只读分区，然后建立配置文件，最后再挂载回来，所以不能直接在&#x2F;分区建立配置文件，这时就需要使用-m强制以读写方式扫描文件系统了。</p>
<ul>
<li><p>设置用户和组的配额限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：  设定用户配额</span><br><span class="line">  -g 组名：    设定组配额</span><br><span class="line">  -t：        设定宽限时间</span><br><span class="line">  -p：        复制配额限制。如果已经设定好某个用户的配额限制，其他用户的配额限制如果和这个用户相同，那么可以直接复制配额限制，而不用都手工指定</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota -u user1</span><br><span class="line"># edquota命令进入之后，就是标准的vi操作方法</span><br><span class="line">Disk quotas for user user1（uid 500）：</span><br><span class="line"># 磁盘配额是设定用户user1（UID是500）</span><br><span class="line">Filesystem    blocks        soft     hard     inodes        soft      hard</span><br><span class="line">/dev/sdb1       0           40000    50000      0            8         10</span><br><span class="line"># 分区名        已占用容量    软限制    硬限制     已占用文件数   软限制     硬限制</span><br></pre></td></tr></table></figure>
</li>
<li><p>配额复制</p>
<p>user3用户的配额值和user2用户完全一样，就可以使用user2用户作为模板进行复制，这样我们如果需要建立大量的配额值一致的用户时，就会非常方便，不用一个个手工建立了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota -p user2 -u user3</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改宽限时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota -t</span><br><span class="line">Grace period before enforcing soft limits for users:</span><br><span class="line">Time units may be: days, hours, minutes, or seconds</span><br><span class="line">Filesystem    Block grace period    Inode grace period</span><br><span class="line">/dev/sdb1       8days                8days</span><br><span class="line"># 分区名        容量的宽限时间          个数的宽限时间</span><br></pre></td></tr></table></figure>


</li>
<li><p>启动和关闭配额</p>
<p>启动配额：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotaon [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件启动所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：启动用户配额</span><br><span class="line">  -g：启动组配额</span><br><span class="line">  -v：显示启动过程的信息</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quotaon -vug /disk/        # 启动/disk分区的配额</span><br><span class="line">/dev/sdb1 [/disk]：group quotas turned on</span><br><span class="line">/dev/sdb1 [/disk]：user quotas turned on</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# quotaon -avug        # 这条命令也可以</span><br></pre></td></tr></table></figure>

<p>关闭配额：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotaoff [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件关闭所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：关闭用户配额</span><br><span class="line">  -g：关闭组配额</span><br><span class="line">  </span><br><span class="line"> [root@localhost ~]# quotaoff -a        # 依据/etc/mtab文件关闭配额分区</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4）磁盘配额查询"><a href="#4）磁盘配额查询" class="headerlink" title="4）磁盘配额查询"></a>4）磁盘配额查询</h3><ul>
<li><p>quota查询用户或用户组配额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：   查询用户配额</span><br><span class="line">  -g 组名：     查询组配额</span><br><span class="line">  -v：          显示详细信息</span><br><span class="line">  -s：          以习惯单位显示容量大小，如M,G</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quota -uvs user1</span><br></pre></td></tr></table></figure>
</li>
<li><p>repquota查询文件系统配额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# repquota [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：    依据/etc/mtab文件查询配额，如果不加-a选项，就一定要加分区名</span><br><span class="line">  -u：    查询用户配额</span><br><span class="line">  -g:     查询组配额</span><br><span class="line">  -v：    显示详细信息</span><br><span class="line">  -s：    以习惯单位显示容量大小</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# repquota -augvs</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5）测试"><a href="#5）测试" class="headerlink" title="5）测试"></a>5）测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[user1@localhost disk]$ dd if=/dev/zero of=/disk/testfile bs=1M count=60    # 建立testfile文件，指定大小60MB</span><br></pre></td></tr></table></figure>



<h3 id="6）非交互设定用户磁盘配额"><a href="#6）非交互设定用户磁盘配额" class="headerlink" title="6）非交互设定用户磁盘配额"></a>6）非交互设定用户磁盘配额</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">[root@localhost ~]# setquota -u user4 10000 20000 5 8 /disk</span><br></pre></td></tr></table></figure>



<h2 id="2-LVM逻辑卷管理"><a href="#2-LVM逻辑卷管理" class="headerlink" title="2. LVM逻辑卷管理"></a>2. LVM逻辑卷管理</h2><h3 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h3><p>LVM是Logical Volume Manager的简称，中文就是逻辑卷管理。</p>
<ul>
<li>物理卷(PV, Physical Volume)：就是真正的物理硬盘或分区。</li>
<li>卷组(VG, Volume Group)：将多个物理卷合起来就组成了卷组，组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘上的不同分区，可以把卷组想象为一个逻辑硬盘。</li>
<li>逻辑卷(LV, Logical Volume)：卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区称作逻辑卷，逻辑卷可以格式化和写入数据。可以把逻辑卷想象成为分区。</li>
<li>物理扩展(PE, Physical Extend)：PE是用来保存数据的最小单元，数据实际上都是写入PE当中，PE的大小是可以配置的，默认是4MB。</li>
</ul>
<h3 id="2）建立LVM的步骤"><a href="#2）建立LVM的步骤" class="headerlink" title="2）建立LVM的步骤"></a>2）建立LVM的步骤</h3><ul>
<li>首先需要把物理硬盘分成分区，当然也可以是整块物理硬盘。</li>
<li>然后把物理分区建立成为物理卷(PV)，也可以直接把整块硬盘都建立为物理卷。</li>
<li>接下来把物理卷整合成为卷组(VG)。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。</li>
<li>最后就是把卷组再划分成为逻辑卷(LV)，当然逻辑卷也是可以直接调整大小的。逻辑卷可以想象成为分区，所以也需要格式化和挂载。</li>
</ul>
<h3 id="3）物理卷管理"><a href="#3）物理卷管理" class="headerlink" title="3）物理卷管理"></a>3）物理卷管理</h3><p>a）硬盘分区</p>
<p>创建方式就是使用fdisk交互命令，不过需要注意的是分区的系统ID不再是Linux默认的分区ID号(83)了，而要改为LVM的ID号8e。</p>
<p>b）建立物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate [设备文件名]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"># 把整块硬盘都建立成物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb</span><br><span class="line"></span><br><span class="line"># 把分区建立成为物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb5</span><br></pre></td></tr></table></figure>



<p>c）查看物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvscan</span><br><span class="line">[root@localhost ~]# pvdisplay        # 更详细的物理卷信息</span><br></pre></td></tr></table></figure>



<p>d）删除物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvremove /dev/sdb5</span><br></pre></td></tr></table></figure>



<h3 id="4）卷组管理"><a href="#4）卷组管理" class="headerlink" title="4）卷组管理"></a>4）卷组管理</h3><p>a）建立卷组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate [选项] 卷组名 物理卷名</span><br><span class="line">[选项]：</span><br><span class="line">  -s PE大小    指定PE的大小，单位可以是MB,GB,TB等。如是不写默认PE大小为4MB</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6</span><br></pre></td></tr></table></figure>



<p>b）查看卷组</p>
<p>查看卷组的命令有两个：</p>
<ul>
<li><p>vgscan</p>
<p>vgscan主要是查看系统中是否有卷组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgscan</span><br></pre></td></tr></table></figure>
</li>
<li><p>vgdisplay</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgdisplay</span><br></pre></td></tr></table></figure></li>
</ul>
<p>c）增加卷组容量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgextend scvg /dev/sdb7</span><br></pre></td></tr></table></figure>



<p>d）减小卷组容量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在卷组中删除/dev/sdb7物理卷</span><br><span class="line">[root@localhost ~]# vgreduce scvg /dev/sdb7</span><br><span class="line"># 删除所有的未使用物理卷</span><br><span class="line">[root@localhost ~]# vgreduce -a</span><br></pre></td></tr></table></figure>



<p>e）删除卷组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgremove scvg</span><br></pre></td></tr></table></figure>

<p>卷组删除之后，才能删除物理卷，要注意的是scvg卷组还没有添加任何的逻辑卷，如果拥有了逻辑卷，得先删除逻辑卷再删除卷组。</p>
<h3 id="5）逻辑卷管理"><a href="#5）逻辑卷管理" class="headerlink" title="5）逻辑卷管理"></a>5）逻辑卷管理</h3><p>a）建立逻辑卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate [选项] [-n 逻辑卷名] 卷组名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：指定逻辑卷大小，单位MB，GB，TB等</span><br><span class="line">  -l 个数：按照PE个数指定逻辑卷大小，这个参数需要换算容量，太麻烦</span><br><span class="line">  -n 逻辑卷名：指定逻辑卷名</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate -L 1.5G -n userlv scvg    # 在scvg卷组中建立1.5GB的userlv逻辑卷</span><br></pre></td></tr></table></figure>

<p>建立完成逻辑卷之后，还要格式化和挂载之后逻辑卷才能正常使用。不过需要注意的是逻辑卷的设备文件名是&#x2F;dev&#x2F;卷组名&#x2F;逻辑卷名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t ext4 /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# mkdir /disklvm</span><br><span class="line">[root@localhost ~]# mount /dev/scvg/userlv /disklvm/</span><br><span class="line">[root@localhost ~]# mount      # 查看挂载</span><br></pre></td></tr></table></figure>

<p>如果需要开机自动挂载，也要修改&#x2F;etc&#x2F;fstab文件。</p>
<p>b）查看逻辑卷</p>
<p>查看命令有两个：</p>
<ul>
<li><p>lvscan</p>
<p>lvscan只能看到系统中是否拥有逻辑卷。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvscan</span><br></pre></td></tr></table></figure>
</li>
<li><p>lvdisplay</p>
<p>lvdisplay可以看到逻辑卷的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvdisplay</span><br></pre></td></tr></table></figure></li>
</ul>
<p>c）调整逻辑卷大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvresize [选项] 逻辑卷设备文件名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：安装容量调整大小，单位KB,GB,TB等。使用+代表增加空间，-号代表减少空间。如果直接写容量，代表设定逻辑卷大小为指定大小。</span><br><span class="line">  -l 个数：按照PE个数调整逻辑卷大小</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvresize -L 2.5.G /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# lvdisplay               # 逻辑卷的大小已经改变了</span><br><span class="line">[root@localhost ~]# df -h /disklvm/         # 大小没有变化</span><br></pre></td></tr></table></figure>

<p>lvresize只能改变逻辑卷的大小，如果需要让分区使用这个新逻辑卷，还要使用resize2fs命令来调整分区的大小。不过这里体现了LVM的优势，不需要卸载分区，直接就能调整分区的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs [选项] [设备文件名] [调整的大小]</span><br><span class="line">选项：</span><br><span class="line">  -f：    强制调整</span><br><span class="line">  设备文件名：指定调整哪个分区的大小</span><br><span class="line">  调整的大小：指定把分区调整到多大，要加M,G等单位。如果不加大小，会使用整个分区</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# df -h /disklvm/       # 已经调整过来了</span><br></pre></td></tr></table></figure>



<h3 id="4）删除逻辑卷"><a href="#4）删除逻辑卷" class="headerlink" title="4）删除逻辑卷"></a>4）删除逻辑卷</h3><p>删除逻辑卷前要先卸载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvremove 逻辑卷设备文件名</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ben</p>
  <div class="site-description" itemprop="description">E-mail:17620170099@163.com</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ben</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
