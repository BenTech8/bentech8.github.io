<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"bentech8.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Ben">
<meta property="og:url" content="https://bentech8.github.io/index.html">
<meta property="og:site_name" content="Ben">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Ben">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://bentech8.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Ben</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Ben" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Ben</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">个人学习笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/BenTech8/bentech8.github.io.git" class="github-corner" title="BenTech8 GitHub" aria-label="BenTech8 GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/03/05/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/05/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">服务管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-03-05 15:31:39 / 修改时间：17:26:04" itemprop="dateCreated datePublished" datetime="2025-03-05T15:31:39+08:00">2025-03-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="服务的简介与分类"><a href="#服务的简介与分类" class="headerlink" title="服务的简介与分类"></a>服务的简介与分类</h2><h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><p>Linux服务：</p>
<ul>
<li><p>RPM包默认安装的服务</p>
<ul>
<li><p>独立的服务</p>
<p>就是独立启动的意思，这类型的服务可以自行启动，而不用依赖其他的管理服务。不依赖其他管理服务，那么当客户端请求访问时，独立的服务响应请求更迅速。Linux中目前大多数服务都是独立的服务，比如apache服务，FTP服务，Samba服务等。</p>
</li>
<li><p>基于xinetd服务</p>
<p>这种服务就不能独立启动了，而是要依靠管理服务来调用这种服务。这个负责管理的服务就是xinetd服务，xinetd服务是系统的超级守护进程。xinetd服务的作用就是管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务云唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释放资源。这样做的好处是只需要持续启动xinetd服务，而其他基于xinetd的服务只有在需要时才启动，不会占用过多的服务器资源。但是这种服务由于在有客户端靖求时才会被唤醒，所以响应时间相对较慢。</p>
</li>
</ul>
</li>
<li><p>源码包安装的服务</p>
</li>
</ul>
<h3 id="查询已经安装的服务"><a href="#查询已经安装的服务" class="headerlink" title="查询已经安装的服务"></a>查询已经安装的服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --list [服务名]</span><br><span class="line">选项：</span><br><span class="line">  --list: 列出所有RPM默认安装服务的自启动状态</span><br></pre></td></tr></table></figure>



<h2 id="RPM包默认安装的服务管理"><a href="#RPM包默认安装的服务管理" class="headerlink" title="RPM包默认安装的服务管理"></a>RPM包默认安装的服务管理</h2><h3 id="独立服务管理"><a href="#独立服务管理" class="headerlink" title="独立服务管理"></a>独立服务管理</h3><h4 id="独立服务的启动管理"><a href="#独立服务的启动管理" class="headerlink" title="独立服务的启动管理"></a>独立服务的启动管理</h4><ul>
<li><p>使用&#x2F;etc&#x2F;init.d&#x2F;目录中的启动脚本启动服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /etc/init.d/httpd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用service命令来启动独立的服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service [独立服务名] start|stop|restart|...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="独立服务的自启动管理"><a href="#独立服务的自启动管理" class="headerlink" title="独立服务的自启动管理"></a>独立服务的自启动管理</h4><ul>
<li><p>使用chkconfig服务自启动管理命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig [--level 运行级别] [独立服务名] [on|off]</span><br><span class="line">选项：</span><br><span class="line">  --level:    设定在哪个运行级别中开机自启动(on)，或是关闭自启动(off)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --level 2345 httpd on</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件，设置服务自启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/etc/rc.d/init.d/httpd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ntsysv命令管理自启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ntsysv [--level 运行级别]</span><br><span class="line">选项：</span><br><span class="line">  --level 运行级别:  可以指定设定自启动的运行级别</span><br></pre></td></tr></table></figure>

<p>这个命令的操作是这样的：</p>
<ul>
<li>上下键：在不同服务之间移动</li>
<li>空格键：选定或取消服务的自启动，就是在服务之前是否打入“*”</li>
<li>tab键：在不同项目间切换</li>
<li>F1键：显示服务的说明</li>
</ul>
</li>
</ul>
<h3 id="基于xinetd服务的管理"><a href="#基于xinetd服务的管理" class="headerlink" title="基于xinetd服务的管理"></a>基于xinetd服务的管理</h3><h4 id="基于xinetd服务的启动"><a href="#基于xinetd服务的启动" class="headerlink" title="基于xinetd服务的启动"></a>基于xinetd服务的启动</h4><p>以telnet服务为例，telnet服务是用来进行系统远程管理的，端口是23。不过需要注意的是telnet的远程管理数据在网络中是明文传输，非常不安全。在生产服务器上不建议启动telnet服务。在生产服务器上，远程管理使用的是ssh协议，ssh是加密的，更加安全。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default: on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: The telnet server serves telnet sessions: it uses \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#       unencrypted username/password pairs for authentication.</span></span></span><br><span class="line">service telnet                                     # 服务的名称为telnet</span><br><span class="line">&#123;</span><br><span class="line">	flags				= REUSE                    # 标志为REUSE，设定TCP/IP socket可重用</span><br><span class="line">	socket_type         = stream                   # 使用TCP协议数据包</span><br><span class="line">	wait				= no					   # 允许多个连接同时连接</span><br><span class="line">	user				= root					   # 启动服务的用户为root</span><br><span class="line">	server				= /usr/sbin/in.telnetd     # 服务的启动程序</span><br><span class="line">	log_on_failure		+= USERID                  # 登录失败后，记录用户的ID</span><br><span class="line">	disable				= yes					   # 服务不启动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	disable				= no</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# service xinetd restart</span><br></pre></td></tr></table></figure>



<h4 id="基于xinetd服务的自启动"><a href="#基于xinetd服务的自启动" class="headerlink" title="基于xinetd服务的自启动"></a>基于xinetd服务的自启动</h4><ul>
<li><p>使用chkconfig命令管理自启动</p>
</li>
<li><p>使用ntsysv命令管理自启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig 服务名 on|off</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码包安装的服务管理"><a href="#源码包安装的服务管理" class="headerlink" title="源码包安装的服务管理"></a>源码包安装的服务管理</h2><h3 id="源码包服务的启动管理"><a href="#源码包服务的启动管理" class="headerlink" title="源码包服务的启动管理"></a>源码包服务的启动管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/apache2/bin/apachectl start|stop|restart|...</span><br></pre></td></tr></table></figure>



<h3 id="源码包服务的自启动管理"><a href="#源码包服务的自启动管理" class="headerlink" title="源码包服务的自启动管理"></a>源码包服务的自启动管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/usr/local/apache2/bin/apachectl start</span><br></pre></td></tr></table></figure>



<h2 id="Linux中常见服务的作用"><a href="#Linux中常见服务的作用" class="headerlink" title="Linux中常见服务的作用"></a>Linux中常见服务的作用</h2><table>
<thead>
<tr>
<th>服务名称</th>
<th>功能简介</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>acpid</td>
<td>电源管理接口。如果是笔记本用户建立开启，可以监听内核层的相关电源事件</td>
<td>on</td>
</tr>
<tr>
<td>anacron</td>
<td>系统的定时任务程序。cron的一个子系统，如果定时任务错过了执行时间，可以通过anacron继续唤醒执行。</td>
<td>off</td>
</tr>
<tr>
<td>alsasound</td>
<td>Alsa声卡驱动。如果使用alsa声卡，开启</td>
<td>off</td>
</tr>
<tr>
<td>apmd</td>
<td>电源管理模块。如果支持acpid，就不需要apmd，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>atd</td>
<td>指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用crond来进行循环定时任务。</td>
<td>off</td>
</tr>
<tr>
<td>auditd</td>
<td>审核子系统。如果开启了此服务，SELinux的审核信息会写入&#x2F;var&#x2F;log&#x2F;audit&#x2F;audit.log文件，如果不开启，审核信息会记录在syslog中</td>
<td>on</td>
</tr>
<tr>
<td>autofs</td>
<td>让服务器可以自动挂载网络中的其他服务器的共享数据，一般用来自动挂载NFS服务。如果没有NFS服务建立关闭</td>
<td>off</td>
</tr>
<tr>
<td>avahi-daemon</td>
<td>Avahi是zeroconf协议的实现。它可以在没有DNS服务的局域网里发现基于zeroconf协议的设备和服务。除非有兼容设备或使用zeroconf协议，否则关闭</td>
<td>off</td>
</tr>
<tr>
<td>bluetooth</td>
<td>蓝牙设备支持。一般不会在服务器上启用蓝牙设备。</td>
<td>off</td>
</tr>
<tr>
<td>capi</td>
<td>仅对使用ISND设备的用户有用。</td>
<td>off</td>
</tr>
<tr>
<td>chargen-dgram</td>
<td>使用UDP协议的chargen server。主要功能是提供类似远程打字的功能。</td>
<td>off</td>
</tr>
<tr>
<td>chargen-stream</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>cpuspeed</td>
<td>可以用来调整CPU的频率。当闲置时可以自动降低CPU频率来节省电量</td>
<td>on</td>
</tr>
<tr>
<td>crond</td>
<td>系统的定时任务，一般的Linux服务器都需要定时任务帮助系统维护</td>
<td>on</td>
</tr>
<tr>
<td>cvs</td>
<td>一个版本控制系统</td>
<td>off</td>
</tr>
<tr>
<td>daytime-dgram</td>
<td>daytime使用TCP协议的Daytime守护进程，该协议为客户机实现从远程服务器获取日期和时间的功能。</td>
<td>off</td>
</tr>
<tr>
<td>daytime-stream</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>dovecot</td>
<td>邮件服务中POP3&#x2F;IMAP服务的守护进程。主要用来接收信件，如果启动了邮件服务则开启，否则关闭</td>
<td>off</td>
</tr>
<tr>
<td>echo-dgram</td>
<td>服务器回显客户服务的进程。</td>
<td>off</td>
</tr>
<tr>
<td>echo-stream</td>
<td>同上。</td>
<td>off</td>
</tr>
<tr>
<td>firstboot</td>
<td>系统安装完成之后，有个欢迎界面，需要对系统进程初始设定，就是这个进程的作用。既然不是第一次启动，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>gpm</td>
<td>在字符终端(tty1-tty6)中可以使用鼠标复制和粘贴。就是这个服务的功能。</td>
<td>on</td>
</tr>
<tr>
<td>haldaemon</td>
<td>检测盒支持USB设备。如果是服务器可以关闭，个人建议关闭</td>
<td>off</td>
</tr>
<tr>
<td>hidd</td>
<td>蓝牙鼠标、键盘等蓝牙设备检测。必须启动bluetooth服务。</td>
<td>off</td>
</tr>
<tr>
<td>hplip</td>
<td>HP打印机支持，如果没有HP打印机则关闭</td>
<td>off</td>
</tr>
<tr>
<td>httpd</td>
<td>apache服务的守护进程。如果需要启动apache，则开启</td>
<td>on</td>
</tr>
<tr>
<td>ip6tables</td>
<td>IPv6防火墙，目前IPv6协议并没有使用，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>iptables</td>
<td>防火墙功能，Linux中防火墙是内核支持功能，这是服务器的主要防护手段，必须开启</td>
<td>on</td>
</tr>
<tr>
<td>irda</td>
<td>IrDA提供红外线设备(笔记本、PDA’s，手机，计算器等等)间的通讯支持。</td>
<td>off</td>
</tr>
<tr>
<td>irqbalance</td>
<td>支持多核处理器，让CPU可以自动分配系统中断(IRQ)，提高系统性能。</td>
<td>on</td>
</tr>
<tr>
<td>isdn</td>
<td>使用ISDN设备连接网络。目前主流的联网方式是光纤接入和ADSL，ISDN已经非常少见</td>
<td>off</td>
</tr>
<tr>
<td>kudzu</td>
<td>该服务可以在开机时进行硬件检测，并会调用相关的设置软件。</td>
<td>off</td>
</tr>
<tr>
<td>lvm2-monitor</td>
<td>该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM方式，那么应该开启</td>
<td>on</td>
</tr>
<tr>
<td>mcstrans</td>
<td>SELinux的支持服务</td>
<td>on</td>
</tr>
<tr>
<td>mdmonitor</td>
<td>该服务用来监测Software RAID或LVM的信息。不是必须服务</td>
<td>off</td>
</tr>
<tr>
<td>mdmpd</td>
<td>该服务用来监测Multi-Path设备</td>
<td>off</td>
</tr>
<tr>
<td>messagebus</td>
<td>这是Linuxr IPC（Interprocess Communication, 进程间通讯）服务，用来在各个软件中交换信息</td>
<td>off</td>
</tr>
<tr>
<td>microcode_ctl</td>
<td>Intel系列的CPU可以通过这个服务支持额外的微指令集。</td>
<td>off</td>
</tr>
<tr>
<td>mysqld</td>
<td>mysql数据库服务器。如果需要就开启，</td>
<td>off</td>
</tr>
<tr>
<td>named</td>
<td>DNS服务的守护进程，用来进行域名解析。如果是DNS服务器则开启</td>
<td>off</td>
</tr>
<tr>
<td>netfs</td>
<td>该服务用于在系统启动时自动挂载网络中的共享文件空间，比如：NFS, Samba等。需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>network</td>
<td>提供网络设置功能。通过这个服务来管理网络</td>
<td>on</td>
</tr>
<tr>
<td>nfs</td>
<td>NFS（Network File System）服务，Linux与Linux之间的文件共享服务。需要就开启</td>
<td>off</td>
</tr>
<tr>
<td>nfslock</td>
<td>在Linux中如果使用了NFS服务，为了避免同一个文件被不同的用户编辑，所以有了这个锁服务。有NFS是开启</td>
<td>off</td>
</tr>
<tr>
<td>ntpd</td>
<td>该服务可以通过互联网自动更新系统时间，使系统时间永远都准确。需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>pcscd</td>
<td>智能卡检测服务</td>
<td>off</td>
</tr>
<tr>
<td>portmap</td>
<td>用在远程过程调用（RPC）的服务，如果没有任何RPC服务时，可以关闭，主要是NFS和NIS服务需要</td>
<td>off</td>
</tr>
<tr>
<td>psacct</td>
<td>该守护进程支持几个监控进程活动的工具。</td>
<td>off</td>
</tr>
<tr>
<td>rdisc</td>
<td>客户端ICMP路由协议</td>
<td>off</td>
</tr>
<tr>
<td>readahead_early</td>
<td>在系统开机的时候，先将某些进程加载如内存整理，可以加快一点启动速度。</td>
<td>off</td>
</tr>
<tr>
<td>readahead_later</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>restorecond</td>
<td>用于给SELinux监测和重新加载正确的文件上下文。如果开启SELinux则需要开启。</td>
<td>off</td>
</tr>
<tr>
<td>rpcgssd</td>
<td>与NFS有关的客户端功能</td>
<td>off</td>
</tr>
<tr>
<td>rpcidmapd</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>rsync</td>
<td>远程数据备份守护进程</td>
<td>off</td>
</tr>
<tr>
<td>sendmail</td>
<td>sendmail邮件服务的守护进程。如果有邮件服务就开启</td>
<td>off</td>
</tr>
<tr>
<td>setroubleshoot</td>
<td>该服务用于将SELinux相关信息记录在日志&#x2F;var&#x2F;log&#x2F;messages中</td>
<td>on</td>
</tr>
<tr>
<td>smartd</td>
<td>该服务用于自动检则硬盘状态</td>
<td>on</td>
</tr>
<tr>
<td>smb</td>
<td>网络服务samba守护进程。可以让Linux和Windows之间共享数据。如果需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>squid</td>
<td>代理服务的守护进程。</td>
<td>off</td>
</tr>
<tr>
<td>sshd</td>
<td>ssh加密远程登录管理的服务。</td>
<td>on</td>
</tr>
<tr>
<td>syslog</td>
<td>日志的守护进程。</td>
<td>on</td>
</tr>
<tr>
<td>vsftpd</td>
<td>vsftpd服务的守护进程。如果需要FTP服务则开启</td>
<td>off</td>
</tr>
<tr>
<td>xfs</td>
<td>这个是X Window的字体守护进程。为图形界面提供字体服务，如果不启动图形界面就不用开启</td>
<td>off</td>
</tr>
<tr>
<td>xinetd</td>
<td>超级守护进程。如果有依赖xinetd的服务就必须开启</td>
<td>off</td>
</tr>
<tr>
<td>ypbind</td>
<td>为NIS(网络信息系统)客户机激活ypbind服务进程。</td>
<td>off</td>
</tr>
<tr>
<td>yum-updatesd</td>
<td>yum的在线升级服务</td>
<td>off</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/03/04/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%BF%AE%E5%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/03/04/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%BF%AE%E5%A4%8D/" class="post-title-link" itemprop="url">启动引导与修复</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-04 15:32:41" itemprop="dateCreated datePublished" datetime="2025-03-04T15:32:41+08:00">2025-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-05 17:27:30" itemprop="dateModified" datetime="2025-03-05T17:27:30+08:00">2025-03-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h2><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>Linux默认有7个运行级别</p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式，可以想象为windows的安全模式，主要用于系统修复</td>
</tr>
<tr>
<td>2</td>
<td>不完全的命令行模式，不含NFS服务</td>
</tr>
<tr>
<td>3</td>
<td>完全的命令行模式，就是标准字符界面</td>
</tr>
<tr>
<td>4</td>
<td>系统保留</td>
</tr>
<tr>
<td>5</td>
<td>图形模式</td>
</tr>
<tr>
<td>6</td>
<td>重启动</td>
</tr>
</tbody></table>
<p>在Linux系统中可以使用runlevel命令来查看系统的运行级别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">N 5</span><br></pre></td></tr></table></figure>

<p>在这个命令的结果中，”N 5”中的N代表进入这个级别前，上一个级别是什么，5代表当前级别。”N”就是None的意思，也就是说系统是开机直接进入的5运行级别，没有上一个运行级别。那如果是从图形界面切换到字符界面的话，再查看运行级别，应该是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure>

<p>使用init命令可以手工改变当前的运行级别：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入图形界面，当然要已经安装了图形界面才可以</span></span><br><span class="line">[root@localhost ~]# init 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关机</span></span><br><span class="line">[root@localhost ~]# init 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">[root@localhost ~]# init 6</span><br></pre></td></tr></table></figure>

<p>不过要注意使用init命令关机和重启并不是太安全，容易造成数据丢失。所以推荐还是使用shutdown命令进行关机和重启。</p>
<h3 id="系统默认运行级别"><a href="#系统默认运行级别" class="headerlink" title="系统默认运行级别"></a>系统默认运行级别</h3><p>&#x2F;etc&#x2F;init&#x2F;rcS.conf配置文件调用&#x2F;etc&#x2F;inittab配置文件的目的就是为了确定系统的默认运行级别。也就是系统一开机后会进入那个运行级别。</p>
<p>注意这里的默认运行级别只能写成3或5，其的级别要不就是关机重启，要不就是保留或单用户，都不能作为系统默认运行级别。</p>
<h3 id="etc-rc-d-rc-local文件"><a href="#etc-rc-d-rc-local文件" class="headerlink" title="&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件"></a>&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件</h3><p>这个配置文件会在用户登录之前读取，这个文件中写入什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动就运行的工作，只需要写入&#x2F;etc&#x2F;rc.d&#x2F;rc.local这个配置文件即可。</p>
<h2 id="启动引导程序-Boot-Loader"><a href="#启动引导程序-Boot-Loader" class="headerlink" title="启动引导程序(Boot Loader)"></a>启动引导程序(Boot Loader)</h2><p>早期的Lilo引导程序已经不是很常见了，grub相比有很多优势，主要有：</p>
<ul>
<li>支持更多的文件系统；</li>
<li>grub的主程序可以直接在文件系统中查找内核文件；</li>
<li>在系统启动时，可以利用grub的交互界面编辑和修改启动选项；</li>
<li>可以动态的修改grub的配置文件，这样在修改配置文件之后不需要重新安装grub，而只需要重新启动就可以生效了。</li>
</ul>
<p>a）&#x2F;boot&#x2F;grub目录</p>
<p>grub的作用有以下几个：</p>
<ul>
<li>加载操作系统的内核。</li>
<li>拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。</li>
<li>还可以调用其他的启动引导程序，来实现多系统引导。</li>
</ul>
<p>grub的配置文件主要是放置在&#x2F;boot&#x2F;grub&#x2F;目录中的。其实这个目录中主要就是grub的配置文件和各种文件系统的stage1.5文件。不过grub的配置文件有两个&#x2F;boot&#x2F;grub&#x2F;grub.conf和&#x2F;boot&#x2F;grub&#x2F;menu.lst，这两个配置文件是软链接，所以修改哪一个都可以，个人习惯改grub.conf。</p>
<p>b）grub的配置文件</p>
<p>在grub中分区的表示方法</p>
<table>
<thead>
<tr>
<th>硬盘</th>
<th>分区</th>
<th>Linux中设备文件名</th>
<th>grub中设备文件名</th>
</tr>
</thead>
<tbody><tr>
<td>第一块SCSI硬盘</td>
<td>第一个主分区</td>
<td>&#x2F;dev&#x2F;sda1</td>
<td>hd(0,0)</td>
</tr>
<tr>
<td></td>
<td>第二个主分区</td>
<td>&#x2F;dev&#x2F;sda2</td>
<td>hd(0,1)</td>
</tr>
<tr>
<td></td>
<td>扩展分区</td>
<td>&#x2F;dev&#x2F;sda3</td>
<td>hd(0,2)</td>
</tr>
<tr>
<td></td>
<td>第一个逻辑分区</td>
<td>&#x2F;dev&#x2F;sda5</td>
<td>hd(0,4)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第一个主分区</td>
<td>&#x2F;dev&#x2F;sdb1</td>
<td>hd(1,0)</td>
</tr>
<tr>
<td></td>
<td>第二个主分区</td>
<td>&#x2F;dev&#x2F;sdb2</td>
<td>hd(1,1)</td>
</tr>
<tr>
<td></td>
<td>扩展分区</td>
<td>&#x2F;dev&#x2F;sdb3</td>
<td>hd(1,2)</td>
</tr>
<tr>
<td></td>
<td>第一个逻辑分区</td>
<td>&#x2F;dev&#x2F;sdb5</td>
<td>hd(1,4)</td>
</tr>
</tbody></table>
<p>grub的配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">		root (hd0,0)</span><br><span class="line">		kernel				/vmlinuz-2.6.32-279.el6.i686			ro		root=UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS	KEYBOARDTYPE=pc	KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</span><br><span class="line">		initrd	/initramfs-2.6.32-279.el6.i686.img</span><br></pre></td></tr></table></figure>

<ul>
<li><p>default&#x3D;0</p>
<p>默认启动第一个系统。也就是如蛤在等待时间结束后，用户没有选择进入哪一个系统，那么系统会默认进入第一个系统。如果有多系统并存，那么每个系统都会有自己的titile字段，如果想要默认进入第二个系统，可以设为default&#x3D;1。</p>
</li>
<li><p>timeout&#x3D;5</p>
<p>等待时间，默认是5秒。也就是进入系统时，如果5秒内用户没有按下任意键，那么系统会进入default字段定义的系统。当然可以手工修改这个等待时间，如果timeout&#x3D;0则不会等待直接进入系统，timeout&#x3D;-1则是一直等待用户输入，而不会自动进入系统。</p>
</li>
<li><p>splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz</p>
<p>这里是指定grub启动时的背景图像文件的保存位置。hd(0,0)代表第一个硬盘的第一个分区。</p>
</li>
<li><p>hiddenmenu</p>
<p>隐藏菜单。启动时默认只能看到读秒，而不能看到菜单，如果想要看到菜单需要按任意键。如果注释了这句话，那么启动时就能直接看到菜单了。</p>
</li>
</ul>
<p>Centos系统的启动配置：</p>
<ul>
<li><p>title Centos (2.6.32-279.el6.i686)</p>
<p>title就是标题的意思，也就是说在title后面写入的是什么，那么系统启动时在grub的启动菜单中看到的就是什么。</p>
</li>
<li><p>root (hd0,0)</p>
<p>是指启动程序的保存分区。这个root并不是管理员。在我的系统中，&#x2F;boot分区是独立划分的，而且设备文件名为&#x2F;dev&#x2F;sda1，所以在grub中，就被描述为hd（0,0）。</p>
</li>
<li><p>kernel				&#x2F;vmlinuz-2.6.32-279.el6.i686			ro		root&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS	KEYBOARDTYPE&#x3D;pc	KEYTABLE&#x3D;us rd_NO_MD crashkernel&#x3D;auto LANG&#x3D;zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</p>
<ul>
<li><p>&#x2F;vmlinuz-2.6.32-279.el6.i686</p>
<p>指定了内核文件的位置，这里的&#x2F;是指&#x2F;boot分区。</p>
</li>
<li><p>ro</p>
<p>启动时以只读方式挂载根文件系统，这是为了不让启动过程影响磁盘内的文件系统。</p>
</li>
<li><p>root&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS</p>
<p>指定根文件系统所在位置。</p>
</li>
<li><p>rd_NO_LUKS</p>
<p>禁用LUKS，LUKS用于给磁盘加密。</p>
</li>
<li><p>rd_NO_MD</p>
<p>禁用软RAID</p>
</li>
<li><p>rd_NO_DM</p>
<p>禁用硬RAID</p>
</li>
<li><p>rd_NO_LVM</p>
<p>禁用LVM。以上禁用都只是在启动过程中禁用，是为加速系统启动的。</p>
</li>
<li><p>KEYBOARDTYPE&#x3D;pc    KEYTABLE&#x3D;us</p>
<p>键盘类型</p>
</li>
<li><p>crashkernel&#x3D;auto</p>
<p>自动为crashkernel预留内存</p>
</li>
<li><p>LANG&#x3D;zh_CN.UTF-8</p>
<p>语言环境</p>
</li>
<li><p>rhgb</p>
<p>（redhat graphics boot）用图片来代替启动过程中的文字信息。启动完成之后可以使用dmesg命令来查看这些文字信息。</p>
</li>
<li><p>quiet</p>
<p>隐藏启动信息，只显示重要信息。</p>
</li>
<li><p>initrd    &#x2F;initramfs-2.6.32-279.el6.i686.img</p>
<p>指定了initramfs内存文件系统镜像文件的所在位置。</p>
</li>
</ul>
</li>
</ul>
<p>grub加密</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grub-mkpasswd-pbkdf2</span><br><span class="line">输入密码： </span><br><span class="line">重新输入口令： </span><br><span class="line">您的密码的 PBKDF2 哈希为 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br></pre></td></tr></table></figure>

<p>这样就可以生成加密密码字串，这个字串是采用md5加密的，就是你的密码经md5编码之后的。</p>
<p>grub菜单整体加密</p>
<p>如果只是加密单个启动菜单，grub的编辑模式是不能锁定的，还是可以按“e”键进入编辑模式。而且进入编辑模式后，是可以删除password字段的，再按“b”（boot启动）键就可以不用密码直接进入系统。这时就需要给grub菜单整体加密了，整体加密后，如果想进入grub编辑界面必须输入正确的密码。加密方法其实只是把password字段换个位置而已。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout=5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但是这样加密，启动CentOS时，是不需要密码就能正常启动的。如果需要grub整体加密，又需要系统启动时输入正确的密码时，则需：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">		lock</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<p>在title字段加入lock。代表锁死，如果不输入正确的grub密码也不能启动。</p>
<h2 id="系统修复模式"><a href="#系统修复模式" class="headerlink" title="系统修复模式"></a>系统修复模式</h2><h3 id="单用户模式"><a href="#单用户模式" class="headerlink" title="单用户模式"></a>单用户模式</h3><p>Linux的单用户模式有些类似Windows的安全模式，只启动最少的程序用于系统修复。在单用户模式(运行级别为1)中，Linux引导进入根shell，网络被禁用，只有少数进程运行。单用户模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。</p>
<p>a）进入单用户模式</p>
<p>开机进入引导界面，按“e”进入。</p>
<p>b）单用户模式常见的错误修复</p>
<ul>
<li><p>遗忘root密码</p>
<p>进入单用户模式最大的特点就是不需要输入用户名和密码就能登录。既然已经登录了单用户模式，那么直接给root用户设定新密码即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost /]# passwd root</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改系统默认运行级别</p>
<p>如果把系统的默认运行级别修改错误，比如改为了0或6，系统就不能正常启动了。这时也可以利用单用户模式进行修复，只要直接修改默认运行级别配置文件&#x2F;etc&#x2F;inittab，把系统默认运行级别修改回来即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/inittab</span><br><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure>

<p>绝大多数系统错误都可以通过单用户模式进行修复，理论上是只要能够进入单用户模式，那么系统错误就可以被单用户模式修复。当然意判断系统到底是哪里出现了问题，是需要不断地经验积累。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/28/Terraform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/28/Terraform/" class="post-title-link" itemprop="url">Terraform</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-28 20:48:38" itemprop="dateCreated datePublished" datetime="2025-02-28T20:48:38+08:00">2025-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-01 14:56:00" itemprop="dateModified" datetime="2025-03-01T14:56:00+08:00">2025-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/terraform/" itemprop="url" rel="index"><span itemprop="name">terraform</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Terraform工作流程"><a href="#Terraform工作流程" class="headerlink" title="Terraform工作流程"></a>Terraform工作流程</h2><p>Terraform是一个基础设施即代码(IaC)工具，通过以下几个步骤来管理基础设施：</p>
<ul>
<li><p>配置文件（.tf文件）</p>
<p>用户首先通过编写Terraform配置文件来定义所需的基础设施。这些文件使用HCL（HashiCorp Configuration Language）语言，描述资源的类型、属性和配置。</p>
</li>
<li><p>初始化（terraform init）</p>
<p>在开始Terraform之前，用户需要运行terraform init命令。这一步会初始化工作目录，下载所需的提供程序(如AWS、Azure等)，并准备后续的操作。</p>
</li>
<li><p>生成执行计划（terraform plan）</p>
<p>使用terraform plan命令，Terraform会读取配置文件并生成执行计划，展示将要执行的操作（如创建、更新或删除资源）。这一步允许用户预览即将进行的变更，避免意外操作。</p>
</li>
<li><p>应用变更（terraform apply）</p>
<p>在确认执行计划后，用户可以运行terraform apply命令，Terraform会根据生成的计划实际执行相应的操作，创建、更新或删除云资源。</p>
</li>
<li><p>状态管理</p>
<p>Terraform会维护一个状态文件（terraform.tfstate），记录当前基础设施的状态。这个文件用于跟踪资源的实际状态，以便在后续操作中进行对比和管理。</p>
</li>
<li><p>变更管理</p>
<p>当需要对基础设施进行更改时，用户只需要修改配置文件，然后重复执行plan和apply流程。Terraform会自动识别资源的变更，并进行相应的更新。</p>
</li>
<li><p>销毁资源（terraform destory）</p>
<p>当不再需要某些资源时，用户可以运行terraform destory命令，Terraform会删除所有配置文件中定义的资源，确保清理工作整洁。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/27/Shell%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/27/Shell%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Shell编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-27 11:12:53" itemprop="dateCreated datePublished" datetime="2025-02-27T11:12:53+08:00">2025-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-01 19:05:53" itemprop="dateModified" datetime="2025-03-01T19:05:53+08:00">2025-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Shell/" itemprop="url" rel="index"><span itemprop="name">Shell</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>正则表达式用来在文件中匹配符合条件的字符串，通配符用来匹配符合条件的文件名。其实这种区别只在Shell当中适用，因为用来文件当中搜索字符串的命令如grep、awk、sed等命令可以支持正则表达式，而在系统当中搜索文件的命令如ls、find、cp这些命令不支持正则表达式，所以只能使用Shell自己的通配符来进行匹配了。</p>
<h4 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>前一个字符匹配0次或任意多次</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符外任意一个字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配行首。例如^hello会匹配以hello开头的行</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾。例如hello$会匹配以hello结尾的行</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中指定的任意一个字符，只匹配一个字符。例如[aoeiu]匹配任意一个元音字母</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配除中括号的字符以外的任意一个字符。例如[^0-9]匹配任意一位非数字字符</td>
</tr>
<tr>
<td>\</td>
<td>转义符。用于取消特殊符号的转义</td>
</tr>
<tr>
<td>\{n\}</td>
<td>表示其前面的字符恰好出现n次。例如[0-9]\{4\}匹配4位数字</td>
</tr>
<tr>
<td>\{n, \}</td>
<td>表示其前面的字符出现不小于n次。例如[0-9]\{2, \}表示两位及以上的数字</td>
</tr>
<tr>
<td>\{n,m\}</td>
<td>表示其前面的字符至少出现n次，最多出现m次。例如[a-z]\{6,8\}匹配6到8位的小写字母。</td>
</tr>
</tbody></table>
<p>练习文件建立：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“a*”前一个字符匹配0次，或任意多次</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“aa*”代表这行字符串最少要有一个a</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;aa*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“.”匹配除了换行符外任意一个字符，只能匹配一个字符，这个字符可以是任意字符</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s..d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# grep &quot;s.*d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“^”代表匹配行首，比如“^M”会匹配以大写“M”开头的行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^M&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure>

<p>“$”代表匹配行尾，比如“n$”会匹配以小写“n”结尾的行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;n$&quot; test_rule.txt</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure>

<p>“^$”则会匹配空白行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^$&quot; test_rule.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“[]”会匹配中括号中指定任意一个字符，注意只能匹配一个字符。比如[ao]会匹配a或o</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s[ao]id&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“[^]”匹配除中括号的字符以外的任意一个字符</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[^a-z]&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">5555nice!</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“\“转义符</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;\.$&quot; test_rule.txt</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“\{n\}”表示其前面的字符恰好出现n次</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a\&#123;3\&#125;&quot; test_rule.txt</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br></pre></td></tr></table></figure>

<p>“\{n,\}”会匹配前面的字符出现最少n次。比如“^[0-9]\{3, \}[a-z]”这个正则就能匹配最少用连续三个数字开头的字符串</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[0-9]\&#123;3,\&#125;[a-z]&quot; test_rule.txt</span><br><span class="line">123despise him.</span><br><span class="line">5555nice!</span><br></pre></td></tr></table></figure>

<p>“\{n,m\}”匹配其前面的字符至少出现n次，最多出现m次</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;sa\&#123;1,3\&#125;i&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br></pre></td></tr></table></figure>



<h4 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h4><p>在正则表达式中应该还可以支持一些元字符，比如“+”、“?”、“|”、“()”。其实Linux是支持这些元字符的，只是grep命令默认不支持而已。如果想要支持这些元字符，必须使用egrep命令或grep -E选项，所以我们又把这些元字符称作扩展元字符。</p>
<p>如果查询grep的帮助，对egrep的说明就是和grep -E选项一样的命令，所以我们可以把这两个命令当做别名来对待。</p>
<table>
<thead>
<tr>
<th>扩展元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>前一个字符匹配1次或任意多次。如“go+gle”会匹配“gogle”、“google”或“gooogle”等。</td>
</tr>
<tr>
<td>?</td>
<td>前一个字符匹配0次或1次。如”colou?r”可以匹配“colour”或“color”。</td>
</tr>
<tr>
<td>|</td>
<td>匹配两个或多个分支的选择。如”was|his”会匹配既包含“was”的行，也匹配包含”his”的行。</td>
</tr>
<tr>
<td>()</td>
<td>匹配其整体为一个字符，即模式单元。可以理解为由多个单字符组成的大字符。如“(dog)+”会匹配“dog”、“dogdog”、“dogdogdog”等。因为被()包含的字符会当成一个整体。</td>
</tr>
</tbody></table>
<h3 id="字符截取和替换命令"><a href="#字符截取和替换命令" class="headerlink" title="字符截取和替换命令"></a>字符截取和替换命令</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f 列号：         提取第几列</span><br><span class="line">  -d 分隔号：       按照指定分隔符分割列</span><br><span class="line">  -c 字符范围：      不依赖分隔符来区分列，而是通过字符范围(行首为0)来进行字段提取。“n-”表示从第n个字符到行尾；&quot;n-m&quot;表示从第n个字符到第m个字符；&quot;-                     m&quot;表示从第1个字符到第m个字符。</span><br></pre></td></tr></table></figure>

<p>cut命令的默认分隔符是制表符，也就是“tab”键。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    Gender  Mark</span><br><span class="line">1       Liming  M       86</span><br><span class="line">2       Sc      M       90</span><br><span class="line">3       Tg      M       83</span><br></pre></td></tr></table></figure>

<p>提取第二列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2 test.txt</span><br><span class="line">Name</span><br><span class="line">Liming</span><br><span class="line">Sc</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure>

<p>提取多列：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2,3 test.txt</span><br><span class="line">Name	Gender</span><br><span class="line">Liming	M</span><br><span class="line">Sc	M</span><br><span class="line">Tg	M</span><br></pre></td></tr></table></figure>

<p>按照字符进行提取：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -c 8- test.txt        # &quot;8-&quot;代表提取所有行的第8个字符到结尾</span><br><span class="line">	Gender	Mark</span><br><span class="line">g	M	86</span><br><span class="line">90</span><br><span class="line">83</span><br></pre></td></tr></table></figure>

<p>以“:”作为分隔符提取：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cut -d &quot;:&quot; -f 1,3 /etc/passwd</span><br><span class="line">root:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>a）printf格式化输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;输出类型输出格式&#x27; 输出内容</span><br><span class="line">输出类型：</span><br><span class="line">  %ns:        输出字符串。n是数字指代输出几个字符</span><br><span class="line">  %ni:        输出整数。n是数字指代输出几个数字</span><br><span class="line">  %m.nf:      输出浮点数。m和n是数字，指代输出的整数位和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。</span><br><span class="line">输出格式：</span><br><span class="line">  \a：         输出警告声音</span><br><span class="line">  \b：         输出退格键，也就是Backspace键</span><br><span class="line">  \f：         清除屏幕</span><br><span class="line">  \n:          换行</span><br><span class="line">  \r:          回车，也就是Enter键</span><br><span class="line">  \t:          水平输出退格键，也就是Tab键</span><br><span class="line">  \v:          垂直输出退格键，也就是Tab键</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>使用printf输出test.txt文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s&#x27; $(cat test.txt)</span><br><span class="line">IDNamePHPLinuxMySQLAverage1Liming82958687.662Sc74968785.663Tg99839391.66[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>如果不指定输出格式，则会把所有输出内容连在一起输出。其实文本的输出本身就是这样的，cat等文本输出命令之所以可以按照格式漂亮的输出，那是因为cat命令已经设定了输出格式。为了用printf输出合理的格式，可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意在<span class="built_in">printf</span>命令的单引号中，只能识别格式输出符号，而手工输入的空格是无效的</span></span><br><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %s\t %s\t %s\t %s\t \n&#x27; $(cat test.txt)</span><br><span class="line">ID	 Name	 PHP	 Linux	 MySQL	 Average	 </span><br><span class="line">1	 Liming	 82	 95	 86	 87.66	 </span><br><span class="line">2	 Sc	 74	 96	 87	 85.66	 </span><br><span class="line">3	 Tg	 99	 83	 93	 91.66</span><br></pre></td></tr></table></figure>

<p>如果不想把成绩当成字符串输出，而是按照整形和浮点型输出，则要这样：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %i\t %i\t %i\t %8.2f\t \n&#x27; $(cat test.txt | grep -v Name)</span><br><span class="line">1	 Liming	 82	 95	 86	    87.66	 </span><br><span class="line">2	 Sc	 74	 96	 87	    85.66	 </span><br><span class="line">3	 Tg	 99	 83	 93	    91.66</span><br></pre></td></tr></table></figure>



<p>b）awk基本使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;...&#x27; 文件名</span><br><span class="line">条件(Pattern)：</span><br><span class="line">    一般使用关系表达式作为条件。这些关系表达式非常多。如：</span><br><span class="line">    x &gt; 10    判断变量x是否大于10</span><br><span class="line">    x == y    判断变是x是否等于变量y</span><br><span class="line">    A`B       判断字符串A中是否包含能匹配B表达式的子字符串</span><br><span class="line">    A!`B      判断字符串A中是否不包含能匹配B表达式的子字符串</span><br><span class="line">动作(Action)：</span><br><span class="line">    格式化输出</span><br><span class="line">    流程控制语句</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出第二列和第六列</span></span><br><span class="line">[root@localhost ~]# awk &#x27;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>



<p>c）awk的条件</p>
<table>
<thead>
<tr>
<th>条件的类型</th>
<th>条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>awk保留字</td>
<td>BEGIN</td>
<td>在awk程序一开始时，尚未读取任何数据之前执行。BEGIN后的动作只在程序开始时执行一次。</td>
</tr>
<tr>
<td></td>
<td>END</td>
<td>在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td></td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td></td>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td></td>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td></td>
<td>&#x3D;&#x3D;</td>
<td>等于。用于判断两个值是否相等，如果是给变量赋值，请使用“&#x3D;”号</td>
</tr>
<tr>
<td></td>
<td>!&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td></td>
<td>A~B</td>
<td>判断字符串A中是否包含能匹配B表达式的子字符串</td>
</tr>
<tr>
<td></td>
<td>A!~B</td>
<td>判断字符串B中是否不包含能匹配B表达式的子字符串</td>
</tr>
<tr>
<td>正则表达式</td>
<td>&#x2F;正则&#x2F;</td>
<td>如果在“&#x2F;&#x2F;”中可以写入字符，也可以支持正则表达式</td>
</tr>
</tbody></table>
<ul>
<li><p>BEGIN</p>
<p>BEGIN是awk的保留字，是一种特殊的条件类型。BEGIN的执行时机是“在awk程序一开始时，尚未读取任何数据之前执行”。一旦BEGIN后的动作执行一次，当awk开始从文件中读入数据，BEGIN的条件就不再成立，所以BEGIN定义的动作只能被执行一次。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">awk命令只要检测不到完整的单引号不会执行，所以这个命令的换行不用加入<span class="string">&quot;\&quot;</span></span></span><br><span class="line">[root@localhost ~]# awk &#x27;BEGIN&#123;printf &quot;This is a transcript \n&quot;&#125; </span><br><span class="line">&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">This is a transcript </span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>
</li>
<li><p>END</p>
<p>END也是awk保留字，不过刚好和BEGIN相反。END是在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;END&#123;printf &quot;The END \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br><span class="line">The END</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算符</p>
<p>查看平均成绩大于等于87分的学员是谁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$6 &gt;= 87&#123;printf $2 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">Liming</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure>

<p>加入条件之后，只有条件成立动作才会执行，如果条件不满足，则运作不运行。通过这个实验，大家可以发现，虽然awk是列提取命令，但是也要按行来读入的。这个命令的执行过程是这样的：</p>
<p>1）如果有BEGIN条件，则先执行BEGIN定义的动作</p>
<p>2）如果没有BEGIN条件，则读入第一行，把第一行的数据依次赋予$0、$1、$2等变量。其中$0代表此行的整体数据，$1代表第一字段，$2代表第二字段。</p>
<p>3）依据条件类型判断动作是否执行。如果条件符合，则执行动作，否则读入下一行数据。如果没有条件，则每行都执行动作。</p>
<p>4）读入下一行数据，重复执行以上步骤。</p>
<p>查看Sc用户的平均成绩：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$2 ~ &quot;Sc&quot;&#123;printf $6 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">85.66</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式</p>
<p>如果想让awk识别字符串，必须使用“&#x2F;&#x2F;”包含，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印LiMing的成绩</span></span><br><span class="line">[root@localhost ~]# awk &#x27;/Liming/ &#123;print&#125;&#x27; test.txt </span><br><span class="line">1	Liming	82	95	86	87.66</span><br></pre></td></tr></table></figure>

<p>当使用df命令查看分区使用情况时，如果只想看真正的系统分区的使用状况，而不想查看光盘和临时分区的使用状况，则可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -h | awk &#x27;/sda[0-9]/ &#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>4）awk内置变量</p>
<table>
<thead>
<tr>
<th>awk内置变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>代表目前awk所读入的整行数据。我们已知awk是一行一行读入数据的，$0就代表当前读入行的整行数据。</td>
</tr>
<tr>
<td>$n</td>
<td>代表目前读入行的第n个字段。</td>
</tr>
<tr>
<td>NF</td>
<td>当前行拥有的字段(列)总数。</td>
</tr>
<tr>
<td>NR</td>
<td>当前awk所处理的行，是总数据的第几行。</td>
</tr>
<tr>
<td>FS</td>
<td>用户定义分隔符。awk的默认分隔符是任何空格，如果想要使用其他分隔符(如”：”)，就需要FS变量定义。</td>
</tr>
<tr>
<td>ARGC</td>
<td>命令行参数个数。</td>
</tr>
<tr>
<td>ARGV</td>
<td>命令行参数数组。</td>
</tr>
<tr>
<td>FNR</td>
<td>当前文件中的当前记录数(对输入文件起始为1)。</td>
</tr>
<tr>
<td>OFMT</td>
<td>数值的输出格式(默认为%.6g)。</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段的分隔符(默认为空格)。</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符(默认为换行符)。</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符(默认为换行符)。</td>
</tr>
</tbody></table>
<p>查询可以登录的用户的用户名和UID：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root	0</span><br><span class="line">ben	1000</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号:&quot; NR &quot;\t 字段数: &quot; NF &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root	0	 行号:1	 字段数: 7</span><br><span class="line">ben	1000	 行号:2	 字段数: 7</span><br></pre></td></tr></table></figure>

<p>查看sshd这个伪用户的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $1==&quot;sshd&quot; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号：&quot; NR &quot;\t 字段数：&quot; NF &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>5）awk流程控制</p>
<p>统计PHP成绩的总分：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR==2&#123;php1=$3&#125; NR==3&#123;php2=$3&#125; NR==4&#123;php3=$3;total=php1+php2+php3;print &quot;total php is &quot; total&#125;&#x27; test.txt</span><br><span class="line">total php is 255</span><br></pre></td></tr></table></figure>

<ul>
<li>“NR&#x3D;&#x3D;2{php1&#x3D;$3}”：条件是NR&#x3D;&#x3D;2，动作是php1&#x3D;$3，指如果输入数据是第二行(第一行是标题行)，就把第二行的第三字段的值赋予变量“php1”。</li>
<li>“NR&#x3D;&#x3D;3{php2&#x3D;$3}”：如果输入数据是第三行，就把第三行的第三字段的值赋予变量“php2”。</li>
<li>‘NR&#x3D;&#x3D;4{php3&#x3D;$3;total&#x3D;php1+php2+php3;print “total php is “ total}’：如果输入数据是第四行，就把第四行的第三字段的值赋予变量“php3”；然后定义变量total的值为‘php1+php2+php3’；然后输出”total php is “关键字，后面加变量total的值。</li>
</ul>
<p>在awk编程中，因为命令语句非常长，在输入格式时需要注意以下内容：</p>
<ul>
<li>多个条件{动作}可以用空格分割，也可以用回车分割。</li>
<li>在一个动作中，如果需要执行多个命令，需要用“;”分割，或用回车分割。</li>
<li>在awk中，变量的赋值与调用都不需要加入“$”符。</li>
<li>条件中判断两个值是否相同，请使用”&#x3D;&#x3D;”，以便和变量赋值进行区分。</li>
</ul>
<p>如果Linux成绩大于90，就是一个好学生：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;&#123;if (NR&gt;=2)&#123;if ($3&gt;90) printf $2 &quot; is a good student!\n&quot;&#125;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure>

<p>其实awk中if判断语句，完全可以直接利用awk自带的条件来取代：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR&gt;=2&#123;test=$3&#125; test&gt;90&#123;printf $2 &quot; is a good student!\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure>



<p>6）awk函数</p>
<p>awk编程也允许在编程时使用函数，awk函数定义方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名 (参数列表) &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一简单的函数，使用函数来打印test.txt的学员姓名和平均成绩：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;function test(a,b) &#123;printf a &quot;\t&quot; b &quot;\n&quot;&#125; &#123;test($2,$6)&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>



<p>7）awk中调用脚本</p>
<p>对于小的单行程序来说，将脚本作为命令行自变量传递给awk是非常简单的，而对于多行程序就比较难处理。当程序是多行的时候，使用外部脚本是很适合的。首先在外部文件中写好脚本，然后可以使用awk的-f选项，使其读入脚本并且执行。</p>
<p>例如，我们可以先编写一个awk脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim pass.awk</span><br><span class="line">BEGIN	&#123;FS=&quot;:&quot;&#125;</span><br><span class="line">&#123;print $1 &quot;\t&quot; $3&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以使用”-f”选项来调用这个脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# awk -f pass.awk /etc/passwd</span><br><span class="line">root	0</span><br><span class="line">daemon	1</span><br><span class="line">bin	2</span><br><span class="line">sys	3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>sed主要是用来将数据进行选取、替换、删除和新增的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed [选项] &#x27;[动作]&#x27; 文件名</span><br><span class="line">选项：</span><br><span class="line">  -n:              一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。</span><br><span class="line">  -e:              允许对输入数据应用多条sed命令编辑。</span><br><span class="line">  -f 脚本文件名:    从sed脚本中读入sed操作。和awk命令的-f非常类似。</span><br><span class="line">  -r:              在sed中支持扩展正则表达式。</span><br><span class="line">  -i:              用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出</span><br><span class="line">动作：</span><br><span class="line">  a \n:             追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  c \n:             行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用&quot;\&quot;代表数据未完结。</span><br><span class="line">  i \n:             插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  d:               删除，删除指定的行。</span><br><span class="line">  p:               打印，输出指定的行。</span><br><span class="line">  s:               字串替换，用一个字符串替换另外一个字符串。格式为&quot;行范围 s/旧字串/新字串/g&quot;（和vim中的替换格式类似）</span><br></pre></td></tr></table></figure>

<p>对sed命令要注意，sed所做的修改并不会直接改变文件的内容(如果是用管道符接收的命令的输出，这种情况连文件都没有)，而是把修改结果只显示到屏幕上，除非使用“-i”选项才会直接修改文件。</p>
<ul>
<li><p>行数据操作</p>
<p>【查看】</p>
<p>查看test.txt的第二行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2p&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>“p”命令确实输出了第二行数据，但是sed命令还会把所有数据都输出一次。如果想指定输出某行数据，需要”-n”选项的帮助：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -n &#x27;2p&#x27; test.txt</span><br><span class="line">1       Liming  82      95      86      87.66</span><br></pre></td></tr></table></figure>



<p>【删除】</p>
<p>删除第二行到第四行的数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,4d&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件本身并没有修改</span></span><br><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>



<p>【追加】</p>
<p>“a“会在指定行后面追加入数据：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2a hello&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">hello</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>



<p>【插入】</p>
<p>“i”会在指定行前面插入数据:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# sed -n &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>



<p>【替换】</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2c No such person&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No such person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat test.txt | sed &#x27;2c No sucn person&#x27;</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No sucn person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>sed命令默认情况下是不会修改文件内容的，如果确定需要让sed命令直接处理文件的内容，可以使用”-i”选项。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -i &#x27;2c No such person&#x27; test.txt</span><br></pre></td></tr></table></figure>


</li>
<li><p>字符串替换</p>
<p>“c”动作是进行整行替换的，如果仅仅想替换行中的部分数据，就要使用“s”动作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/旧字串/新字串/g&#x27; 文件名</span><br></pre></td></tr></table></figure>

<p>在第三行中，把74替换成99：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3s/74/99/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      99      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>把第四行注释掉：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;4s/^/#/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3       Tg      99      83      93      91.66</span></span><br></pre></td></tr></table></figure>

<p>“-e”选项可以同时执行多个sed动作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -e &#x27;s/Liming//g;s/Tg//g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1         82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3             99      83      93      91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f:        忽略大小写</span><br><span class="line">  -b:        忽略每行前面的空白部分</span><br><span class="line">  -n:        以数值型进行排序，默认使用字符串型排序</span><br><span class="line">  -r:        反向排序</span><br><span class="line">  -u:        删除重复行。就是uniq命令</span><br><span class="line">  -t:        指定分隔符，默认分隔符是制表符</span><br><span class="line">  -k n[,m]:  按照指定的字段范围排序。从第n字段开始，m字段结束(默认到行尾)</span><br></pre></td></tr></table></figure>

<p>sort命令默认是用每行开头第一个字符来进行排序的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort /etc/passwd</span><br><span class="line">_apt:x:105:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:109:116:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">avahi:x:115:121:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>反向排序：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort -r /etc/passwd</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">whoopsie:x:120:125::/nonexistent:/bin/false</span><br><span class="line">uuidd:x:107:114::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果想要指定排序的字段，需要先使用“-t”选项指定分隔符，并使用“-k”选项指定字段号。例如按照UID字段排序&#x2F;etc&#x2F;passwd文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然“-k”选项可以直接使用“-k 3”，代表从第三字段到行尾排序（第一个字符先排序，如果一致，第二个字符再排序，直到行尾）。</p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>uniq命令是用来取消重复行的命令，其实和”sort -u”选项是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# uniq [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -i:        忽略大小写</span><br></pre></td></tr></table></figure>



<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>统计命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# wc [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -l:        只统计行数</span><br><span class="line">  -w:        只统计单词数</span><br><span class="line">  -m:        只统计字符数</span><br></pre></td></tr></table></figure>



<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="按照文件类型进行判断"><a href="#按照文件类型进行判断" class="headerlink" title="按照文件类型进行判断"></a>按照文件类型进行判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b 文件</td>
<td>判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）</td>
</tr>
<tr>
<td>-c 文件</td>
<td>判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真）</td>
</tr>
<tr>
<td>-d 文件</td>
<td>判断该文件是否存在，并且是否为目录文件（是目录为真）</td>
</tr>
<tr>
<td>-e 文件</td>
<td>判断该文件是否存在（存在为真）</td>
</tr>
<tr>
<td>-f 文件</td>
<td>判断该文件是否存在，并且是否为普通文件（是普通文件为真）</td>
</tr>
<tr>
<td>-L 文件</td>
<td>判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）</td>
</tr>
<tr>
<td>-p 文件</td>
<td>判断该文件是否存在，并且是否为管道文件（是管道文件为真）</td>
</tr>
<tr>
<td>-s 文件</td>
<td>判断该文件是否存在，并且是否为非空（非空为真）</td>
</tr>
<tr>
<td>-S 文件</td>
<td>判断该文件是否存在，并且是否为套接字文件（是套接字文件为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# [ -e /root/sh/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">0        # 判断结果为0，/root/sh/目录是存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -e /root/test/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">1        # 判断结果为0，/root/test/目录是不存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -d /root/sh ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个判断命令如果正确执行，则打印<span class="string">&quot;yes&quot;</span>，否则打印<span class="string">&quot;no&quot;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="按照文件权限进行判断"><a href="#按照文件权限进行判断" class="headerlink" title="按照文件权限进行判断"></a>按照文件权限进行判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-r 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真）</td>
</tr>
<tr>
<td>-w 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有写权限（有写权限为真）</td>
</tr>
<tr>
<td>-x 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）</td>
</tr>
<tr>
<td>-u 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真）</td>
</tr>
<tr>
<td>-g 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真）</td>
</tr>
<tr>
<td>-k 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SBIT权限（有SBIT权限为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll test.txt</span><br><span class="line">-rw-rw-r-- 1 ben ben 187  2月 28 02:09 test.txt</span><br><span class="line">[root@localhost ~]# [ -w test.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="两个文件之间进行比较"><a href="#两个文件之间进行比较" class="headerlink" title="两个文件之间进行比较"></a>两个文件之间进行比较</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>文件1 -nt 文件2</td>
<td>判断文件1的修改时间是否比文件2的新（如果新则为真）</td>
</tr>
<tr>
<td>文件1 -ot 文件2</td>
<td>判断文件1的修改时间是否比文件2的旧（如果旧则为真）</td>
</tr>
<tr>
<td>文件1 -ef 文件2</td>
<td>判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建个硬链接</span></span><br><span class="line">[root@localhost ~]# ln /tmp/test.txt /tmp/stu.txt</span><br><span class="line">[root@localhost ~]# [ /tmp/test.txt -ef /tmp/stu.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="两个整数之间比较"><a href="#两个整数之间比较" class="headerlink" title="两个整数之间比较"></a>两个整数之间比较</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>整数1 -eq 整数2</td>
<td>判断整数1是否和整数2相等（相等为真）</td>
</tr>
<tr>
<td>整数1 -ne 整数2</td>
<td>判断整数1是否和整数2不相等（不相等为真）</td>
</tr>
<tr>
<td>整数1 -gt 整数2</td>
<td>判断整数1是否大于整数2（大于为真）</td>
</tr>
<tr>
<td>整数1 -lt 整数2</td>
<td>判断整数1是否小于整数2（小于为真）</td>
</tr>
<tr>
<td>整数1 -ge 整数2</td>
<td>判断整数1是否大于等于整数2（大于等于为真）</td>
</tr>
<tr>
<td>整数1 -le 整数2</td>
<td>判断整数1是否小于等于整数2（小于等于为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# [ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br><span class="line">[root@localhost ~]# [ 23 -le 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-z 字符串</td>
<td>判断字符串是否为空（为空返回真）</td>
</tr>
<tr>
<td>-n 字符串</td>
<td>判断字符串是否为非空（非空返回真）</td>
</tr>
<tr>
<td>字符串1 &#x3D;&#x3D; 字符串2</td>
<td>判断字符串1是否和字符串2相等（相等返回真）</td>
</tr>
<tr>
<td>字符串1 !&#x3D; 字符串2</td>
<td>判断字符串1 是否和字符串2不相等（不相等返回真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给name赋值</span></span><br><span class="line">[root@localhost ~]# name=ben</span><br><span class="line">[root@localhost ~]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# bb=22</span><br><span class="line">[root@localhost ~]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>判断1 -a 判断2</td>
<td>逻辑与，判断1和判断2都成立，最终的结果为真</td>
</tr>
<tr>
<td>判断1 -o 判断2</td>
<td>逻辑或，判断1和判断2有一个成立，最终的结果就为真</td>
</tr>
<tr>
<td>! 判断</td>
<td>逻辑非，使原始的判断式取反</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line">[root@localhost ~]# [ ! -n &quot;$aa&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>“!”和“-n”之间必须加入空格，否则会报错的。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h4><p>a）单分支if条件语句</p>
<p>单分支条件语句最为简单，就是只有一个判断条件，如果符合条件则执行某个程序，否则什么事情都不做。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>单分支条件语句需要注意几个点：</p>
<ul>
<li><p>if语句使用fi结尾，和一般语言使用大括号结尾不同。</p>
</li>
<li><p>[ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格。</p>
</li>
<li><p>then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">	then</span><br><span class="line">		程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda3&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f1)</span><br><span class="line">if [ $rate -ge 80 ];then</span><br><span class="line">	echo &quot;Warning! /dev/sda3 is full!!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>b）双分支if条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式 ]；then</span><br><span class="line">	条件成立时，执行的程序</span><br><span class="line">else</span><br><span class="line">	条件不成立时，执行的另一个程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步系统时间</span></span><br><span class="line">ntpdate asia.pool.ntp.org &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把当前系统时间按照<span class="string">&quot;年月日&quot;</span>格式赋予变量<span class="built_in">date</span></span></span><br><span class="line">date=$(date +%y%m%d)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计mysql数据库的大小，并把大小赋予size变量</span></span><br><span class="line">size=$(du -sh /var/lib/mysql)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断备份目录是否存在，是否为目录</span></span><br><span class="line">if [ -d  /tmp/dbak ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">	echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">	echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入备份目录</span></span><br><span class="line">	cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">	tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除临时文件</span></span><br><span class="line">	rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果判断为假，则建立备份目录</span></span><br><span class="line">	mkdir /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">	echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">	echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入备份目录</span></span><br><span class="line">	cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">	tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除临时文件</span></span><br><span class="line">	rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>在工作中，服务器上的服务经常会宕机。如果我们对服务器监控不好，就会造成服务器中服务宕机了，而管理员却不知道的情况，这时我们可以写一个脚本来监听本机的服务，如果服务停止或宕机了，可以自动重启这些服务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用nmap命令扫描服务器，并截取apache服务的状态，赋予变量port</span></span><br><span class="line">port=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">if [ &quot;$port&quot; == &quot;open&quot; ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">则证明apache正常启动，在正常日志中写入一句话即可</span></span><br><span class="line">	echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/autostart-acc.log</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">否则证明apache没有启动，自动启动apache</span></span><br><span class="line">	/etc/rc.d/init.d/httpd start &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">并在错误日志中记录自动启动apache的时间</span></span><br><span class="line">	echo &quot;$(date) restart httpd!!&quot; &gt;&gt; /tmp/autostart-err.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>c）多分支if条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ 条件判断式1 ];then</span><br><span class="line">	当条件判断式1成立时，执行程序1</span><br><span class="line">elif [ 条件判断式2 ];then</span><br><span class="line">	当条件判断式2成立时，执行程序2</span><br><span class="line">else</span><br><span class="line">	当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>判断用户输入的是什么文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">！/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email:17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接收键盘的输入，并赋予变量file</span></span><br><span class="line">read -p &quot;Please input a filename: &quot; file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file变量是否为空</span></span><br><span class="line">if [ -z &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;Error,please input a filename&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出程序，并返回1</span></span><br><span class="line">	exit 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否存在</span></span><br><span class="line">elif [ ! -e &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;Your input is not a file!&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出程序，并返回2</span></span><br><span class="line">	exit 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为普通文件</span></span><br><span class="line">elif [ -f &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;$file is a regulare file!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为目录文件</span></span><br><span class="line">elif [ -d &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;$file is a directory!&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;$file is an other file!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="多分支case条件语句"><a href="#多分支case条件语句" class="headerlink" title="多分支case条件语句"></a>多分支case条件语句</h4><p>case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">	&quot;值1&quot;)</span><br><span class="line">		如果变量的值等于值1，则执行程序1</span><br><span class="line">		;;</span><br><span class="line">	&quot;值2&quot;)</span><br><span class="line">		如果变量的值等于值2，则执行程序2</span><br><span class="line">		;;</span><br><span class="line">	...</span><br><span class="line">	*)</span><br><span class="line">		如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">		;;</span><br><span class="line">esac	</span><br></pre></td></tr></table></figure>

<p>这个语句需要注意以下内容：</p>
<ul>
<li><p>case语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行“*)”（“*”代表所有其他值）中的程序。</p>
</li>
<li><p>case语句以“case”开头，以“esac”结尾。</p>
</li>
<li><p>每个分支程序之后要通过“;;”双分号结尾，代表该程序段结束。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please choose yes/no: &quot; -t 30 cho</span><br><span class="line">case $cho in </span><br><span class="line">	&quot;yes&quot;)</span><br><span class="line">		echo &quot;Your choose is yes!&quot;</span><br><span class="line">		;;</span><br><span class="line">	&quot;no&quot;)</span><br><span class="line">		echo &quot;Your choose is no!&quot;</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		echo &quot;Your choose is error!&quot;</span><br><span class="line">		;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环是固定循环，也就是在循环时已经知道需要进行几次循环，有时也把for循环称为计数循环。</p>
<p>语法一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>这种语法中for循环的次数，取决于in后面值的个数（空格分隔），有几个值就循环几次，并且每次循环都把值赋予变量。</p>
<p>打印时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for time in morning noon afternoon evening</span><br><span class="line">	do</span><br><span class="line">		echo &quot;This time is $time&quot;</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>批量解压缩脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入压缩目录</span></span><br><span class="line">cd /lamp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把所有tar.gz结尾的文件的文件覆盖到ls.log临时文件中</span></span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line">for i in $(cat ls.log)</span><br><span class="line">	do</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">解压缩</span></span><br><span class="line">		tar -zxf $i &amp;&gt;/dev/null</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件ls.log</span></span><br><span class="line">rm -rf /lamp/ls.log</span><br></pre></td></tr></table></figure>



<p>语法二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>这种语法需要注意：</p>
<ul>
<li>初始值：在循环开始时，需要给某个变量赋予初始值，如i&#x3D;1;</li>
<li>循环控制条件：用于指定变量循环的次数，如i&lt;&#x3D;100，则只要i的值小于等于100，循环就会继续;</li>
<li>变量变化：每次循环之后，变量该如何变化，如i&#x3D;i+1。代表每次循环之后，变量i的值都加1。</li>
</ul>
<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for (( i=1;i&lt;=100;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum of 1+2+...+100 is : $s&quot;</span><br></pre></td></tr></table></figure>

<p>批量添加指定数量的用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入用户名，把输入保存入变量name</span></span><br><span class="line">read -p &quot;Please input user name: &quot; -t 30 name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入添加用户的数量，把输入保存入变量num</span></span><br><span class="line">read -p &quot;Please input the number of users: &quot; -t num</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入初始密码，把输入保存入变量pass</span></span><br><span class="line">read -p &quot;Please input the password of users: &quot; -t pass</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断三个变量不为空</span></span><br><span class="line">if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;#pass&quot; ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">判断变量num的值是否为数字</span></span><br><span class="line">	y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line">	if [ -z &quot;$y&quot; ];then</span><br><span class="line">		for (( i=1;i&lt;=$num;i=i+1 ))</span><br><span class="line">			do</span><br><span class="line">				# 添加用户</span><br><span class="line">				/usr/sbin/useradd $name$i &amp;&gt;/dev/null</span><br><span class="line">				# 修改用户密码</span><br><span class="line">				echo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null</span><br><span class="line">			done</span><br><span class="line">	fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>批量删除用户：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">user=$(cat /etc/passwd | grep &quot;/bin/bash&quot; | grep -v &quot;root&quot; | cut -d &quot;:&quot; -f 1)</span><br><span class="line">for i in $user</span><br><span class="line">	do</span><br><span class="line">		userdel -r $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>对while循环来讲，只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。</p>
<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+ 1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure>



<h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><p>until循环和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ 条件判断式 ]</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">until [ $i -gt 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure>



<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 函数名（）&#123;</span><br><span class="line">	程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">function sum () &#123;</span><br><span class="line">	s=0</span><br><span class="line">	for (( i=0;i&lt;=$1;i=i+1 ))</span><br><span class="line">		do</span><br><span class="line">			s=$(( $i+$s ))</span><br><span class="line">		done</span><br><span class="line">	echo &quot;The sum of 1+2+3+...+$l is: $s&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line">y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line"></span><br><span class="line">if [ -z $y ];then</span><br><span class="line">	sum $num</span><br><span class="line">else</span><br><span class="line">	echo &quot;Error!! Please input a number!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="特殊流程控制语名"><a href="#特殊流程控制语名" class="headerlink" title="特殊流程控制语名"></a>特殊流程控制语名</h4><p>a）exit语句</p>
<p>系统是有exit命令的，用于退出当前用户的登录状态。可是在shell脚本中，exit语句是用来退出当前脚本的。也就是说，在Shell脚本中，只要碰到了exit语句，后续的程序就不再执行，而是直接退出脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit [返回值]</span><br></pre></td></tr></table></figure>

<p>如果exit命令之后定义了返回值，那么这个脚本执行之后的返回值就是我们自己定义的返回值。可以通过$?这个变量来查看返回值。如果exit之后没有定义返回值，脚本执行之后的返回值是执行exit语句之前，最后执行的一条命令的返回值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line"></span><br><span class="line">y=$(echo $num | sed &quot;s/[0-9]//g&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断变量num的值如果不为空，则输出报错信息，并且退出脚本，退出返回值为18</span></span><br><span class="line">[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18</span><br><span class="line"></span><br><span class="line">echo &quot;The number is: $num&quot;</span><br></pre></td></tr></table></figure>



<p>b）break语句</p>
<p>当程序执行到break语句时，会结束整个当前循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		if [ $i -eq 4 ];then</span><br><span class="line">			break</span><br><span class="line">		fi</span><br><span class="line">		echo $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<p>c）continue语句</p>
<p>continue也是结束流程控制的语句。continue语句只会结束单次当前循环。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		if [ $i -eq 4 ];then</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		echo $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/25/%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/25/%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">高级文件系统管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-25 13:05:22 / 修改时间：13:10:07" itemprop="dateCreated datePublished" datetime="2025-02-25T13:05:22+08:00">2025-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高级文件系统管理"><a href="#高级文件系统管理" class="headerlink" title="高级文件系统管理"></a>高级文件系统管理</h1><h2 id="1-磁盘配额"><a href="#1-磁盘配额" class="headerlink" title="1. 磁盘配额"></a>1. 磁盘配额</h2><h3 id="1）磁盘配额条件"><a href="#1）磁盘配额条件" class="headerlink" title="1）磁盘配额条件"></a>1）磁盘配额条件</h3><ul>
<li><p>内核必须支持磁盘配额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# grep CONFIG_QUOTA /boot/config-2.6.32-279.el6.i686</span><br><span class="line">CONFIG_QUOTA=y</span><br><span class="line">CONFIG_QUOTA_NETLINK_INTERFACE=y</span><br><span class="line"># CONFIG_QUOTA_DEBUG is not set</span><br><span class="line">CONFIG_QUOTA_TREE=m</span><br><span class="line">CONFIG_QUOTACTL=y</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统中必须安装了quota工具，Linux默认是安装了quota工具</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa | grep quota</span><br><span class="line">quota-3.17-16.el6.i686</span><br></pre></td></tr></table></figure>

<p>要支持磁盘配额的分区必须开启磁盘配额功能，这个功能需要手工开启，不再是默认就开启的。</p>
</li>
</ul>
<h3 id="2）概念"><a href="#2）概念" class="headerlink" title="2）概念"></a>2）概念</h3><ul>
<li>用户配额和组配额</li>
<li>磁盘容量限制和文件个数限制</li>
<li>软限制和硬限制</li>
<li>宽限时间</li>
</ul>
<p>如果用户的空间占用数处于软限制和硬限制之间，都会在用户登录时警告用户磁盘将满，这个时间就是宽限时间，默认是7天。如果达到了宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级为硬限制。</p>
<h3 id="3）磁盘配额规划"><a href="#3）磁盘配额规划" class="headerlink" title="3）磁盘配额规划"></a>3）磁盘配额规划</h3><p>磁盘配额实验：</p>
<ul>
<li>磁盘配额是限制普通用户在分区上使用磁盘空间和文件个数的，所以我们需要指定一个分区，那么我们手工建立一个5GB的&#x2F;dev&#x2F;sdb1分区，把它挂载到&#x2F;disk目录当中。</li>
<li>还有我们需要建立被限制的用户和用户组。那么我们假设需要限制user1、user2和user3用户，这三个用户属于test组。</li>
<li>其中test组磁盘容量硬限制为500MB，软限制450MB，文件个数不做限制。user1用户为了便于测试，磁盘容量硬限制为50MB，软限制为40MB，文件个数硬限制为10个，软限制为8个。user2和user3用户磁盘容量硬限制为250MB，软限制为200MB，文件个数不做限制。</li>
<li>user1、user2和user3用户加起来的磁盘容量限制为550MB，超过了test组的磁盘容量500MB。这样的话，某个用户可能达不到自己的用户限制，而达到组限制时就不能再写入数据了。也就是说，如果用户限制和组限制同时存在，那么哪个限制更小，哪个限制优先生效。</li>
<li>系统宽限时间改为8天。</li>
</ul>
<p>磁盘配额步骤：</p>
<ul>
<li><p>分配5GB的&#x2F;dev&#x2F;sdb1分区，并将它挂载到&#x2F;disk目录当中。</p>
</li>
<li><p>建立需要做限制的用户和用户组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# groupadd test</span><br><span class="line">[root@localhost ~]# useradd -G test user1</span><br><span class="line">[root@localhost ~]# useradd -G test user2</span><br><span class="line">[root@localhost ~]# useradd -G test user3</span><br><span class="line">[root@localhost ~]# passwd user1</span><br><span class="line">[root@localhost ~]# passwd user2</span><br><span class="line">[root@localhost ~]# passwd user3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在分区上开启磁盘配额功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,usruota,grpquota /disk    # 重新挂载/disk分区，并加入用户和用户组的磁盘配额功能</span><br></pre></td></tr></table></figure>

<p>要想永久生效，则需要修改&#x2F;etc&#x2F;fstab文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1    /disk    ext4    defaults,usrquota,grpquota    0    0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /disk    # 修改配置文件如果想要生效，必须重启系统，否则也需要把分区重新挂载一遍</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立磁盘配额的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：扫描/etc/mtab文件中所有启用磁盘配额功能的分区。如果加入此参数，命令后面就不需要加入分区名了</span><br><span class="line">  -c：不管原有的配置文件，重新扫描并建立新的配置文件</span><br><span class="line">  -u：建立用户配额的配置文件，也就是生成aquota.user文件</span><br><span class="line">  -g：建立组配额的配置文件，会生成aquota.group文件</span><br><span class="line">  -v：显示扫描过程</span><br><span class="line">  -m：强制以读写的方式扫描文件系统，和-M类似。一般扫描根分区时使用。</span><br><span class="line">  -f：强制扫描文件系统，并写入新的配置文件。一般扫描新添加的硬盘分区时使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck -avug</span><br></pre></td></tr></table></figure>

<p>需要关闭SELinux，否则会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /disk/</span><br><span class="line">总计 24</span><br><span class="line">-rw-------   1 root root  6144  4月 31 19:30 aquota.group</span><br><span class="line">-rw-------   1 root root  6144  4月 18 19:30 aquota.user</span><br><span class="line"># /disk目录中两个配额配置文件已经建立</span><br></pre></td></tr></table></figure>

<p>如果需要给根分区开启配额功能，需要：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2    /    ext4    defaults,usrquota,grpquota    1    1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /</span><br><span class="line">[root@localhost ~]# quotacheck -avugm</span><br></pre></td></tr></table></figure>

<p>如果我们自动扫描&#x2F;分区建立配额文件时，因为&#x2F;分区已经挂载成读写系统，而quotacheck需要把分区先挂载成只读分区，然后建立配置文件，最后再挂载回来，所以不能直接在&#x2F;分区建立配置文件，这时就需要使用-m强制以读写方式扫描文件系统了。</p>
<ul>
<li><p>设置用户和组的配额限制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：  设定用户配额</span><br><span class="line">  -g 组名：    设定组配额</span><br><span class="line">  -t：        设定宽限时间</span><br><span class="line">  -p：        复制配额限制。如果已经设定好某个用户的配额限制，其他用户的配额限制如果和这个用户相同，那么可以直接复制配额限制，而不用都手工指定</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota -u user1</span><br><span class="line"># edquota命令进入之后，就是标准的vi操作方法</span><br><span class="line">Disk quotas for user user1（uid 500）：</span><br><span class="line"># 磁盘配额是设定用户user1（UID是500）</span><br><span class="line">Filesystem    blocks        soft     hard     inodes        soft      hard</span><br><span class="line">/dev/sdb1       0           40000    50000      0            8         10</span><br><span class="line"># 分区名        已占用容量    软限制    硬限制     已占用文件数   软限制     硬限制</span><br></pre></td></tr></table></figure>
</li>
<li><p>配额复制</p>
<p>user3用户的配额值和user2用户完全一样，就可以使用user2用户作为模板进行复制，这样我们如果需要建立大量的配额值一致的用户时，就会非常方便，不用一个个手工建立了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota -p user2 -u user3</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改宽限时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# edquota -t</span><br><span class="line">Grace period before enforcing soft limits for users:</span><br><span class="line">Time units may be: days, hours, minutes, or seconds</span><br><span class="line">Filesystem    Block grace period    Inode grace period</span><br><span class="line">/dev/sdb1       8days                8days</span><br><span class="line"># 分区名        容量的宽限时间          个数的宽限时间</span><br></pre></td></tr></table></figure>


</li>
<li><p>启动和关闭配额</p>
<p>启动配额：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotaon [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件启动所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：启动用户配额</span><br><span class="line">  -g：启动组配额</span><br><span class="line">  -v：显示启动过程的信息</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quotaon -vug /disk/        # 启动/disk分区的配额</span><br><span class="line">/dev/sdb1 [/disk]：group quotas turned on</span><br><span class="line">/dev/sdb1 [/disk]：user quotas turned on</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# quotaon -avug        # 这条命令也可以</span><br></pre></td></tr></table></figure>

<p>关闭配额：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quotaoff [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件关闭所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：关闭用户配额</span><br><span class="line">  -g：关闭组配额</span><br><span class="line">  </span><br><span class="line"> [root@localhost ~]# quotaoff -a        # 依据/etc/mtab文件关闭配额分区</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4）磁盘配额查询"><a href="#4）磁盘配额查询" class="headerlink" title="4）磁盘配额查询"></a>4）磁盘配额查询</h3><ul>
<li><p>quota查询用户或用户组配额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# quota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：   查询用户配额</span><br><span class="line">  -g 组名：     查询组配额</span><br><span class="line">  -v：          显示详细信息</span><br><span class="line">  -s：          以习惯单位显示容量大小，如M,G</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quota -uvs user1</span><br></pre></td></tr></table></figure>
</li>
<li><p>repquota查询文件系统配额</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# repquota [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：    依据/etc/mtab文件查询配额，如果不加-a选项，就一定要加分区名</span><br><span class="line">  -u：    查询用户配额</span><br><span class="line">  -g:     查询组配额</span><br><span class="line">  -v：    显示详细信息</span><br><span class="line">  -s：    以习惯单位显示容量大小</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# repquota -augvs</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5）测试"><a href="#5）测试" class="headerlink" title="5）测试"></a>5）测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[user1@localhost disk]$ dd if=/dev/zero of=/disk/testfile bs=1M count=60    # 建立testfile文件，指定大小60MB</span><br></pre></td></tr></table></figure>



<h3 id="6）非交互设定用户磁盘配额"><a href="#6）非交互设定用户磁盘配额" class="headerlink" title="6）非交互设定用户磁盘配额"></a>6）非交互设定用户磁盘配额</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">[root@localhost ~]# setquota -u user4 10000 20000 5 8 /disk</span><br></pre></td></tr></table></figure>



<h2 id="2-LVM逻辑卷管理"><a href="#2-LVM逻辑卷管理" class="headerlink" title="2. LVM逻辑卷管理"></a>2. LVM逻辑卷管理</h2><h3 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h3><p>LVM是Logical Volume Manager的简称，中文就是逻辑卷管理。</p>
<ul>
<li>物理卷(PV, Physical Volume)：就是真正的物理硬盘或分区。</li>
<li>卷组(VG, Volume Group)：将多个物理卷合起来就组成了卷组，组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘上的不同分区，可以把卷组想象为一个逻辑硬盘。</li>
<li>逻辑卷(LV, Logical Volume)：卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区称作逻辑卷，逻辑卷可以格式化和写入数据。可以把逻辑卷想象成为分区。</li>
<li>物理扩展(PE, Physical Extend)：PE是用来保存数据的最小单元，数据实际上都是写入PE当中，PE的大小是可以配置的，默认是4MB。</li>
</ul>
<h3 id="2）建立LVM的步骤"><a href="#2）建立LVM的步骤" class="headerlink" title="2）建立LVM的步骤"></a>2）建立LVM的步骤</h3><ul>
<li>首先需要把物理硬盘分成分区，当然也可以是整块物理硬盘。</li>
<li>然后把物理分区建立成为物理卷(PV)，也可以直接把整块硬盘都建立为物理卷。</li>
<li>接下来把物理卷整合成为卷组(VG)。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。</li>
<li>最后就是把卷组再划分成为逻辑卷(LV)，当然逻辑卷也是可以直接调整大小的。逻辑卷可以想象成为分区，所以也需要格式化和挂载。</li>
</ul>
<h3 id="3）物理卷管理"><a href="#3）物理卷管理" class="headerlink" title="3）物理卷管理"></a>3）物理卷管理</h3><p>a）硬盘分区</p>
<p>创建方式就是使用fdisk交互命令，不过需要注意的是分区的系统ID不再是Linux默认的分区ID号(83)了，而要改为LVM的ID号8e。</p>
<p>b）建立物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate [设备文件名]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"># 把整块硬盘都建立成物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb</span><br><span class="line"></span><br><span class="line"># 把分区建立成为物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb5</span><br></pre></td></tr></table></figure>



<p>c）查看物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvscan</span><br><span class="line">[root@localhost ~]# pvdisplay        # 更详细的物理卷信息</span><br></pre></td></tr></table></figure>



<p>d）删除物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# pvremove /dev/sdb5</span><br></pre></td></tr></table></figure>



<h3 id="4）卷组管理"><a href="#4）卷组管理" class="headerlink" title="4）卷组管理"></a>4）卷组管理</h3><p>a）建立卷组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate [选项] 卷组名 物理卷名</span><br><span class="line">[选项]：</span><br><span class="line">  -s PE大小    指定PE的大小，单位可以是MB,GB,TB等。如是不写默认PE大小为4MB</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6</span><br></pre></td></tr></table></figure>



<p>b）查看卷组</p>
<p>查看卷组的命令有两个：</p>
<ul>
<li><p>vgscan</p>
<p>vgscan主要是查看系统中是否有卷组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgscan</span><br></pre></td></tr></table></figure>
</li>
<li><p>vgdisplay</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgdisplay</span><br></pre></td></tr></table></figure></li>
</ul>
<p>c）增加卷组容量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgextend scvg /dev/sdb7</span><br></pre></td></tr></table></figure>



<p>d）减小卷组容量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在卷组中删除/dev/sdb7物理卷</span><br><span class="line">[root@localhost ~]# vgreduce scvg /dev/sdb7</span><br><span class="line"># 删除所有的未使用物理卷</span><br><span class="line">[root@localhost ~]# vgreduce -a</span><br></pre></td></tr></table></figure>



<p>e）删除卷组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vgremove scvg</span><br></pre></td></tr></table></figure>

<p>卷组删除之后，才能删除物理卷，要注意的是scvg卷组还没有添加任何的逻辑卷，如果拥有了逻辑卷，得先删除逻辑卷再删除卷组。</p>
<h3 id="5）逻辑卷管理"><a href="#5）逻辑卷管理" class="headerlink" title="5）逻辑卷管理"></a>5）逻辑卷管理</h3><p>a）建立逻辑卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate [选项] [-n 逻辑卷名] 卷组名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：指定逻辑卷大小，单位MB，GB，TB等</span><br><span class="line">  -l 个数：按照PE个数指定逻辑卷大小，这个参数需要换算容量，太麻烦</span><br><span class="line">  -n 逻辑卷名：指定逻辑卷名</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate -L 1.5G -n userlv scvg    # 在scvg卷组中建立1.5GB的userlv逻辑卷</span><br></pre></td></tr></table></figure>

<p>建立完成逻辑卷之后，还要格式化和挂载之后逻辑卷才能正常使用。不过需要注意的是逻辑卷的设备文件名是&#x2F;dev&#x2F;卷组名&#x2F;逻辑卷名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t ext4 /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# mkdir /disklvm</span><br><span class="line">[root@localhost ~]# mount /dev/scvg/userlv /disklvm/</span><br><span class="line">[root@localhost ~]# mount      # 查看挂载</span><br></pre></td></tr></table></figure>

<p>如果需要开机自动挂载，也要修改&#x2F;etc&#x2F;fstab文件。</p>
<p>b）查看逻辑卷</p>
<p>查看命令有两个：</p>
<ul>
<li><p>lvscan</p>
<p>lvscan只能看到系统中是否拥有逻辑卷。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvscan</span><br></pre></td></tr></table></figure>
</li>
<li><p>lvdisplay</p>
<p>lvdisplay可以看到逻辑卷的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvdisplay</span><br></pre></td></tr></table></figure></li>
</ul>
<p>c）调整逻辑卷大小</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvresize [选项] 逻辑卷设备文件名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：安装容量调整大小，单位KB,GB,TB等。使用+代表增加空间，-号代表减少空间。如果直接写容量，代表设定逻辑卷大小为指定大小。</span><br><span class="line">  -l 个数：按照PE个数调整逻辑卷大小</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvresize -L 2.5.G /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# lvdisplay               # 逻辑卷的大小已经改变了</span><br><span class="line">[root@localhost ~]# df -h /disklvm/         # 大小没有变化</span><br></pre></td></tr></table></figure>

<p>lvresize只能改变逻辑卷的大小，如果需要让分区使用这个新逻辑卷，还要使用resize2fs命令来调整分区的大小。不过这里体现了LVM的优势，不需要卸载分区，直接就能调整分区的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs [选项] [设备文件名] [调整的大小]</span><br><span class="line">选项：</span><br><span class="line">  -f：    强制调整</span><br><span class="line">  设备文件名：指定调整哪个分区的大小</span><br><span class="line">  调整的大小：指定把分区调整到多大，要加M,G等单位。如果不加大小，会使用整个分区</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# df -h /disklvm/       # 已经调整过来了</span><br></pre></td></tr></table></figure>



<h3 id="4）删除逻辑卷"><a href="#4）删除逻辑卷" class="headerlink" title="4）删除逻辑卷"></a>4）删除逻辑卷</h3><p>删除逻辑卷前要先卸载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lvremove 逻辑卷设备文件名</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/25/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/25/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">文件系统管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-25 13:05:05 / 修改时间：13:09:36" itemprop="dateCreated datePublished" datetime="2025-02-25T13:05:05+08:00">2025-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h1><h2 id="1-硬盘结构"><a href="#1-硬盘结构" class="headerlink" title="1. 硬盘结构"></a>1. 硬盘结构</h2><h3 id="1）硬盘的逻辑结构"><a href="#1）硬盘的逻辑结构" class="headerlink" title="1）硬盘的逻辑结构"></a>1）硬盘的逻辑结构</h3><p>每个扇区的大小是固定的，为512Byte。扇区也是磁盘的最小存储单位。</p>
<p>硬盘的大小是用”磁头数X柱面数X扇区数X每个扇区的大小”这样的公式来计算的。其中磁头数(Heads)表示硬盘总共有几个磁头，也可以理解成硬盘有几个盘面，然后乘以2；柱面数(Cylinders)表示硬盘每一面盘片有几条磁道；扇区数(Sectors)表示每条磁道上有几个扇区；每个扇区的大小一般是512Byte。</p>
<h3 id="2）硬盘接口"><a href="#2）硬盘接口" class="headerlink" title="2）硬盘接口"></a>2）硬盘接口</h3><ul>
<li><p>IDE硬盘接口(Integrated Drive Electronics，并口，即电子集成驱动器)</p>
<p>也称作”ATA硬盘”或”PATA硬盘”，是早期机械硬盘的主要接口，ATA133硬盘的理论速度可以达到133MB&#x2F;s(此速度为理论平均值)。</p>
</li>
<li><p>SATA接口(Serial ATA，串口)</p>
<p>是速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力。目前已经是SATA三代，理论传输速度达到600MB&#x2F;s(此速度为理论平均值)。</p>
</li>
<li><p>SCSI接口(Small Computer System Interface，小型计算机系统接口)广泛用在服务器上，具有应用范围广、多任务、带宽大、CPU占用率低及支持执插拔等优点，理论传输速度达到320MB&#x2F;s。</p>
</li>
</ul>
<h2 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2. 文件系统"></a>2. 文件系统</h2><h3 id="1）Linux文件系统的特性"><a href="#1）Linux文件系统的特性" class="headerlink" title="1）Linux文件系统的特性"></a>1）Linux文件系统的特性</h3><ul>
<li><p>super block（超级块）</p>
<p>记录整个文件系统的信息，包括：</p>
<ul>
<li>block与inode的总量</li>
<li>已经使用的inode和block的数量</li>
<li>未使用的inode和block的数量</li>
<li>block与inode的大小</li>
<li>文件系统的挂载时间</li>
<li>最近一次的写入时间</li>
<li>最近一次的磁盘检验时间等</li>
</ul>
</li>
<li><p>data block（数据块，也称作block）</p>
<p>用来实际保存数据的，block的大小(1KB|2KB|4KB)和数量在格式化后就已经决定，不能改变，除非重新格式化。每个block只能保存一个文件的数据，要是文件数据小于一个block块，那么这个block的剩余空间不能被其他文件使用；要是文件数据大于一个block块，则占用多个block块。Windows中磁盘碎片整理工具的原理就是把一个文件占用的多个block块尽量整理到一起，这样可以加快读写速度。</p>
</li>
<li><p>inode（i节点）</p>
<p>用来记录文件的权限(r、w、x)，文件的所有者和属组，文件的大小，文件的状态改变时间(ctime)，文件的最近一次读取时间(atime)，文件的最近一次修改时间(mtime)，文件的数据真正保存的block编号。每个文件需要占一个inode。</p>
</li>
</ul>
<h3 id="2）Linux常见文件系统"><a href="#2）Linux常见文件系统" class="headerlink" title="2）Linux常见文件系统"></a>2）Linux常见文件系统</h3><table>
<thead>
<tr>
<th>文件系统</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ext</td>
<td>Linux中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用。</td>
</tr>
<tr>
<td>ext2</td>
<td>是ext文件系统的升级版本，Red Hat Linux 7.2版本以前的系统默认都是ext2文件系统。于1993年发布，支持最大16TB的分区和最大2TB的文件</td>
</tr>
<tr>
<td>ext3</td>
<td>是ext2文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大16TB的分区和最大2TB的文件</td>
</tr>
<tr>
<td>ext4</td>
<td>是ext3文件系统的升级版。ext4在性能、伸缩性和可靠性方面进行了大量改进。ext4的变化可以说是翻天覆地的，比如向下兼容ext3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等。它是CentOS 6.x的默认文件系统</td>
</tr>
<tr>
<td>xfs</td>
<td>XFS最早针对IRIX操作系统开发，是一个高性能的日志型文件系统，能够在断电以及操作系统崩溃的情况下保证文件系统数据的一致性。它是一个64位的文件系统，后来进行开源并且移植到了Linux操作系统中，目前CentOS 7.x将XFS+LVM作为默认的文件系统，据官方所称，XFS对于大文件的读写性能较好。</td>
</tr>
<tr>
<td>swap</td>
<td>swap是Linux中用于交换分区的文件系统(类似于Windows中的虚拟内存)，当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的2倍，但不要超2GB。它是Linux的必需分区。</td>
</tr>
<tr>
<td>NFS</td>
<td>NFS是网络文件系统(Network File System)的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源</td>
</tr>
<tr>
<td>ISO9660</td>
<td>光盘的标准文件系统，Linux要想使用光盘，必须支持iso9660文件系统</td>
</tr>
<tr>
<td>fat</td>
<td>就是Windows下的fat16文件系统，在Linux中识别为fat</td>
</tr>
<tr>
<td>vfat</td>
<td>就是Windows下的fat32文件系统，在Linux中识别为vfat。支持最大32GB的分区和最大4GB的文件。</td>
</tr>
<tr>
<td>NTFS</td>
<td>就是Windows下的NTFS文件系统，不过Linux默认是不能识别NTFS文件系统的，如果需要识别，则需要重新编译内核才能支持。它比fat32文件系统更加安全，速度更快，支持最大2TB的分区和最大64GB的文件。</td>
</tr>
</tbody></table>
<h2 id="3-常用的硬盘管理命令"><a href="#3-常用的硬盘管理命令" class="headerlink" title="3. 常用的硬盘管理命令"></a>3. 常用的硬盘管理命令</h2><h3 id="1）df命令"><a href="#1）df命令" class="headerlink" title="1）df命令"></a>1）df命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -ahT</span><br><span class="line">选项：</span><br><span class="line">  -a:    显示特殊文件系统，这些文件系统几乎都是保存在内存中的。如/proc,因为挂载在内存中，所以占用量都是0</span><br><span class="line">  -h:    单位不是只用KB，而是换算成习惯单位</span><br><span class="line">  -T:    多出了文件系统类型一列</span><br></pre></td></tr></table></figure>



<h3 id="2）du命令"><a href="#2）du命令" class="headerlink" title="2）du命令"></a>2）du命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# du [选项] [目录或文件名]</span><br><span class="line">选项：</span><br><span class="line">  -a 显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量</span><br><span class="line">  -h 使用习惯单位显示磁盘占用量，如KB，MB或GB等</span><br><span class="line">  -s 统计总占用量，而不列出子目录和子文件的占用量</span><br></pre></td></tr></table></figure>

<p>du与df的区别：du是用于统计文件大小的，统计的文件大小是准确的；df是用于统计空间大小的，统计的剩余空间是准确的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# df -Th</span><br><span class="line">文件系统        类型      大小  已用  可用 已用% 挂载点</span><br><span class="line">tmpfs           tmpfs     687M  2.5M  685M    1% /run</span><br><span class="line">/dev/nvme0n1p10 ext4      187G  144G   34G   82% /</span><br><span class="line">tmpfs           tmpfs     3.4G  5.4M  3.4G    1% /dev/shm</span><br><span class="line">tmpfs           tmpfs     5.0M   12K  5.0M    1% /run/lock</span><br><span class="line">efivarfs        efivarfs  148K  112K   32K   79% /sys/firmware/efi/efivars</span><br><span class="line">/dev/nvme0n1p1  vfat       96M   53M   44M   56% /boot/efi</span><br><span class="line">tmpfs           tmpfs     687M  172K  687M    1% /run/user/1000</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# du -sh /</span><br><span class="line">113G	/</span><br></pre></td></tr></table></figure>

<p>df和du统计的根目录大小有差异，是因为du统计的是根目录文件大小，df统计的不仅只有根目录文件大小，还有临时文件的大小。</p>
<h3 id="3）fsck文件系统修复命令"><a href="#3）fsck文件系统修复命令" class="headerlink" title="3）fsck文件系统修复命令"></a>3）fsck文件系统修复命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fsck -y 分区                  # 开机重启自动修复</span><br></pre></td></tr></table></figure>



<h3 id="4）显示磁盘状态"><a href="#4）显示磁盘状态" class="headerlink" title="4）显示磁盘状态"></a>4）显示磁盘状态</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs -h 分区</span><br></pre></td></tr></table></figure>



<h3 id="5）查看文件的详细时间"><a href="#5）查看文件的详细时间" class="headerlink" title="5）查看文件的详细时间"></a>5）查看文件的详细时间</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# stat 文件名</span><br></pre></td></tr></table></figure>



<h3 id="6）判断文件类型"><a href="#6）判断文件类型" class="headerlink" title="6）判断文件类型"></a>6）判断文件类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# file 文件名</span><br></pre></td></tr></table></figure>



<h3 id="7）判断命令类型"><a href="#7）判断命令类型" class="headerlink" title="7）判断命令类型"></a>7）判断命令类型</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# type 命令名</span><br></pre></td></tr></table></figure>



<h2 id="4-fdisk命令手工分区"><a href="#4-fdisk命令手工分区" class="headerlink" title="4. fdisk命令手工分区"></a>4. fdisk命令手工分区</h2><h3 id="1）查看系统所有硬盘及分区"><a href="#1）查看系统所有硬盘及分区" class="headerlink" title="1）查看系统所有硬盘及分区"></a>1）查看系统所有硬盘及分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk -l</span><br></pre></td></tr></table></figure>



<h3 id="2）磁盘分区"><a href="#2）磁盘分区" class="headerlink" title="2）磁盘分区"></a>2）磁盘分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk 磁盘</span><br></pre></td></tr></table></figure>

<p>fdisk交互指令说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>设置可引导标记</td>
</tr>
<tr>
<td>b</td>
<td>编辑bsd磁盘标签</td>
</tr>
<tr>
<td>c</td>
<td>设置DOS操作系统兼容标记</td>
</tr>
<tr>
<td>d</td>
<td>删除一个分区</td>
</tr>
<tr>
<td>l</td>
<td>显示已知的文件系统类型。82为Linux swap分区，83为Linux分区</td>
</tr>
<tr>
<td>m</td>
<td>显示帮助菜单</td>
</tr>
<tr>
<td>n</td>
<td>新建分区</td>
</tr>
<tr>
<td>o</td>
<td>建立空白DOS分区表</td>
</tr>
<tr>
<td>p</td>
<td>显示分区列表</td>
</tr>
<tr>
<td>q</td>
<td>不保存退出</td>
</tr>
<tr>
<td>s</td>
<td>新建空白SUN磁盘标签</td>
</tr>
<tr>
<td>t</td>
<td>改变一个分区的系统ID</td>
</tr>
<tr>
<td>u</td>
<td>改变显示记录单位</td>
</tr>
<tr>
<td>v</td>
<td>验证分区表</td>
</tr>
<tr>
<td>w</td>
<td>保存退出</td>
</tr>
<tr>
<td>x</td>
<td>附加功能</td>
</tr>
</tbody></table>
<p>新建主分区：n—p—1—1分区号—分区大小+100M—w</p>
<p>新建扩展分区：n—e—2分区号—124起始柱面—1024柱面(所有剩余空间都分配给扩展分区)</p>
<p>新建逻辑分区：n—l—不用指定分区号—124起始柱面—+100M(指定大小)—w</p>
<h3 id="3）格式化"><a href="#3）格式化" class="headerlink" title="3）格式化"></a>3）格式化</h3><p>a）mkfs</p>
<p>mkfs命令非常简单易用，不过是不能调整分区的默认参数的（比如块大小是4096），这些默认参数除非特殊情况，否则不能调整。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t 文件系统类型 分区</span><br></pre></td></tr></table></figure>



<p>b）mke2fs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mke2fs [选项] 分区</span><br><span class="line">[选项]：</span><br><span class="line">  -t 文件系统：    指定格式化成哪个文件系统，如ext4, xfs</span><br><span class="line">  -b 字节:        指定block块的大小</span><br><span class="line">  -i 字切:        指定&quot;字节/inode&quot;的比例，也就是多少个字节分配一个inode</span><br><span class="line">  -j：            建立带有ext3日志功能的文件系统</span><br><span class="line">  -L 卷标名:      给文件系统设置卷标名，就不使用e2label命令设定了</span><br></pre></td></tr></table></figure>



<h3 id="4）建立挂载点"><a href="#4）建立挂载点" class="headerlink" title="4）建立挂载点"></a>4）建立挂载点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /disk1</span><br></pre></td></tr></table></figure>



<h3 id="5）挂载"><a href="#5）挂载" class="headerlink" title="5）挂载"></a>5）挂载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount 分区 挂载点</span><br></pre></td></tr></table></figure>



<h3 id="6）查看"><a href="#6）查看" class="headerlink" title="6）查看"></a>6）查看</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有已经挂载的分区和光盘</span><br><span class="line">[root@localhost ~]# mount</span><br><span class="line"></span><br><span class="line"># 查看系统分区</span><br><span class="line">[root@localhost ~]# fdisk -l</span><br><span class="line"></span><br><span class="line"># 查看分区占用百分比</span><br><span class="line">[root@Loaclhost ~]# df -Th</span><br></pre></td></tr></table></figure>



<h3 id="7）自动挂载"><a href="#7）自动挂载" class="headerlink" title="7）自动挂载"></a>7）自动挂载</h3><p>修改分区自动挂载文件(&#x2F;etc&#x2F;fstab)。此文件直接参与系统启动，如果修改错误，系统启动报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1              /disk1               ext4            defaults            1                  2</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：设备文件名</li>
<li>第二列：挂载点</li>
<li>第三列：文件系统</li>
<li>第四列：挂载选项</li>
<li>第五列：是否可以被备份。0（不备份） 1（每天备份） 2（不定期备份）</li>
<li>第六列：是否检测磁盘。0（不检测） 1（启动时检测） 2（启动后检测）</li>
</ul>
<p>也可以使用UUID进行挂载，UUID（硬盘通用唯一识别码，可以理解为硬盘的ID）。</p>
<ul>
<li>这个字段在CentOS 5.5的系统当中是写入分区的卷标名或分区设备文件名的，现在变更成硬盘的UUID。这样做的好处是当硬盘增加了新的分区，或者分区的顺序改变，再或者内核升级后，仍然能够保证分区能够正确的加载，而不至于造成启动障碍。</li>
<li>dumpe2fs命令可以查看磁盘状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs /dev/sdb5</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /dev/disk/by-uuid/</span><br></pre></td></tr></table></figure>



<h3 id="8）重启测试"><a href="#8）重启测试" class="headerlink" title="8）重启测试"></a>8）重启测试</h3><p>或者使用”mount -a”重新挂载所有内容，用它进行测试。</p>
<h2 id="5-etc-fstab文件修复"><a href="#5-etc-fstab文件修复" class="headerlink" title="5. &#x2F;etc&#x2F;fstab文件修复"></a>5. &#x2F;etc&#x2F;fstab文件修复</h2><ul>
<li><p>服务器连接显示器输入root密码登录系统。</p>
</li>
<li><p>此时根目录为只读文件系统，需要重新挂载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,rw /</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;fstab文件内容至正确。</p>
</li>
<li><p>重启服务器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# reboot</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-parted命令分区"><a href="#6-parted命令分区" class="headerlink" title="6 parted命令分区"></a>6 parted命令分区</h2><p>Linux系统中有两种常见的分区表：</p>
<ul>
<li><p>MBR分区表（主引导记录分区表）</p>
<p>支持的最大分区是2TB，最多支持4个主分区，或3个主分区1个扩展分区。</p>
</li>
<li><p>GPT分区表（GUID分区表）</p>
<p>支持最大18EB分区，最多支持128个分区，其中1个系统保留分区，127个用户自定义分区。</p>
</li>
</ul>
<p>不过parted命令也有点小问题，就是命令自身分区的时候只能格式化成ext2文件系统，不支持ext3和ext4文件系统。不过这没有太多的影响，因为我们可以先分区再用mkfs进行格式化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted 硬盘</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>parted交互命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>check NUMBER</td>
<td>做一次简单的文件系统检测</td>
</tr>
<tr>
<td>cp [FROM-DEVICE] FROM-NUMBER TO NUMBER</td>
<td>复制文件系统到另一个分区</td>
</tr>
<tr>
<td>help [COMMAND]</td>
<td>显示所有的命令帮助</td>
</tr>
<tr>
<td>mklabel,mktable LABEL-TYPE</td>
<td>创建新的磁盘卷标(分区表)</td>
</tr>
<tr>
<td>mkfs NUMBER FS-TYPE</td>
<td>在分区上建立文件系统</td>
</tr>
<tr>
<td>mkpart PART-TYPE [FS-TYPE] START END</td>
<td>创建一个分区</td>
</tr>
<tr>
<td>mkpartfs PART-TYPE FS-TYPE START END</td>
<td>创建分区，并建立文件系统</td>
</tr>
<tr>
<td>move NUMBER START END</td>
<td>移动分区</td>
</tr>
<tr>
<td>name NUMBER NAME</td>
<td>给分区命名</td>
</tr>
<tr>
<td>print [devices|free|list,all|NUMBER]</td>
<td>显示分区表，活动设备，空闲空间，所有分区</td>
</tr>
<tr>
<td>quit</td>
<td>退出</td>
</tr>
<tr>
<td>rescue START END</td>
<td>修复丢失的分区</td>
</tr>
<tr>
<td>resize NUMBER START END</td>
<td>修改分区大小</td>
</tr>
<tr>
<td>rm NUMBER</td>
<td>删除分区</td>
</tr>
<tr>
<td>select DEVICE</td>
<td>选择需要编辑的设备</td>
</tr>
<tr>
<td>set NUMBER FLAG STATE</td>
<td>改变分区标记</td>
</tr>
<tr>
<td>toggle [NUMBER [FLAG]]</td>
<td>切换分区表的状态</td>
</tr>
<tr>
<td>unit UNIT</td>
<td>设置默认的单位</td>
</tr>
<tr>
<td>Version</td>
<td>显示版本</td>
</tr>
</tbody></table>
<h3 id="1）查看分区"><a href="#1）查看分区" class="headerlink" title="1）查看分区"></a>1）查看分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">(parted) print                                 # 输入print指令</span><br><span class="line">Model： VMware, VMware Virtual S（scsi）        # 硬盘参数</span><br><span class="line">Disk /dev/sdb：21.5GB                           # 硬盘大小</span><br><span class="line">Sector size (logical/physical)：512B/512B       # 扇区大小</span><br><span class="line">Partition Table：msdos                          # 分区表类型，就是MBR分区表</span><br><span class="line">Number      Start    End     Size    Type    File system    标志</span><br><span class="line">1           32.3kB   5379MB  5379MB   primary</span><br></pre></td></tr></table></figure>

<h3 id="2）修改成GPT分区表"><a href="#2）修改成GPT分区表" class="headerlink" title="2）修改成GPT分区表"></a>2）修改成GPT分区表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">（parted）mklabel gpt</span><br><span class="line">警告：正在使用/dev/sdb上的分区                            # 由于/dev/sdb分区已经挂载，所以有警告</span><br><span class="line"></span><br><span class="line">忽略/Ingore/放弃/Cancel? ignore                         # 输入ignore忽略报错</span><br><span class="line">警告：The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost, Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes                                       # 输入yes</span><br><span class="line">警告：WARNING：the kernel failed to re-read the partition table on /dev/sdb（设备或资源忙）. As a result,it may not reflect all of your changes until after reboot.                        # 下次重启后，才能生效</span><br><span class="line"></span><br><span class="line">（parted）print                                          # 查看分区表</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt                                     # 分区表已经变成GPT</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志          # 所有的分区都消失了</span><br></pre></td></tr></table></figure>

<p>修改了分区表，如果这块硬盘已经有分区了，那么原有分区和分区中的数据都会消失，而且需要重启系统才会生效。</p>
<p>转换分区表的目的是为了支持大于2TB的分区，如果分区并没有大于2TB，那么这步是可以不执行的。</p>
<p>**注意：**一定要把&#x2F;etc&#x2F;fstab文件中和原有分区的内容删除掉，才能重启，不然系统重启一定会报错。</p>
<h3 id="3）建立分区"><a href="#3）建立分区" class="headerlink" title="3）建立分区"></a>3）建立分区</h3><p>因为修改过分区表，所以&#x2F;dev&#x2F;sdb中的所有数据丢失了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">（parted）mkpart                                    # 输入创建分区命令</span><br><span class="line">分区名称?  []? disk1                                 # 分区名称</span><br><span class="line">文件系统类型？  [ext2]?                               # 文件系统类型，直接回车，使用默认ext2</span><br><span class="line">起始点? 1MB                                          # 分区从1MB开始</span><br><span class="line">结束点? 5GB                                          # 分区到5GB结束</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br><span class="line">1         1049kB   5000MB  4999MB                disk1</span><br></pre></td></tr></table></figure>



<h3 id="4）建立文件系统"><a href="#4）建立文件系统" class="headerlink" title="4）建立文件系统"></a>4）建立文件系统</h3><p>分区分完了，还需要格式化。不过如果使用parted交互命令格式化的话，只能格式化成ext2文件系统。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">（parted）mkfs</span><br><span class="line">WARNING：you are attempting to use parted to operate on （mkfs） a file system. parted&#x27;s file system manipulation code is not as rebust as what you&#x27;ll find in dedicated, file-system-specific packages like e2fsprogs. We recommand you use parted only to manipulate partition tables, whenever possible. Support for performing most operations on most types of file systems will be removed in an upcoming release.</span><br><span class="line">警告：The existing file system will be destoryed and all data on the partition will be lost.</span><br><span class="line">Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes                                # 警告你格式化数据会丢失</span><br><span class="line">分区编号? 1</span><br><span class="line">文件系统类型?  [ext2]?                             # 指定文件系统类型</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br><span class="line">1         1049kB   5000MB  4999MB    ext2        disk1</span><br></pre></td></tr></table></figure>

<p>如果要格式化成ext4文件系统，需要使用Linux的mkfs命令。</p>
<h3 id="5）删除分区"><a href="#5）删除分区" class="headerlink" title="5）删除分区"></a>5）删除分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(parted) rm                                     # 删除分区命令</span><br><span class="line">分区编号? 1                                      # 指定分区号</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br></pre></td></tr></table></figure>

<p>parted中的所有操作都是立即生效，没有保存生效的概念，这点和fdisk交互命令明显不同。</p>
<p>至于到底使用fdisk还是parted进行分区？推荐分区大小小于2GB，使用fdisk分区；分区大小大于2GB，使用parted分区。 </p>
<h2 id="7-swap分区"><a href="#7-swap分区" class="headerlink" title="7. swap分区"></a>7. swap分区</h2><h3 id="1）分区"><a href="#1）分区" class="headerlink" title="1）分区"></a>1）分区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# fdisk /dev/sdb</span><br><span class="line">Command (m for help): t                               # 修改分区的系统id</span><br><span class="line">Selected partition 1                                  # 选择分区</span><br><span class="line">Hex code (type L to list codes)：82                    # 改为swap的id</span><br><span class="line">Changed system type of partition 1 to 82 (Linux swap / Solaris)</span><br></pre></td></tr></table></figure>



<h3 id="2）格式化"><a href="#2）格式化" class="headerlink" title="2）格式化"></a>2）格式化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkswap /dev/sdb1</span><br><span class="line">Setting up swapspace version 1, size = 522076 KiB</span><br><span class="line">no label, UUID=C3351dc3-f403-419a-9666-c24615e170fb</span><br></pre></td></tr></table></figure>



<h3 id="3）挂载"><a href="#3）挂载" class="headerlink" title="3）挂载"></a>3）挂载</h3><p>swap空间支持扩容。扩容也使用swapon命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# swapon /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>开机自动挂载：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1      swap      swap      defaults      0      0</span><br></pre></td></tr></table></figure>

<p>也可以使用uuid。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/25/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/25/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">权限管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-25 13:04:53 / 修改时间：13:08:52" itemprop="dateCreated datePublished" datetime="2025-02-25T13:04:53+08:00">2025-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><h2 id="1-ACL权限"><a href="#1-ACL权限" class="headerlink" title="1. ACL权限"></a>1. ACL权限</h2><h3 id="1）ACL概述"><a href="#1）ACL概述" class="headerlink" title="1）ACL概述"></a>1）ACL概述</h3><p>ACL是用于解决用户对文件身份不足问题的。</p>
<h3 id="2）开启ACL"><a href="#2）开启ACL" class="headerlink" title="2）开启ACL"></a>2）开启ACL</h3><p>查询acl是否开启：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dumpe2fs命令是查询指定分区详细文件系统信息的命令</span></span><br><span class="line">dumpe2fs -h &lt;根分区&gt;</span><br><span class="line">选项：</span><br><span class="line">  -h:    仅显示超级地中信息，而不显示磁盘块组的详细信息。</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> Default mount options:     user_xattr acl</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>如果没有开启，手工开启分区的ACL权限：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新挂载根分区，并挂载加入acl权限</span></span><br><span class="line">mount -o remount,acl /</span><br></pre></td></tr></table></figure>

<p>也可以通过修改&#x2F;etc&#x2F;fstab文件，永久开启ACL权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line">UUID=6f9a4f35-3b8f-425e-b8f3-4d46dbca87ad /               ext4       defaults.acl 0       1</span><br></pre></td></tr></table></figure>

<p>验证目录ACL权限存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -ahl /</span><br><span class="line">drwxrwx---+   2 sc   tg         4096  2月 14 20:19 www/</span><br><span class="line"># “+”代表有ACL权限</span><br></pre></td></tr></table></figure>



<h3 id="3）ACL基本命令"><a href="#3）ACL基本命令" class="headerlink" title="3）ACL基本命令"></a>3）ACL基本命令</h3><p>a）查询文件的ACL权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getfacl 文件名</span><br></pre></td></tr></table></figure>



<p>b）设定ACL权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setfacl [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -m    设定ACL权限</span><br><span class="line">  -b    删除ACL权限</span><br><span class="line">  -x    删除单个用户的ACL权限</span><br><span class="line">  -R    递归(只能赋予目录，且只对已经存在的文件生效)</span><br><span class="line"></span><br><span class="line">setfacl -m u:用户名:权限(1|2|4|5|7) 文件名</span><br><span class="line">setfacl -m g:组名:权限(1|2|4|5|7) 文件名</span><br><span class="line"></span><br><span class="line"># 赋予ACL默认权限。默认权限只能赋予目录，且只对以后新建的文件生效</span><br><span class="line">setfacl -m d:u:用户名|组名:权限(1|2|4|5|7) 目录</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 给test目录赋予aa用户读写执行的ACL权限</span><br><span class="line">setfacl -m u:aa:rwx /test</span><br><span class="line"></span><br><span class="line"># 赋予递归ACL权限</span><br><span class="line">setfacl -m u:cc:rx -R soft/</span><br><span class="line"></span><br><span class="line"># ACL默认权限</span><br><span class="line">setfacl -m d:u:aa:rwx -R soft/</span><br></pre></td></tr></table></figure>

<p>**注意：**ACL权限，一旦递归后，不可避免的出现权限溢出。因为x权限对目录来说相当于cd，而对文件是最大权限。所以ACL权限能不用则不用。</p>
<h3 id="4）最大有效权限-mask"><a href="#4）最大有效权限-mask" class="headerlink" title="4）最大有效权限(mask)"></a>4）最大有效权限(mask)</h3><p>即最大ACL权限。设定用户或组ACL权限后，该用户或组最终权限是最大ACL权限(mask权限)与该用户或组权限逻辑与的结果的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 设定mask权限为r-x,使用“m:权限”格式</span><br><span class="line">setfacl -m m:rx project/</span><br><span class="line"></span><br><span class="line"># 查询project/目录权限</span><br><span class="line"># file: project/</span><br><span class="line"># owner: root</span><br><span class="line"># group: tgroup</span><br><span class="line">user::rwx              #effective:r-x</span><br><span class="line">group::rwx             #effective:r-x</span><br><span class="line">mask::r-x</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>



<h3 id="5）删除ACL权限"><a href="#5）删除ACL权限" class="headerlink" title="5）删除ACL权限"></a>5）删除ACL权限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 删除指定用户和用户组的ACL权限</span><br><span class="line">setfacl -x u:st /project/</span><br><span class="line"></span><br><span class="line"># 删除文件的所有ACL权限</span><br><span class="line">setfacl -b /project/</span><br></pre></td></tr></table></figure>



<h2 id="2-sudo授权"><a href="#2-sudo授权" class="headerlink" title="2. sudo授权"></a>2. sudo授权</h2><p>给普通用户赋予部分管理员权限。</p>
<p>在&#x2F;sbin&#x2F;和&#x2F;usr&#x2F;sbin&#x2F;目录下的命令只有超级用户才能使用。</p>
<h3 id="1）root身份"><a href="#1）root身份" class="headerlink" title="1）root身份"></a>1）root身份</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 执行visudo命令，赋予普通用户权限命令，命令执行后和vi一样使用</span><br><span class="line">visudo</span><br><span class="line"></span><br><span class="line">root     ALL=(ALL)                         ALL</span><br><span class="line">#用户名   被管理主机的地址=(可使用的身份)       授权命令(绝对路径)</span><br><span class="line"># %wheel        ALL=(ALL)                              ALL</span><br><span class="line">#%组名           被管理主机的地址=(可使用的身份)            授权命令(绝对路径)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用户名&#x2F;组名：代表root给哪个用户或用户组赋予命令，注意组名前加“%”。</p>
</li>
<li><p>用户可以用指定的命令管理指定IP地址的服务器。如果写ALL，代表可以管理任务主机，如果写固定IP，代表用户可以管理指定的服务器。(这里的IP指定的是用户可以管理哪个IP地址的服务器，那么如果你是一台独立的服务器，这里写ALL和你服务器的IP地址，作用是一样的。而写入网段，只有对NIS服务这样用户和密码集中管理的服务器才有意义)。如果我们这里写本机的IP地址，不代表只允许本机的用户使用指定命令，而代表指定的用户可以从任何IP地址来管理当前服务器。</p>
</li>
<li><p>可使用身份：就是把来源用户切换成什么身份使用，(ALL)代表可以切换成任意身份。这个字段可以省略。</p>
</li>
<li><p>授权命令：代表root把什么命令授权给普通用户。默认是ALL，代表任何命令，这个当然不行，如果需要给哪个命令授权，写入命令名即可。不过需要注意一定要命令写成绝对路径。</p>
</li>
</ul>
<p>【示例1】：授权用户user1可以重启服务器。</p>
<p>则由root用户添加如下行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">user1         ALL=/sbin/shutdown -r now</span><br><span class="line"></span><br><span class="line"># 查看可用的授权</span><br><span class="line">[user1@localhost ~]$ sudo -l</span><br><span class="line"></span><br><span class="line"># 执行授权命令</span><br><span class="line">[user1@localhost ~]$ sudo /sbin/shutdown -r now</span><br></pre></td></tr></table></figure>



<p>【示例2】：授权一个用户管理web服务器。</p>
<p>首先要分析授权用户管理Apache至少要实现哪些基本授权：</p>
<ul>
<li>可以使用Apache管理脚本</li>
<li>可以修改Apache配置文件</li>
<li>可以更新网页内容</li>
</ul>
<p>假设Apache管理脚本程序为&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;httpd。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># visudo授权</span><br><span class="line">[root@loaclhost ~]# visudo</span><br><span class="line">user1      192.168.0.156=/etc/rc.d/init.d/httpd reload,/etc/rc.d/init.d/httpd configtest</span><br></pre></td></tr></table></figure>

<p>授权用户user1可以连接192.168.0.156上的Apache服务器，通过Apache管理脚本重新读取配置文件让更改的设置生效(reload)和可以检测Apache配置文件语法错误(configtest)。</p>
<p>为满足条件二：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">user1      192.168.0.156=/usr/bin/vim /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure>

<p>授权用户user1可以用root身份使用vi编辑Apache配置文件。</p>
<p>为满足条件三，假设网页存放目录为&#x2F;var&#x2F;www&#x2F;html，则只需要授权user1对此目录具有写权限或者索性更改目录所有者为user1即可。如果需要，还可以设置user1可以通过FTP等文件共享服务更新网页。</p>
<p>【示例3】：授权aa用户可以添加其他普通用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">aa    ALL=/usr/sbin/useradd</span><br><span class="line">aa    ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd &quot;&quot;, !/usr/bin/passwd root    # 不能改root用户密码</span><br></pre></td></tr></table></figure>



<h2 id="3-文件特殊权限"><a href="#3-文件特殊权限" class="headerlink" title="3.文件特殊权限"></a>3.文件特殊权限</h2><h3 id="1）SetUID"><a href="#1）SetUID" class="headerlink" title="1）SetUID"></a>1）SetUID</h3><p>a）SetUID概念</p>
<p>SetUID的功能可以这样理解：</p>
<ul>
<li>只有可以执行的文件才能设定SUID权限</li>
<li>命令执行者要对该程序拥有x（执行）权限</li>
<li>命令执行者在执行该程序时获得该程序文件属主的身份(在执行程序的过程中灵魂附体为文件的属主)</li>
<li>SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /etc/passwd</span><br><span class="line">-rw-r--r-- 1 root root 3626  2月 15 11:38 /etc/passwd</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll /etc/shadow</span><br><span class="line">-rw-r----- 1 root shadow 2092  2月 15 11:37 /etc/shadow</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 root root 64152  5月 30  2024 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p>&#x2F;usr&#x2F;bin&#x2F;passwd命令拥有特殊权限SetUID，也就是在属主的权限位的执行权限上是s。可以这样来理解它：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。&#x2F;usr&#x2F;bin&#x2F;passwd命令具有SetUID权限，所有者为root（Linux中的命令默认所有者都是root），也就是说当普通用户使用passwd更改自己密码的时候，那一瞬间突然灵魂附体了，实际是用passwd命令所有者root的身份在执行passwd命令，root当然可以将密码写入&#x2F;etc&#x2F;shadow文件，所以普通用户也可以修改&#x2F;etc&#x2F;shadow文件，命令执行完成后该身份也随之消失。如果取消SetUID权限，则普通用户就不能修改自己的密码了。</p>
<p>b）设置SetUID权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 设置SetUID权限</span><br><span class="line">[root@localhost ~]# chmod u+s /usr/bin/vim      # 极其危险，意味着把服务器送给别人了，别人可以打开、修改任何文件了</span><br><span class="line"></span><br><span class="line"># 查看SetUID权限</span><br><span class="line">[root@localhost ~]# ll /usr/bin/vim</span><br><span class="line">-rwsr-xr-x 1 root root 1847752 4月 5 2012 /usr/bin/vim </span><br></pre></td></tr></table></figure>



<p>c）建议</p>
<ul>
<li>关键目录应严格控制写权限，比如“&#x2F;”、“&#x2F;usr”等；</li>
<li>用户的密码设置要严格遵守密码三原则；</li>
<li>对系统中默认应该具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限。</li>
</ul>
<p>d）检测SetUID的脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: ben (E-main: 326525276@qq.com)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索系统中所有拥有SUID和SGID的文件，并保存到临时目录中</span></span><br><span class="line">find / -perm -4000 -o -perm -2000 &gt; /tmp/setuid.check</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">做循环，每次循环取出临时文件中的文件名</span></span><br><span class="line">for i in $(cat /tmp/setuid.check)</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">比对这个文件名是否在模板文件中</span></span><br><span class="line">	grep $i /root/suid.list &gt; /dev/null</span><br><span class="line">	if [&quot;$?&quot; != &quot;0&quot;]</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果在，不报错</span></span><br><span class="line">	then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果文件不在模板文件中，则报错，并把报错存在日志中</span></span><br><span class="line">		echo &quot;$i isn&#x27;t in listfile!&quot; &gt;&gt; /root/suid_log_$(date +%F)</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件</span></span><br><span class="line">rm -rf /tmp/setuid.check</span><br></pre></td></tr></table></figure>



<h3 id="2）SetGID"><a href="#2）SetGID" class="headerlink" title="2）SetGID"></a>2）SetGID</h3><p>SGID既可以针对文件生效，也可以针对目录生效。这和SUID明显不同。</p>
<p>a）针对文件的作用</p>
<p>针对文件，SGID的含义如下：</p>
<ul>
<li>只有可执行的文件才能设置SGID权限</li>
<li>命令执行者要对该文件拥有x（执行）权限</li>
<li>命令执行者在执行文件的时候，组身份升级为该文件的属组</li>
<li>SetGID权限同样只在该文件执行过程中有效，也就是说组身份改变只在文件执行过程中有效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /var/lib/mlocate/mlocate.db</span><br><span class="line">-rw-r----- 1 root slocate 1838850 1月    20 04：29 /var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>

<p>属主权限是r、w，属组权限是r，其他人权限是0；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ll /usr/bin/locate</span><br><span class="line">-rwx--s--x. 1 root slocate 38464  8月 24 2010 /usr/bin/locate    # 所属组s代表SetGID权限</span><br></pre></td></tr></table></figure>

<p>当普通用户user1执行locate命令时，会发生如下事情：</p>
<ul>
<li>&#x2F;usr&#x2F;bin&#x2F;locate是可执行二进制程序，可以赋予SGID</li>
<li>执行用户user1对&#x2F;usr&#x2F;bin&#x2F;locate命令拥有执行权限</li>
<li>执行&#x2F;usr&#x2F;bin&#x2F;locate命令时，组身份会升级为slocate组，而slocate组对&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db数据库拥有r权限，所以普通用户可以使用locate</li>
</ul>
<p>命令查询mlocate.db数据库</p>
<ul>
<li>命令结束，user1用户的组身份返回为user1组</li>
</ul>
<p>b）针对目录的作用</p>
<p>如果SGID针对目录设置，含义如下：</p>
<ul>
<li>普通用户必须对此目录拥有r和x权限，才能进入此目录</li>
<li>普通用户在此目录中的有效组会变成此目录的属组</li>
<li>若普通用户对此目录拥有w权限时，新建的文件的默认属组就是这个目录的属组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 进入临时目录</span><br><span class="line">[root@localhost ~]# cd /tmp</span><br><span class="line"># 建立测试目录</span><br><span class="line">[root@localhost tmp]# mkdir dtest</span><br><span class="line"># 给测试目录赋予SGID</span><br><span class="line">[root@localhost tmp]# chmod g+s dtest</span><br><span class="line"># 查询SGID是否生效</span><br><span class="line">[root@localhost tmp]# ll -d dtest/</span><br><span class="line">drwxr-sr-x 2 root root 4096 1月 20 06：04 dtest/</span><br><span class="line"># 给测试目录权限，让普通用户可以写</span><br><span class="line">[root@localhost tmp]# chmod 777 dtest/</span><br><span class="line"># 切换成普通用户user1</span><br><span class="line">[root@localhost tmp]# su - user1</span><br><span class="line"># 普通用户进入测试目录</span><br><span class="line">[user1@localhost ~]$ cd /tmp/dtest/</span><br><span class="line"># 普通用户建立abc文件</span><br><span class="line">[user1@localhost ~]$ touch abc</span><br><span class="line"># abc文件的默认属组是root, 说明SGID生效</span><br><span class="line">[user1@localhost ~]$ ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-rw-r-- 1 user1 root 0 1月 20 06：07 abc</span><br></pre></td></tr></table></figure>



<h3 id="3）Sticky-BIT"><a href="#3）Sticky-BIT" class="headerlink" title="3）Sticky BIT"></a>3）Sticky BIT</h3><p>Sticky BIT粘着位，也简称为SBIT，SBIT目前仅针对目录有效。</p>
<p>SBIT作用如下：</p>
<ul>
<li>粘着位目录只对目录有效</li>
<li>普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限</li>
<li>如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件，一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。</li>
</ul>
<h3 id="4）设定文件特殊权限"><a href="#4）设定文件特殊权限" class="headerlink" title="4）设定文件特殊权限"></a>4）设定文件特殊权限</h3><p>特殊权限：</p>
<ul>
<li>4代表SUID</li>
<li>2代表SGID</li>
<li>1代表SBIT</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 赋予SUID权限</span><br><span class="line">[root@localhost ~]# chmod 4755 ftest              # 或者chmod u+s ftest</span><br><span class="line"></span><br><span class="line"># 赋予SGID权限</span><br><span class="line">[root@localhost ~]# chmod 2755 ftest              # 或者chmod g+s ftest</span><br><span class="line"></span><br><span class="line"># 赋予SBIT权限</span><br><span class="line">[root@localhost ~]# mkdir dtest</span><br><span class="line">[root@localhost ~]# chmod 1755 dtest/             # 或者chmod o+t ftest</span><br></pre></td></tr></table></figure>



<h2 id="4-文件系统属性chattr权限"><a href="#4-文件系统属性chattr权限" class="headerlink" title="4. 文件系统属性chattr权限"></a>4. 文件系统属性chattr权限</h2><p>a）命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]chattr [+-=] [选项] 文件或目录名</span><br><span class="line">选项：</span><br><span class="line">  +：    增加权限</span><br><span class="line">  -：    删除权限</span><br><span class="line">  =：    等于某权限</span><br><span class="line">  i：    如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和          删除文件</span><br><span class="line">  a：    如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许          删除</span><br><span class="line">  e：    Linux中绝大多数的文件都默认拥有e属性。表示该文件是使用ext文件系统进行存储的，而且不能使用“chattr -e”命令取消e属性</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 赋予文件i属性</span><br><span class="line">chattr +i abc</span><br><span class="line"></span><br><span class="line"># 取消文件i属性</span><br><span class="line">chattr -i abc</span><br><span class="line"></span><br><span class="line"># 赋予目录i属性</span><br><span class="line">chattr +i bcd/</span><br><span class="line"></span><br><span class="line"># 取消目录i属性</span><br><span class="line">chattr -i bcd/</span><br></pre></td></tr></table></figure>



<p>b) 查看文件系统属性(lsattr)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsattr 选项 文件名</span><br><span class="line">选项：</span><br><span class="line">  -a:    显示所有文件和目录</span><br><span class="line">  -d:    若目标是目录，仅列出目录本身的属性，而不是子文件</span><br></pre></td></tr></table></figure>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/25/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/25/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">用户管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-25 13:04:38 / 修改时间：13:07:39" itemprop="dateCreated datePublished" datetime="2025-02-25T13:04:38+08:00">2025-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="1-用户相关文件"><a href="#1-用户相关文件" class="headerlink" title="1. 用户相关文件"></a>1. 用户相关文件</h2><h3 id="1）用户信息文件"><a href="#1）用户信息文件" class="headerlink" title="1）用户信息文件"></a>1）用户信息文件</h3><p>&#x2F;etc&#x2F;passwd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一列：用户名</p>
</li>
<li><p>第二列：密码位</p>
<p>x为密码标志位，代表用户有密码，用户密码放置在&#x2F;etc&#x2F;shadow文件中。</p>
</li>
<li><p>第三列：用户ID</p>
<ul>
<li>0：超级用户UID，如果用户UID为0，代表这个账号是管理员账号。那Linux中如何把普通用户升级为管理员呢？就是把其他用户的UID修改为0就可以了。不过不建议建立多个管理员账号。</li>
<li>1-499：系统用户(伪用户)UID，这些UID账号是系统保留给系统用户的UID，也就是说UID是1-499范围内的用户是不能登录系统的，而是用来运行系统或服务的，其中1-99是系统保留的账号，系统自动创建。100-499是预留给用户创建系统账号的。</li>
<li>500-65535：普通用户UID。建立的普通用户UID从500开始，最大到65535。这些用户足够使用了，但是如果不够也不用害怕，2.6.x内核以后的Linux系统用户UID已经可以支持2的32次方了。</li>
</ul>
</li>
<li><p>第四列：组ID（GID）</p>
<p>添加用户时，如果不指定用户所属的初始组，那么会建立和用户名相同的组。</p>
</li>
<li><p>第五列：用户说明</p>
</li>
<li><p>第六列：用户家目录（~）</p>
</li>
<li><p>第七列：登录shell（标准是&#x2F;bin&#x2F;bash）</p>
</li>
</ul>
<h3 id="2）影子文件"><a href="#2）影子文件" class="headerlink" title="2）影子文件"></a>2）影子文件</h3><p>&#x2F;etc&#x2F;shadow</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:$6$jvGI3Z2PqL/TT4lT$q1lVTdba3dRsmWsEJVHzTqAHOSlb3qvM/hL7wKTQCo5148xfMiT0mnq1zQ7n7wCZu/QEdtP/57BVko4X6U4in0:18929:0:99999:7:::</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一列：用户名</p>
</li>
<li><p>第二列：加密密码</p>
<p>我们也可以在密码前人为的加入“!”或“*”改变加密值让密码暂时失效，使这个用户无法登录，达到暂时禁止用户登录的效果。</p>
<p>所有伪用户的密码都是”!!”或“*”，代表没有密码是不能登录的。当然新创建的用户如果不设定密码，它的密码项也是”!!”，代表这个用户没有密码，不能登录。</p>
</li>
<li><p>第三列：密码最近更改时间（day），1970年1月1日作为标准时间</p>
<p>时间戳转日期</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -d &quot;1970-01-01 18929 days&quot;</span><br><span class="line">2021年 10月 29日 星期五 00:00:00 CST</span><br></pre></td></tr></table></figure>

<p>日期转时间戳</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $(($(date --date=&quot;2021/10/29&quot; +%s)/86400+1))</span><br><span class="line">18929</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四列：两次密码的修改间隔时间（和第3个字段相比）</p>
</li>
<li><p>第五列：密码有效期(和第3个字段相比)</p>
</li>
<li><p>第六列：密码修改到期前警告天数(和第5个字段相比)</p>
</li>
<li><p>第七列：密码过期后的宽限天数(和第5个字段相比)</p>
</li>
<li><p>第八列：密码失效时间</p>
<p>这里同样要写时间戳，也就是用1970年1月1日进行时间换算，如果超过了失效时间，就算密码没有过期，用户也就失效无法使用了。</p>
</li>
<li><p>第九列：保留</p>
</li>
</ul>
<h3 id="3）组信息文件"><a href="#3）组信息文件" class="headerlink" title="3）组信息文件"></a>3）组信息文件</h3><p>&#x2F;etc&#x2F;group</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:x:0:</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：组名</li>
<li>第二列：组密码位</li>
<li>第三列：GID</li>
<li>第四列：此组中支持的其他用户，附加组是此组的用户<ul>
<li>初始组：每个用户初始组只能有一个，一般都是和用户名相同的组作为初始组。</li>
<li>附加组：每个用户可以属于多个附加组。要把用户加入组，都是加入附加组。</li>
</ul>
</li>
</ul>
<h3 id="4）组密码文件-不建议使用"><a href="#4）组密码文件-不建议使用" class="headerlink" title="4）组密码文件(不建议使用)"></a>4）组密码文件(不建议使用)</h3><p>&#x2F;etc&#x2F;gshadow</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root:*::</span><br></pre></td></tr></table></figure>

<p>如果给用户组设定了组管理员，并给该用户组设定了组密码，组密码就保存在这个文件当中。组管理员就可以利用这个密码管理这个用户组了。</p>
<h3 id="5）用户家目录"><a href="#5）用户家目录" class="headerlink" title="5）用户家目录"></a>5）用户家目录</h3><h3 id="6）用户邮箱目录"><a href="#6）用户邮箱目录" class="headerlink" title="6）用户邮箱目录"></a>6）用户邮箱目录</h3><p>这个邮箱在&#x2F;var&#x2F;spool&#x2F;mail目录当中，例如lamp用户的邮箱就是&#x2F;var&#x2F;spool&#x2F;mail&#x2F;lamp文件</p>
<h3 id="7）用户模板目录"><a href="#7）用户模板目录" class="headerlink" title="7）用户模板目录"></a>7）用户模板目录</h3><p>&#x2F;etc&#x2F;skel&#x2F;</p>
<p>用户家目录初始化时的模板目录。</p>
<h2 id="2-用户管理命令"><a href="#2-用户管理命令" class="headerlink" title="2.用户管理命令"></a>2.用户管理命令</h2><h3 id="1）添加用户"><a href="#1）添加用户" class="headerlink" title="1）添加用户"></a>1）添加用户</h3><p>a）手工删除用户</p>
<p>手工删除用户试验：手工删除，如果可以正常建立用户，证明用户删除干净。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 创建用户，就是写入这6个文件</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/group</span><br><span class="line">/etc/gshadow</span><br><span class="line">/home/user1</span><br><span class="line">/var/spool/mail/user1</span><br></pre></td></tr></table></figure>



<p>b）useradd命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">useradd 选项 用户名</span><br><span class="line">选项：</span><br><span class="line">  -u：UID   指定UID</span><br><span class="line">  -g：组名   指定初始组，不要手工指定</span><br><span class="line">  -G：组名   指定附加组，把用户加入组，使用附加组</span><br><span class="line">  -c：说明   添加说明</span><br><span class="line">  -d：目录   手工指定家目录，目录不需要事先建立</span><br><span class="line">  -s：shell  /bin/bash</span><br><span class="line">  -m：创建家目录</span><br></pre></td></tr></table></figure>



<p>c）useradd默认值</p>
<p>useradd添加用户时参考的默认值文件主要有两个：</p>
<ul>
<li><p>&#x2F;etc&#x2F;default&#x2F;useradd</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># useradd defaults file</span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=yes</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GROUP&#x3D;100</p>
<p>这个选项是建立用户的默认组，也就是说添加每个用户时，用户的初始组就是GID为100的这个用户组。</p>
</li>
<li><p>HOME&#x3D;&#x2F;home</p>
<p>这个选项是用户的家目录的默认位置，所以所有的新建用户的家目录默认都在&#x2F;home&#x2F;下。</p>
</li>
<li><p>INACTIVE&#x3D;-1</p>
<p>这个选项就是密码过期后的宽限天数，也就是&#x2F;etc&#x2F;shadow文件的第七个字段。如果是天数，比如10代表密码过期后10天后失效；如果是0，代表密码过期后立即失效；如果是-1，则代表密码永远不会失效。这是默认值是-1，所以所有新建立的用户密码都不会失效。</p>
</li>
<li><p>EXPIRE&#x3D;</p>
<p>这个选项是密码失效时间，也就是&#x2F;etc&#x2F;shadow文件的第八个字段，也就是说用户到达这个日期后就会直接失效。当然这里也是使用时间戳来表示日期的。默认是空，所以所有新建用户没有失效时间。永久有效。</p>
</li>
<li><p>SHELL&#x3D;&#x2F;bin&#x2F;bash</p>
<p>这个选项是用户的默认shell。&#x2F;bin&#x2F;bash是Linux的标志shell，所以所有新建立的用户默认都具备shell赋予的权限。</p>
</li>
<li><p>SKEL&#x3D;&#x2F;etc&#x2F;skel</p>
<p>这个选项就是定义用户的模板目录的位置，&#x2F;etc&#x2F;skel&#x2F;目录中的文件都会复制到新建用户的家目录当中。</p>
</li>
<li><p>CREATE_MAIL_SPOOL&#x3D;yes</p>
<p>这个选项定义是否给新建用户建立邮箱，默认是创建，也就是说所有的新建用户系统都会新建一个邮箱，放在&#x2F;var&#x2F;spool&#x2F;mail&#x2F;下，和用户名相同。</p>
</li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;login.defs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">MAIL_DIR        /var/spool/mail</span><br><span class="line"></span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DYAS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line"></span><br><span class="line">UID_MIN         500</span><br><span class="line">UID_MAX         60000</span><br><span class="line"></span><br><span class="line">GID_MIN         500</span><br><span class="line">GID_MAX         60000</span><br><span class="line"></span><br><span class="line">CREATE_HOME     yes</span><br><span class="line"></span><br><span class="line">UMASK           077</span><br><span class="line"></span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line"></span><br><span class="line">ENCRYPT_METHOD  SHA512</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MAIL_DIR          &#x2F;var&#x2F;spool&#x2F;mail</p>
<p>这行指定了新建用户的默认邮箱位置。比如lamp用户的邮箱就是&#x2F;var&#x2F;spool&#x2F;mail&#x2F;lamp。</p>
</li>
<li><p>PASS_MAX_DAYS    99999</p>
<p>这行指定的是密码的有效期，也就是&#x2F;etc&#x2F;shadow文件的第五个字段。代表多少天之后必须修改密码，默认值是99999</p>
</li>
<li><p>PASS_MIN_DAYS    0</p>
<p>这行指定是两次密码的修改间隔时间，也就是&#x2F;etc&#x2F;shadow文件的第四个字段。代表第一次修改密码之后，几天后才能再次修改密码，默认值是0</p>
</li>
<li><p>PASS_MIN_LEN    5</p>
<p>这行代表密码的最小长度，默认不小于5位，但是我们现在用户登录时验证已经被PAM模块取代，所以这个选项并不生效。</p>
</li>
<li><p>PASS_WARN_AGE    7</p>
<p>这行代表密码修改到期前的警告天数。也就是&#x2F;etc&#x2F;shadow文件的第六个字段。代表密码到底有效期前多少天开始进行警告提醒，默认值是7天。</p>
</li>
<li><p>UID_MIN|UID_MAX</p>
<p>这两行指定了UID的最小值和最大值之间的范围。</p>
</li>
<li><p>GID_MIN|GID_MAX</p>
<p>这两行指定了GID的最小值和最大值之间的范围。</p>
</li>
<li><p>CREATE_HOME    yes</p>
<p>这行指定建立用户时是否自动建立用户的家目录，默认是建立。</p>
</li>
<li><p>UMASK    077</p>
<p>这行指定的是建立的用户家目录的默认权限，因为umask值是077，所以新建的用户家目录的权限是700。</p>
</li>
<li><p>USERGROUPS_ENAB    yes</p>
<p>这行指定的是使用命令userdel删除用户时，是否删除用户的初始组，默认是删除。</p>
</li>
<li><p>ENCRYPT_METHOD    SHA512</p>
<p>这行指定Linux用户的密码使用SHA512散列模式加密，这是新的密码加密模式，原先的Linux只能用DES或MD5方式加密。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2）设定密码"><a href="#2）设定密码" class="headerlink" title="2）设定密码"></a>2）设定密码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -l:         暂时锁定用户。仅root用户可用（lock）</span><br><span class="line">  -u:         解锁用户。仅root用户可用（unlock）</span><br><span class="line">  --stdin:    可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改当前用户的密码</span><br><span class="line">passwd</span><br><span class="line"></span><br><span class="line"># 使用字符串作为密码</span><br><span class="line">echo &quot;123&quot; | passwd --stdin lamp</span><br><span class="line"></span><br><span class="line"># 把密码修改日期归零(shadow第3个字段，0代表1970年1月1日)。这样用户一登录就要修改密码。</span><br><span class="line">chage -d 0 lamp</span><br></pre></td></tr></table></figure>



<h3 id="3）用户信息修改"><a href="#3）用户信息修改" class="headerlink" title="3）用户信息修改"></a>3）用户信息修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">usermod [选项] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -u UID:        修改用户的UID</span><br><span class="line">  -d 家目录：     修改用户的家目录。家目录必须写绝对路径</span><br><span class="line">  -c 用户说明:    修改用户的说明信息，就是/etc/passwd文件的第五个字段</span><br><span class="line">  -g 组名：       修改用户的初始组，就是/etc/passwd文件的第四个字段</span><br><span class="line">  -G 组名：       修改用户的附加组，其实就是把用户加入其他用户组</span><br><span class="line">  -s shell:      修改用户的登录Shell。默认是/bin/bash</span><br><span class="line">  -e 日期：       修改用户的失效日期，格式为&quot;YYYY-MM-DD&quot;。也就是/etc/shadow文件的第八个字段</span><br><span class="line">  -L:            临时锁定用户(Lock)</span><br><span class="line">  -U:            解锁用户(Unlock)</span><br></pre></td></tr></table></figure>

<p>usermod也可以修改用户名，但不建议这么做，这样及其容易把管理员自己稿晕。建议删除旧用户，再建立新用户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修改用户名</span><br><span class="line">usermod -l 新名 旧名</span><br></pre></td></tr></table></figure>



<h3 id="4）删除用户"><a href="#4）删除用户" class="headerlink" title="4）删除用户"></a>4）删除用户</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userdel [-r] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -r:    在删除用户的同时删除用户的家目录</span><br></pre></td></tr></table></figure>



<h3 id="5）切换用户身份"><a href="#5）切换用户身份" class="headerlink" title="5）切换用户身份"></a>5）切换用户身份</h3><p>su命令可以切换成不同的用户身份。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">su [选项] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -:          选项只使用“-”代表连带用户的环境变量一起切换</span><br><span class="line">  -c 命令:    仅执行一次命令，而不切换用户身份</span><br></pre></td></tr></table></figure>

<p>“-”不能省略，它代表切换用户身份时，用户的环境变量也要切换成新用户的环境变量。</p>
<h2 id="3-组管理命令"><a href="#3-组管理命令" class="headerlink" title="3. 组管理命令"></a>3. 组管理命令</h2><h3 id="1）添加用户组"><a href="#1）添加用户组" class="headerlink" title="1）添加用户组"></a>1）添加用户组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] 组名</span><br><span class="line">选项：</span><br><span class="line">  -g GID:    指定组ID</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 添加group1组</span><br><span class="line">groupadd group1</span><br></pre></td></tr></table></figure>



<h3 id="2）删除用户组"><a href="#2）删除用户组" class="headerlink" title="2）删除用户组"></a>2）删除用户组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure>

<p>不过要注意，要删除的组不能是其他用户的初始组，也就是说这个组中没有初始用户才可以删除。如果组中有附加用户，则删除组时不受影响。</p>
<h3 id="3）把用户添加进组或从组中删除"><a href="#3）把用户添加进组或从组中删除" class="headerlink" title="3）把用户添加进组或从组中删除"></a>3）把用户添加进组或从组中删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpasswd [选项] 组名</span><br><span class="line">选项：</span><br><span class="line">  -a 用户名：    把用户加入组</span><br><span class="line">  -d 用户名：    把用户从组中删除</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加test组</span><br><span class="line">groupadd test</span><br><span class="line"></span><br><span class="line"># 把test1用户加入test组</span><br><span class="line">gpasswd -a test1 test</span><br><span class="line"></span><br><span class="line"># 把用户test1从test组中删除</span><br><span class="line">gpasswd -d test1 test</span><br></pre></td></tr></table></figure>



<h3 id="4）改变有效组"><a href="#4）改变有效组" class="headerlink" title="4）改变有效组"></a>4）改变有效组</h3><p>每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？当然是初始用户组的组身份。因为初始组是用户一旦登录就直接获得的组身份。也就是说，用户在创建文件后，文件的属组就是用户的初始组，因为用户的有效组默认是初始组。使用newgrp可以切换用户的有效组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp 组名</span><br></pre></td></tr></table></figure>



<h3 id="5-组权限实验"><a href="#5-组权限实验" class="headerlink" title="5. 组权限实验"></a>5. 组权限实验</h3><p>根目录下创建个www目录，属主为teacher, 学生st1，st2可以往这个目录提交作业。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 创建www目录</span><br><span class="line">mkdir /www</span><br><span class="line"></span><br><span class="line"># 创建teacher用户</span><br><span class="line">useradd -m teacher</span><br><span class="line"></span><br><span class="line"># 设置teacher用户密码</span><br><span class="line">passwd teacher</span><br><span class="line"></span><br><span class="line"># 创建st1,st2用户并设置密码</span><br><span class="line">useradd -m st1</span><br><span class="line">useradd -m st2</span><br><span class="line"></span><br><span class="line"># 创建tg组</span><br><span class="line">groupadd tg</span><br><span class="line"></span><br><span class="line"># 将st1, st2加入tg组</span><br><span class="line">gpasswd -a st1 tg</span><br><span class="line">gpasswd -a st2 tg</span><br><span class="line"></span><br><span class="line"># 设置www目录属主和属组</span><br><span class="line">chown teacher:tg /www/</span><br><span class="line"></span><br><span class="line"># 设置www目录权限</span><br><span class="line">chmod 770 /www/</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/25/%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/25/%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">软件包安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-25 13:04:20 / 修改时间：13:06:34" itemprop="dateCreated datePublished" datetime="2025-02-25T13:04:20+08:00">2025-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a>软件包安装</h1><h2 id="1-软件包分类"><a href="#1-软件包分类" class="headerlink" title="1. 软件包分类"></a>1. 软件包分类</h2><ul>
<li>源码包</li>
<li>二进制包</li>
</ul>
<h2 id="2-源码包"><a href="#2-源码包" class="headerlink" title="2. 源码包"></a>2. 源码包</h2><h3 id="1）源码包优点"><a href="#1）源码包优点" class="headerlink" title="1）源码包优点"></a>1）源码包优点</h3><ul>
<li>开源，如果有足够的能力，可以修改源码包。</li>
<li>可以自由选择所需的功能</li>
<li>软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高</li>
<li>卸载方便</li>
</ul>
<h3 id="2）源码包缺点"><a href="#2）源码包缺点" class="headerlink" title="2）源码包缺点"></a>2）源码包缺点</h3><ul>
<li>安装过程步骤较多，尤其安装较大的软件集合时(如LAMP环境搭建)，容易出现拼写错误</li>
<li>编译过程时间较长，安装比二进制安装时间长</li>
<li>因为是编译安装，安装过程中一旦报错新手很难解决</li>
</ul>
<h2 id="3-二进制包"><a href="#3-二进制包" class="headerlink" title="3. 二进制包"></a>3. 二进制包</h2><p>Linux系列：Debian和RedHat。</p>
<h3 id="1）二进制包分类"><a href="#1）二进制包分类" class="headerlink" title="1）二进制包分类"></a>1）二进制包分类</h3><p>a）DPKG包</p>
<p>是由Debian Linux所开发出来的包管理机制，通过DPKG包，Debian Linux就可以进行软件包管理。主要应用在Debian和Ubuntu中。</p>
<p>b）RPM包</p>
<p>是由Red Hat公司所开发的包管理系统。功能强大，安装、升级、查询和卸载都非常简单和方便。目前很多Linux都在使用这种包管理方式，包括Fedora、CentOS、SuSE等。</p>
<h3 id="2）RPM包特点"><a href="#2）RPM包特点" class="headerlink" title="2）RPM包特点"></a>2）RPM包特点</h3><p>RPM包优点：</p>
<ul>
<li>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
<p>RPM包缺点：</p>
<ul>
<li>经过编译，不再可以看到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>依赖性。有时我们会发现需要安装软件包a时需要先安装b和c，而安装b时需要安装d和e。这时需要先安装d和e，再安装b和c，最后才能安装a包。</li>
</ul>
<h3 id="3）RPM包依赖"><a href="#3）RPM包依赖" class="headerlink" title="3）RPM包依赖"></a>3）RPM包依赖</h3><p>a）树形依赖</p>
<p>a——&gt;b——&gt;c</p>
<p>b）环形依赖</p>
<p>a——&gt;b——&gt;c——&gt;a</p>
<p>c）模块依赖</p>
<p>什么是模块依赖？例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysql-connector-odbc-5.2.5-7.el7.x86_64.rpm</span><br><span class="line">错误：依赖检测失败：</span><br><span class="line">    libodbc.so.2()(64bit) 被 mysql-connector-odbc-5.2.5-7.el7.x86_64 需要</span><br><span class="line">    libodbcinst.so.2()(64bit) 被 mysql-connector-odbc-5.2.5-7.el7.x86_64 需要</span><br></pre></td></tr></table></figure>

<p>发现报错，需要安装”libodbc.so.2”函数库文件，这时会发现在光盘中根本找不到这个文件，那是因为函数库没有单独成包，是包含在某一个软件包中的，而如果知道在哪个软件包中，需要查询网站<a target="_blank" rel="noopener" href="http://www.rpmfind.net./">www.rpmfind.net。</a></p>
<h3 id="4）RPM包安装方法"><a href="#4）RPM包安装方法" class="headerlink" title="4）RPM包安装方法"></a>4）RPM包安装方法</h3><ul>
<li>手工安装</li>
<li>yum在线安装</li>
</ul>
<h2 id="4-软件包选择建议"><a href="#4-软件包选择建议" class="headerlink" title="4. 软件包选择建议"></a>4. 软件包选择建议</h2><ul>
<li>源码包：如果软件包是给大量客户端提供访问，建议使用源码包安装，源码包效率更高(LAMP)。</li>
<li>RPM包：如果软件包是给Linux底层使用，或只给少量客户访问，建议使用RPM包安装，因为RPM包简单。</li>
</ul>
<h2 id="5-RPM手工安装"><a href="#5-RPM手工安装" class="headerlink" title="5. RPM手工安装"></a>5. RPM手工安装</h2><p>rpm数据库路径：&#x2F;var&#x2F;lib&#x2F;rpm&#x2F;</p>
<h3 id="1）RPM包命名规则"><a href="#1）RPM包命名规则" class="headerlink" title="1）RPM包命名规则"></a>1）RPM包命名规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpd-2.2.15-15.el6.centos.1.i686.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li>httpd：软件包名</li>
<li>2.2.15：软件版本</li>
<li>15：软件发布的次数</li>
<li>el6：软件发行商。el6是RedHat公司发布，适合RHEL6.x(Red Hat Enterprise Linux)和CentOS6.x下使用</li>
<li>i686：适合的硬件平台。RPM包可以在不同的硬件平台安装，选择适合不同CPU的软件版本，可以最大化的发挥CPU性能，所以出现了所谓的i386（386以上计算机都可以安装）、i586（586以上的计算机都可以安装）、i686（奔腾II以上计算机都可以安装，目前所有的CPU都是奔腾II以上，所以这个软件版本居多）、x86_64（64位CPU可以安装）和noarch（没有硬件限制）等文件名了。</li>
<li>rpm：rpm包的扩展名，我们说过Linux下文件不是靠扩展名区分文件类型，也就是Linux中扩展名没有任何意义。可是这里怎么又出现了扩展名呢？如果RPM包不用“rpm”作为扩展名，系统可以正确识别没有问题，可是管理员很难识别这是个什么样的软件。</li>
</ul>
<h3 id="2）RPM包手工命令安装"><a href="#2）RPM包手工命令安装" class="headerlink" title="2）RPM包手工命令安装"></a>2）RPM包手工命令安装</h3><p>a）默认安装位置</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;bin&#x2F;</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib&#x2F;</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;man&#x2F;</td>
<td>帮助文件保存位置</td>
</tr>
</tbody></table>
<p>b）安装命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh 包全名</span><br><span class="line">选项：</span><br><span class="line">  -i    install安装(install)</span><br><span class="line">  -v    显示更详细的信息(verbose)</span><br><span class="line">  -h    打印#显示安装进度(hash)</span><br></pre></td></tr></table></figure>

<p>其他选项：</p>
<ul>
<li>–nodeps：不检测依赖性安装。安装软件时会检测依赖性，确定所需的底层软件是否安装。如果没有安装则会报错。如果我不管依赖性，想强行安装，可以使用这个选项。这样不检测依赖性安装的软件是不能使用的，所以不建议这样做。</li>
<li>–replacefiles：替换文件安装。如果安装软件包，可是包中部分文件已经存在，那么正常安装时，会报错”某个文件已经存在”从而导致软件无法安装，使用这个选项可以忽视这个报错，而覆盖安装。</li>
<li>–replacepkgs：替换软件包安装。如果软件包已经安装，此选项可以把软件包重复安装一遍。</li>
<li>–force：强制安装。不管是否已经安装，都重新安装。就是–replacefiles和–replacepkgs的综合。</li>
<li>–test：测试安装。不会实际安装，只是检测一下依赖性。</li>
<li>–prefix：指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。如果指定了安装路径，软件没有安装到系统默认路径中的话，系统会找不到这些安装的软件，需要进行手工配置才能被系统识别。所以rpm包我们一般都采用默认路径安装：1）默认安装位置是系统的习惯位置。2）RPM包管理系统是有卸载命令的(数据库记录安装位置)</li>
</ul>
<p>c）服务启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># service启动</span><br><span class="line">service 服务名 start|stop|restart|status</span><br><span class="line">参数：</span><br><span class="line">  start:    启动服务</span><br><span class="line">  stop:     停止服务</span><br><span class="line">  restart:  重启服务</span><br><span class="line">  status:   查看服务状态</span><br><span class="line">  </span><br><span class="line">  # 标准启动</span><br><span class="line">  /etc/init.d/服务名 start|stop|restart|status</span><br></pre></td></tr></table></figure>



<h3 id="3）RPM包升级"><a href="#3）RPM包升级" class="headerlink" title="3）RPM包升级"></a>3）RPM包升级</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh 包全名</span><br><span class="line">选项：</span><br><span class="line">  -U      升级安装，如果没有安装过，系统直接安装。如果安装过的版本较旧，则升级到新版本(upgrade)</span><br><span class="line"> </span><br><span class="line">rpm -Fvh 包全名</span><br><span class="line">选项：</span><br><span class="line">  -F      升级安装，如果没有安装过，则不会安装，必须安装有较旧版本，才能升级(freshen)</span><br></pre></td></tr></table></figure>



<h3 id="4）RPM包卸载"><a href="#4）RPM包卸载" class="headerlink" title="4）RPM包卸载"></a>4）RPM包卸载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -e 包名</span><br><span class="line">选项：</span><br><span class="line">  --nodeps      不检查依赖性</span><br><span class="line">  -e            卸载</span><br></pre></td></tr></table></figure>



<h3 id="5）RPM包查询"><a href="#5）RPM包查询" class="headerlink" title="5）RPM包查询"></a>5）RPM包查询</h3><p>a）查询软件包是否安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -q 包名</span><br><span class="line">选项：</span><br><span class="line">  -q：查询(query)</span><br></pre></td></tr></table></figure>



<p>b）查询系统中的所有安装软件包</p>
<p>可以查询Linux系统中所有已经安装的软件包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa</span><br><span class="line">选项：</span><br><span class="line">  -a：所有(all)</span><br></pre></td></tr></table></figure>

<p>可以用管道符来查看所需内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep 包名</span><br></pre></td></tr></table></figure>



<p>c）查询软件包的详细信息</p>
<p>可以查询已经安装的某个软件包的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qi 包名</span><br><span class="line">选项：</span><br><span class="line">  -i：查询软件信息(information)</span><br></pre></td></tr></table></figure>

<p>也可以查询还没有安装的软件包的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qip 包全名</span><br><span class="line">选项：</span><br><span class="line">  -p：查询没有安装的软件包(package)</span><br></pre></td></tr></table></figure>



<p>d）查询软件包中的文件列表</p>
<p>可以查询已经安装的软件包中的文件列表和安装的完整目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -ql 包名</span><br><span class="line">选项：</span><br><span class="line">  -l：列出软件包中所有的文件列表和软件所安装的目录(list)</span><br></pre></td></tr></table></figure>

<p>查询未安装的软件包中的文件列表和打算安装的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qlp 包全名</span><br><span class="line">选项：</span><br><span class="line">  -p：查询没有安装的软件包信息(package)</span><br></pre></td></tr></table></figure>



<p>e）查询系统文件属于哪个RPM包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qf 系统文件名</span><br><span class="line">选项：</span><br><span class="line">  -f：查询系统文件属于哪个软件包(file)</span><br></pre></td></tr></table></figure>



<p>f）查询软件包所依赖的软件包</p>
<p>查询系统中和已经安装的软件包有依赖关系的软件包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -qR 包名</span><br><span class="line">选项：</span><br><span class="line">  -R：查询软件包的依赖性(requires)</span><br></pre></td></tr></table></figure>

<p>查询未安装的软件包的依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qRp 包全名</span><br></pre></td></tr></table></figure>



<h3 id="6）验证"><a href="#6）验证" class="headerlink" title="6）验证"></a>6）验证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验本机已经安装的所有软件包</span></span><br><span class="line">rpm -Va</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验指定RPM包中的文件(verify)</span></span><br><span class="line">rpm -V 已安装的名包</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验某个系统文件是否被修改</span></span><br><span class="line">rpm -Vf 系统文件名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm -V httpd</span><br><span class="line">S.5....T.    c             /etc/httpd/conf/httpd.conf</span><br><span class="line">验证内容    文件类型          文件名</span><br></pre></td></tr></table></figure>

<p>验证内容详情：</p>
<ul>
<li>S：文件大小是否改变</li>
<li>M：文件的类型或文件的权限(rwx)是否被改变</li>
<li>5：文件MD5校验和是否改变(可以看成文件内容是否改变)</li>
<li>D：设备的主从代码是否改变</li>
<li>L：文件路径是否改变</li>
<li>U：文件的属主(所有者)是否改变</li>
<li>G：文件的属组是否改变</li>
<li>T：文件的修改时间是否改变</li>
</ul>
<p>文件类型：</p>
<ul>
<li>c：配置文件(config file)</li>
<li>d：普通文档(documention)</li>
<li>g：“鬼”文件(ghost file)，很少见，就是该文件不应该被这个RPM包包含 </li>
<li>l：授权文件(license file)</li>
<li>r：描述文件(readme)</li>
</ul>
<h3 id="7）数字证书"><a href="#7）数字证书" class="headerlink" title="7）数字证书"></a>7）数字证书</h3><p>前面的校验方法只能对已经安装的RPM包中的文件进行校验，但是如果RPM包本身就被动过手脚，那么校验就不能解决问题了，我们就必须使用数字证书验证了。</p>
<p>数字证书特点：</p>
<ul>
<li>首先必须找到原厂的公钥文件，然后进行安装</li>
<li>再安装RPM包时会提取RPM包中的证书信息，然后和本机安装的原厂证书进行验证</li>
<li>如果验证通过，则允许安装；如果验证不通过，则不允许安装并警告</li>
</ul>
<p> a）数字证书导入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpm --import 数字证书文件</span><br><span class="line">选项：</span><br><span class="line">  --import：导入数字证书</span><br></pre></td></tr></table></figure>



<p>b）查询系统中安装好的数字证书</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep gpg-pubkey</span><br></pre></td></tr></table></figure>



<h3 id="8）RPM包中文件的提取"><a href="#8）RPM包中文件的提取" class="headerlink" title="8）RPM包中文件的提取"></a>8）RPM包中文件的提取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm2cpio 包全名 | cpio -idv . 文件的绝对路径</span><br></pre></td></tr></table></figure>

<p>rpm2cpio：将rpm包转换为cpio格式的命令。</p>
<p>cpio：是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件。</p>
<h2 id="6-RPM包在线安装-yum"><a href="#6-RPM包在线安装-yum" class="headerlink" title="6. RPM包在线安装(yum)"></a>6. RPM包在线安装(yum)</h2><h3 id="1）yum源文件解析"><a href="#1）yum源文件解析" class="headerlink" title="1）yum源文件解析"></a>1）yum源文件解析</h3><p>yum源配置文件保存在&#x2F;etc&#x2F;yum.repos.d&#x2F;目录中，文件的扩展名一定是”*.repo”。也就是说，yum源配置文件只要扩展名是”*.repo”就会生效。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /etc/yum.repos.d/</span><br><span class="line">CentOS-Base.repo    CentOS-Debuginfo.repo    CentOS-fasttrack.repo    CentOS-Media.repo    CentOS-Vault.repo</span><br></pre></td></tr></table></figure>

<p>这个目录中有5个yum源配置文件，默认情况下CentOS-Base.repo文件生效。</p>
<p>CentOS-Base.repo中有5个yum源容器，以base容器解释其内容详情：</p>
<ul>
<li>[base]：容器名称，一定要放在[]中。</li>
<li>name：容器说明，可以自己随便写。</li>
<li>mirrorlist：镜像站点，这个可以注释掉。</li>
<li>baseurl：yum源服务器的地址。默认是CentOS官方的yum源服务器，是可以使用的。如果觉得慢，可以改成国内yum源地址。</li>
<li>enabled：此容器是否生效，如果不写或写成enabled&#x3D;1则表示此容器生效，写成enabled&#x3D;0则表示此容器不生效。</li>
<li>gpgcheck：如果为1则表示RPM的数字证书生效，如果为0则表示RPM的数字证书不生效。</li>
<li>gpgkey：数字证书的公钥文件保存位置，不用修改。</li>
</ul>
<h3 id="2）搭建本地光盘yum源"><a href="#2）搭建本地光盘yum源" class="headerlink" title="2）搭建本地光盘yum源"></a>2）搭建本地光盘yum源</h3><p>a）放入CentOS安装光盘，并挂载光盘到指定位置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建cdrom目录，作为光盘的挂载点</span></span><br><span class="line">mkdir /mnt/cdrom</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载光盘到/mnt/cdrom</span></span><br><span class="line">mount /dev/cdrom /mnt/cdrom/</span><br></pre></td></tr></table></figure>

<p>b）修改其他几个yum源配置文件的扩展名，让它们失效，因为只有扩展名是”*.repo”的文件才能作为yum源配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/yum.repo.d</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure>

<p>c）修改光盘yum源配置文件CentOS-Media.repo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim CentOS-Media.repo</span><br><span class="line">[c6-media]</span><br><span class="line">name=CentOS-$releasever - Media</span><br><span class="line">baseurl=file:///mnt/cdrom/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1   # 让配置生效</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>

<p>d）查看是否生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询yum源所有可安装的软件包列表</span></span><br><span class="line">yum list</span><br></pre></td></tr></table></figure>



<h3 id="3）yum命令"><a href="#3）yum命令" class="headerlink" title="3）yum命令"></a>3）yum命令</h3><p>a）查询</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询yum所有安装包</span></span><br><span class="line">yum list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询yum源服务器中是否包含某个软件包</span></span><br><span class="line">yum list 包名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索yum源服务器上所有和关键字相关的软件包</span></span><br><span class="line">yum search 关键字</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询指定软件包的信息</span></span><br><span class="line">yum info samba</span><br></pre></td></tr></table></figure>

<p>yum search搜索可以用于确定某个软件在哪个相关包当中。</p>
<p>b）安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum -y install 包名</span><br><span class="line">选项：</span><br><span class="line">  install：    安装</span><br><span class="line">  -y：         自动回答yes。如果不加-y，那么每个安装的软件都需要手工回答yes</span><br></pre></td></tr></table></figure>



<p>c）升级</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y update 包名</span><br><span class="line">选项：</span><br><span class="line">  update:    升级</span><br><span class="line">  -y：       自动回答yes</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">升级本机所有软件包（包括内核，不常用）</span></span><br><span class="line">yum -y update</span><br></pre></td></tr></table></figure>



<p>d）卸载</p>
<p>除非你确定卸载的软件的依赖包不会对系统产生影响，否则不要执行yum的卸载，因为很有可能在卸载软件包的同时卸载的依赖包也是重要的系统文件，这就可能导致系统崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove 包名</span><br></pre></td></tr></table></figure>



<h3 id="4）yum组管理命令"><a href="#4）yum组管理命令" class="headerlink" title="4）yum组管理命令"></a>4）yum组管理命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有可用的软件组列表</span></span><br><span class="line">yum grouplist</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出软件组中包含的软件</span></span><br><span class="line">yum groupinfo 软件组名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装指定软件组</span></span><br><span class="line">yum groupinstall 软件组名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载指定软件组</span></span><br><span class="line">yum groupremove 软件组名</span><br></pre></td></tr></table></figure>



<h2 id="7-源码包安装"><a href="#7-源码包安装" class="headerlink" title="7.源码包安装"></a>7.源码包安装</h2><h3 id="1）注意事项"><a href="#1）注意事项" class="headerlink" title="1）注意事项"></a>1）注意事项</h3><p>a）源码包是从哪里来的？</p>
<p>源码包是通过官方网站下载的，如果需要使用，是需要单独下载的。</p>
<p>b）是否可以在系统中既安装rpm包的Apache，又安装源码包的Apache？</p>
<p>可以，因为两种安装方法安装的Apache，安装位置是不一样的：</p>
<ul>
<li>源码包必须指定安装位置(源码包没有安装数据库，没有删除命令)</li>
<li>RPM包不建议指定安装位置，建议安装在默认位置(RPM包安装的服务有标准卸载命令，不怕文件到处安装)</li>
</ul>
<h3 id="2）安装过程"><a href="#2）安装过程" class="headerlink" title="2）安装过程"></a>2）安装过程</h3><p>a）下载软件包</p>
<p>b）解压缩</p>
<p>c）进入解压目录</p>
<p>d）.&#x2F;configure（编译前准备）</p>
<p>这一步主要有三个作用：</p>
<ul>
<li>在安装之前需要检测系统环境是否符合安装要求。</li>
<li>定义需要的功能选项。”.&#x2F;configure”支持的功能选项较多，可以执行“.&#x2F;configure –help”命令查询其支持的功能，一般都会通过”.&#x2F;configure –prefix&#x3D;安装路径”来指定安装路径。</li>
<li>把系统环境的检测结果和定义好的功能选项写入Makefile文件，后续的编译和安装需要依赖这个文件的内容。</li>
</ul>
<p>需要注意的是，configure不是系统命令，而是源码包软件自带的一个脚本程序，所以必须采用“.&#x2F;configure”方式执行。</p>
<p>e）make（编译）</p>
<p>make会调用gcc编译器，并读取Makefile文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被Linux识别的可执行文件，这些可执行文件保存在当前目录下。编译过程较为耗时，需要有足够的耐心。</p>
<p>f）make clean（清空编译内容，非必需步骤）</p>
<p>如果在”.&#x2F;configure”或“make”编译中报错，那么我们在重新执行命令前一定要记得执行make clean命令，它会清空Makefile文件或编译产生的“.o”文件。</p>
<p>g）make install（编译安装）</p>
<p>这才是真正的安装过程，一般会写清楚程序的安装位置。如果忘记指定安装目录，则可以把这个命令的执行过程保存下来，以备将来删除使用。</p>
<h3 id="3）删除"><a href="#3）删除" class="headerlink" title="3）删除"></a>3）删除</h3><p>源码包没有删除命令，如果需要删除，直接删除安装目录即可。</p>
<h3 id="4）打入补丁"><a href="#4）打入补丁" class="headerlink" title="4）打入补丁"></a>4）打入补丁</h3><p>a）补丁的生成</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 比较old和new文件的不同</span><br><span class="line">diff 选项 old new</span><br><span class="line">选项：</span><br><span class="line">  -a    将任何文档当做文本文档处理</span><br><span class="line">  -b    忽略空格造成的不同</span><br><span class="line">  -B    忽略空白行造成的不同</span><br><span class="line">  -I    忽略大小写造成的不同</span><br><span class="line">  -N    当比较两个目录时，如果某个文件只在一个目录中，则另一个目录中视作空文件。</span><br><span class="line">  -r    当比较目录时，递归比较子目录</span><br><span class="line">  -u    使用统一的输出格式</span><br></pre></td></tr></table></figure>

<p>比较两个文件的不同，并生成补丁文件”txt.patch”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 比较两个文件的不同，同时生成txt.patch补丁文件</span><br><span class="line">diff -Naur /root/test/old.txt /root/test/new.txt &gt; txt.patch</span><br></pre></td></tr></table></figure>



<p>b）打入补丁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 按照补丁文件进行更新</span><br><span class="line">patch -pn &lt; 补丁文件</span><br><span class="line">选项：</span><br><span class="line">  -pn    n为数字。代表按照补丁文件中的路径，指定更新文件的位置。</span><br></pre></td></tr></table></figure>

<p>“-pn”不好理解，补丁文件是要打入旧文件的，但是你当前所在的目录和补丁文件中的记录是不一定匹配的，所以就需要”-pn”来同步两个目录。</p>
<p>比如我当前在“&#x2F;root&#x2F;test”目录下，补丁文件中记录的文件目录是为“&#x2F;root&#x2F;test&#x2F;old.txt”。这时如果写入“p1”，那么补丁文件就会打入”&#x2F;root&#x2F;test&#x2F;root&#x2F;test&#x2F;old.txt”。如果写入的是“p2”，那么补丁文件就会打入”&#x2F;root&#x2F;test&#x2F;test&#x2F;old.txt”。如果写入的是“p3”，那么补丁文件就会打入”&#x2F;root&#x2F;test&#x2F;old.txt”。即n表示删除补丁文件中记录的文件目录的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p3 &lt; txt.patch</span><br></pre></td></tr></table></figure>



<h2 id="8-脚本安装程序"><a href="#8-脚本安装程序" class="headerlink" title="8. 脚本安装程序"></a>8. 脚本安装程序</h2><p>以Webmin安装为例。</p>
<p>a）下载webmin软件，地址：<a target="_blank" rel="noopener" href="http://sourceforge.net/projects/webadmin/files/webmin/">http://sourceforge.net/projects/webadmin/files/webmin/</a></p>
<p>b）解压软件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf webmin-1.610.tar.gz</span><br></pre></td></tr></table></figure>

<p>c）进入解压目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd webmin-1.610</span><br></pre></td></tr></table></figure>

<p>d）执行安装程序setup.sh，并指定功能选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://bentech8.github.io/2025/02/25/vim%E7%BC%96%E8%BE%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ben">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ben">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/25/vim%E7%BC%96%E8%BE%91%E5%99%A8/" class="post-title-link" itemprop="url">vim编辑器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-25 13:01:43 / 修改时间：13:02:50" itemprop="dateCreated datePublished" datetime="2025-02-25T13:01:43+08:00">2025-02-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h1><p>vim是一个全屏幕纯文本编辑器，是vi编辑器的增强版。</p>
<p>可以利用别名让输入vi命令的时候，实际上执行vim编辑器，如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义别名</span></span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br></pre></td></tr></table></figure>

<p>这样定义的别名是临时生效，如果需要永久生效，需要放入环境变量配置文件(~&#x2F;.bashrc)。</p>
<h2 id="1-vim工作模式"><a href="#1-vim工作模式" class="headerlink" title="1. vim工作模式"></a>1. vim工作模式</h2><h3 id="1）命令模式"><a href="#1）命令模式" class="headerlink" title="1）命令模式"></a>1）命令模式</h3><p>主要使用快捷键的模式。</p>
<p>命令模式想要进入输入模式，可以使用以下方式：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>在光标所在字符后插入</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行尾插入</td>
</tr>
<tr>
<td>i</td>
<td>在光标所在字符前插入</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行行首插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标下插入新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标上插入新行</td>
</tr>
<tr>
<td>ZZ</td>
<td>保存退出</td>
</tr>
</tbody></table>
<h3 id="2）输入模式"><a href="#2）输入模式" class="headerlink" title="2）输入模式"></a>2）输入模式</h3><p>主要用于文本编辑，和记事本类似，输入数据就好。</p>
<h3 id="3）编辑模式-末行模式"><a href="#3）编辑模式-末行模式" class="headerlink" title="3）编辑模式(末行模式)"></a>3）编辑模式(末行模式)</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存不退出</td>
</tr>
<tr>
<td>:w 新文件名</td>
<td>把文件另存为新文件</td>
</tr>
<tr>
<td>:q</td>
<td>不保存退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存退出</td>
</tr>
<tr>
<td>:!</td>
<td>强制</td>
</tr>
<tr>
<td>:q!</td>
<td>强制不保存退出，用于修改文件之后，不保存数据退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存退出，当文件的所有者或者root用户，对文件没有写权限的时候，强制写入数据使用</td>
</tr>
</tbody></table>
<h2 id="2-命令模式操作"><a href="#2-命令模式操作" class="headerlink" title="2. 命令模式操作"></a>2. 命令模式操作</h2><h3 id="1）移动光标"><a href="#1）移动光标" class="headerlink" title="1）移动光标"></a>1）移动光标</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>上下左右移动光标</td>
<td>上、下、左、右方向键或者k、j、h、l</td>
</tr>
<tr>
<td>移动到文件头</td>
<td>gg</td>
</tr>
<tr>
<td>移动到文件尾</td>
<td>G或者shift+g</td>
</tr>
<tr>
<td>移动到行首</td>
<td>^</td>
</tr>
<tr>
<td>移动到行尾</td>
<td>$</td>
</tr>
<tr>
<td>移动到指定行</td>
<td>:n(这里n是数字，准备移动到第几行，就用哪个数字</td>
</tr>
</tbody></table>
<h3 id="2）删除或剪切"><a href="#2）删除或剪切" class="headerlink" title="2）删除或剪切"></a>2）删除或剪切</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>删除单个字母</td>
<td>x</td>
</tr>
<tr>
<td>删除n个字母</td>
<td>nx</td>
</tr>
<tr>
<td>删除单行</td>
<td>dd</td>
</tr>
<tr>
<td>删除多行</td>
<td>ndd</td>
</tr>
<tr>
<td>删除指定范围的行</td>
<td>:n1,n2d</td>
</tr>
<tr>
<td>粘贴到光标后</td>
<td>p</td>
</tr>
<tr>
<td>粘贴到光标前</td>
<td>P(大)</td>
</tr>
<tr>
<td>从光标所在行删除到文件尾</td>
<td>dG</td>
</tr>
</tbody></table>
<p>删除整行或多行，这是比较常用的删除方法，这里的dd快捷键既是删除，也是剪切。删除内容放入了剪切板，如果不粘贴就是剪切。</p>
<h3 id="3）复制"><a href="#3）复制" class="headerlink" title="3）复制"></a>3）复制</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>复制单行</td>
<td>yy</td>
</tr>
<tr>
<td>复制多行</td>
<td>nyy</td>
</tr>
</tbody></table>
<h3 id="4）撤销"><a href="#4）撤销" class="headerlink" title="4）撤销"></a>4）撤销</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>撤销</td>
<td>u</td>
</tr>
<tr>
<td>反撤销</td>
<td>ctrl+r</td>
</tr>
</tbody></table>
<p>u键能一直撤销到文件打开时的状态，类似Windows下ctrl+z键的作用。</p>
<p>ctrl+z能一直反撤销到最后一次操作状态，类似Windows下ctrl+y键的作用。</p>
<h3 id="5）vim配置文件"><a href="#5）vim配置文件" class="headerlink" title="5）vim配置文件"></a>5）vim配置文件</h3><p>这些末行模式参数设置，多数需要在vim中才能生效。</p>
<table>
<thead>
<tr>
<th>设置参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号</td>
</tr>
<tr>
<td>:syntax on</td>
<td>依据语法显示相关的颜色帮助</td>
</tr>
<tr>
<td>:syntax off</td>
<td>不显示语法相关的颜色帮助</td>
</tr>
<tr>
<td>:set hlsearch</td>
<td>设置将查找的字符串高亮显示，默认是set hlsearch高亮显示</td>
</tr>
<tr>
<td>:set nohlsearch</td>
<td>取消将查找的字符串高亮显示</td>
</tr>
<tr>
<td>:set ruler</td>
<td>设置显示右下角的状态栏</td>
</tr>
<tr>
<td>:set noruler</td>
<td>取消显示右下角的状态栏</td>
</tr>
<tr>
<td>:set showmode</td>
<td>设置在左下角显示如“–INSERT–”之类的状态栏，默认是set showmode显示</td>
</tr>
<tr>
<td>:set noshowmode</td>
<td>取消在左下角显示如”–INSERT–”之类的状态栏</td>
</tr>
<tr>
<td>:set list</td>
<td>设置显示隐藏字符(Tab键用”I”表示，回车符用“$”表示)</td>
</tr>
<tr>
<td>:set nolist</td>
<td>设置不显示隐藏字符，默认是nolist</td>
</tr>
<tr>
<td>:set all</td>
<td>查看所有设置参数</td>
</tr>
</tbody></table>
<p>大家会发现，这些设置参数都只是临时生效，一旦关闭文件再打开，又需要重新输入。如果想要永久生效，需要手工建立vim的配置文件”~&#x2F;.vimrc”，把你需要的参数写入配置文件就永久生效了。</p>
<p>Windows下回车符在Linux中是用“^M$”符号显示，而不是”$”符。这样会导致Windows下编辑的程序脚本，无法在Linux中执行。这时可以通过命令”dos2unix”，把Windows格式转为Linux格式，当然反过来”unix2dos”命令就是把Linux格式转为Windows格式。这两个命令默认没有安装，需要手工安装才能使用。</p>
<h3 id="6）查找"><a href="#6）查找" class="headerlink" title="6）查找"></a>6）查找</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;查找内容</td>
<td>从光标所在行向下查找</td>
</tr>
<tr>
<td>?查找内容</td>
<td>从光标所在行向上查找</td>
</tr>
<tr>
<td>n</td>
<td>下一个</td>
</tr>
<tr>
<td>N</td>
<td>上一个</td>
</tr>
</tbody></table>
<h3 id="7）替换"><a href="#7）替换" class="headerlink" title="7）替换"></a>7）替换</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>替换光标所在处的字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在处开始替换字符，按ESC结束</td>
</tr>
<tr>
<td>:1,10s&#x2F;old&#x2F;new&#x2F;g</td>
<td>替换1到10行的所有old为new</td>
</tr>
<tr>
<td>:%s&#x2F;old&#x2F;new&#x2F;g</td>
<td>替换整个文件的old为new</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 在shell中“#”开头是注释，批量注释1到10行</span><br><span class="line">:1,10s/^/#/g</span><br><span class="line"></span><br><span class="line"># 取消注释</span><br><span class="line">:1,10s/^#//g</span><br><span class="line"></span><br><span class="line"># 批量添加“//”注释</span><br><span class="line">:1,10s/^/\/\//g</span><br><span class="line"></span><br><span class="line"># 取消注释</span><br><span class="line">:1,10s/^\/\///g</span><br></pre></td></tr></table></figure>



<h2 id="3-vim使用技巧"><a href="#3-vim使用技巧" class="headerlink" title="3. vim使用技巧"></a>3. vim使用技巧</h2><h3 id="1）在vim中导入其他文件内容或命令结果"><a href="#1）在vim中导入其他文件内容或命令结果" class="headerlink" title="1）在vim中导入其他文件内容或命令结果"></a>1）在vim中导入其他文件内容或命令结果</h3><p>a）导入其他文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 把文件内容导入光标下一行</span><br><span class="line">:r 文件名            </span><br></pre></td></tr></table></figure>

<p>可以把其他文件的内容导入到光标下一行位置。</p>
<p>b）在vim中执行系统命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在vim中执行系统命令</span><br><span class="line">:!命令</span><br></pre></td></tr></table></figure>

<p>这里只是在vim中执行系统命令，但并不把系统命令的结果写入到文件中，主要用于在文件编辑中，查看系统信息如时间。</p>
<p>c）导入命令结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在vim中执行系统命令，并把命令结果导入光标下一行</span><br><span class="line">:r !命令</span><br></pre></td></tr></table></figure>



<h3 id="2）设定快捷键"><a href="#2）设定快捷键" class="headerlink" title="2）设定快捷键"></a>2）设定快捷键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 自定义快捷键</span><br><span class="line">:map 快捷键 快捷键执行的命令</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 按ctrl+p时，在行首加入注释</span><br><span class="line">:map ^P I#&lt;ESC&gt;</span><br><span class="line"></span><br><span class="line"># 按ctrl+b时，删除行首第一个字母</span><br><span class="line">:map ^B ^x</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：^P快捷键不能手工输入，需要执行ctrl+V+P来定义，或ctrl+v，然后ctrl+p。</p>
<h3 id="3）字符替换"><a href="#3）字符替换" class="headerlink" title="3）字符替换"></a>3）字符替换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 字符替换</span><br><span class="line">:ab 源字符 替换为字符</span><br></pre></td></tr></table></figure>

<p>在vim编辑中，有时候需要频繁输入某一长字符串(比如邮箱)，这时使用字符串替换，能增加输入效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 当碰到“mymail”时，转变为邮箱</span><br><span class="line">:ab mymail ben@163.com</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>“源字符”不应设置的太短，否则有可能影响输入。</p>
<h3 id="4）多文件打开"><a href="#4）多文件打开" class="headerlink" title="4）多文件打开"></a>4）多文件打开</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vim上下分屏同时打开两个文件</span><br><span class="line">vim -o 文件1 文件2</span><br><span class="line"></span><br><span class="line"># vim左右分屏同时打开两个文件</span><br><span class="line">vim -O 文件1 文件2</span><br></pre></td></tr></table></figure>

<p>这样可以同时打开两个文件，方便操作。可以通过先按”ctrl+w”，再按方向键的方式在两个文件之间切换。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ben</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ben</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
