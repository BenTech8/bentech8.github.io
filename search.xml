<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL调优</title>
    <url>/2025/03/15/DB-MySQL%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-入侵检测</title>
    <url>/2025/04/09/Linux-%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>系统安全</title>
    <url>/2025/04/09/Linux-%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><ul>
<li><p>选择稳定版操作系统</p>
</li>
<li><p>最小化安装</p>
</li>
<li><p>不要安装gcc，make</p>
</li>
<li><p>安装完系统后更新系统</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# yum install -y update</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="系统权限"><a href="#系统权限" class="headerlink" title="系统权限"></a>系统权限</h2><h3 id="基本权限（rwx）"><a href="#基本权限（rwx）" class="headerlink" title="基本权限（rwx）"></a>基本权限（rwx）</h3><ul>
<li><p>对于目录，默认权限&#x3D;777-umask</p>
</li>
<li><p>对于文件，默认权限&#x3D;666-umask（文件默认无执行权限）</p>
</li>
<li><p>修改umask</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/bashrc</span><br><span class="line">        umask 002    # 普通用户</span><br><span class="line">    else</span><br><span class="line">        umask 022    # 超级用户</span><br><span class="line">    fi</span><br><span class="line">[root@localhost ~]#　vim /etc/profile</span><br><span class="line">        umask 002    # 普通用户</span><br><span class="line">    else</span><br><span class="line">        umask 022    # 超级用户</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>1）suid</p>
<p>冒险位，执行二进制文件与文件所有人有关，与谁来执行无关。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chmod 4XXX filename</span><br></pre></td></tr></table></figure>



<p>2）sgid</p>
<p>强制位，对目录生效，在此目录中创建文件自动归入目录所在组。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#　chmod 2XXX dirname</span><br></pre></td></tr></table></figure>



<p>3）sticky</p>
<p>粘制位，目录中的文件只能被文件所有者删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chmod 1XXX dirname</span><br></pre></td></tr></table></figure>



<h3 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h3><ul>
<li>对文件的权限进行附加说明的权限设定方式</li>
<li>ACL提供传统的owner&#x2F;group&#x2F;other的read&#x2F;write&#x2F;execute之外的细分权限设定。(可以使用单一的使用者、目录等等)</li>
</ul>
<p>1）查看ACL权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l</span><br><span class="line">总用量</span><br><span class="line">-rw-r--r--  1 root root    4 2月    17 20:56 test.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">-rw-r--r--+ 如果权限后面带有<span class="string">&#x27;+&#x27;</span>号表示有ACL权限</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# getfacl test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: test.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::rw--</span><br><span class="line">group::r--</span><br><span class="line">other::r--</span><br></pre></td></tr></table></figure>

<p>2）设定ACL权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# useradd ben</span><br><span class="line">[root@localhost ~]# setfacl  -m u:ben:rw test.txt</span><br><span class="line">[root@localhost ~]# getfacl test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">file: test.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">owner: root</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">group: root</span></span><br><span class="line">user::rw-</span><br><span class="line">user:ben:rw-</span><br><span class="line">group::r--</span><br><span class="line">mask::rw-</span><br><span class="line">other::r--</span><br><span class="line">[root@localhost ~]# ls -l test.txt</span><br><span class="line">-rw-r-xr--+ 1 root root 4 2月    17 20:56 test.txt</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# setfacl -x u:ben test.txt    # 删除acl权限</span><br></pre></td></tr></table></figure>



<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chattr +a test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只能给文件添加内容，但是删除不了，属于追加</span></span><br><span class="line">[root@localhost ~]# chattr +i test.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件不能删除，不能更改，不能移动</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看文件属性</span></span><br><span class="line">[root@localhost ~]# lsattr test.txt</span><br><span class="line">----i----------- test.txt</span><br></pre></td></tr></table></figure>

<p>案例1：防删除，防修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#　find /bin /sbin /usr/sbin /usr/bin /etc/shadow /etc/passwd /etc/pam.d -type f -exec chattr +i &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>案例2：日志文件防删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chattr +a /var/log/messages /var/log/secure</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志切割要先去掉a属性，之后增加a属性</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# vim /etc/logrotate.d/syslog</span><br><span class="line">prerotate</span><br><span class="line">    chattr -a /var/log/messages</span><br><span class="line">endscript</span><br><span class="line">...</span><br><span class="line">postrotate</span><br><span class="line">    chattr +a /var/log/messages</span><br><span class="line">endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="umask权限"><a href="#umask权限" class="headerlink" title="umask权限"></a>umask权限</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# umask</span><br><span class="line">0022</span><br><span class="line">[root@localhost ~]# umask -S</span><br><span class="line">u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure>



<h3 id="mount权限"><a href="#mount权限" class="headerlink" title="mount权限"></a>mount权限</h3><p>1）rw&amp;ro</p>
<p>合理规划权限，尽量避免777权限出现。</p>
<p>2）sync&amp;async</p>
<p>此选项的默认模式为异步模式，在同步模式下，内存的任何修改都会实时的同步到硬盘当中，这种模式的安全性基本属于最高，但是因为内存的数据基本一致都在变化，所以这种模式会使得程序运行变得缓慢，影响效率。而在异步模式下，虽然同步没有实时，但是现在考虑到日志文件系统的存在，所以安全性基本不用考虑，而异步模式的效会更高，所以目前普遍使用异步模式为默认。</p>
<h2 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h2><h3 id="su"><a href="#su" class="headerlink" title="su"></a>su</h3><p>1）由超级用户切换为普通用户，仅切换用户，环境变量不切换，如若为普通用户，会导致命令不可用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# su ben</span><br><span class="line">[ben@localhost ~]$</span><br></pre></td></tr></table></figure>

<p>2）由超级用户切换为普通用户，切换用户到家目录，环境变量会发生改变。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# su - ben</span><br><span class="line">[ben@localhost ~]$</span><br></pre></td></tr></table></figure>

<p>3）由普通用户切换为root用户。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ben@localhost ~]$ su - root</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>



<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>给普通用户提升(赋予)权限的方法有：</p>
<ul>
<li>suid,sgid</li>
<li>usermod</li>
<li>switching users with su</li>
<li>running commands as root with sudo</li>
</ul>
<p>使用sudo提升(赋予)权限普通用户的权限，可根据&#x2F;etc&#x2F;sudoers文件设置普通用户使用sudo命令时可以以root身份或其他用户身份运行命令。</p>
<p>1)sudoers文件编辑方式</p>
<p>使用vim直接编辑&#x2F;etc&#x2F;sudoers文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/sudoers</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不推荐</span></span><br></pre></td></tr></table></figure>

<p>使用visudo编辑&#x2F;etc&#x2F;sudoers：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推荐，会检查语法</span></span><br></pre></td></tr></table></figure>

<p>2）sudo语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">user        MACHINE=(RUN_AS_USER)           COMMANDS</span></span><br><span class="line">ben          ALL=ALL                         ALL</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">允许ben用户   在任何主机上=（以任何人的身份）      执行任何命令</span></span><br></pre></td></tr></table></figure>

<p>3）案例</p>
<p>案例1：对用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">ben        ALL=/sbin/ip, /sbin/fdisk, /bin/less</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予ben用户使用以上3个命令的权限</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# visudo</span><br><span class="line">ben        ALL=NOPASSWD: /bin/less</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予ben用户使用以上一个命令的权限，切换时不需要输入密码</span></span><br></pre></td></tr></table></figure>

<p>案例2：对组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# groupadd smartgo</span><br><span class="line">[root@localhost ~]# useradd it01 -G smartgo</span><br><span class="line">[root@localhost ~]# useradd it02 -G smartgo</span><br><span class="line">[root@localhost ~]# id it01</span><br><span class="line">uid=1003(it01) gid=1004(it01) 组=1004(it01),1003(smartgo)</span><br><span class="line">[root@localhost ~]# id it02</span><br><span class="line">uid=1004(it02) gid=1005(it02) 组=1005(it02),1003(smartgo)</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# visudo</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">smartgo        ALL=NOPASSWD: /sbin/ip</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">smartgo        ALL=NOPASSWD: /sbin/useradd, /sbin/userdel, /bin/passwd</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">smartgo        ALL=NOPASSWD: !/bin/passwd root, !/bin/passwd root --stdin, !/bin/passwd --stdin root</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# su - it01</span><br><span class="line">[it01@localhost ~]# sudo passwd root</span><br><span class="line">Sorry, user it01 is not allowed to execute &#x27;/bin/passwd root&#x27; as root on localhost.localdomain.</span><br></pre></td></tr></table></figure>

<p>案例3：别名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Host Aliases</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host_Alias        FILESERVERS = fs1, fs2</span></span><br><span class="line">Host_Alias        FILESERVERS = smtp, smtp2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># User Aliases</span></span></span><br><span class="line">User_Alias ADMINS = jsmith, mikem</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Command Aliases</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># These are groups of related commands...</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Networking</span></span></span><br><span class="line">Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient, /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig, /sbin/mii-tool</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Installation and management of software</span></span></span><br><span class="line">Cmnd_Alias SOFTWARE = /bin/rpm, /usr/bin/up2date, /usr/bin/yum</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Services</span></span></span><br><span class="line">Cmnd_Alias SERVICES = /sbin/service, /sbin/chkconfig</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Updating the locate database</span></span></span><br><span class="line">Cmnd_Alias LOCATE = /usr/bin/updatedb</span><br><span class="line"></span><br><span class="line">ADMINS        ALL=NOPASSWD: NETWORKING, SOFTWARE</span><br></pre></td></tr></table></figure>



<p>4）sudo日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]#　grep &#x27;^authpriv&#x27; /etc/rsyslog.conf    # 查看日志文件路径</span><br><span class="line">authpriv.*                        /var/log/secure</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# tail -f /var/log/secure</span><br></pre></td></tr></table></figure>





<h2 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h2><h3 id="PAM介绍"><a href="#PAM介绍" class="headerlink" title="PAM介绍"></a>PAM介绍</h3><p>PAM（Pluggable Authentication Modules）即可插拔式认证模块，它是一种高效而且灵活的用户级别的认证方式，它也是当前Linux服务器普通使用的认证方式。</p>
<p>PAM可以根据用户的网段、时间、用户名、密码等实现认证。</p>
<h3 id="PAM身份认证"><a href="#PAM身份认证" class="headerlink" title="PAM身份认证"></a>PAM身份认证</h3><p>使用PAM做身份认证的服务有：本地(login、gdm、kdm)，sshd，vsftpd，samba等。</p>
<p>不使用PAM做身份认证的服务有：MySQL-Server, Zabbix等。</p>
<p>1）PAM使用帮助</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# firefox /usr/share/doc/pam-1.1.8/html/Linux-PAM_SAG.html</span><br></pre></td></tr></table></figure>

<p>2）PAM认证原理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Service(进程文件)  -&gt; PAM（配置文件）  -&gt; pam_*.so                   -&gt; 模块的配置文件</span><br><span class="line">/usr/bin/sshd    /etc/pam.d/sshd  /lib64/security/pam_access.so  /etc/security/access.conf</span><br><span class="line">                                  /lib64/security/pam_limits.so  /etc/security/limits.conf</span><br><span class="line">                                  /lib64/security/pam_time.so    /etc/security/time.comf</span><br><span class="line">/bin/su          /etc/pam.d/su    /lib64/security/pam_rootok.so</span><br></pre></td></tr></table></figure>

<p>3）PAM认证原理案例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ldd /usr/sbin/sshd | grep -i pam</span><br><span class="line">        libpam.so.0 =&gt; /lib64/libpam.so.0 (0X00007fe76776a000)</span><br><span class="line">[root@localhost ~]# grep -i pam /etc/ssh/sshd_config</span><br><span class="line">UsePAM yes</span><br><span class="line">[root@localhost ~]# vim /etc/pam.d/sshd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">%PAM-1.0</span></span><br><span class="line">auth        required        pam_sepermit.so</span><br><span class="line">auth        substack        password-auth</span><br><span class="line">auth        include         postlogin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Used sith polkit to reauthorize <span class="built_in">users</span> <span class="keyword">in</span> remote sessions</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与polkit一起使用以重新授权远程会话中的用户</span></span><br><span class="line">-auth       optional        pam_reauthorize.so prepare</span><br><span class="line">account     required        pam_nologin.so</span><br><span class="line">account     include         password-auth</span><br><span class="line">password    include         password-auth</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pam_selinux.so close should be the first session rule</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">selinux并闭执行如下</span></span><br><span class="line">session     required        pam_selinux.so close</span><br><span class="line">session     required        pam_loginuid.so</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pam_selinux.so open should only be followed by sessions to be executed <span class="keyword">in</span> the user context</span></span><br><span class="line">session     required       pam_selinux open env_params</span><br><span class="line">session     required       pam_namespace.so</span><br><span class="line">session     optional       pam_keyinit.so force revoke</span><br><span class="line">session     include        password-auth</span><br><span class="line">session     include        postlogin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Used with polkit to reauthorize <span class="built_in">users</span> <span class="keyword">in</span> remote sessions</span></span><br><span class="line">-session    optional       pam_reauthorize.so prepare</span><br></pre></td></tr></table></figure>

<p>4）PAM常见的四种认证类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">auth          认证管理          验证使用者身份，账号和密码</span><br><span class="line">account       用户管理          基于用户时间或密码有效期来决定是否允许访问</span><br><span class="line">password      密码(口令)        认证管理，禁止用户反复尝试登录，在变更密码时进行密码复杂性控制</span><br><span class="line">session       会话管理          进行日志记录，或者限制用户登录的次数，资源限制</span><br></pre></td></tr></table></figure>

<p>5）PAM认证流程控制（流程标记）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">required         (必要条件)    验证失败时仍然继续,但返回fail               </span><br><span class="line">requisite        (必要条件)    验证失败时则立即结束整个验证过程，返回fail       </span><br><span class="line">sufficient       (充分条件)    验证成功则立即返回，不再继续，否则忽略结果并继续   </span><br><span class="line">optional         (可选条件)    无论验证结果如何，均不会影响</span><br><span class="line">include                      包含另外一个配置文件中类型相同的行</span><br><span class="line">substack                     垂直叠加</span><br></pre></td></tr></table></figure>

<p>6）PAM常用模块</p>
<ul>
<li><p>pam_rootok.so模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模块：pam_rootok.so</span><br><span class="line">功能：用户UID是0，返回成功</span><br><span class="line"></span><br><span class="line">示例：限制root切换用户也需要密码</span><br><span class="line">[root@localhost ~]# head -2 /etc/pam.d/su</span><br><span class="line"># auth sufficient pam_rootok.so</span><br></pre></td></tr></table></figure>
</li>
<li><p>pam_access.so模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">模块：pam_access.so</span><br><span class="line">功能：访问控制，默认配置文件/etc/security/access.conf</span><br><span class="line">通常用作登录程序，如su,login,gdm,sshd,例如限制用户从哪些网段登录sshd</span><br><span class="line"></span><br><span class="line">示例：不允许root从172.20.10.7登录sshd</span><br><span class="line">[root@localhost ~]# grep access.so /etc/pam.d/sshd</span><br><span class="line">auth    required    pam_access.so</span><br><span class="line">[root@localhost ~]# vim /etc/security/access.conf</span><br><span class="line">-:root:172.20.10.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：使用不同的模块配置文件</span><br><span class="line">[root@localhost ~]# grep access /etc/pam.d/login</span><br><span class="line">auth    required    pam_access.so accessfile=accessfile2</span><br><span class="line">[root@localhost ~]# grep ben /accessfile2</span><br><span class="line">-:ben:tty5 tty6</span><br><span class="line">[root@localhost ~]# grep access /etc/pam.d/sshd</span><br><span class="line">auth    required    pam_access.so accessfile=/accessfile1</span><br><span class="line">[root@localhost ~]# grep 110 /accessfile1</span><br><span class="line">-:root:ALL EXCEPT 192.168.2.110</span><br></pre></td></tr></table></figure>
</li>
<li><p>pam_listfile.so</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">模块：pam_listfile.so</span><br><span class="line">功能：基于自定义文件允许或拒绝(黑名单或白名单)</span><br><span class="line"></span><br><span class="line">示例：vsftpd黑名单或白名单</span><br><span class="line">[root@localhost ~]# grep listfile /etc/pam.d/vsftpd</span><br><span class="line">auth    required    pam_listfile.so item=user sense=deny file=/etc/vsftpd/ftpusers onerr=succeed</span><br><span class="line"></span><br><span class="line">示例：sshd黑名单或白名单</span><br><span class="line">[root@localhost ~]# grep listfile /etc/pam.d/sshd</span><br><span class="line">auth    required    pam_listfile.so item=user sense=allow file=/etc/ssh_users onerr=fail</span><br></pre></td></tr></table></figure>
</li>
<li><p>pam_time.so</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">模块：pam_time.so</span><br><span class="line">功能：基于时间的访问控制，默认文件/etc/security/time.conf</span><br><span class="line"></span><br><span class="line">示例：基于时间限制sshd的访问</span><br><span class="line">[root@localhost ~]# grep time /etc/pam.d/sshd</span><br><span class="line">account    required    pam_time.so</span><br><span class="line">[root@localhost ~]# grep 0800 /etc/security/time.conf</span><br><span class="line">sshd;*;*;MoTuWeThFr0800-1100</span><br></pre></td></tr></table></figure>
</li>
<li><p>pam_tally2.so</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">模块：pam_tally2.so</span><br><span class="line">功能：登录统计</span><br><span class="line"></span><br><span class="line">示例：实现防止对sshd暴力破解</span><br><span class="line">[root@localhost ~]# grep tally2 /etc/pam.d/sshd</span><br><span class="line">auth    required    pam_tally2.so deny=2 even_deny_root root_unlock_time=60 unlock_time=60</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">deny=2            连续错误登录最大次数，超过最大次数，将被锁定</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">even_deny_root    root用户也被要求锁定</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">root_unlock_time  root用户被锁定后等待的时间，单位为秒</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">unlock_time       普通用户被锁定后等待的时间，单位为秒</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# pam_tally2 -u root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看用户错误登录次数</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# pam_tally2 --reset -u root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除用户错误登录次数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="PAM资源限制"><a href="#PAM资源限制" class="headerlink" title="PAM资源限制"></a>PAM资源限制</h3><p>PAM资源限制主要是对<strong>用户</strong>进行系统资源使用的限制。</p>
<p>PAM资源限制默认已使用，我们只需要调整相应限制值即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模块：pam_limits.so</span><br><span class="line">功能：限制用户会话过程中对各种资源的使用情况，缺省情况下该模块的配置文件是</span><br><span class="line">/etc/security/limits.conf</span><br><span class="line">/etc/security/limits.d/*.conf</span><br></pre></td></tr></table></figure>

<p>PAM资源限制案例</p>
<p>案例1：设置用户最大打开文件数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ulimit -a</span><br><span class="line">[root@localhost ~]# ulimit -n</span><br><span class="line">1024</span><br><span class="line">[root@localhost ~]# vim /etc/security/limits.conf</span><br><span class="line">*        soft        nofile        10240</span><br><span class="line">*        hard        nofile        20480</span><br></pre></td></tr></table></figure>

<p>案例2：设置用户最大创建的进程数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ulimit -u</span><br><span class="line">7183</span><br><span class="line">[root@localhost ~]# vim /etc/security/limits.d/90-noproc.conf</span><br><span class="line">*        soft        nproc        10240</span><br><span class="line">*        hard        nproc        20480</span><br></pre></td></tr></table></figure>

<p>案例3：设置用户nginx最大使用CPU的时间</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/security/limits.conf</span><br><span class="line">nginx        hard        cpu        1</span><br></pre></td></tr></table></figure>



<h2 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h2><h3 id="CGroups介绍"><a href="#CGroups介绍" class="headerlink" title="CGroups介绍"></a>CGroups介绍</h3><p>控制组(CGroups)是Linux内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免多个容器同时运行时对主机系统的资源竞争。控制组可以提供对容器的内存、CPU、磁盘IO等资源进行限制和计费管理。控制组的设计目标是为不同的应用情况提供统一的接口，从控制单一进程(比如nice工具)到系统级虚拟化(包括OpenVZ、Linux-VServer、LXC等)。</p>
<p>具体来看，控制组提供：</p>
<p>资源限制(Resource limiting)：可以将组设置为不超过设定的内存限制。比如：内存子系统可以为进程组设定一个内存使用上限，一旦进程组使用的内存达到限额再申请内存，就会发生Out of Memory警告。</p>
<p>优先级(Prioritzation)：通过优先级让一些组优先得到更多的CPU等资源。</p>
<p>资源审计(Accounting)：用来统计系统实际上把多少资源用到适合的目的上，可以使用cpuacct子系统记录某个进程组使用的CPU时间。</p>
<p>隔离(isolation)：为组隔离命名空间，这样一个组不会看到另一个组的进程、网络连接和文件系统。</p>
<p>控制(Control)：挂起、恢复和重启动等操作。</p>
<p>cgroups: Control Groups</p>
<p>基于进程的限制，而非用户，因此对于超级用户运行的进程也是一样。</p>
<p>cgroup将各种子系统定义为资源，命名为controller。可配额&#x2F;可度量-Control Groups(CGroups)</p>
<p>cgroups实现了对资源的配额和度量九大子系统的资源：</p>
<ul>
<li>blkio：限制每个块设备的输入输出空间。例如：磁盘，光盘以及usb</li>
<li>cpu：限制使用cpu比例</li>
<li>cpuacct：产生cgroup任务的cpu资源报告</li>
<li>cpuset：多核心的cpu时为cgroup任务分配单独的cpu和内存</li>
<li>devices：允许或拒绝对设备的访问</li>
<li>freezer：暂停和恢复cgroup任务</li>
<li>memory：设置内存限制以及产生内存资源报告</li>
<li>net_cls：标记每个网络包</li>
<li>ns：名称空间子系统</li>
</ul>
<p>案例1：对某个进程使用内存进行限制步骤</p>
<ul>
<li>需要在controller memory下建立cgroup，如nginx_mem控制组，并针对该控制组nginx_mem设置相应的内存限制参数。</li>
<li>将进程Nginx分配到memory controller的控制组(nginx_mem)，没有使用controller则不会限制。</li>
</ul>
<h3 id="Cgroups实现资源限制的方法"><a href="#Cgroups实现资源限制的方法" class="headerlink" title="Cgroups实现资源限制的方法"></a>Cgroups实现资源限制的方法</h3><ul>
<li>cgexec手动分配</li>
<li>cgred自动分配</li>
</ul>
<h3 id="Cgroups部署过程"><a href="#Cgroups部署过程" class="headerlink" title="Cgroups部署过程"></a>Cgroups部署过程</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# yum -y install libcgroup libcgroup-tools</span><br><span class="line">[root@localhost ~]# systemctl enable cgconfig</span><br><span class="line">[root@Localhost ~]# systemctl start cgconfig</span><br></pre></td></tr></table></figure>



<h3 id="Cgroups限制步骤"><a href="#Cgroups限制步骤" class="headerlink" title="Cgroups限制步骤"></a>Cgroups限制步骤</h3><ul>
<li>创建cgroup，定义相应的限制</li>
<li>分配程序到cgroup</li>
</ul>
<h3 id="Cgroups限制案例"><a href="#Cgroups限制案例" class="headerlink" title="Cgroups限制案例"></a>Cgroups限制案例</h3><p>1）限制进程使用CPU</p>
<p>a.使用cpu子系统创建两个cgroup</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/cgconfig.conf</span><br><span class="line">group lesscpu &#123;</span><br><span class="line">    cpu &#123;</span><br><span class="line">        cpu.shares=200;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">group morecpu &#123;</span><br><span class="line">    cpu &#123;</span><br><span class="line">        cpu.shares=800;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# systemctl restart cgconfig</span><br></pre></td></tr></table></figure>

<p>b.将程序分配到相应的group</p>
<p>实验中，为了让两个进程抢CPU时间片，故意只留一个CPU在线</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lscpu</span><br><span class="line">[root@localhost ~]# echo 0 &gt; /sys/devices/system/cpu/cpu0/online</span><br><span class="line">[root@localhost ~]# echo 1 &gt; /sys/devices/system/cpu/cpu1/online</span><br></pre></td></tr></table></figure>

<p>手动分配：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cgexec -g cpu:lesscpu shalsum /dev/zero</span><br><span class="line">[root@localhost ~]# cgexec -g cpu:morecpu md5sum  /dev/zero</span><br><span class="line">[root@localhost ~]# top</span><br></pre></td></tr></table></figure>



<p>2）限制进程使用Memory</p>
<p>a.添加cgroup</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/cgconfig.conf</span><br><span class="line">group lessmem &#123;</span><br><span class="line">    memory &#123;</span><br><span class="line">        memory.limit_in_bytes=268435465; // 物理内存限制256M</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]# systemctl restart cgconfig</span><br></pre></td></tr></table></figure>

<p>b.创建内存盘</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /mnt/mem_test</span><br><span class="line">[root@localhost ~]# mount -t tmpfs /dev/shm /mnt/mem_test</span><br><span class="line">[root@localhost ~]# cgexec -g memory:lessmem dd if=/dev/zero of=/mnt/mem_test/file bs=1M count=200  //ok</span><br><span class="line">[root@localhost ~]# cgexec -g memory:lessmem dd if=/dev/zero of=/mnt/mem_test/file bs=1M count=500  //ok</span><br><span class="line">[root@localhost ~]# free -m</span><br></pre></td></tr></table></figure>

<p>结果为失败，因为只限制内存，没有限制swap。</p>
<p>c.创建cgroup</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/cgconf.conf</span><br><span class="line">group lessmem &#123;</span><br><span class="line">    memory &#123;</span><br><span class="line">        memory.limit_in_bytes=268435465; // 物理内存限制256M</span><br><span class="line">        memory.memsw.limit_in_bytes=268435465;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@localhost ~]# systemctl restart cgconfig</span><br></pre></td></tr></table></figure>

<p>d.创建内存盘并测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /mnt/mem_test</span><br><span class="line">[root@localhost ~]# mount -t tmpfs /dev/zero /mnt/mem_test</span><br><span class="line">[root@localhost ~]# cgexec -g memory:lessmem dd if=/dev/zero of=/mnt/mem_test/file bs=1M count=200  //ok</span><br><span class="line">[root@localhost ~]# cgexec -g memory:lessmem dd if=/dev/zero of=/mnt/mem_test/file bs=1M count=500  //fail</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-网络安全</title>
    <url>/2025/04/09/Linux-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2025/02/25/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="1-命令提示符"><a href="#1-命令提示符" class="headerlink" title="1. 命令提示符"></a>1. 命令提示符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$</span><br></pre></td></tr></table></figure>

<ul>
<li>[]：这是提示符的分隔符号，没有特殊含义</li>
<li>ben：显示的是当前的登录用户。</li>
<li>@：分隔符号，没有特殊含义。</li>
<li>ben-NBLK-WAX9X：当前系统的简写主机名。</li>
<li>~：代表用户当前所在的目录。</li>
<li>$：命令提示符，超级用户是#，普通用户是$。</li>
</ul>
<h2 id="2-文件操作命令"><a href="#2-文件操作命令" class="headerlink" title="2. 文件操作命令"></a>2. 文件操作命令</h2><h3 id="1）touch"><a href="#1）touch" class="headerlink" title="1）touch"></a>1）touch</h3><p>创建空文件或者修改文件时间。</p>
<h3 id="2）stat"><a href="#2）stat" class="headerlink" title="2）stat"></a>2）stat</h3><p>查看文件详细信息，而且可以看到文件的四个时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stat abc</span><br><span class="line">文件：abc</span><br><span class="line">  大小：0         	块：0          IO 块大小：4096   普通空文件</span><br><span class="line">设备：259,10	Inode: 2953378     硬链接：1</span><br><span class="line">权限：(0664/-rw-rw-r--)  Uid: ( 1000/     ben)   Gid: ( 1000/     ben)</span><br><span class="line">访问时间：2024-11-19 16:04:02.421884754 +0800      # 最后一次访问时间</span><br><span class="line">修改时间：2024-11-19 16:04:02.421884754 +0800      # 数据修改时间</span><br><span class="line">变更时间：2024-11-19 16:04:02.421884754 +0800      # 状态修改时间</span><br><span class="line">创建时间：2024-11-19 16:03:01.150885757 +0800</span><br></pre></td></tr></table></figure>



<h3 id="3）cat"><a href="#3）cat" class="headerlink" title="3）cat"></a>3）cat</h3><p>【功能描述】：查看文件内容。</p>
<p>选项：</p>
<ul>
<li>-A：相当于-vET选项的整合，用于列出所有隐藏符号</li>
<li>-E：列出每行结尾的回车符$</li>
<li>-n：显示行号</li>
<li>-T：把Tab键用^T显示出来</li>
<li>-v：列出特殊字符</li>
</ul>
<h3 id="4）more"><a href="#4）more" class="headerlink" title="4）more"></a>4）more</h3><p>【功能描述】：分屏显示文件内容。</p>
<p>more命令比较简单，一般不用什么选项，命令会打开一个交互界面，可以识别一些交互命令。常用交互命令如下：</p>
<ul>
<li>空格键：向下翻页</li>
<li>b：向上翻页</li>
<li>回车键：向下滚动一行</li>
<li>&#x2F;字符串：指定搜索的字符串</li>
<li>q：退出</li>
</ul>
<h3 id="5）less"><a href="#5）less" class="headerlink" title="5）less"></a>5）less</h3><p>【功能描述】：分行显示文件内容。</p>
<h3 id="6）head"><a href="#6）head" class="headerlink" title="6）head"></a>6）head</h3><p>【功能描述】：显示文件开头的命令。</p>
<h3 id="7）tail"><a href="#7）tail" class="headerlink" title="7）tail"></a>7）tail</h3><p>【功能描述】：显示文件结尾的命令。</p>
<p>选项：</p>
<ul>
<li>-n 行数：从文件结尾开始，显示指定行数。</li>
<li>-f：监听文件的新增内容，ctrl+c退出。</li>
</ul>
<h3 id="8）ln"><a href="#8）ln" class="headerlink" title="8）ln"></a>8）ln</h3><p>【功能描述】：在文件之间建立链接</p>
<h4 id="1）硬链接"><a href="#1）硬链接" class="headerlink" title="1）硬链接"></a>1）硬链接</h4><p>特征：</p>
<ul>
<li>源文件和硬链接文件拥有相同的Inode和Block</li>
<li>修改任意一个文件，另一个都改变</li>
<li>删除任意一个文件，另一个都能使用</li>
<li>硬链接标记不清，很难确认硬链接文件位置，不建议使用</li>
<li>硬链接不能链接目录</li>
<li>硬链接不能跨分区</li>
</ul>
<h4 id="2）软链接"><a href="#2）软链接" class="headerlink" title="2）软链接"></a>2）软链接</h4><p>特征：</p>
<ul>
<li>软链接和源文件拥有不同的Inode和Block</li>
<li>两个文件修改任意一个，另一个都改变</li>
<li>删除软链接，源文件不受影响；删除源文件，软链接不能使用</li>
<li>软链接没有实际数据，只保存源文件的Inode，不论源文件多大，软链接大小不变</li>
<li>软链接的权限是最大权限lrwxrwxrwx.，但是由于没有实际数据，最终访问时需要参考源文件权限</li>
<li>软链接可以链接目录</li>
<li>软链接可以跨分区</li>
<li>软链接特征明显，建议使用软链接</li>
</ul>
<h2 id="3-目录和文件都能操作的命令"><a href="#3-目录和文件都能操作的命令" class="headerlink" title="3. 目录和文件都能操作的命令"></a>3. 目录和文件都能操作的命令</h2><h3 id="1）rm"><a href="#1）rm" class="headerlink" title="1）rm"></a>1）rm</h3><p>【功能描述】：删除文件或目录</p>
<p>选项：</p>
<ul>
<li>-f：强制删除</li>
<li>-i：交互删除，在删除之前会询问用户(默认)</li>
<li>-r：递归删除，可以删除目录</li>
</ul>
<h3 id="2）cp"><a href="#2）cp" class="headerlink" title="2）cp"></a>2）cp</h3><p>【功能描述】：复制文件和目录</p>
<p>选项：</p>
<ul>
<li>-a：相当于-dpr选项的集合。</li>
<li>-d：如果源文件为软链接(硬链接无效)，则复制出的目标文件也为软链接。</li>
<li>-i：询问，如果目标文件已经存在，则会询问是否覆盖。</li>
<li>-p：复制后目标文件保留源文件的属性(包括所有者、所属组、权限和时间)</li>
<li>-r：递归复制，用于复制目录</li>
</ul>
<h3 id="3）mv"><a href="#3）mv" class="headerlink" title="3）mv"></a>3）mv</h3><p>【功能描述】：移动文件或者改名</p>
<p>选项：</p>
<ul>
<li>-f：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖</li>
<li>-i：交互移动，如果目标文件已经存在，则询问用户是否覆盖(默认)</li>
<li>-v：显示详细信息</li>
</ul>
<h2 id="4-权限"><a href="#4-权限" class="headerlink" title="4. 权限"></a>4. 权限</h2><h3 id="1）权限位含义"><a href="#1）权限位含义" class="headerlink" title="1）权限位含义"></a>1）权限位含义</h3><ul>
<li>第一位代表<strong>文件类型</strong>。Linux不像Windows使用扩展名表示文件类型，而是使用权限位的第1位表示文件类型。虽然Linux文件的种类不像Windows中那么多，但是分类也不少，详细情况可以使用“info ls”命令查看。<ul>
<li>“-”：普通文件。</li>
<li>“b”：块设备文件。</li>
<li>“c”：字符设备文件。</li>
<li>“d”：目录文件。</li>
<li>“l”：软链接文件。</li>
<li>“p”：管道符文件。</li>
<li>“s”：套接字文件。</li>
</ul>
</li>
<li>第2-4位代表<strong>文件所有者</strong>(u)的权限<ul>
<li>r：读权限</li>
<li>w：写权限</li>
<li>x：执行权限</li>
</ul>
</li>
<li>第5-7位代表<strong>文件所属组</strong>(g)的权限</li>
<li>第8-10位代表<strong>其他人</strong>(o)的权限</li>
</ul>
<h3 id="2）基本权限的作用"><a href="#2）基本权限的作用" class="headerlink" title="2）基本权限的作用"></a>2）基本权限的作用</h3><h4 id="a-权限含义的解释"><a href="#a-权限含义的解释" class="headerlink" title="a.权限含义的解释"></a>a.权限含义的解释</h4><p>首先，读、写、执行权限对文件和目录的作用是不同的。</p>
<p>权限对文件的作用</p>
<ul>
<li>读(r)：对文件有读(r)权限，代表可以读取文件中的数据。如果把权限对应到命令上，那么一旦对文件有读(r)权限，就可以对文件执行cat、more、less、head、tail等文件查看命令。</li>
<li>写(w)：对文件有写(w)权限，代表可以修改文件中的数据。如果把权限对应到命令上，那么一旦对文件有写(w)权限，就可以对文件执行vim、echo等修改文件数据的命令。注意：对文件有写权限，是不能删除文件本身的，只能修改文件中的数据。如果要想删除文件，则需要对文件的上级目录有写权限。</li>
<li>执行(x)：对文件有执行(x)权限，代表文件拥有了执行权限。可以运行。在Linux中，只要文件有执行(x)权限，这个文件就是执行文件了。只是这个文件到底能不能正确执行，不仅需要执行(x)权限，还要看文件中的代码是不是正确的语言代码。对文件来说，执行(x)权限是最高权限。</li>
</ul>
<p>权限对目录的作用</p>
<ul>
<li>读(r)：对目录有读(r)权限，代表可以查看目录下的内容，也就是可以查看目录下有哪些子文件和子目录。如果把权限对应到命令上，那么一旦对目录拥有了读(r)权限，就可以在下执行ls命令，查看目录下的内容了。</li>
<li>写(w)：对目录有写(w)权限，代表可以修改目录下的数据，也就是可以在目录中新建、删除、复制、剪切子文件或目录。如果把权限对应到命令上，那么一旦对目录拥有了写(w)权限，就可以在目录下执行touch、rm、cp、mv命令。对目录来说，写(w)权限是最高权限。</li>
<li>执行(x)：目录是不能运行的，那么对目录拥有了执行(x)权限，代表可以进入目录。如果把权限对应到命令上，那么一旦对目录拥有了执行(x)权限，就可以对目录执行cd命令，进入目录。</li>
</ul>
<h4 id="b-目录的可用权限"><a href="#b-目录的可用权限" class="headerlink" title="b.目录的可用权限"></a>b.目录的可用权限</h4><p>目录的可用权限其实只有以下几个：</p>
<ul>
<li>0：任何权限都不赋予。</li>
<li>5：基本的目录浏览和进入权限。</li>
<li>7：完全权限。</li>
</ul>
<h3 id="3）chmod"><a href="#3）chmod" class="headerlink" title="3）chmod"></a>3）chmod</h3><p>【功能描述】：修改文件的权限模式。</p>
<p>选项：</p>
<ul>
<li>-R：递归设置权限，也就是给子目录中的所有文件设定权限。</li>
</ul>
<p>【注意】</p>
<ul>
<li>普通用户可以修改所有者是自己的文件的权限</li>
</ul>
<h3 id="4）chown"><a href="#4）chown" class="headerlink" title="4）chown"></a>4）chown</h3><p>【功能描述】：修改文件和目录的所有者和所有组。</p>
<p>选项：</p>
<ul>
<li>-R：递归设置权限，也就是给子目录中的所有文件设置权限。</li>
</ul>
<p>【注意】</p>
<ul>
<li>普通用户不能修改文件的所有者(哪怕文件属于这个普通用户)，只有超级用户才能修改所有者。</li>
</ul>
<h3 id="5）chgrp"><a href="#5）chgrp" class="headerlink" title="5）chgrp"></a>5）chgrp</h3><p>【功能描述】：修改文件和目录的所属组。</p>
<h3 id="6）umask"><a href="#6）umask" class="headerlink" title="6）umask"></a>6）umask</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询系统umask权限</span><br><span class="line">umask</span><br><span class="line">0002       # 用八进制数值表示umask权限</span><br><span class="line"></span><br><span class="line">umask -S</span><br><span class="line">u=rwx,g=rwx,o=rx      # 用字母表示文件和目录的初始权限</span><br></pre></td></tr></table></figure>



<p>umask权限的计算方法</p>
<p>新建文件和目录的默认最大权限：</p>
<ul>
<li>对文件来讲，新建文件的默认最大权限是666，没有执行(x)权限。这是因为执行权限对文件来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。</li>
<li>对目录来讲，新建目录的默认最大权限是777，这是因为对目录而言，执行(x)权限仅仅代表进入目录，所以即使建立新文件时直接默认赋予，也没有什么危险。</li>
</ul>
<p>按照官方的标准算法，umask默认权限需要使用二进制进行逻辑与和逻辑非联合运算才可以得到正确的新建文件和目录的默认权限。这种方法既不好计算，也不好理解，不太推荐。</p>
<p>按照权限字母来讲解umask权限的计算方法：</p>
<ul>
<li><p>文件的默认权限最大只能是666，而umask的值是002</p>
<p>“-rw-rw-rw-” - “——-w-” &#x3D; “-rw-rw-r–”</p>
</li>
<li><p>目录的默认权限最大可以是777，而umask的值是002</p>
<p>“drwxrwxrwx” - “d——-w-“ &#x3D; “drwxrwxr-x”</p>
</li>
</ul>
<h2 id="5-帮助命令"><a href="#5-帮助命令" class="headerlink" title="5. 帮助命令"></a>5. 帮助命令</h2><h3 id="1）man"><a href="#1）man" class="headerlink" title="1）man"></a>1）man</h3><p>【功能描述】：显示联机帮助手册</p>
<p>man命令快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>上箭头</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>下箭头</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>PgUp</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>PgDn</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>g</td>
<td>移动到第一页</td>
</tr>
<tr>
<td>G</td>
<td>移动到最后一页</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>&#x2F;字符串</td>
<td>从当前页向下搜索字符串</td>
</tr>
<tr>
<td>?字符串</td>
<td>从当前页向上搜索字符串</td>
</tr>
<tr>
<td>n</td>
<td>当搜索字符串时，可以使用n键找到下一个字符串</td>
</tr>
<tr>
<td>N</td>
<td>当搜索字符串时，使用N键反向查询字符串。也就是说，如果使用“&#x2F;字符串”方式搜索，则N键表示向上搜索字符串；如果使用“?字符串”方式搜索，则N键表示向下搜索字符串。</td>
</tr>
</tbody></table>
<p>man命令的帮助级别</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>普通用户可以执行的系统命令和可执行文件的帮助</td>
</tr>
<tr>
<td>2</td>
<td>内核可以调用的函数和工具的帮助</td>
</tr>
<tr>
<td>3</td>
<td>C语言函数的帮助</td>
</tr>
<tr>
<td>4</td>
<td>设备和特殊文件的帮助</td>
</tr>
<tr>
<td>5</td>
<td>配置文件的帮助</td>
</tr>
<tr>
<td>6</td>
<td>游戏的帮助(个人版的Linux中是有游戏的)</td>
</tr>
<tr>
<td>7</td>
<td>杂项的帮助</td>
</tr>
<tr>
<td>8</td>
<td>超级用户可以执行的系统命令的帮助</td>
</tr>
<tr>
<td>9</td>
<td>内核的帮助</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看命令拥有哪个级别的帮助</span></span><br><span class="line">man -f 命令 或 whatis 命令</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看和命令相关的所有帮助</span></span><br><span class="line">man -k 命令 或 apropos 命令</span><br></pre></td></tr></table></figure>



<h3 id="2）info"><a href="#2）info" class="headerlink" title="2）info"></a>2）info</h3><p>【功能描述】：一套完整资料的帮助信息</p>
<p>info命令快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>上箭头</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>下箭头</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>PgUp</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>PgDn</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Tab</td>
<td>在有“*”符号的节点间进行切换</td>
</tr>
<tr>
<td>回车</td>
<td>进入有“*”符号的子页面，查看详细帮助信息</td>
</tr>
<tr>
<td>u</td>
<td>进入上一层信息(回车是进入下一层信息)</td>
</tr>
<tr>
<td>n</td>
<td>进入下一小节信息</td>
</tr>
<tr>
<td>p</td>
<td>进入上一小节信息</td>
</tr>
<tr>
<td>？</td>
<td>查看帮助信息</td>
</tr>
<tr>
<td>q</td>
<td>退出info信息</td>
</tr>
</tbody></table>
<h3 id="3）help-基本不用"><a href="#3）help-基本不用" class="headerlink" title="3）help(基本不用)"></a>3）help(基本不用)</h3><p>【功能描述】：显示Shell内置命令的帮助。</p>
<p>区分Shell内置命令与外部命令：type 命令。</p>
<h3 id="4）–help"><a href="#4）–help" class="headerlink" title="4）–help"></a>4）–help</h3><p>【功能描述】：man命令的信息简要版。</p>
<h2 id="6-搜索命令"><a href="#6-搜索命令" class="headerlink" title="6. 搜索命令"></a>6. 搜索命令</h2><h3 id="1）whereis"><a href="#1）whereis" class="headerlink" title="1）whereis"></a>1）whereis</h3><p>搜索系统命令的命令。</p>
<p>【功能描述】：查找二进制命令、源文件和帮助文档的命令。</p>
<h3 id="2）which"><a href="#2）which" class="headerlink" title="2）which"></a>2）which</h3><p>搜索系统命令的命令。</p>
<p>和whereis命令的区别在于：</p>
<ul>
<li>whereis命令可以在查找到二进制命令的同时，查找到帮助文档的位置；</li>
<li>which命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。</li>
</ul>
<h3 id="3）locate"><a href="#3）locate" class="headerlink" title="3）locate"></a>3）locate</h3><p>【功能描述】：按照文件名搜索文件。</p>
<p>优点：按照数据库搜索，搜索速度快，消耗资源小。数据库位置&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db（更新数据库：updatedb）。</p>
<p>缺点：只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改时间等搜索文件。</p>
<h3 id="4）find"><a href="#4）find" class="headerlink" title="4）find"></a>4）find</h3><ul>
<li><p>按照文件名搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -name: 按照文件名搜索</span><br><span class="line">  -iname: 按照文件名搜索，不区分文件名大小写</span><br><span class="line">  -inum: 按照inode号搜索</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照文件大小搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -size [+|-]大小: 按照指定大小搜索文件。&quot;+&quot;指搜索比指定大小还大的文件，&quot;-&quot;指搜索比指定大小还小的文件。 </span><br><span class="line"></span><br><span class="line">单位：</span><br><span class="line">- b：默认单位，如果单位为b或者不写单位，则按照512 Byte搜索</span><br><span class="line">- c：按照字节搜索</span><br><span class="line">- w：按照双字节搜索</span><br><span class="line">- k：按KB搜索</span><br><span class="line">- M：按MB搜索</span><br><span class="line">- G：按GB搜索</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照修改时间搜索</p>
<p>Linux中的文件有访问时间(atime)、数据修改时间(mtime)、状态修改时间(ctime)等时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">先项：</span><br><span class="line">  -atime [+|-]时间(天)：按照访问时间搜索</span><br><span class="line">  -mtime [+|-]时间(天)：按照数据修改时间搜索</span><br><span class="line">  -ctime [+|-]时间(天)：按照状态修改时间搜索</span><br><span class="line">  </span><br><span class="line">以mtime数据修改时间为例，说明时间含义：</span><br><span class="line">- -5：代表5天内修改的文件</span><br><span class="line">- 5：代表前5~6天那一天修改的文件</span><br><span class="line">- +5：代表6天前修改的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照权限搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -perm 权限模式：查找文件权限刚好等于&quot;权限模式&quot;的文件</span><br><span class="line">  -perm -权限模式：查找文件权限全部包含&quot;权限模式&quot;的文件</span><br><span class="line">  -perm +权限模式：查找文件权限包含&quot;权限模式&quot;的任意一个权限的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照所有者和所属组搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -uid 用户ID：按照用户ID查找所有者是指定ID的文件</span><br><span class="line">  -gid 组ID：按照用户组ID查找所属组是指定ID的文件</span><br><span class="line">  -user 用户名：按照用户名查找所有者是指定用户的文件</span><br><span class="line">  -group 组名：按照组名查打所属组是指定用户组的文件</span><br><span class="line">  -nouser：查找没有所有者的文件</span><br></pre></td></tr></table></figure>

<p>按照所有者和所属组搜索时，“-nouser”选项比较常用，主要用于查找垃圾文件。</p>
<p>只有一种情况例外，那就是外来文件。比如光盘和U盘中的文件如果是由Windows复制的，在Linux中查看就是没有所有者的文件，再比如手工源码包安装的文件，也有可能没有所有者。</p>
</li>
<li><p>按照文件类型搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -type d：查找目录</span><br><span class="line">  -type f：查找普通文件</span><br><span class="line">  -type l：查找软链接文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -a：逻辑与(and)</span><br><span class="line">  -o：逻辑或(or)</span><br><span class="line">  -not(!)：逻辑非(not)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-a：逻辑与(and)</p>
<p>find命令也支持逻辑运算符先项，其中-a代表逻辑与运算，也就是-a的两个条件都成立，find搜索的结果才成立</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录下搜索大小2KB，并且文件类型是普通文件的文件</span></span><br><span class="line">find . -size +2k -a -type f</span><br></pre></td></tr></table></figure>
</li>
<li><p>-o：逻辑或(or)</p>
<p>-o选项代表逻辑或运算，也就是-o的两个条件只要其中一个成立，find命令就可以找到结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录下搜索文件名要么是cangls的文件，要么是bols的文件</span></span><br><span class="line">find . -name cangls -o -name bols</span><br></pre></td></tr></table></figure>
</li>
<li><p>-not(!)：逻辑非(not)</p>
<p>-not是逻辑非，也就是取反的意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录下搜索文件名不是cangls文件</span></span><br><span class="line">find . -not -name cangls</span><br><span class="line">find . ! -name cangls</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其他选项</p>
<ul>
<li><p>-exec选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容 -exec 命令2 &#123;&#125; \；</span><br></pre></td></tr></table></figure>

<p>这个选项的作用其实是把find命令的结果交由“-exec”调用的命令2来处理。”{}”就代表find命令的查找结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /var/log -mtime +10 -exec ls -ahl &#123;&#125; \;</span><br></pre></td></tr></table></figure>
</li>
<li><p>-ok选项</p>
<p>“-ok”选项和”-exec”选项的作用基本一致，区别在于：“-exec”的命令2会直接处理，而不询问：”-ok”的命令2在处理前会先询问用户是否这样处理，在得到确认命令后，才会执行。</p>
</li>
</ul>
</li>
</ul>
<h2 id="7-补充命令"><a href="#7-补充命令" class="headerlink" title="7. 补充命令"></a>7. 补充命令</h2><h3 id="1）grep"><a href="#1）grep" class="headerlink" title="1）grep"></a>1）grep</h3><p>grep的作用是在文件中提取和匹配符合条件的字符串行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep [选项] &quot;搜索内容&quot; 文件名</span><br><span class="line">选项：</span><br><span class="line">  -i：忽略大小写</span><br><span class="line">  -n：输出行号</span><br><span class="line">  -v：反向查找</span><br><span class="line">  --color=auto：搜索出的关键字用颜色显示</span><br></pre></td></tr></table></figure>



<p>find和grep区别：</p>
<ul>
<li>find命令用于在系统中搜索符合条件的文件名，如果需要模糊查询，则使用通配符进行匹配。搜索文件名是完全匹配的。</li>
<li>grep命令用于在文件中搜索符合条件的字符串，如果需要模糊查询，则使用正则表达式进行匹配。搜索时字符串是包含匹配的。</li>
</ul>
<p>通匹符和正则表达式的区别：</p>
<ul>
<li><p>通配符：用于匹配文件名，完全匹配。</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配一个任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或任意多个任意字符，也就是可以匹配任何内容</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中任意一个字符。例如，[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符，-代表一个范围，例如，[a-z]代表匹配一个小写字母</td>
</tr>
<tr>
<td>[^]</td>
<td>逻辑非，表示匹配不是中括号内的一个字符，例如，[^0-9]代表匹配一个不是数字的字符</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式：用于匹配字符串，包含匹配。</p>
<table>
<thead>
<tr>
<th>正则符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配前一个字符重复0次，或1次。只能用egrep才生效</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个字符重复0次，或任意多次</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中任意一个字符，例如，[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符，-代表一个范围，例如，[a-z]代表匹配一个小写字母</td>
</tr>
<tr>
<td>[^]</td>
<td>逻辑非，表示匹配不是中括号内的一个字符，例如，[^0-9]代表匹配一个不是数字的字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配行首</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2）管道符"><a href="#2）管道符" class="headerlink" title="2）管道符"></a>2）管道符</h3><p>命令格式：命令1 | 命令2</p>
<p>命令1的正确输出作为命令2的操作对象。</p>
<h3 id="3）命令的别名"><a href="#3）命令的别名" class="headerlink" title="3）命令的别名"></a>3）命令的别名</h3><p>命令的别名，就是命令的小名，主要是用于照顾管理员使用习惯的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询命令别名</span></span><br><span class="line">alias</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设定命令别名. <span class="built_in">alias</span> 别名=‘原命令’</span></span><br><span class="line">alias ser=&#x27;service network restart&#x27;</span><br></pre></td></tr></table></figure>

<p>用命令定义的别名，是临时生效的，要想永久生效，需要写入环境变量配置文件~&#x2F;.bashrc。</p>
<p>命令的执行顺序：</p>
<ul>
<li>第一顺位执行用绝对路径或相对路径执行的命令。</li>
<li>第二顺位执行别名。</li>
<li>第三顺位执行bash的内部命令。</li>
<li>第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。</li>
</ul>
<h3 id="4）常用快捷键"><a href="#4）常用快捷键" class="headerlink" title="4）常用快捷键"></a>4）常用快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Tab键</td>
<td>命令或文件补全</td>
</tr>
<tr>
<td>ctrl+A</td>
<td>把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移动到命令行开头时使用。</td>
</tr>
<tr>
<td>ctrl+E</td>
<td>把光标移动到命令行结尾。</td>
</tr>
<tr>
<td>ctrl+C</td>
<td>强制终止当前的命令。</td>
</tr>
<tr>
<td>ctrl+L</td>
<td>清屏，相当于clear命令</td>
</tr>
<tr>
<td>ctrl+U</td>
<td>删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便。</td>
</tr>
<tr>
<td>ctrl+Y</td>
<td>粘贴ctrl+U剪切的内容。</td>
</tr>
<tr>
<td>ctrl+D</td>
<td>退出当前终端</td>
</tr>
<tr>
<td>ctrl+Z</td>
<td>暂停，并放入后台。</td>
</tr>
<tr>
<td>ctrl+S</td>
<td>暂停屏幕输出</td>
</tr>
<tr>
<td>ctrl+Q</td>
<td>恢复屏幕输出</td>
</tr>
</tbody></table>
<h2 id="8-压缩和解压缩"><a href="#8-压缩和解压缩" class="headerlink" title="8. 压缩和解压缩"></a>8. 压缩和解压缩</h2><p>在Linux中可以识别的常见压缩格式有十几种，比如“.zip”，“.gz”，“.bz2”，“.tar”，“.tar.gz”，“.tar.bz2”等。</p>
<h3 id="1）“-zip”格式"><a href="#1）“-zip”格式" class="headerlink" title="1）“.zip”格式"></a>1）“.zip”格式</h3><p>“.zip”是Windows中最常见的压缩格式。Linux也可以正确识别”.zip”格式，这可以方便地和Windows系统通用压缩文件。</p>
<p>a）压缩命令(zip)</p>
<p>【功能描述】：压缩文件或目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">zip [选项] 压缩包名 源文件或源目录</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -r: 压缩目录</span><br></pre></td></tr></table></figure>



<p>b）解压缩(unzip)</p>
<p>【功能描述】：列表、测试和提取压缩文件中的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">unzip [选项] 压缩包名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -d：指定解压缩位置</span><br></pre></td></tr></table></figure>



<h3 id="2）“-gz”格式-不会打包"><a href="#2）“-gz”格式-不会打包" class="headerlink" title="2）“.gz”格式(不会打包)"></a>2）“.gz”格式(不会打包)</h3><p>“.gz”格式是Linux中最常用的压缩格式，使用gzip命令进行压缩。</p>
<p>a）压缩命令(gzip)</p>
<p>【功能描述】：压缩文件或目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">gzip [选项] 源文件</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -c：将压缩数据输出到标准输出中，可以用于保留源文件</span><br><span class="line">  -d：解压缩</span><br><span class="line">  -r：压缩目录（将目录下的文件进行压缩）</span><br></pre></td></tr></table></figure>



<p>b）解压缩(gunzip)</p>
<p>如果要解压缩”.gz”格式，那么使用”gzip -d 压缩包”和”gunzip 压缩包”命令都可以。</p>
<p>【功能描述】：解压缩文件或目录。</p>
<h3 id="3）“-bz2”格式-不能压缩目录"><a href="#3）“-bz2”格式-不能压缩目录" class="headerlink" title="3）“.bz2”格式(不能压缩目录)"></a>3）“.bz2”格式(不能压缩目录)</h3><p>“.bz2”格式是Linux的另一种压缩格式，从理论上来讲，“.bz2”格式的算法更先进、压缩比更好；而”.gz”格式相对来讲压缩的时间更快。</p>
<p>a）压缩命令(bzip2)</p>
<p>【功能描述】：bz2格式的压缩命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bzip2命令格式</span></span><br><span class="line">bzip2 [选项] 源文件</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -d：解压缩</span><br><span class="line">  -k：压缩时，保留源文件</span><br><span class="line">  -v：显示压缩的详细信息</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩成.bz2格式</span></span><br><span class="line">bzip2 anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保留源文件压缩</span></span><br><span class="line">bzip2 -k install.log.syslog</span><br></pre></td></tr></table></figure>



<p>b）解压缩（bunzip2）</p>
<p>“.bz2”格式可以使用”bzip2 -d 压缩包”命令来进行解压缩，也可以使用”bunzip2 压缩包”命令来进行解压缩。</p>
<p>【功能描述】：.bz2格式的解压缩命令。</p>
<h3 id="4）“-tar”格式-打包不压缩"><a href="#4）“-tar”格式-打包不压缩" class="headerlink" title="4）“.tar”格式(打包不压缩)"></a>4）“.tar”格式(打包不压缩)</h3><p>“.tar”格式的打包和解打包都使用tar命令，区别只是选项不同。</p>
<p>a）打包(tar)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar命令格式</span></span><br><span class="line">tar [选项] [-f 压缩包名] 源文件或目录</span><br><span class="line">选项：</span><br><span class="line">  -c：打包</span><br><span class="line">  -f：指定压缩包的文件名。压缩包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名</span><br><span class="line">  -v：显示打包文件过程</span><br><span class="line"> </span><br><span class="line">tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg</span><br></pre></td></tr></table></figure>



<p>b）解打包(tar)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">tar [选项] 压缩包</span><br><span class="line">选项：</span><br><span class="line">  -x：解打包</span><br><span class="line">  -f：指定压缩包的文件名</span><br><span class="line">  -v：显示解打包文件过程</span><br><span class="line">  -t：测试，就是不解打包，只是查看包中有哪些文件</span><br></pre></td></tr></table></figure>



<h3 id="5）“-tar-gz”和”-tar-bz2”格式"><a href="#5）“-tar-gz”和”-tar-bz2”格式" class="headerlink" title="5）“.tar.gz”和”.tar.bz2”格式"></a>5）“.tar.gz”和”.tar.bz2”格式</h3><p>使用tar命令直接打包压缩。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">tar [选项] 压缩包 源文件或目录</span><br><span class="line">选项：</span><br><span class="line">  -z：压缩和解压缩“.tar.gz”格式</span><br><span class="line">  -j：压缩和解压缩“.tar.bz2”格式</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将/tmp目录打包压缩</span></span><br><span class="line">tar -zcvf tmp.tar.gz /tmp/</span><br><span class="line">tar -jcvf tmp.tar.bz2 /tmp/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压缩与解打包</span></span><br><span class="line">tar -zxvf tmp.tar.gz</span><br><span class="line">tar -jxvf tmp.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只查看，不解压</span></span><br><span class="line">tar -ztvf tmptar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压到指定位置</span></span><br><span class="line">tar -zxvf tmp.tar.gz -C /tmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只解压压缩包中的特定文件，到指定位置</span></span><br><span class="line">tar -zxvf tmp.tar.gz -C /tmp test/cde</span><br></pre></td></tr></table></figure>



<h2 id="9-关机和重启"><a href="#9-关机和重启" class="headerlink" title="9. 关机和重启"></a>9. 关机和重启</h2><h3 id="1）sync数据同步"><a href="#1）sync数据同步" class="headerlink" title="1）sync数据同步"></a>1）sync数据同步</h3><p>【功能描述】：刷新文件系统缓冲区</p>
<h3 id="2）shutdown-推荐"><a href="#2）shutdown-推荐" class="headerlink" title="2）shutdown(推荐)"></a>2）shutdown(推荐)</h3><p>【功能描述】：关机和重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本命令格式</span><br><span class="line">shutdown [选项] 时间 [警告信息]</span><br><span class="line">选项：</span><br><span class="line">   -c：取消已经执行的shutdown命令</span><br><span class="line">   -h：关机</span><br><span class="line">   -r：重启</span><br></pre></td></tr></table></figure>



<h3 id="3）reboot"><a href="#3）reboot" class="headerlink" title="3）reboot"></a>3）reboot</h3><p>在现在的系统中，reboot命令也是安全的，而且不需要加入过多的选项。</p>
<h3 id="4）halt和poweroff"><a href="#4）halt和poweroff" class="headerlink" title="4）halt和poweroff"></a>4）halt和poweroff</h3><p>这两个都是关机命令，直接执行即可。这两个命令不会完整关闭和保存系统的服务，不建议使用。</p>
<h3 id="5）init"><a href="#5）init" class="headerlink" title="5）init"></a>5）init</h3><p>init是修改Linux运行级别的命令，也可以用于关机和重启，这个命令并不安全，不建议使用。</p>
<h2 id="10-网络命令"><a href="#10-网络命令" class="headerlink" title="10. 网络命令"></a>10. 网络命令</h2><h3 id="1）配置IP地址"><a href="#1）配置IP地址" class="headerlink" title="1）配置IP地址"></a>1）配置IP地址</h3><p>a. 配置IP地址</p>
<p>IP地址是计算机在互联网中唯一的地址编码。每台计算机如果需要接入网络和其他计算机进行数据通信，就必须配置唯一的公网IP地址。</p>
<p>配置IP地址方法：</p>
<ul>
<li>setup工具</li>
<li>手工修改配置文件：vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</li>
</ul>
<p>b. 重启网络服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启网络服务</span></span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure>



<p>c. 虚拟机需要桥接到有线网卡，并重启网络服务。</p>
<p>d. 复制镜像有可能需要重置UUID（唯一识别符）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除MAC地址行</span></span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除MAC地址和UUID绑定文件</span></span><br><span class="line">rm -rf /etc/udev/rules.d/70-persistent-net.rules</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启Linux</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h3 id="2）ifconfig"><a href="#2）ifconfig" class="headerlink" title="2）ifconfig"></a>2）ifconfig</h3><p>【功能描述】：配置网络接口</p>
<p>ifconfig命令最主要的作用就是查看IP地址的信息，直接输入ifconfig命令即可。</p>
<h3 id="3）ping"><a href="#3）ping" class="headerlink" title="3）ping"></a>3）ping</h3><p>【功能描述】：向网络主机发送ICMP请求。</p>
<p>ping是常用的网络命令，主要通过ICMP协议进行网络探测，测试网络中主机的通信情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本命令格式</span><br><span class="line">ping [选项] IP</span><br><span class="line">选项：</span><br><span class="line">  -b：后面加入广播地址，用于对整个网段进行探测</span><br><span class="line">  -c 次数：用于指定ping的次数</span><br><span class="line">  -s 字节：指定探测包的大小</span><br><span class="line"></span><br><span class="line"># 探测192.168.103.0/24网段中有多少可以通信的主机</span><br><span class="line">ping -b -c 3 192.168.103.255</span><br></pre></td></tr></table></figure>



<h3 id="4）netstat"><a href="#4）netstat" class="headerlink" title="4）netstat"></a>4）netstat</h3><p>【功能描述】：输出网络连接、路由表、接口统计、伪装连接和组播成员。</p>
<p>netstat是网络状态查看命令，既可以查看到本机开启的端口，也可以查看有哪些客户端连接。</p>
<p>在CentOS 7.x中netstat命令默认没有安装，如果需要使用，需要安装net-snmp和net-tools软件包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本命令格式</span><br><span class="line">netstat [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -a：列出所有网络状态，包括Socket程序</span><br><span class="line">  -c 秒数：指定每隔几秒刷新一次网络状态</span><br><span class="line">  -n：使用IP地址和端口号显示，不使用域名与服务名</span><br><span class="line">  -p：显示PID和程序名</span><br><span class="line">  -t：显示使用TCP协议端口的连接状况</span><br><span class="line">  -u：显示使用UDP协议端口的连接状况</span><br><span class="line">  -l：仅显示监听状态的连接</span><br><span class="line">  -r：显示路由表</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 查看本机开启的端口</span><br><span class="line">netstat -tuln</span><br></pre></td></tr></table></figure>

<p>命令输出结果：</p>
<ul>
<li>Proto：网络连接的协议，一般就是TCP协议或者UDP协议。</li>
<li>Recv-Q：表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走。</li>
<li>Send-Q：表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，一般是不具备ACK标志的数据包。</li>
<li>Local Address：本机的IP地址和端口号。</li>
<li>Foreign Address：远程主机的IP地址和端口号。</li>
<li>State：状态。常见的状态主要有以下几种。<ul>
<li>LISTEN：监听状态，只有TCP协议需要监听，而UDP协议不需要监听。</li>
<li>ESTABLISHED：已经建立连接的状态。如果使用“-l”选项，则看不到已经建立连接的状态。</li>
<li>SYN_SENT：SYN发起包，就是主动发起连接的数据包。</li>
<li>SYN_RECV：接收到主动连接的数据包。</li>
<li>FIN_WAIT1：正在中断的连接。</li>
<li>FIN_WAIT2：已经中断的连接，但是正在等待对方主机进行确认。</li>
<li>FIN_WAIT：连接已经中断，但是套接字依然在网络中等待结束。</li>
<li>CLOSED：套接字没有被使用。</li>
</ul>
</li>
</ul>
<p>在这些状态中，我们最用的就是LISTEN和ESTABLISHED状态，一种代表正在监听，另一种代表已经建立连接。</p>
<h3 id="5）write"><a href="#5）write" class="headerlink" title="5）write"></a>5）write</h3><p>【功能描述】：向其他用户发送信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看有多少人正在登录</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$ w</span><br><span class="line"> 14:50:14 up 4 min,  1 user,  load average: 2.31, 1.29, 0.56</span><br><span class="line">USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU  WHAT</span><br><span class="line">ben               -                14:46     ?     0.00s  0.04s lightdm --session-child 13 20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向在pts/1（远程终端）登录的user1用户发送信息，使用<span class="string">&quot;Ctrl+D&quot;</span>快捷键保存发送的数据</span></span><br><span class="line">write user1 pts/1</span><br></pre></td></tr></table></figure>



<h3 id="6）wall"><a href="#6）wall" class="headerlink" title="6）wall"></a>6）wall</h3><p>write命令用于给指定用户发送信息，而wall命令用于给所有登录用户发送信息，包括自己。执行时，在wall命令后加入需要发送的信息即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wall &quot;hello&quot;</span><br></pre></td></tr></table></figure>



<h3 id="7）mail"><a href="#7）mail" class="headerlink" title="7）mail"></a>7）mail</h3><p>mail是Linux的邮件客户端命令，可以利用这个命令给其他用户发送邮件。</p>
<p>【功能描述】：发送和接收电子邮件。</p>
<p>a. 发送邮件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送邮件, Ctrl+D发送</span></span><br><span class="line">mail user1</span><br></pre></td></tr></table></figure>

<p>接收到的邮件都保存在“&#x2F;var&#x2F;spool&#x2F;mail&#x2F;用户名”中，每个用户都有一个以自己的用户名命令的邮箱。</p>
<p>b. 发送文件内容</p>
<p>如果想把某个文件的内容发送给指定用户，则可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把/root/anaconda-ks.cfg文件内容发送给root用户</span></span><br><span class="line">mail -s &quot;test mail&quot; root &lt; /root/anaconda-ks.cfg</span><br><span class="line">选项：</span><br><span class="line">  -s：指定邮件标题</span><br></pre></td></tr></table></figure>

<p>在写脚本时，有时需要脚本自动发送一些信息给指定用户，把要发送的信息预先写到文件中，是一个非常不错的选择。</p>
<p>c. 查看已经接收的邮件</p>
<p>我们可以直接在命令行中执行mail命令，进入mail的交互命令中，可以在这里查看已经接收到的邮件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mail</span></span><br><span class="line">&quot;/var/mail/test&quot;: 2 messages 2 new</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">N   1 ben                日 12月 22 15:  13/425   hello</span></span><br><span class="line"> N   2 ben                日 12月 22 15:  15/434   hello</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">未阅读 编号 发件人            时间                  标题</span></span><br></pre></td></tr></table></figure>

<p>可以看到已经接收到的邮件列表，“N”代表未读邮件，如果是已经阅读过的邮件，则前面是不会有这个“N”的；之后的数字是邮件的编号，我们主要通过这个编号来进行邮件的操作。如果我们想要查看第一封邮件，则只需要输入邮件的编号“1”就可以了。</p>
<p>交互命令是可以简化输入的。</p>
<ul>
<li>headers: 列出邮件标题列表，直接输入“h”命令即可。</li>
<li>delete：删除指定邮件。比如想要删除第二封邮件，可以输入“d 2”。</li>
<li>save：保存邮件。可以把指定邮件保存成文件。如”s 2 &#x2F;tmp&#x2F;test.mail”。</li>
<li>quit：退出，并把已经操作过的邮件进行保存。比如移除已删除邮件、保存已阅读邮件等。</li>
<li>exit：退出，但是不保存任何操作。</li>
</ul>
<h3 id="8）nmap"><a href="#8）nmap" class="headerlink" title="8）nmap"></a>8）nmap</h3><p>端口扫描命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nmap -sT 域名或IP</span><br><span class="line">选项：</span><br><span class="line">  -s        扫描</span><br><span class="line">  -T        扫描所有开启的TCP端口</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nmap -sT 127.0.0.1</span><br><span class="line">Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-03-01 15:55 CST</span><br><span class="line">Nmap scan report for localhost (127.0.0.1)</span><br><span class="line">Host is up (0.00027s latency).</span><br><span class="line">Not shown: 995 closed tcp ports (conn-refused)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">25/tcp   open  smtp</span><br><span class="line">631/tcp  open  ipp</span><br><span class="line">1090/tcp open  ff-fms</span><br><span class="line">4000/tcp open  remoteanything</span><br><span class="line">9090/tcp open  zeus-admin</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.09 seconds</span><br></pre></td></tr></table></figure>



<h2 id="11-痕迹命令"><a href="#11-痕迹命令" class="headerlink" title="11. 痕迹命令"></a>11. 痕迹命令</h2><p>系统中有一些重要的痕迹日志文件，如&#x2F;var&#x2F;log&#x2F;wtmp、&#x2F;var&#x2F;run&#x2F;utmp、&#x2F;var&#x2F;log&#x2F;btmp、&#x2F;var&#x2F;log&#x2F;lastlog等日志文件，如果你用vim打开这些文件，你会发现这些文件是二进制乱码。这是由于这些日志中保存的是系统的重要登录痕迹，包括某个用户何时登录了系统，何时退出了系统，错误登录等重要的系统信息。这些信息要是可以通过vim打开，就能编辑，这样痕迹信息就不准确，所以这些重要的痕迹日志，只能通过对应的命令来进行查看。</p>
<h3 id="1）w"><a href="#1）w" class="headerlink" title="1）w"></a>1）w</h3><p>w命令是显示系统中正在登录的用户信息的命令，这个命令查看的痕迹日志是&#x2F;var&#x2F;run&#x2F;utmp。</p>
<p>【功能描述】：显示登录用户，和他正在做什么。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# w</span><br><span class="line"> 15:44:22 up  1:59,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    192.168.0.75     15:44    3.00s  0.01s  0.00s w</span><br></pre></td></tr></table></figure>

<p>第一行信息：</p>
<ul>
<li>系统当前时间</li>
<li>系统运行时间</li>
<li>当前登录用户数</li>
<li>系统在之前1分钟、5分钟、15分钟的平均负载。如果CPU是单核的，则这个数值超过1就是高负载，如果CPU是四核的，则这个数值超过4就是高负载。</li>
</ul>
<p>第二行信息：</p>
<ul>
<li>USER: 当前登录的用户</li>
<li>TTY: 登录的终端<ul>
<li>tty1-6：本地字符终端(alt+F1-6切换)</li>
<li>tty7：本地图形终端(ctrl+alt+F7切换，必须安装启动图形界面)</li>
<li>pts&#x2F;0-255：远程终端</li>
</ul>
</li>
<li>FROM：登录的IP地址，如果是本地终端，则是空</li>
<li>LOGIN@：登录时间</li>
<li>IDLE：用户闲置时间</li>
<li>JCPU：所有进程占用的CPU时间</li>
<li>PCPU：当前进程占用的CPU时间</li>
<li>WHAT：用户正在进行的操作</li>
</ul>
<h3 id="2）who"><a href="#2）who" class="headerlink" title="2）who"></a>2）who</h3><p>who命令和w命令类似，用于查看正在登录的用户，但是显示的内容更加简单，也是查看&#x2F;var&#x2F;run&#x2F;utmp。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# who</span><br><span class="line">root     pts/0        2024-12-22 15:44 (192.168.0.75)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名   登录终端      登录时间(来源IP)</span></span><br></pre></td></tr></table></figure>



<h3 id="3）last"><a href="#3）last" class="headerlink" title="3）last"></a>3）last</h3><p>last命令是查看系统所有登录过的用户的信息的，包括正在登录的用户和之前登录的用户。这个命令查看的是&#x2F;var&#x2F;log&#x2F;wtmp痕迹日志文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# last</span><br><span class="line">root     pts/0        192.168.0.75     Sun Dec 22 15:44   still logged in</span><br><span class="line">reboot   system boot  5.15.0-117-gener Sun Dec 22 13:45   still running</span><br><span class="line">reboot   system boot  5.15.0-117-gener Sun Dec 22 13:15   still running</span><br><span class="line">reboot   system boot  5.15.0-117-gener Fri Dec 20 15:52   still running</span><br><span class="line">reboot   system boot  5.15.0-117-gener Fri Dec 20 15:44   still running</span><br><span class="line">reboot   system boot  5.15.0-117-gener Thu Dec 19 19:53   still running</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统重启信息记录</span></span><br><span class="line">root     pts/0        192.168.0.75     Thu Dec 19 17:00 - 18:02  (01:02)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名   终端号        来源IP地址        登录时间            退出时间</span></span><br></pre></td></tr></table></figure>



<h3 id="4）lastlog"><a href="#4）lastlog" class="headerlink" title="4）lastlog"></a>4）lastlog</h3><p>lastlog命令是查看系统中所有用户最后一次的登录时间的命令，他查看的日志是&#x2F;var&#x2F;log&#x2F;lastlog文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# lastlog</span><br><span class="line">Username         Port     From             Latest</span><br><span class="line">root             pts/0    192.168.0.75     Sun Dec 22 15:44:19 +0800 2024</span><br><span class="line">daemon                                     **Never logged in**     # 系统伪用户</span><br><span class="line">bin                                        **Never logged in**</span><br><span class="line">sys                                        **Never logged in**</span><br><span class="line">sync                                       **Never logged in**</span><br><span class="line">games                                      **Never logged in**</span><br><span class="line">man                                        **Never logged in**</span><br><span class="line">lp                                         **Never logged in**</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名         终端       来源IP           登录时间</span></span><br></pre></td></tr></table></figure>



<h3 id="5）lastb"><a href="#5）lastb" class="headerlink" title="5）lastb"></a>5）lastb</h3><p>lastb命令是查看错误登录的信息的，查看的是&#x2F;var&#x2F;log&#x2F;btmp痕迹日志。。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# lastb</span><br><span class="line">root         tty1                        Mon Nov 12 23:50 - 23:58 （00:00）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">错误登录用户  终端                        尝试登录的时间</span></span><br></pre></td></tr></table></figure>





<h2 id="12-挂载命令"><a href="#12-挂载命令" class="headerlink" title="12. 挂载命令"></a>12. 挂载命令</h2><h3 id="1）mount"><a href="#1）mount" class="headerlink" title="1）mount"></a>1）mount</h3><p>linux所有存储设备都必须挂载使用，包括硬盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询系统中已经挂载的设备，-l会显示卷标名称</span><br><span class="line">mount -l</span><br><span class="line"></span><br><span class="line"># 依据配置文件/etc/fstab的内容，自动挂载</span><br><span class="line">mount -a</span><br><span class="line"></span><br><span class="line">mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span><br><span class="line">选项：</span><br><span class="line">  -t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统</span><br><span class="line">  -L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</span><br><span class="line">  -o 特殊选项：可以指定挂载的额外选项，比如读写权限、同步异步等，如果不指定则默认值生效。参数如下表。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>atime&#x2F;noatime</td>
<td>更新访问时间&#x2F;不更新访问时间，访问时区文件时，是否更新文件的访问时间，默认为更新</td>
</tr>
<tr>
<td>async&#x2F;sync</td>
<td>异步&#x2F;同步，默认为异步</td>
</tr>
<tr>
<td>auto&#x2F;noauto</td>
<td>自动&#x2F;手动，mount -a命令执行时，是否会自动安装&#x2F;etc&#x2F;fstab文件内容挂载，默认为自动</td>
</tr>
<tr>
<td>defaults</td>
<td>定义默认值，相当于rw,suid,dev,exec,auto,nouser,async这七个选项</td>
</tr>
<tr>
<td>exec &#x2F;noexec</td>
<td>执行&#x2F;不执行，设定是否允许在文件系统中执行可执行文件，默认是exec允许</td>
</tr>
<tr>
<td>remount</td>
<td>重新挂载已经挂载的文件系统，一般用于指定修改特殊权限</td>
</tr>
<tr>
<td>rw&#x2F;ro</td>
<td>读写&#x2F;只读，文件系统挂载时，是否具有读写权限，默认是w</td>
</tr>
<tr>
<td>suid&#x2F;nosuid</td>
<td>具有&#x2F;不具有SUID权限，设定文件系统是否具有SUID和SGID的权限，默认是具有</td>
</tr>
<tr>
<td>user&#x2F;nouser</td>
<td>允许&#x2F;不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认是不允许，只有root挂载分区</td>
</tr>
<tr>
<td>usrquota</td>
<td>写入代表文件系统支持用户磁盘配额，默认不支持</td>
</tr>
<tr>
<td>grpquota</td>
<td>写入代表文件系统支持组磁盘配额，默认不支持</td>
</tr>
</tbody></table>
<h3 id="2）挂载光盘"><a href="#2）挂载光盘" class="headerlink" title="2）挂载光盘"></a>2）挂载光盘</h3><p>光盘挂载的前提依然是指定光盘的设备文件名，不同版本的Linux，设备文件名并不相同。</p>
<ul>
<li>CentOS 5.x以前的系统，光盘设备文件名是&#x2F;dev&#x2F;hdc。</li>
<li>CentOS 6.x以后的系统，光盘设备文件名是&#x2F;dev&#x2F;sr0。</li>
</ul>
<p>不论哪个系统都有软链接&#x2F;dev&#x2F;cdrom，都可以作为光盘的设备文件名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载光盘</span></span><br><span class="line">mount -t iso9660 /dev/cdrom /mnt/cdrom/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载</span></span><br><span class="line">umount /mnt/cdrom 或 umount /dev/sr0</span><br></pre></td></tr></table></figure>

<p>【注意】：卸载的时候需要退出光盘目录，才能正常卸载。</p>
<h3 id="3）挂载U盘"><a href="#3）挂载U盘" class="headerlink" title="3）挂载U盘"></a>3）挂载U盘</h3><p>U盘会和硬盘共用设备文件名，所以U盘的设备文件名不是固定的，需要手工查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询硬盘</span></span><br><span class="line">fdisk -l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载</span></span><br><span class="line">mount -t vfat /dev/sdb1 /mnt/usb/</span><br></pre></td></tr></table></figure>

<p>如果U盘中有中文，会发现中文是乱码，Linux要想正常显示中文，需要两个条件：</p>
<ul>
<li>安装了中文编码和中文字体。</li>
<li>操作终端需要支持中文显示(纯字符终端，是不支持中文编码的)。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载U盘，指定中文编码格式为UTF-8</span></span><br><span class="line">mount -t vfat -o iocharset=utf8 /dev/sdb1 /mnt/usb/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载</span></span><br><span class="line">umount /mnt/usb/</span><br></pre></td></tr></table></figure>



<h3 id="4）挂载NTFS分区"><a href="#4）挂载NTFS分区" class="headerlink" title="4）挂载NTFS分区"></a>4）挂载NTFS分区</h3><p>Linux的驱动加载顺序：</p>
<ul>
<li>驱动直接放入系统内核之中，这种驱动主要是系统启动加载必须的驱动，数量较少。</li>
<li>驱动以模块的形式放入硬盘。大多数驱动都以这种方式保存，保存位置在&#x2F;lib&#x2F;modules&#x2F;3.10.0-862.el7.x86_64&#x2F;kernel&#x2F;中。</li>
<li>驱动可以被Linux识别，但是系统认为这种驱动一般不常用，默认不加载。如果需要加载这种驱动，需要重新编译内核，而NTFS文件系统的驱动就属于这种情况。</li>
<li>硬件不能被Linux内核识别，需要手工安装驱动。当然前提是厂商提供了该硬件针对Linux的驱动，否则需要自己开发驱动了。</li>
</ul>
<p>使用NTFS-3G安装NTFS文件系统模块</p>
<p>下载NTFS-3G插件：<a href="https://github.com/tuxera/ntfs-3g">https://github.com/tuxera/ntfs-3g</a></p>
<p>安装完成后，就可以挂载和使用Windows的NTFS分区了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t ntfs-3g /dev/sdb1 /mnt/win</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统性能调优</title>
    <url>/2025/03/06/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="CPU调优"><a href="#CPU调优" class="headerlink" title="CPU调优"></a>CPU调优</h2><p>目标：最大化CPU利用率，减少上下文切换和延迟。</p>
<h3 id="调整CPU频率策略"><a href="#调整CPU频率策略" class="headerlink" title="调整CPU频率策略"></a>调整CPU频率策略</h3><p>将CPU频率设置为’performance’模式，确保CPU始终以最高频率运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装cpufrequtils工具</span></span><br><span class="line">sudo apt install cpufrequtils</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置为performance模式</span></span><br><span class="line">sudo cpufreq-set -g performance</span><br></pre></td></tr></table></figure>



<h3 id="绑定进程到特定CPU核心"><a href="#绑定进程到特定CPU核心" class="headerlink" title="绑定进程到特定CPU核心"></a>绑定进程到特定CPU核心</h3><p>使用’taskset’将关键进程绑定到特定CPU核心，减少上下文切换。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taskset -cp 0,1 &lt;pid&gt;</span><br></pre></td></tr></table></figure>



<h3 id="优化中断处理"><a href="#优化中断处理" class="headerlink" title="优化中断处理"></a>优化中断处理</h3><p>将中断处理分散到多个CPU核心，避免单个CPU过载。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 2 | sudo tree /proc/irq/&lt;irq_number&gt;/smp_affinity</span><br></pre></td></tr></table></figure>



<h2 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h2><p>目标：减少内存碎片化，降低交换分区使用频率。</p>
<h3 id="调整Swappiness"><a href="#调整Swappiness" class="headerlink" title="调整Swappiness"></a>调整Swappiness</h3><p>降低swappiness值，减少系统使用交换分区（swap）的频率。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时生效</span></span><br><span class="line">sudo sysctl vm.swappiness=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久生效,在/etc/sysctl.conf下添加</span></span><br><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure>

<p>在读取swap交换分区中的数据时，由于数据需要从磁盘中读取，因此可能会比物理内存中读取慢得多。</p>
<p>Linux中的swap交换分区是类似于Windows的虚拟内存，它的作用是在物理内存使用完之后，将磁盘空间(也就是swap分区)虚拟成内存来使用。它的功能就是在内存不够的情况下，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，腾出来让别的程序运行。</p>
<h3 id="调整内存分配策略"><a href="#调整内存分配策略" class="headerlink" title="调整内存分配策略"></a>调整内存分配策略</h3><p>设置vm.overcommit_memory为1，允许系统超额分配内存。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl vm.overcommit_memory=1</span><br></pre></td></tr></table></figure>

<p>可选值：</p>
<ul>
<li>0：表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。</li>
<li>1：表示内核允许分配所有的物理内存，而不管当前的内存状态如何。</li>
<li>2：表示内核允许分配超过所有物理内存和交换空间总和的内存。</li>
</ul>
<p>Linux对大部分申请的内存的请求都回复“yes”，以便能跑更多更大的程序。因为申请内存后，并不会马上使用内存。这种技术叫做overcommit。当Linux发现内存不足时，会发生OOM killer(OOM&#x3D;out-of-memory)。它会选择杀死一些进程(用户态进程，不是内核线程)，以便释放内存。</p>
<h3 id="调整透明大页-THP"><a href="#调整透明大页-THP" class="headerlink" title="调整透明大页(THP)"></a>调整透明大页(THP)</h3><p>对于某些工作负载(如数据库)，禁用透明大页可能更有利。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo never | sudo tree /sys/kernel/mm/transparent_hugepage/enabled</span><br></pre></td></tr></table></figure>



<h2 id="磁盘I-O调优"><a href="#磁盘I-O调优" class="headerlink" title="磁盘I&#x2F;O调优"></a>磁盘I&#x2F;O调优</h2><p>目标：优化磁盘读写性能，减少I&#x2F;O延迟。</p>
<h3 id="选择合适的I-O调度器"><a href="#选择合适的I-O调度器" class="headerlink" title="选择合适的I&#x2F;O调度器"></a>选择合适的I&#x2F;O调度器</h3><p>对于SSD，建议使用noop或deadline调度器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo noop | sudo tree /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>

<p>对于HDD，建议使用deadline调度器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo deadline | sudo tree /sys/block/sdX/queue/scheduler</span><br></pre></td></tr></table></figure>



<h3 id="调整文件系统挂载选项"><a href="#调整文件系统挂载选项" class="headerlink" title="调整文件系统挂载选项"></a>调整文件系统挂载选项</h3><p>对于ext4文件系统，启用noatime和data&#x3D;writeback选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mount -o remount,noatime,data=writeback /</span><br></pre></td></tr></table></figure>

<p>默认的方式下linux会把文件访问的时间(atime)做记录，因为系统运行的时候要访问大量文件，如果能减少一些动作(比如减少时间戳的记录次数等)将会显著提高磁盘IO效率、提升文件系统的性能。</p>
<p>data&#x3D;ordered模式是ext4文件系统默认日志格式。在data&#x3D;writeback模式下，当元数据提交到日志后，data可以直接被提交到磁盘。即会做元数据日志，数据不做日志，并且不保证数据比元数据先落盘。writeback是ext4提供的性能最好的模式。</p>
<h3 id="优化磁盘队列深度"><a href="#优化磁盘队列深度" class="headerlink" title="优化磁盘队列深度"></a>优化磁盘队列深度</h3><p>增加磁盘队列深度以提高I&#x2F;O吞吐量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 256 | sudo tree /sys/block/sdX/queue/nr_requests</span><br></pre></td></tr></table></figure>

<p>队列深度决定了给块设备写I&#x2F;O的最大并发数，对于Linux系统，默认值为128。一般情况下不建议用户修改此参数。当对系统进行极限性能测试时，为了增大主机写I&#x2F;O的压力及I&#x2F;O在队列中被合并的概率，可以适当的增大此参数。</p>
<h2 id="网络调优"><a href="#网络调优" class="headerlink" title="网络调优"></a>网络调优</h2><p>目标：提高网络吞吐量，降低延迟。</p>
<h3 id="调整TCP缓冲区大小"><a href="#调整TCP缓冲区大小" class="headerlink" title="调整TCP缓冲区大小"></a>调整TCP缓冲区大小</h3><p>增加TCP接收和发送缓冲区大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w net.core.rmem_max=16777216</span><br><span class="line">sudo sysctl -w net.core.wmem_max=16777216</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_rmem=&quot;4096 87380 16777216&quot;</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_wmem=&quot;4096 65536 16777216&quot;</span><br></pre></td></tr></table></figure>



<h3 id="启用TCP快速打开"><a href="#启用TCP快速打开" class="headerlink" title="启用TCP快速打开"></a>启用TCP快速打开</h3><p>减少TCP连接的建立时间。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w net.ipv4.tcp_fastopen=3</span><br></pre></td></tr></table></figure>



<h3 id="调整连接队列大小"><a href="#调整连接队列大小" class="headerlink" title="调整连接队列大小"></a>调整连接队列大小</h3><p>增加连接队列大小以应对高并发连接。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w net.core.somaxconn=65535</span><br><span class="line">sudo sysctl -w net.ipv4.tcp_max_syn_backlog=65535</span><br></pre></td></tr></table></figure>



<h2 id="文件系统调优"><a href="#文件系统调优" class="headerlink" title="文件系统调优"></a>文件系统调优</h2><p>目标：提高文件系统性能，减少元数据操作开销。</p>
<h3 id="调整文件描述符限制"><a href="#调整文件描述符限制" class="headerlink" title="调整文件描述符限制"></a>调整文件描述符限制</h3><p>增加系统允许打开的文件描述符数量。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w fs.file-max=100000</span><br><span class="line">ulimit -n 100000</span><br></pre></td></tr></table></figure>



<h3 id="优化inode缓存"><a href="#优化inode缓存" class="headerlink" title="优化inode缓存"></a>优化inode缓存</h3><p>增加inode缓存大小以提高文件系统性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w vm.vfs_cache_pressure=50</span><br></pre></td></tr></table></figure>



<h2 id="内核参数调优"><a href="#内核参数调优" class="headerlink" title="内核参数调优"></a>内核参数调优</h2><p>目标：优化内核行为，提升系统整体性能。</p>
<h3 id="调整进程调度策略"><a href="#调整进程调度策略" class="headerlink" title="调整进程调度策略"></a>调整进程调度策略</h3><p>对于实时性要求高的任务，使用SCHED_FIFO或SCHED_RR调度策略。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chrt -f -p 99 &lt;pid&gt;</span><br></pre></td></tr></table></figure>



<h3 id="优化虚拟内存管理"><a href="#优化虚拟内存管理" class="headerlink" title="优化虚拟内存管理"></a>优化虚拟内存管理</h3><p>调整vm.dirty_ratio和vm.dirty_background_ratio，控制脏页写回行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w vm.dirty_ratio=10</span><br><span class="line">sudo sysctl -w vm.dirty_background_ratio=5</span><br></pre></td></tr></table></figure>



<h2 id="监控与维护"><a href="#监控与维护" class="headerlink" title="监控与维护"></a>监控与维护</h2><p>目标：持续监控系统性能，及时发现瓶颈。</p>
<h3 id="使用性能监控工具"><a href="#使用性能监控工具" class="headerlink" title="使用性能监控工具"></a>使用性能监控工具</h3><ul>
<li>top、htop：监控CPU和内存的使用情况。</li>
<li>vmstat：监控虚拟内存、CPU和I&#x2F;O状态。</li>
<li>iostat：监控磁盘I&#x2F;O性能。</li>
<li>netstat、ss：监控网络连接状态。</li>
</ul>
<h3 id="定期清理系统"><a href="#定期清理系统" class="headerlink" title="定期清理系统"></a>定期清理系统</h3><ul>
<li>清理不必要的日志文件和缓存。</li>
<li>使用logrotate管理日志文件大小。</li>
</ul>
<h2 id="硬件优化"><a href="#硬件优化" class="headerlink" title="硬件优化"></a>硬件优化</h2><p>目标：充分利用硬件资源</p>
<h3 id="升级硬件"><a href="#升级硬件" class="headerlink" title="升级硬件"></a>升级硬件</h3><ul>
<li>使用SSD替代HDD以提高I&#x2F;O性能。</li>
<li>增加内存容量以减少交换分区的使用。</li>
<li>使用多核CPU以提高并发处理能力。</li>
</ul>
<h2 id="持久化调优配置"><a href="#持久化调优配置" class="headerlink" title="持久化调优配置"></a>持久化调优配置</h2><p>将调优参数写入&#x2F;etc&#x2F;sysctl.conf，确保重启后生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vm.swappiness=10</span><br><span class="line">vm.overcommit_memory=1</span><br><span class="line">net.core.somaxconn=65535</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=65535</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Redis性能问题排查</title>
    <url>/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<p>Redis作为内存数据库，具有非常高的性能，单个实例的OPS能够达到10W左右。</p>
<h2 id="确认是否Redis本身响应慢"><a href="#确认是否Redis本身响应慢" class="headerlink" title="确认是否Redis本身响应慢"></a>确认是否Redis本身响应慢</h2><p>如果你发现你的业务服务API响应延迟变长，首先你需要先排查服务内部，究竟是哪个环境拖慢了整个服务。比较高效的做法是在服务内部集成链路追踪。</p>
<p>如果发现确实是操作Redis的这条链路耗时变长了，那么此刻需要把焦点关注在业务服务到Redis这条链路上。</p>
<p>从你的业务服务到Redis这条链路变慢的原因可能也有2个：</p>
<ul>
<li>业务服务器到Redis服务器之间的网络存在问题，例如网络线路质量不佳，网络数据包在传输时存在延迟、丢包等情况。</li>
<li>Redis本身存在问题，需要进一步排查是什么原因导致Redis变慢。</li>
</ul>
<h2 id="Redis基准性能测试"><a href="#Redis基准性能测试" class="headerlink" title="Redis基准性能测试"></a>Redis基准性能测试</h2><p>从Redis角度来排查，是否存在导致变慢的场景，以及都有哪些因素会导致Redis的延迟增加，然后针对性的进行优化。</p>
<p>排除网络原因，确认你的Redis是否真的变慢了，首先需要对Redis进行基准性能测试，了解你的Redis在生产环境服务器上的基准性能。</p>
<p>什么是基准性能？</p>
<p>基准性能就是指Redis在一台负载正常的机器上，其最大的响应延迟和平均响应延迟分别是怎样的。</p>
<p>Redis在不同的软硬件环境下，它的性能是不同的，比如我的机器配置比较低，当延迟为2ms时，我就认为Redis变慢了，但是如果你的硬件配置比较高，那么在你的运行环境下，可能延迟在0.5ms时就可以认为Redis变慢了。所以，只有在了解你的Redis在生产环境服务器上的基准性能，才能进一步评估，当其延迟达到什么程度时，才认为Redis确实变慢了。</p>
<p>具体如何做？</p>
<p>为避免业务服务器到Redis服务器之间的网络延迟，你需要直接在Redis服务器上测试实例的响应延迟情况。</p>
<p>执行以下命令，就可以测试出这个实例60s内的最大响应延迟：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli -h 127.0.0.1 -p 6379 --intrinsic-latency 60</span></span><br><span class="line">Max latency so far: 1 microseconds.</span><br><span class="line">Max latency so far: 15 microseconds.</span><br><span class="line">Max latency so far: 17 microseconds.</span><br><span class="line">Max latency so far: 18 microseconds.</span><br><span class="line">Max latency so far: 31 microseconds.</span><br><span class="line">Max latency so far: 32 microseconds.</span><br><span class="line">Max latency so far: 59 microseconds.</span><br><span class="line">Max latency so far: 72 microseconds.</span><br><span class="line"></span><br><span class="line">1428669267 total runs (avg latency: 0.0420 microseconds / 42.00 nanoseconds per run).</span><br><span class="line">Worst run took 1429x longer than the average latency.</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看到，这60s内的最大响应延迟为72微秒。</p>
<p>还可以执行以下命令，查看一段时间内Redis的最小、最大、平均访问延迟：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli -h 127.0.0.1 -p 6379 --latency-history -i 1</span></span><br><span class="line">min: 0, max: 1, avg: 0.13 (100 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.12 (99 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.13 (99 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.10 (99 samples) -- 1.01 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.13 (98 samples) -- 1.00 seconds range</span><br><span class="line">min: 0, max: 1, avg: 0.08 (99 samples) -- 1.01 seconds range</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以上输出结果为每间隔1s，采样Redis的平均操作耗时，其结果分布在0.08~0.13ms之间。</p>
<p>基准性能测试方法</p>
<p>了解了基准性能测试方法，就可以按照以下几步，来判断你的Redis是否真的变慢了：</p>
<ul>
<li>在相同配置的服务器上，测试一个正常Redis实例的基准性能。</li>
<li>找到你认为可能变慢的Redis实例，测试这个实例的基准性能。</li>
<li>如果观察到，这个可能变慢的Redis实例的运行延迟是正常Redis基准性能的2倍以上，即可认为这个Redis实例确实变慢了。</li>
</ul>
<h2 id="Redis变慢的因素"><a href="#Redis变慢的因素" class="headerlink" title="Redis变慢的因素"></a>Redis变慢的因素</h2><h3 id="使用复杂度过高的命令"><a href="#使用复杂度过高的命令" class="headerlink" title="使用复杂度过高的命令"></a>使用复杂度过高的命令</h3><p>如何发现耗时长的命令？</p>
<p>Redis提供了慢日志(slowlog)命令统计功能，它记录了有哪些命令在执行时耗时比较久。</p>
<p>查看Redis慢日志前，你需要设置慢日志的阈值。如设置慢日志的阈值为5ms，并且保留最近500条慢日志记录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令执行耗时超过5ms，记录慢日志</span></span><br><span class="line">CONFIG SET slowlog-log-slower-than 5000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只保留最近500条慢日志</span></span><br><span class="line">CONFIG SET slowlog-max-len 500</span><br></pre></td></tr></table></figure>

<p>设置完成后，所有执行的命令如果操作耗时超过了5ms，都会被Redis记录下来。</p>
<p>此时，你执行以下命令，就可以查询到最近记录的慢日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG get 5</span><br><span class="line">1) 1) (integer) 32693       # 慢日志ID</span><br><span class="line">   2) (integer) 1593763337  # 执行时间戳</span><br><span class="line">   3) (integer) 5299        # 执行耗时(微秒)</span><br><span class="line">   4) 1) &quot;LRANGE&quot;           # 具体执行的命令和参数</span><br><span class="line">      2) &quot;user_list:2000&quot;</span><br><span class="line">      3) &quot;0&quot;</span><br><span class="line">      4) &quot;-1&quot;</span><br><span class="line">2) 1) (integer) 32692</span><br><span class="line">   2) (integer) 1593763337</span><br><span class="line">   3) (integer) 5044</span><br><span class="line">   4) 1) &quot;GET&quot;</span><br><span class="line">      2) &quot;user_info:1000&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过查看慢日志，就可以知道在什么时间间，执行了哪些命令比较耗时。</p>
<p>使用复杂度过高命令的场景有哪些？</p>
<p>如果你的应用程序执行的Redis命令有以下特点，那么可能会导致操作延迟变大：</p>
<ul>
<li>经常使用O(N)以上复杂度的命令，例如SORT、SUNION、ZUNIONSTORE聚合类命令</li>
<li>使用O(N)复杂度的命令，但N的值非常大</li>
</ul>
<p>第一种情况导致变慢的原因在于，Redis在操作内存数据时，时间复杂度过高，要花费更多的CPU资源。</p>
<p>第二种情况导致变慢的原因在于，Redis一次需要返回给客户端的数据过多，更多时间花费在数据协议的组装和网络传输过程中。</p>
<p>另外，我们还可以从资源使用率层面来分析，如果你的应用程序操作Redis的OPS不是很大，但Redis实例的CPU使用率却很高，那么很有可能是使用了复杂度过高的命令导致的。</p>
<p>除此之外，我们都知道，Redis是单线程处理客户端请求的，如果你经常使用以上命令，那么当Redis处理客户端请求时，一旦前面某个命令发生耗时，就会导致后面的请求发生排队，对于客户端来说，响应延迟也会变长。</p>
<p>如何解决？</p>
<ul>
<li>尽量不使用O(N)以上复杂度过高的命令，对于数据的聚合操作，放在客户端做。</li>
<li>执行O(N)命令，保证N尽量小(推荐N&lt;&#x3D;300)，每次获取尽量少的数据，让Redis可以及时处理返回。</li>
</ul>
<h3 id="操作bigkey"><a href="#操作bigkey" class="headerlink" title="操作bigkey"></a>操作bigkey</h3><p>如果查询慢日志发现，并不是复杂度过高的命令导致，而都是SET&#x2F;DEL这种简单命令出现在慢日志中，那么就要怀疑你的实例是否写入了bigkey。</p>
<p>何为bigkey?</p>
<p>Redis在写入数据时，需要为新的数据分配内存，相对应的，当从Redis中删除数据时，它会释放对应的内存空间。</p>
<p>例如一个key写入的value非常大，那么Redis在分配内存时就会比较耗时；同样的，当删除这个key时，释放内存也会比较耗时，这种类型的key我们一般称之为bigkey。</p>
<p>如何扫描bigkey？</p>
<p>Redis提供了扫描bigkey的命令，执行以下命令就可以扫描出来，一个实例中bigkey的分布情况，输出结果是以类型维度展示的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01</span></span><br><span class="line">...</span><br><span class="line">-------- summary -------</span><br><span class="line"></span><br><span class="line">Sampled 829675 keys in the keyspace!</span><br><span class="line">Total key length in bytes is 10059825 (avg len 12.13)</span><br><span class="line"></span><br><span class="line">Biggest string found &#x27;key:291880&#x27; has 10 bytes</span><br><span class="line">Biggest   list found &#x27;mylist:004&#x27; has 40 items</span><br><span class="line">Biggest    set found &#x27;myset:2386&#x27; has 38 members</span><br><span class="line">Biggest   hash found &#x27;myhash:3574&#x27; has 37 fields</span><br><span class="line">Biggest   zset found &#x27;myzset:2704&#x27; has 42 members</span><br><span class="line"></span><br><span class="line">36313 strings with 363130 bytes (04.38% of keys, avg size 10.00)</span><br><span class="line">787393 lists with 896540 items (94.90% of keys, avg size 1.14)</span><br><span class="line">1994 sets with 40052 members (00.24% of keys, avg size 20.09)</span><br><span class="line">1990 hashs with 39632 fields (00.24% of keys, avg size 19.92)</span><br><span class="line">1985 zsets with 39750 members (00.24% of keys, avg size 20.03)</span><br></pre></td></tr></table></figure>

<p>从输出结果可以清晰地看到，每种数据类型所占用的最大内存&#x2F;拥用最多元素的key是哪一个，以及每种数据类型在整个实例中的占比和平均大小&#x2F;元素数量。</p>
<p>这个命令的原理就是Redis在内部执行了SCAN命令，遍历了整个实例中所有的key，然后针对key的类型，分别执行STRLEN、LLEN、HLEN、SCARD、ZCARD命令，来获取string类型的长度、容器类型(List、Hash、Set、ZSet)的元素个数。</p>
<p>当执行这个命令时，需要注意两个问题：</p>
<ul>
<li>对线上实例进行bigkey扫描时，Redis的OPS会突增，为了降低扫描过程中对Redis的影响，最好控制下扫描频率，指定-i参数即可，它表示扫描过程中每次扫描后休息的时间间隔，单位是秒。</li>
<li>扫描结果中，对于容器类型(List、Hash、Set、ZSet)的key，只能扫描出元素最多的key。但一个key的元素多，不一定表示占用内存也多，还需要根据业务情况，进一步评估内存占用情况。</li>
</ul>
<p>如何解决？</p>
<p>针对bigkey导致延迟的问题，有两点可以优化：</p>
<ul>
<li>业务应用尽量避免写入bigkey。</li>
<li>如果使用的Redis是4.0以上版本，用UNLINK命令替代DEL，此命令可以把释放key内存的操作，放到后台线程中去执行，从而降低对Redis的影响。如果使用的Redis是6.0以上版本，可以开启lazy-free机制(lazyfree-lazy-user-del &#x3D; yes)，在执行DEL命令时，释放内存也会放到后线程中执行。</li>
</ul>
<p>但即便可以使用方案二，也不建议在实例中存入bigkey。因为bigkey在很多场景下，依旧会产生性能问题。例如bigkey在分片集群模式下，对于数据的迁移也会有性能影响，以及数据过期、数据淘汰、透明大页等都会受到bigkey的影响。</p>
<h3 id="集中过期"><a href="#集中过期" class="headerlink" title="集中过期"></a>集中过期</h3><p>如果你发现，平时在操作Redis时，并没有延迟很大的情况发生，但在某个时间点突然出现一波延时，其现象表现为：<strong>变慢的时间点很有规律，例如某个整点，或者每间隔一段时间就会发生一波延迟。</strong></p>
<p>如果出现这种情况，那么就需要排查一下业务代码中是否存在设置大量key集中过期的情况。如果有大量的key在某个固定时间点集中过期，在这个时间点访问Redis时，就有可能导致延时变大。</p>
<p>为何集中过期会导致Redis延迟变大？</p>
<p>这就需要了解Redis的过期策略是怎样的，Redis的过期数据采用被动过期+主动过期两种策略：</p>
<ul>
<li><strong>被动过期</strong>：只有当访问某个key时，才判断这个key是否已过期，如果已过期，则从实例中删除。</li>
<li><strong>主动过期</strong>：Redis内部维护了一个定时任务，默认每隔100ms(1秒10次)就会从全局的过期哈希表中随机取出20个key，然后删除其中过期的key，如果过期key的比例超过了25%，则继续重复此过程，直到过期key的比例下降到25%以下，或者这次任务的执行耗时超过了25ms，才会退出循环。</li>
</ul>
<p><strong>这个主动过期key的定时任务，是在Redis主线程中执行的</strong>。也就是说如果在执行主动过期的过程中，出现了需要大量删除过期key的情况，那么此时应用程序在访问Redis时，必须要等待这个过期任务执行结束，Redis才可以响应这个客户端的请求。此时就会出现应用访问Redis延时变大。</p>
<p>如果此时需要过期删除的是一个bigkey，那么这个耗时会更久。而且，<strong>这个操作延迟的命令并不会记录在慢日志中</strong>。所以此时你会看到慢日志中没有操作耗时的命令，但我们的应用程序却感知到了延迟变大，其实时间都花费在了删除过期key上，这种情况需要尤为注意。</p>
<img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681422.jpg" class="" width="16113834681422">

<p>如何排查？</p>
<p>1）你需要检查你的业务代码，是否存在集中过期key的逻辑。</p>
<p>一般集中过期使用的是expireat&#x2F;pexpireat命令，你需要在代码中搜索这个关键字。</p>
<p>2）通过运维手段及时发现问题</p>
<p>运维层面，你需要把Redis的各项运行状态数据监控起来，在Redis上执行INFO命令就可以拿到这个实例所有的运行状态数据。在这里我们需要重点关注expired_keys这一项，它代表整个实例到目前为止，累计删除过期key的数量。当这个指标在很短时间内出现了突增，需要及时报警出来，然后与业务应用报慢的时间点进行对比分析，确认时间是否一致，如果一致，则可以确认确实是因为集中过期key导致的延迟变大。</p>
<p>如何解决？</p>
<p>排查代码后，如果确实存在集中过期key的逻辑存在，但这种逻辑又是业务所必须的，那此时如何优化，同时又不对Redis产生性能影响，一般有两种方案来规避这个问题：</p>
<ul>
<li><p>集中过期key增加一个随机过期时间，把集中过期的时间打散，降低Redis清理过期key的压力。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在过期时间点之后的5分钟内随机过期掉</span><br><span class="line">redis.expireat(key, expire_time + random(300))</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你使用的的Redis是4.0以上的版本，可以开启lazy-free机制，当删除过期key时，把释放内存的操作放到后台线程中执行，避免阻塞主线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 释放过期key的内存，放到后台线程执行</span><br><span class="line">lazyfree-lazy-expire yes</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实例内存达到上限"><a href="#实例内存达到上限" class="headerlink" title="实例内存达到上限"></a>实例内存达到上限</h3><p>如果你的Redis实例设置了内存上限maxmemory，那么也可能导致Redis变慢。</p>
<p>当我们把Redis当做纯缓存使用时，通常会给这个实例设置一个内存上限maxmemory，然后设置一个数据淘汰策略。而当实例的内存达到了maxmemory后，你可能会发现，在此之后每次写入新数据，操作延迟变大了。</p>
<p>为什么延迟变大？</p>
<p>原因在于，当Redis内存达到maxmemory后，每次写入新的数据之前，Redis必须先从实例中踢出一部分数据，让整个实例的内存维持在maxmemory之下，然后才能把新数据写进来。</p>
<p>这个踢出旧数据的逻辑也是需要消耗时间的，而具体耗时的长短，要取决于你配置的淘汰策略：</p>
<ul>
<li>allkeys-lru：不管key是否设置了过期，淘汰最近最少访问的key</li>
<li>volatile-lru：只淘汰最近最少访问、并设置了过期时间的key</li>
<li>allkeys-random：不管key是否设置了过期，随机淘汰key</li>
<li>volatile-random: 只随机淘汰设置了过期时间的key</li>
<li>volatile-ttl: 不管key是否设置了过期，淘汰即将过期的key</li>
<li>noeviction: 不淘汰任何key，实例内存达到maxmemory后，再写入新数据直接返回错误</li>
<li>allkeys-lfu: 不管key是否设置了过期，淘汰访问频率最低的key（4.0+版本支持）</li>
<li>volatile-lfu: 只淘汰访问频率最低、并设置了过期时间key（4.0+版本支持）</li>
</ul>
<p>具体使用哪种策略，我们需要根据具体的业务场景来配置。</p>
<p>一般最常用的是allkeys-lru和volatile-lru淘汰策略，它们的处理逻辑是，每次从实例中随机取出一批key（这个数量可配置），然后淘汰一个最少访问的key，之后把剩下的key暂存到一个池子中，继续随机取一批key，并与之前池子中的key比较，再淘汰一个最少访问的key。以此往复，直到实例内存降到maxmemory之下。</p>
<p>需要注意的是，Redis的淘汰数据的逻辑与删除过期key的逻辑一样，<strong>也是在命令真正执行之前执行的</strong>，也就是说它也会增加我们操作Redis的延迟，而且，写OPS越高，延迟也会越明显。</p>
<p>另外，如果此时你的Redis实例中还存储了bigkey，那么在<strong>淘汰删除bigkey释放内存时，也会耗时比较久</strong>。</p>
<img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681427.jpg" class="">

<p>bigkey的危害到处都是，所以尽量不存储bigkey。</p>
<p>如何解决？</p>
<p>四个优化建议：</p>
<ul>
<li>避免存储bigkey，降低释放内存的耗时</li>
<li>淘汰策略改为随机淘汰，随机淘汰比LRU要快很多(视业务情况调整)</li>
<li>拆分实例，把淘汰key的压力分摊到多个实例上</li>
<li>如果使用的是Redis 4.0以上版本，开启lazy-free机制，把淘汰key释放内存的操作放到后台线程中执行(配置lazyfree-lazy-eviction&#x3D;yes)</li>
</ul>
<h3 id="fork耗时严重"><a href="#fork耗时严重" class="headerlink" title="fork耗时严重"></a>fork耗时严重</h3><p>为了保证Redis数据的安全性，我们可能会开启后台定时RDB和AOF rewrite功能。</p>
<p>但如果你发现，<strong>操作Redis延迟变大，都发生在Redis后台RDB和AOF rewrite期间</strong>，那你就需要排查，在这期间有可能导致变量的情况。</p>
<p>当Redis开启了后台RDB和AOF rewrite后，在执行时，它们都需要主进程创建出一个子进程进行数据的持久化。</p>
<p>主进程创建子进程，会调用操作系统提供的fork函数。</p>
<p>而fork在执行过程中，<strong>主进程需要拷贝自己的内存页表给子进程</strong>，如果这个实例很大，那么这个拷贝的过程也会比较耗时。而且这个fork过程会消耗大量的CPU资源，在完成fork之前，整个Redis实例会被阻塞住，无法处理任何客户端请求。</p>
<p>如果此时你的CPU资源本来就很紧张，那么fork的耗时会更长，甚至达到秒级，这会严重影响Redis的性能。</p>
<p>你可以在Redis上执行INFO命令，查看latest_fork_usec项，单位微稍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 上一次fork耗时，单位微秒</span><br><span class="line">latest_fork_usec:59477</span><br></pre></td></tr></table></figure>

<p>这个时间就是主进程在fork子进程期间，整个实例阻塞无法处理客户端请求的时间。</p>
<p>如果你发现这个耗时很久，就要警惕起来了，这意味着在这期间，你的整个Redis实例都处于不可用的状态。</p>
<p>除了数据持久化会生成RDB之外，当主从节点第一次建立数据同步时，主节点也创建子进程生成RDB，然后发给从节点进行一次全量同步，所以，这个过程也会对Redis产生性能影响。</p>
<img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681431.jpg" class="">

<p>如何解决？</p>
<p>要想避免这种情况，你可以采取以下方案进行优化：</p>
<ul>
<li>控制Redis实例的内存：尽量在10G以下，执行fork的耗时与实例大小有关，实例越大，耗时越久</li>
<li>合理配置数据持久化策略：在slave节点执行RDB备份，推荐在低峰期执行，而对于丢失数据不敏感的业务(例如把Redis当做纯缓存使用)，可以关闭AOF和AOF rewrite</li>
<li>Redis实例不要部署在虚拟机上：fork的耗时也与系统有关，虚拟机比物理机耗时更久</li>
<li>降低主从库全量同步的概率：适当调大repl-backlog-size参数，避免主从全量同步</li>
</ul>
<h3 id="开启内存大页"><a href="#开启内存大页" class="headerlink" title="开启内存大页"></a>开启内存大页</h3><p>子进程RDB和AOF rewrite期间，除了fork耗时导致的延迟变大之外，还有一个方面也会导致性能问题，这就是操作系统是否开启了内存大页机制。</p>
<p>什么是内存大页？</p>
<p>我们都知道，应用程序向操作系统申请内存时，是按内存页进行申请的，而常规的内存页大小是4KB。</p>
<p>Linux内核从2.6.38开始，支持了内存大页机制，该机制允许应用程序以2MB大小为单位，向操作系统申请内存。</p>
<p>应用程序每次向操作系统申请的内存单位变大了，但这也意味着申请内存的耗时变长。</p>
<p>这对Redis会有什么影响？</p>
<p>当Redis在执行后台RDB和AOF rewrite时，采用fork子进程的方式来处理。但主进程fork子进程后，此时的<strong>主进程依旧是可以接收写请求的</strong>，而进来的写请求，会采用Copy On Write(写时复制)的方式操作内存数据。</p>
<p>也就是说，主进程一旦有数据需要修改，Redis并不会直接修改现有内存中的数据，而是<strong>先将这块内存数据拷贝出来，再修改这块新内存的数据</strong>，这就是所谓的<strong>写时复制</strong>。可以理解成谁需要发生写操作，谁就需要先拷贝，再修改。</p>
<p>这样做的好处是，父进程有任何写操作，并不会影响子进程的数据持久化(子进程只持久化fork这一瞬间整个实例中的所有数据即可，不关心新的数据变更，因为子进程只需要一份内存快照，然后持久化到磁盘上)。</p>
<p>但是请注意，主进程在拷贝内存数据时，这个阶段就涉及到新内存的申请，如果此时操作系统开启了内存大页，那么在此期间，客户端即便只修改10B的数据，<strong>Redis在申请内存时也会以2MB为单位向操作系统申请，申请内存的耗时变长，进而导致每个写请求的延迟增加，影响到Redis性能</strong>。</p>
<p>同样地，如果这个写请求操作的是一个bigkey，那么主进程在拷贝这个bigkey内存块时，一次申请的内存会更大，时间也会更久。可见，bigkey在这里又一次影响到了性能。</p>
<img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681437.jpg" class="">

<p>如何解决？</p>
<p>很简单，你只需要关闭内存大页机制就可以了。</p>
<p>首先，你需要查看Redis机器是否开启了内存大页：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/kernel/mm/transparent_hugepage/enabled</span></span><br><span class="line">[always] madvise never</span><br></pre></td></tr></table></figure>

<p>如果输出选项是always，就表示目前开启了内存大页机制，我们需要关闭它：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span></span><br></pre></td></tr></table></figure>

<p>其实，操作系统提供的内存大页机制，其优势是，可以在一定程度上降低应用程序申请内存的次数。</p>
<p>但是对于Redis这种对性能和延迟极其敏感的数据库来说，我们希望Redis在每次申请内存时，耗时尽量短，所以不建议在Redis机器上开启这个机制。</p>
<h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>前面我们分析了RDB和AOF rewrite对Redis性能的影响，主要关注点在fork上。</p>
<p>其实，关于数据持久化方面，还有影响Redis性能的因素。如果你的AOF配置不合理，还是有可能会导致性能问题。</p>
<p>当Redis开启AOF后，其工作原理如下：</p>
<ul>
<li>Redis执行写命令后，把这个命令写入到AOF文件内存中(write系统调用)</li>
<li>Redis根据配置的AOF刷盘策略，把AOF内存数据刷到磁盘上(fsync系统调用)</li>
</ul>
<p>为了保证AOF文件数据的安全性，Redis提供了3种刷盘机制：</p>
<ul>
<li><p>appendfsync always</p>
<p>主线程每次执行写操作后立即刷盘，此方案会占用比较大的磁盘IO资源，但数据安全性最高。</p>
</li>
<li><p>appendfsync no</p>
<p>主线程每次写操作只写内存就返回，内存数据什么时候刷到磁盘，交由操作系统决定，此方案对性能影响最小，但数据安全性也最低，Redis宕机时丢失的数据取决于操作系统刷盘时机。</p>
</li>
<li><p>appendfsync everysec</p>
<p>主线程每次写操作只写内存就返回，然后由后台线程每隔1s执行一次刷盘操作(触发fsync系统调用)，此方案对性能影响相对较小，但当Redis宕机时会丢失1s的数据。</p>
</li>
</ul>
<p>下面我们依次来分析，这几个机制对性能的影响。</p>
<p>如果你的AOF配置为appendfsync always，那么Redis每处理一次写操作，都会把这个命令写入到磁盘中才返回，整个过程都是主线程执行的，这个过程必须会加重Redis写负担。原因很简单，操作磁盘要比操作内存慢几百倍，采用这个配置会严重拖慢Redis的性能，因此不建议把AOF刷盘方式配置为always。</p>
<p>如果你的AOF配置为appendfsync no，那么Redis每次写操作只写内存，什么时候把内存中的数据刷到磁盘，交给操作系统决定，此方案对Redis的性能影响最小，但当Redis宕机时，会丢失一部分数据，为了数据的安全性，一般我们也不采取这种配置。如果你的Redis只用作纯缓存，对于数据丢失不敏感，采用这种方式也是可以的。</p>
<p>如果你的AOF配置为appendfsync everysec，那么Redis主线程写完内存就返回，具体的刷盘操作放到后台线程中执行，后台线程每隔1s把内存中的数据刷到磁盘中。</p>
<p>everysec这种方案既兼顾了性能，又尽可能的保证了数据安全，是不是觉得很完美？</p>
<p><strong>采用这种方案也要警惕一下，因为这种方案还是存在导致Redis延迟变大的情况发生，甚至会阻塞整个Redis</strong>。</p>
<p>试想这样一种情况：当Redis后台线程在执行AOF文件刷盘时，如果此时磁盘的IO负载很高，那这个后台线程在执行刷盘操作(fsync系统调用)时就会被阻塞住。</p>
<p>此时的主线程依旧会接收写请求，紧接着，主线程又需要把数据写到文件内存中(write系统调用)，但此时的后台子线程由于磁盘负载过高，导致fsync发生阻塞，迟迟不能返回，那主线程在执行write系统调用时，也会被阻塞住，直到后台线程fsync执行完成后，主线程执行write才能成功返回。这个过程中，主线程依旧有阻塞的风险。</p>
<p>所以，尽管你的AOF配置为appendfsync everysec，也不能掉以轻心，要警惕磁盘压力过大导致的Redis有性能问题。</p>
<img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681440.jpg" class="">

<p>什么情况下会导致磁盘IO负载过大？以及如何解决这个问题？</p>
<p>主要有以下几种情况：</p>
<ul>
<li>子进程正在执行AOF rewrite，这个过程会占用大量的磁盘IO资源</li>
<li>有其他应用程序正在执行大量的写文件操作，也会占用磁盘IO资源</li>
</ul>
<p>第一种情况是Redis的AOF后台子线程刷盘操作，撞上了子进程AOF rewrite。</p>
<p>Redis提供了一个配置项，当子进程在AOF rewrite期间，可以让后台子线程不执行刷盘(不触发fsync系统调用)操作。</p>
<p>这相当于在AOF rewrite期间，临时把appendfsync设置为none，配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF rewrite期间，AOF后台子线程不进行刷盘操作</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相当于在这期间，临时把appendfsync设置为none</span></span><br><span class="line">no-appendfsync-on-rewrite yes</span><br></pre></td></tr></table></figure>

<p>当然，开启这个配置项，在AOF rewrite期间，如果实例发生宕机，那么此时会丢失更多的数据，性能和数据安全性需要权衡后进行选择。</p>
<p>如果占用磁盘资源的是其他应用程序，你需要定位到是哪个应用程序在大量写磁盘，然后把这个应用程序迁移到其他机器上执行就好了，避免对Redis产生影响。</p>
<p>当然，如果你对Redis的性能和数据安全性都有很高的要求，那么建议从<strong>硬件层面</strong>来优化，更换为SSD磁盘，提高磁盘的IO能力，保证AOF期间有充足的磁盘资源可以使用。</p>
<h3 id="绑定CPU"><a href="#绑定CPU" class="headerlink" title="绑定CPU"></a>绑定CPU</h3><p>很多时候，我们在部署服务时，为了提高服务性能，降低应用程序在多个CPU核心之间的上下文切换带来的性能损耗，通常采用的方案是进程绑定CPU的方式提高性能。</p>
<p>但在部署Redis时，如果你需要绑定CPU来提高其性能，我建议你仔细斟酌后再做操作。</p>
<p>为什么？</p>
<p>因为Redis在绑定CPU时，是有很多讲究的，如果你不了解Redis的运行原理，随意绑定CPU不仅不会提高性能，甚至有可能会带来相反的效果。</p>
<p>我们知道，一般现代的服务器会有多个CPU，而每个CPU又包含多个物理核心，每个物理核心又分为多个逻辑核心，每个物理核下的逻辑核共用L1&#x2F;L2 Cache。</p>
<p>而Redis Server除了主线程服务客户端请求之外，还有创建子进程、子线程。</p>
<p>其中子进程用于数据持久化，而子线程用于执行一些比较耗时的操作，例如异步释放fd、异步AOF刷盘、异步lazy-free等等。</p>
<p>如果你把Redis进程只绑定了一个CPU逻辑核心上，那么当Redis在进行数据持久化时，fork出的子进程会继承父进程的CPU使用偏好。</p>
<p><strong>而此时的子进程会消耗大量的CPU资源进行数据持久化(把实例数据全部扫描出来需要耗费CPU)，这就会导致子进程会与主进程发生CPU争抢，进而影响到主进程服务客户端请求，访问延迟变大</strong>。</p>
<p>如何解决？</p>
<p>如果你确实想要绑定CPU，可以优化的方案是，不要让Redis进程只绑定在一个CPU逻辑核上，而是绑定在多个逻辑核心上，而且，绑定的多个逻辑核心最好是同一个物理核心，这样它们还可以共用L1&#x2F;L2 Cache。</p>
<p>当然，即便我们把Redis绑定在多个逻辑核心上，只能在一定程度上缓解主进程、子进程、后台线程在CPU资源上的竞争。</p>
<p>因为这些子进程、子线程还是会在多个逻辑核心上进行切换，存在性能损耗。</p>
<p>再进一步，我们可以让主进程、子进程、后台线程分别绑定在固定的CPU核心上，不让它们来回切换，这样一来，他们各自使用的CPU资源互不影响。</p>
<p>Redis在6.0版本已经推出了这个功能，我们可以通过以下配置，对主进程、子进程、后台线程、后台RDB进程、AOF rewrite进程，绑定固定的CPU逻辑核心：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Redis Server和IO线程绑定至CPU核心0，2，4，6</span></span><br><span class="line">server_cpulist 0-7:2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台子线程绑定到CPU核心1，3</span></span><br><span class="line">bio_cpulist 1,3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台AOF rewrite进程绑定到CPU核心8，9，10，11</span></span><br><span class="line">aof_rewrite_cpulist 8-11</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台RDB进程绑定到CPU核心1，10，11</span></span><br><span class="line">bgsave_cpulist 1,10-1</span><br></pre></td></tr></table></figure>

<p>如果你使用的正好是Redis6.0版本，就可以通过以上配置，来进一步提高Redis性能。</p>
<p>一般来说，Redis的性能已经足够优秀，除非你对Redis的性能有更加严苛的要求，否则不建议你绑定CPU。</p>
<h3 id="使用Swap"><a href="#使用Swap" class="headerlink" title="使用Swap"></a>使用Swap</h3><p>如果你发现Redis突然变得非常慢，<strong>每次的操作耗时都达到了几面毫秒甚至秒级</strong>，那此时你就需要检查Redis是否使用到了Swap，在这种情况下Redis基本上已经无法提供高性能服务了。</p>
<p>什么是Swap？为什么使用Swap会导致Redis的性能下降？</p>
<p>操作系统为了缓解内存不足对应用程序的影响，允许把一部分内存中的数据换到磁盘上，以达到应用程序对内存使用的缓冲，这些内存数据被换到磁盘上的区域，就是Swap。</p>
<p>问题就在于，当内存中的数据被换到磁盘上后，Redis再访问这些数据时，就需要从磁盘上读取，访问磁盘的速度要比访问内存慢几百倍。</p>
<p><strong>尤其是针对Redis这种对性能要求极高、性能极其敏感的数据库来说，这种操作延迟是无法接受的</strong>。</p>
<p>此时，你需要检查Redis机器的内存使用情况，确认是否存在使用了Swap:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先找到Redis的进程ID</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -aux | grep redis-server</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Redis Swap使用情况</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/<span class="variable">$pid</span>/smaps | egrep <span class="string">&#x27;^(Swap|Size)&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Size:               1256 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:                  4 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:                132 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:              63488 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:                132 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:              65404 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">Size:            1921024 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这个结果会列出Redis进程的内存使用情况。</p>
<p>每一行Size表示Redis所用的一块内存大小，Size下面的Swap就表示这块Size大小的内存，有多少数据已经被换到磁盘上了，如果这两个值相等，说明这块内存的数据都已经完全被换到磁盘上了。</p>
<p>如果只是少量数据被换到磁盘上，例如每一块Swap占对应Size的比例很小，那影响并不是很大。<strong>如果是几百兆甚至上GB的内存被换到了磁盘上</strong>，那么你就需要警惕了，这种情况Redis的性能肯定会急剧下降。</p>
<p>如何解决？</p>
<p>此时的解决方案是：</p>
<ul>
<li><p>增加机器的内存，让Redis有足够的内存可以使用。</p>
</li>
<li><p>整理内存空间，释放出足够的内存供Redis使用，然后释放Redis的Swap，让Redis重新使用内存。</p>
</li>
</ul>
<p>释放Redis的Swap过程通常要重启实例，为了避免重启实例对业务的影响，一般会先进行主从切换，然后释放旧主节点的Swap，重启旧主节点实例，待从库数据同步完成后，再进行主从切换即可。</p>
<p>可见，当Redis使用到Swap后，此时的Redis性能基本达不到高性能的要求，所以需要提前预防。预防的办法是你需要对Redis机器的内存和Swap使用情况进行监控，在内存不足或使用到Swap时报警出来，及时处理。</p>
<h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><p>Redis的数据都存储在内存中，当我们的应用程序频繁修改Redis中的数据时，就有可能会导致Redis产生内存碎片。</p>
<p>内存碎片会降低Redis的内存使用率，我们可以通过INFO命令，得到这个实例的内存碎片率：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Memory</span><br><span class="line">used_memory:5709194824</span><br><span class="line">used_memory_human:5.32G</span><br><span class="line">used_memory_rss:8264855552</span><br><span class="line">used_memory_rss_human:7.70G</span><br><span class="line">...</span><br><span class="line">mem_fragmentation_ratio:1.45</span><br></pre></td></tr></table></figure>

<p>mem_fragmentation_ratio &#x3D; used_memory_rss&#x2F;used_memory</p>
<p>其中used_memory表示Redis存储数据的内存大小，而used_memory_rss表示操作系统实际分配给Redis进程的大小。</p>
<p>如果mem_fragmentation_ratio &gt; 1.5，说明内存碎片率已经超过了50%，这时我们就需要采取一此措施来降低内存碎片了。</p>
<p>如何解决？</p>
<p>解决的方案一般有：</p>
<ul>
<li>如果你使用的是Redis 4.0以下的版本，只能通过重启实例来解决。</li>
<li>如你使用的是Redis 4.0以上版本，它正好提供了自动碎片整理的功能，可以通过配置开启碎片自动整理。</li>
</ul>
<p><strong>但是，开启内存碎片整理，它也有可能会导致Redis性能下降</strong>。</p>
<p>原因在于，Redis的碎片整理工作也是主进程中执行的，当其进行碎片整理时，必然会消耗CPU资源，产生更多的耗时，从而影响到客户端的请求。</p>
<p>所以，当你需要开启这个功能时，最好提前测试评估它对Redis的影响。</p>
<p>Redis碎片整理的参数配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启自动内存碎片整理(总开关)</span></span><br><span class="line">activedefrag yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存使用100MB以下，不进行碎片整理</span></span><br><span class="line">active-defrag-ignore-bytes 100mb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存碎片率超过10%，开始碎片整理</span></span><br><span class="line">active-defrag-threshold-lower 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存碎片率超过100%，尽最大努力碎片整理</span></span><br><span class="line">active-defrag-threshold-upper 100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存碎片整理占用CPU资源最小百分比</span></span><br><span class="line">active-defrag-cycle-min 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内存碎片整理占用CPU资源最大百分比</span></span><br><span class="line">active-defrag-cycle-max 25</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">碎片整理期间，对于List/Set/Hash/ZSet类型元素一次Scan的数量</span></span><br><span class="line">active-defrag-mzx-scan-fields 1000</span><br></pre></td></tr></table></figure>

<p>你需要结合Redis机器的负载情况，以及应用程序可接受的延迟范围进行评估，合理调整碎片整理的参数，尽可能降低碎片整理期间对Redis的影响。</p>
<h3 id="网络带宽过载"><a href="#网络带宽过载" class="headerlink" title="网络带宽过载"></a>网络带宽过载</h3><p>如果以上产生性能问题的场景，你都规避掉了，而且Redis也稳定运行了很长时间，但在某个时间点之后开始，操作Redis突然开始变慢了，而且一直持续下去，这种情况又是什么原因导致？</p>
<p>此时你需要排查一下Redis机器的网络带宽是否过载，是否存在某个实例把整个机器的网络带宽占满的情况。</p>
<p>网络带宽过载的情况下，服务器在TCP层和网络层就会出现数据包发送延迟、丢包等情况。</p>
<p>Redis的高性能，除了操作内存之外，就在于网络IO了，如果网络IO存在瓶颈，那么也会严重影响Redis的性能。</p>
<p>如果确实出现这种情况下，你需要及时确认占满网络带宽Redis实例，如果属于正常的业务访问，那就需要及时扩容或迁多实例了，避免因为这个实例流量过大，影响这个机器的其他实例。</p>
<p>运维层面，你需要对Redis机器的各项指标增加监控，包括网络流量，在网络流量达到一定阈值时提前报警，及时确认和扩容。</p>
<h3 id="其他原因"><a href="#其他原因" class="headerlink" title="其他原因"></a>其他原因</h3><p>1）频繁短连接</p>
<p>你的业务应用，应该使用长连接操作Redis，避免频繁的短连接。</p>
<p>频繁的短连接会导致Redis大量时间耗费在连接的建立和释放上，TCP的三次握手和四次挥手同样也会增加访问延迟。</p>
<p>2）运维监控</p>
<p>要想提前预知Redis变慢的情况发生，必不可少的就是做好完善的监控。</p>
<p>监控其实就是对采集Redis的各项运行时指标，通常的做法是监控程序定时采集Redis的INFO信息，然后根据INFO信息中的状态数据做数据展示和报警。</p>
<p>这里提醒一下，在写一些监控脚本，或使用开源的监控组件时，也不以掉以轻心。</p>
<p>在写监控脚本访问Redis时，尽量采用长连接的方式采集状态信息，避免频繁短连接。同时，还要注意控制访问Redis的频率，避免影响到业务请求。</p>
<p>在使用一些开源的监控组件时，最好了解一下这些组件的实现原理，以及正确配置这些组件，防止出现监控组件发生Bug，导致短时大量操作Redis，影响Redis性能的情况发生。</p>
<p>3）其他程序争抢资源</p>
<p>最后需要提醒的是，你的Redis机器最好专机专用，只用来部署Redis实例，不要部署其他应用程序，尽量给Redis提供一个相对“安静”的环境，避免其它程序占用CPU、内存、磁盘资源，导致分配给Redis的资源不足而受到影响。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是在使用Redis过程中，常见的可能导致延迟、甚至阻塞的问题场景，以及如何快速定位和分析这些问题，并且针对性地提供了解决方案。</p>
<p>这时汇总成了思维导图，方便排查Redis性能问题时，快速分析和定位。</p>
<img src="/2025/03/20/Redis%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/16113834681446.png" class="">
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell基础</title>
    <url>/2025/02/25/Shell%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h2><h3 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h3><table>
<thead>
<tr>
<th>Shell类别</th>
<th>易学性</th>
<th>可移植性</th>
<th>编辑性</th>
<th>快捷性</th>
</tr>
</thead>
<tbody><tr>
<td>Bourne Shell（sh）</td>
<td>容易</td>
<td>好</td>
<td>较差</td>
<td>较差</td>
</tr>
<tr>
<td>Korn Shell（ksh）</td>
<td>较难</td>
<td>较好</td>
<td>好</td>
<td>较好</td>
</tr>
<tr>
<td>Bourne Again（Bash）</td>
<td>难</td>
<td>较好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>POSIX Shell（psh）</td>
<td>较难</td>
<td>好</td>
<td>好</td>
<td>较好</td>
</tr>
<tr>
<td>C Shell（csh）</td>
<td>较难</td>
<td>差</td>
<td>较好</td>
<td>较好</td>
</tr>
<tr>
<td>TC Shell（tcsh）</td>
<td>难</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
</tbody></table>
<p>Shell的两种主语法类型有Bourne和C，这两种语法彼此不兼容。Bourne家族主要包括sh、ksh、Bash、psh、zsh；C家族主要包括：csh、tcsh（Bash和zsh在不同程度上支持csh的语法）。</p>
<p>可以通过&#x2F;etc&#x2F;shells文件来查询Linux支持的Shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/shells</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/rbash</span><br><span class="line">/usr/bin/dash</span><br><span class="line">/usr/bin/sh</span><br></pre></td></tr></table></figure>



<h3 id="Shell脚本的执行方式"><a href="#Shell脚本的执行方式" class="headerlink" title="Shell脚本的执行方式"></a>Shell脚本的执行方式</h3><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo [选项] [输出内容]</span><br><span class="line">选项：</span><br><span class="line">  -e：    支持反斜线控制的字符转换（如下表）</span><br><span class="line">  -n：    取消输出后行末的换行符号(就是内容输出后不换行)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;Mr. Ben is the most honest man!&quot;</span><br><span class="line">Mr. Ben is the most honest man!</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo -n &quot;Mr. Ben is the most honest man!&quot;</span><br><span class="line">Mr. Ben is the most honest man![root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>在echo命令中如果使用了”-e”选项，则可以支持控制字符。</p>
<table>
<thead>
<tr>
<th>控制字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\\</td>
<td>输出\本身</td>
</tr>
<tr>
<td>\a</td>
<td>输出警告音</td>
</tr>
<tr>
<td>\b</td>
<td>退格键，也就是向左删除键</td>
</tr>
<tr>
<td>\c</td>
<td>取消输出行末的换行符。和“-n”选项一致</td>
</tr>
<tr>
<td>\e</td>
<td>ESCAPE键</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车键</td>
</tr>
<tr>
<td>\t</td>
<td>制表符，也就是Tab键</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\0nnn</td>
<td>按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数</td>
</tr>
<tr>
<td>\xhh</td>
<td>按照十六进制ASCII码表输出字符。其中hh是两位十六进制数</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo -e &quot;\\ \a&quot;</span><br><span class="line">\</span><br><span class="line"># 这个输出会输出\，同时会在系统音响中输出一声提示音</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo -e &quot;ab\bc&quot;</span><br><span class="line">ac</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo -e &quot;a\tb\tc\nd\te\tf&quot;</span><br><span class="line">a    b    c</span><br><span class="line">d    e    f</span><br><span class="line"></span><br><span class="line"># 八进制输出</span><br><span class="line">[root@localhost ~]# echo -e &quot;\0141\t\0142\t\0143\n\0144\t\0145\t\0146&quot;</span><br><span class="line">a    b    c</span><br><span class="line">d    e    f</span><br><span class="line"></span><br><span class="line"># 十六进制</span><br><span class="line">[root@localhost ~]# echo -e &quot;\x61\t\x62\t\x63\n\x64\t\x65\t\x66&quot;</span><br><span class="line">a    b    c</span><br><span class="line">d    e    f</span><br><span class="line"></span><br><span class="line"># 按颜色输出</span><br><span class="line">[root@localhost ~]# echo -e &quot;\e[1;31m    abcd \e[0m&quot;</span><br><span class="line">    abcd</span><br></pre></td></tr></table></figure>

<p>按颜色输出这个命令，“\e[1”是标准格式，代表颜色输出开始，”\e[0m”代表颜色输出结束，31m定义字体颜色是红色。echo能够识别的颜色：</p>
<ul>
<li>30m：黑色</li>
<li>31m：红色</li>
<li>32m：绿色</li>
<li>33m：黄色</li>
<li>34m：蓝色</li>
<li>35m：洋红</li>
<li>36m：青色</li>
<li>37m：白色</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo -e &quot;\e[1;42m abcd \e[0m&quot;</span><br></pre></td></tr></table></figure>

<p>这条命令会给abcd加一个绿色的背景。echo可以使用的背景颜色如下：</p>
<ul>
<li>40m：黑色</li>
<li>41m：红色</li>
<li>42m：绿色</li>
<li>43m：黄色</li>
<li>44m：蓝色</li>
<li>45m：洋红</li>
<li>46m：青色</li>
<li>47m：白色</li>
</ul>
<h4 id="Shell脚本的执行"><a href="#Shell脚本的执行" class="headerlink" title="Shell脚本的执行"></a>Shell脚本的执行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The first program</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 326525276@qq.com）</span></span><br><span class="line"></span><br><span class="line">echo -e &quot;Mr. Ben is the most honest man! &quot;</span><br></pre></td></tr></table></figure>

<p>在Linux中脚本的执行主要有两种方法：</p>
<ul>
<li><p>赋予执行权限，直接运行（推荐）</p>
<p>这种方法是最常用的Shell脚本运行方法，也最为直接简单。运行时可以使用绝对路径，也可以使用相对路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予执行权限</span></span><br><span class="line">[root@localhost sh]# chmod +x hello.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绝对路径执行</span></span><br><span class="line">[root@localhost sh]# /root/sh/hello.sh</span><br><span class="line">Mr. Ben is the most honest man!</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相对路径执行</span></span><br><span class="line">[root@localhost sh]# ./hello.sh</span><br><span class="line">Mr. Ben is the most honest man!</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Bash调用执行脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost sh]# bash hello.sh</span><br><span class="line">Mr. Ben is the most honest man!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bash的基本功能"><a href="#Bash的基本功能" class="headerlink" title="Bash的基本功能"></a>Bash的基本功能</h2><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# history [选项] [历史命令保存文件]</span><br><span class="line">选项：</span><br><span class="line">  -c：    清空历史命令</span><br><span class="line">  -w：    把缓存中的历史命令写入历史命令保存文件。如果不手工指定历史命令保存文件，则放入默认历史命令保存文件~/.bash_history中</span><br></pre></td></tr></table></figure>

<p>history命令查看的历史命令和<del>&#x2F;.bash_history文件中保存的历史命令是不同的。那是因为当前登录操作的命令并没有直接写入</del>&#x2F;.bash_history文件，而是保存在缓存当中的。需要等当前用户注销之后，缓存中的命令才会写入<del>&#x2F;.bash_history文件。如果需要把内存中的命令直接写入</del>&#x2F;.bash_history文件，而不等用户注销时再写入，就需要使用”-w”选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把缓存中的历史命令直接写入~/.bash_history</span><br><span class="line">[root@localhost ~]# history -w</span><br><span class="line"></span><br><span class="line"># 清空历史命令</span><br><span class="line">[root@localhost ~]# history -c</span><br></pre></td></tr></table></figure>

<h3 id="历史命令的调用"><a href="#历史命令的调用" class="headerlink" title="历史命令的调用"></a>历史命令的调用</h3><p>如果想要使用原先的历史命令有这样几种方法：</p>
<ul>
<li>使用上、下箭头调用以前的历史命令</li>
<li>使用“!n”重复执行第n条历史命令</li>
<li>使用”!!”重复执行上一条命令</li>
<li>使用”!字串”重复执行最后一条以该字串开头的命令</li>
<li>使用”!$”重复上一条命令的最后一个参数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用最后一条以<span class="built_in">cat</span>开头的命令</span></span><br><span class="line">[root@localhost ~]# !cat</span><br></pre></td></tr></table></figure>

<h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>bash的标准输入输出</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>键盘</td>
<td>&#x2F;dev&#x2F;stdin</td>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>显示器</td>
<td>&#x2F;dev&#x2F;stdout</td>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>显示器</td>
<td>&#x2F;dev&#x2F;stderr</td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody></table>
<p>输出重定向</p>
<ul>
<li><p>标准输出重定向：</p>
<ul>
<li>命令 &gt; 文件：以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中。</li>
<li>命令 &gt;&gt; 文件：以追加的方式，把命令的正确输出输出到指定的文件或设备当中。</li>
</ul>
</li>
<li><p>标准错误输出重定向：</p>
<ul>
<li>错误命令 2&gt;文件：以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。</li>
<li>错误命令 2&gt;&gt;文件：以追加的方式，把命令的错误输出输出到指定的文件或设备当中。</li>
</ul>
</li>
<li><p>正确输出和错误输出同时保存：</p>
<ul>
<li>命令 &gt; 文件 2&gt;&amp;1：以覆盖的方式，把正确输出和错误输出都保存在同一个文件当中。</li>
<li>命令 &gt;&gt; 文件 2&gt;&amp;1：以追加的方式，把正确输出和错误输出都保存在同一个文件当中。</li>
<li>命令 &amp;&gt;文件：以覆盖的方式，把正确输出和错误输出都保存在同一个文件当中。</li>
<li>命令 &amp;&gt;&gt;文件：以追加的方式，把正确输出和错误输出都保存在同一个文件当中。</li>
<li>命令&gt;&gt;文件1 2&gt;&gt;文件2：把正确的输出追加到文件1中，把错误的输出追加到文件2中。</li>
</ul>
</li>
</ul>
<p>输入重定向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# wc [选项] [文件名]</span><br><span class="line">选项：</span><br><span class="line">  -c    统计字节数</span><br><span class="line">  -w    统计单词数</span><br><span class="line">  -l    统计行数</span><br></pre></td></tr></table></figure>



<h3 id="多命令执行顺序"><a href="#多命令执行顺序" class="headerlink" title="多命令执行顺序"></a>多命令执行顺序</h3><table>
<thead>
<tr>
<th>多命令执行符</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>；</td>
<td>命令1 ; 命令2</td>
<td>多个命令顺序执行，命令之间没有任何逻辑联系</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>命令1 &amp;&amp; 命令2</td>
<td>1）当命令1正确执行($?&#x3D;0)，则命令2才会执行。2）当命令1执行不正确，则命令2不会执行。</td>
</tr>
<tr>
<td>||</td>
<td>命令1 || 命令2</td>
<td>1）当命令1执行不正确，则命令2才会执行。2）当命令1正确执行，则命令2不会执行。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls &amp;&amp; echo yes || echo no</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>a）行提取命令grep</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep [选项] &quot;搜索内容&quot; 文件名</span><br><span class="line">选项：</span><br><span class="line">  -A 数字：      列出符合条件的行，并列出后续的n行</span><br><span class="line">  -B 数字：      列出符合条件的行，并列出前面的n行</span><br><span class="line">  -c：          统计找到的符合条件的字符串的次数</span><br><span class="line">  -i：          忽略大小写</span><br><span class="line">  -n：          输出行号</span><br><span class="line">  -v：          反向查找</span><br><span class="line">  --color=auto  搜索出的关键字用颜色显示</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找用户信息文件/etc/passwd中，有多少可以登录的用户</span></span><br><span class="line">[root@localhost ~]# grep &quot;/bin/bash&quot; /etc/passwd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找包含有“root”的行，并列出后续的3行</span></span><br><span class="line">[root@localhost ~]# grep -A 3 &quot;root&quot; /etc/passwd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找可以登录的用户，并显示行号</span></span><br><span class="line">[root@localhost ~]# grep -n &quot;/bin/bash&quot; /etc/passwd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找不含有“/bin/bash”的行，其实就是列出所有的伪用户</span></span><br><span class="line">[root@localhost ~]# grep -v &quot;/bin/bash&quot; /etc/passwd</span><br></pre></td></tr></table></figure>



<p>b）find和grep的区别</p>
<p>find命令是在系统当中搜索符合条件的文件名，如果需要模糊查询，使用通配符进行匹配，搜索时文件名是完全匹配。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# touch abc</span><br><span class="line">[root@localhost ~]# touch abcd</span><br><span class="line">[root@localhost ~]# find . -name &quot;abc&quot;</span><br><span class="line">./abc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索文件名是abc的文件，只会找到abc文件，而不会找到文件abcd。虽然abcd文件名中包含abc，但是find是完全匹配，只能和要搜索的数据完全一样，才能找到</span></span><br></pre></td></tr></table></figure>

<p>**注意：**find命令是可以通过-regex选项识别正则表达式规则的，也就是说find命令可以按照正则表达式规则匹配，而正则表达式是模糊匹配。</p>
<p>grep命令是在文件当中搜索符合条件的字符串，如果需要模糊查询，使用正则表达式进行匹配，搜索时字符串是包含匹配。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo abc &gt; test</span><br><span class="line">[root@localhost ~]# echo abcd &gt;&gt; test</span><br><span class="line">[root@localhost ~]# grep &quot;abc&quot; test</span><br><span class="line">abc</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure>



<p>c）管道符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll -a /etc/ | more</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询下本地所有网络连接，提取包含ESTABLISHED(已建立连接)的行，就可以知道服务器上有多个已经成功连接的网络连接</span></span><br><span class="line">[root@localhost ~]# netstat -an | grep &quot;ESTABLISHED&quot;</span><br><span class="line">[root@localhost ~]# netstat -an | grep &quot;ESTABLISHED&quot; | wc -l</span><br></pre></td></tr></table></figure>



<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配一个任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或任意多个字符，也就是可以匹配任何内容</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号任意一个字符。例如[abc]代表一定匹配一个字符，a或b或c</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符，-代表一个范围。例如[a-z]代表匹配一个小写字母</td>
</tr>
<tr>
<td>[^]</td>
<td>逻辑非，表示匹配不是中括号内的一个字符。例如[^0-9]代表匹配一个不是数字的字符</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# touch abc</span><br><span class="line">[root@localhost ~]# touch abcd</span><br><span class="line">[root@localhost ~]# touch 012</span><br><span class="line">[root@localhost ~]# touch 0abc</span><br><span class="line">[root@localhost ~]# ls *</span><br><span class="line">012 0abc abc abcd</span><br><span class="line">[root@localhost ~]# ls ?abc</span><br><span class="line">0abc</span><br><span class="line">[root@localhost ~]# ls [0-9]*</span><br><span class="line">012 0abc</span><br><span class="line">[root@localhost ~]# ls [^0-9]*</span><br><span class="line">abc abcd</span><br></pre></td></tr></table></figure>



<h3 id="Bash中其他特殊符号"><a href="#Bash中其他特殊符号" class="headerlink" title="Bash中其他特殊符号"></a>Bash中其他特殊符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>‘’</td>
<td>单引号。在单引号中所有的特殊符号，如“$”和“~”都没有特殊含义</td>
</tr>
<tr>
<td>“”</td>
<td>双引号。在双引号中特殊符号都没有特殊含义，但是“$”、“~”和“\”是例外，拥有”调用变量的值”、“引用命令”和“转义符”的特殊含义。</td>
</tr>
<tr>
<td>&#96;&#96;</td>
<td>反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号不易读。</td>
</tr>
<tr>
<td>$()</td>
<td>和反引号作用一样，用来引用系统命令。</td>
</tr>
<tr>
<td>()</td>
<td>用于一串命令执行时，()中的命令会在子Shell中运行</td>
</tr>
<tr>
<td>{}</td>
<td>用于一串命令执行时，{}中的命令会在当前Shell中执行。也可以用于变量变形与替换</td>
</tr>
<tr>
<td>[]</td>
<td>用于变量的测试</td>
</tr>
<tr>
<td>#</td>
<td>在Shell脚本中，#开头的行代表注释</td>
</tr>
<tr>
<td>$</td>
<td>用于调用变量的值，</td>
</tr>
<tr>
<td>\</td>
<td>转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。</td>
</tr>
</tbody></table>
<p>a）单引号和双引号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量的值</span></span><br><span class="line">[root@localhost ~]# name=ben</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果输出时使用单引号，则<span class="variable">$name</span>原封不动输出</span></span><br><span class="line">[root@localhost ~]# echo &#x27;$name&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果输出时使用双引号，则会输出变量name的值</span></span><br><span class="line">[root@localhost ~]# echo &quot;$name&quot;</span><br><span class="line">ben</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反引号括起来的命令会正常执行</span></span><br><span class="line">[root@localhost ~]# echo `date`</span><br><span class="line">2025年 02月 25日 星期二 17:16:57 CST</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果反引号命令被单引号括起来，则这个命令不会执行</span></span><br><span class="line">[root@localhost ~]# echo &#x27;`date`&#x27;</span><br><span class="line">`date`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果反引号被双引号括起来，则这个命令会执行</span></span><br><span class="line">[root@localhost ~]# echo &quot;`date`&quot;</span><br><span class="line">2025年 02月 25日 星期二 17:19:24 CST</span><br></pre></td></tr></table></figure>

<p>b）反引号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果命令不用反引号包含，命令不会执行，而是直接输出</span></span><br><span class="line">[root@localhost ~]# echo ls</span><br><span class="line">ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只有用反引号包括命令，这个命令才会执行</span></span><br><span class="line">[root@localhost go]# echo `ls`</span><br><span class="line">bin pkg src</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$()作用和反引号一样</span></span><br><span class="line">[root@localhost ~]# echo $(date)</span><br><span class="line">2025年 02月 25日 星期二 17:28:03 CST</span><br></pre></td></tr></table></figure>

<p>c）小括号、中括号和大括号</p>
<p>父Shell和子Shell。在Bashk中，是可以调用新的Shell的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# bash</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>通过pstree命令查看下进程数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pstree</span><br><span class="line">systemd————ModemManager————3*[&#123;ModemManager&#125;]</span><br><span class="line">         |——systemd————(sd-pam)</span><br><span class="line">                     |——gnome-terminal————bash————bash————pstree</span><br></pre></td></tr></table></figure>

<p>如果是用于一串命令的执行，那么小括号和大括号的主要区别在于：</p>
<ul>
<li><p>()执行一串命令时，需要重新开一个子shell进行执行</p>
</li>
<li><p>{}执行一串命令时，是在当前shell执行</p>
</li>
<li><p>()最后一个子命令可以不用分号</p>
</li>
<li><p>{}最后一个子命令要用分号</p>
</li>
<li><p>{}的第一个命令和左括号之间必须要有一个空格</p>
</li>
<li><p>()里的各命令不必和括号有空格</p>
</li>
<li><p>()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令</p>
</li>
<li><p>()和{}都是把一串的命令放在括号里面，并且命令之间用:号隔开</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">父shell中定义变量name</span></span><br><span class="line">[root@localhost ~]# name=ben</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">子shell中给name赋值</span></span><br><span class="line">[root@localhost ~]# (name=liming;echo $name)</span><br><span class="line">liming</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">父shell中name值还是ben</span></span><br><span class="line">[root@localhost ~]# echo $name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#123;&#125;是在当前shell执行，会修改name的值</span></span><br><span class="line">[root@localhost ~]# &#123; name=liming;echo $name;&#125;</span><br><span class="line">liming</span><br><span class="line">[root@localhost ~]# echo $name</span><br><span class="line">liming</span><br></pre></td></tr></table></figure>



<h2 id="Bash的变量和运算符"><a href="#Bash的变量和运算符" class="headerlink" title="Bash的变量和运算符"></a>Bash的变量和运算符</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>在定义变量时，有一些规则需要遵守：</p>
<ul>
<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。</li>
<li>在Bash中，变量的默认类型是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。</li>
<li>变量用等号连接值，等号左右两侧不能有空格。</li>
<li>变量的值如果有空格，需要使用单引号或双引号包括。其中双引号括起来的内容“$”、“\”和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符。</li>
<li>在变量的值中，可以使用“\”转义符。</li>
<li>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含“$变量名”或用${变量名}包含变量名。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# test=123</span><br><span class="line">[root@localhost ~]# test=&quot;$test&quot;456</span><br><span class="line">[root@localhost ~]# echo $test</span><br><span class="line">123456</span><br><span class="line">[root@localhost ~]# test=$&#123;test&#125;789</span><br><span class="line">[root@localhost ~]# echo $test</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>

<p>变量值的叠加可以使用两种格式：“$变量名”或${变量名}。</p>
<ul>
<li>如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# test=$(date)</span><br><span class="line">[root@localhost ~]# echo $test</span><br><span class="line">2025年 02月 25日 星期二 18:22:43 CST</span><br></pre></td></tr></table></figure>

<ul>
<li>环境变量名建议大写，便于区分。</li>
</ul>
<h4 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h4><ul>
<li><p>用户自定义变量</p>
<p>这种变量是最常见的变量，由用户自由定义变量名和变量的值。</p>
</li>
<li><p>环境变量</p>
<p>这种变量中主要保存的是和系统操作环境相关的数据，比如当前登录用户，用户的家目录，命令的提示符等。环境变量的变量名可以自由定义，但是一般对系统起作用的环境变量的变量名是系统预先设定好的。</p>
</li>
<li><p>位置参数变量</p>
<p>这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</p>
</li>
<li><p>预定义变量</p>
<p>是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</p>
</li>
</ul>
<h4 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h4><p>定义变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量name</span></span><br><span class="line">[root@localhost ~]# name=&quot;Ben&quot;</span><br></pre></td></tr></table></figure>



<p>调用变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出变量name的值</span></span><br><span class="line">[root@localhost ~]# ehco $name</span><br><span class="line">Ben</span><br></pre></td></tr></table></figure>



<p>查看变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# set [选项]</span><br><span class="line">选项：</span><br><span class="line">  -u：    如果设定此选项，调用未声明变量时会报错(默认无任何提示)</span><br><span class="line">  -x：    如果设定此选项，在命令执行之前，会把命令先输出一次</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有变量</span></span><br><span class="line">[root@localhost ~]# set</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# set -u</span><br><span class="line">[root@localhost ~]# echo $file</span><br><span class="line">bash: file: 未绑定的变量</span><br><span class="line">[root@localhost ~]# set -x</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">+ ls --color=auto</span><br><span class="line">_config.landscape.yml  _config.yml  db.json  deploy.sh  node_modules  package.json</span><br></pre></td></tr></table></figure>



<p>删除变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# unset name</span><br></pre></td></tr></table></figure>



<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>设置环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# export age=&quot;18&quot;</span><br></pre></td></tr></table></figure>



<p>查看环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# env | grep age</span><br></pre></td></tr></table></figure>

<p>set命令可以查看所有变量，而env命令只能查看环境变量。</p>
<p>删除环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# unset age</span><br></pre></td></tr></table></figure>



<p>系统默认环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# env</span><br><span class="line">SHELL=/bin/bash                                                # 当前的shell</span><br><span class="line">SESSION_MANAGER=local/ben-NBLK-WAX9X:@/tmp/.ICE-unix/4024,unix/ben-NBLK-WAX9X:/tmp/.ICE-unix/4024</span><br><span class="line">QT_ACCESSIBILITY=1</span><br><span class="line">COLORTERM=truecolor</span><br><span class="line">XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg</span><br><span class="line">XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session0</span><br><span class="line">XDG_MENU_PREFIX=gnome-</span><br><span class="line">GNOME_DESKTOP_SESSION_ID=this-is-deprecated</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">LANGUAGE=zh_CN:zh:en_US:en</span><br><span class="line">LC_ADDRESS=zh_CN.UTF-8</span><br><span class="line">GNOME_SHELL_SESSION_MODE=ubuntu</span><br><span class="line">LC_NAME=zh_CN.UTF-8</span><br><span class="line">SSH_AUTH_SOCK=/run/user/1000/keyring/ssh</span><br><span class="line">MEMORY_PRESSURE_WRITE=c29tZSAyMDAwMDAgMjAwMDAwMAA=</span><br><span class="line">HOMEBREW_PREFIX=/home/linuxbrew/.linuxbrew</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">DESKTOP_SESSION=ubuntu</span><br><span class="line">LC_MONETARY=zh_CN.UTF-8</span><br><span class="line">GTK_MODULES=gail:atk-bridge</span><br><span class="line">PWD=/home/ben/work/个人/githubPage</span><br><span class="line">LOGNAME=ben</span><br><span class="line">XDG_SESSION_DESKTOP=ubuntu</span><br><span class="line">XDG_SESSION_TYPE=x11</span><br><span class="line">MANPATH=/home/linuxbrew/.linuxbrew/share/man:</span><br><span class="line">GPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1</span><br><span class="line">SYSTEMD_EXEC_PID=4060</span><br><span class="line">XAUTHORITY=/home/ben/.Xauthority</span><br><span class="line">XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/ben</span><br><span class="line">GDM_LANG=zh_CN</span><br><span class="line">HOME=/home/ben                                                    # 当前登录用户的家目录</span><br><span class="line">IM_CONFIG_PHASE=1</span><br><span class="line">LC_PAPER=zh_CN.UTF-8</span><br><span class="line">LANG=zh_CN.UTF-8                                                  # 语系</span><br><span class="line">LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.crdownload=00;90:*.dpkg-dist=00;90:*.dpkg-new=00;90:*.dpkg-old=00;90:*.dpkg-tmp=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:*.swp=00;90:*.tmp=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:          # 定义颜色显示</span><br><span class="line">XDG_CURRENT_DESKTOP=ubuntu:GNOME</span><br><span class="line">MEMORY_PRESSURE_WATCH=/sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/session.slice/org.gnome.Shell@x11.service/memory.pressure</span><br><span class="line">VTE_VERSION=7600</span><br><span class="line">XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0</span><br><span class="line">GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/e46b9f29_027f_412a_aa8b_f9404dd3bc96</span><br><span class="line">QTWEBENGINE_DICTIONARIES_PATH=/usr/share/hunspell-bdic/</span><br><span class="line">CLUTTER_IM_MODULE=fcitx</span><br><span class="line">INFOPATH=/home/linuxbrew/.linuxbrew/share/info:</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line">LESSCLOSE=/usr/bin/lesspipe %s %s</span><br><span class="line">XDG_SESSION_CLASS=user</span><br><span class="line">TERM=xterm-256color                                                     # 终端环境</span><br><span class="line">LC_IDENTIFICATION=zh_CN.UTF-8</span><br><span class="line">LESSOPEN=| /usr/bin/lesspipe %s</span><br><span class="line">USER=ben                                                                # 当前登录的用户</span><br><span class="line">HOMEBREW_CELLAR=/home/linuxbrew/.linuxbrew/Cellar</span><br><span class="line">GNOME_TERMINAL_SERVICE=:1.10145</span><br><span class="line">DISPLAY=:0</span><br><span class="line">SHLVL=1</span><br><span class="line">GSM_SKIP_SSH_AGENT_WORKAROUND=true</span><br><span class="line">LC_TELEPHONE=zh_CN.UTF-8</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">HOMEBREW_REPOSITORY=/home/linuxbrew/.linuxbrew/Homebrew</span><br><span class="line">LC_MEASUREMENT=zh_CN.UTF-8</span><br><span class="line">XDG_RUNTIME_DIR=/run/user/1000</span><br><span class="line">DEBUGINFOD_URLS=https://debuginfod.ubuntu.com </span><br><span class="line">LC_TIME=zh_CN.UTF-8</span><br><span class="line">GTK3_MODULES=xapp-gtk3-module</span><br><span class="line">XDG_DATA_DIRS=/usr/share/ubuntu:/usr/share/gnome:/usr/local/share:/usr/share:/var/lib/snapd/desktop</span><br><span class="line">PATH=/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/ben/.local/bin:/home/ben/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin    # 系统查找命令的路径</span><br><span class="line">GDMSESSION=ubuntu</span><br><span class="line">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus</span><br><span class="line">LC_NUMERIC=zh_CN.UTF-8</span><br><span class="line">_=/usr/bin/env</span><br><span class="line">OLDPWD=/home/ben/work/个人/githubPage/themes/next</span><br></pre></td></tr></table></figure>



<h4 id="Bash操作接口相关的变量"><a href="#Bash操作接口相关的变量" class="headerlink" title="Bash操作接口相关的变量"></a>Bash操作接口相关的变量</h4><p>Bash操作接口相关的变量对我们的Bash操作终端起到了重要的作用。这些变量只能用set命令查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# set</span><br><span class="line">BASH=/usr/bin/bash                       # Bash的位置</span><br><span class="line">BASH_VERSINFO=([0]=&quot;5&quot; [1]=&quot;2&quot; [2]=&quot;21&quot; [3]=&quot;1&quot; [4]=&quot;release&quot; [5]=&quot;x86_64-pc-linux-gnu&quot;)    # Bash的版本</span><br><span class="line">BASH_VERSION=&#x27;5.2.21(1)-release&#x27;         # bash的版本</span><br><span class="line">HISTFILE=/home/ben/.bash_history         # 历史命令保存文件</span><br><span class="line">HISTFILESIZE=2000                        # 在文件当中记录的历史命令最大条数</span><br><span class="line">HISTSIZE=1000                            # 在缓存中记录的历史命令最大条数</span><br><span class="line">LANG=zh_CN.UTF-8                         # 语系环境</span><br><span class="line">MACHTYPE=x86_64-pc-linux-gnu             # 软件类型是i386兼容类型</span><br><span class="line">MAILCHECK=60                             # 每60s去扫描新邮件</span><br><span class="line">PPID=557258                              # 父shell的PID</span><br><span class="line">PS1=&#x27;\[\e]0;\u@\h: \w\a\]$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;                                              # 命令提示符</span><br><span class="line">PS2=&#x27;&gt; &#x27;                                 # 如果命令一行没有输入完成，第二行命令的提示符</span><br><span class="line">UID=1000                                 # 当前用户的UID</span><br></pre></td></tr></table></figure>



<h4 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h4><p>系统查找命令的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询PATH环境变量的值</span></span><br><span class="line">[root@localhost ~]# echo $PATH</span><br><span class="line">/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/ben/.local/bin:/home/ben/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin</span><br></pre></td></tr></table></figure>

<p>PATH变量的值是用“：”分割的路径，这些路径就是系统查找命令的路径。也就是说当我们输入了一个程序名，如果没有写入路径，系统就会到PATH变量定义的路径中去寻找是否可以执行的程序，如果找到则执行，否则会报“命令没有发现”的错误。</p>
<p>我们把自己的脚本拷贝到PATH变量定义的路径中，自己写的脚本也可以不输入路径而直接运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝hello.sh到/bin目录</span></span><br><span class="line">[root@localhost ~]# cp /root/sh/hello.sh /bin/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行hello.sh</span></span><br><span class="line">[root@localhost ~]# hello.sh</span><br><span class="line">Mr. Ben is the most honest man.</span><br></pre></td></tr></table></figure>

<p>我们也可以修改PATH变量的值，而不把程序脚本复制到&#x2F;bin&#x2F;目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在变量PATH的后面，加入/root/sh目录</span></span><br><span class="line">[root@localhost ~]# PATH=&quot;$PATH&quot;:/root/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询PATH的值</span></span><br><span class="line">[root@localhost ~]# echo $PATH</span><br><span class="line">/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/ben/.local/bin:/home/ben/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin:/root/sh</span><br></pre></td></tr></table></figure>

<p>这样定义的PATH变量只是临时生效，一旦重启或注销就会消失，如果想要永久生效，需要写入环境变量配置文件。</p>
<h4 id="PS1变量"><a href="#PS1变量" class="headerlink" title="PS1变量"></a>PS1变量</h4><p>命令提示符设置。</p>
<p>PS1是用来定义命令行的提示符的，可以安装我们自己的需求来定义自己喜欢的提示符。PS1可以支持以下这些选项：</p>
<ul>
<li>\d：显示日期，格式为”星期 月 日”</li>
<li>\H：显示完整的主机名，如默认主机名”localhost.localdomain”</li>
<li>\h：显示简写主机名。如默认主机名”localhost”</li>
<li>\t：显示24小时制时间，格式为”HH:MM:SS”</li>
<li>\T：显示12小时制时间，格式为”HH:MM:SS”</li>
<li>\A：显示24小时制时间，格式为“HH:MM”</li>
<li>@：显示12小时制时间，格式为”HH:MM am&#x2F;pm”</li>
<li>\u：显示当前用户名</li>
<li>\v：显示Bash的版本信息</li>
<li>\w：显示当前所在目录的完整名称</li>
<li>\W：显示当前所在目录的最后一个目录</li>
<li>\#：执行的第几个命令</li>
<li>\$：提示符。如果是root用户会显示提示符为“#”， 如果是普通用户会显示提示符为“$”</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo $PS1</span><br><span class="line">\[\e]0;\u@\h: \w\a\]$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$</span><br></pre></td></tr></table></figure>

<p>在PS1变量中，如果是可以解释的符号，如”\u”、“\h”等，则显示这个符号的作用，如果是不能解释的符号，如”@”或“空格”，则原符号输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改提示符</span><br><span class="line">[root@localhost ~]# PS1=&#x27;\[\u@\t \w\]\$&#x27;</span><br></pre></td></tr></table></figure>

<p>PS1变量的值要用单引号包含，否则设置不生效。PS1变量可以自由定制，不过说实话一个提示符已经使用习惯了，还是用默认的吧。</p>
<h4 id="LANG语系变量"><a href="#LANG语系变量" class="headerlink" title="LANG语系变量"></a>LANG语系变量</h4><p>LANG变量定义了Linux系统的主语系环境。这个变量的默认值是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo $LANG</span><br><span class="line">zh_CN.UTF-8</span><br></pre></td></tr></table></figure>

<p>这是因为Linux安装时，选择的是中文安装，所以默认的主语系变量是“zh_CN.UTF-8”。</p>
<p>那么Linux到底支持多少语系呢？可以使用以下命令查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# locale -a | more</span><br><span class="line">C</span><br><span class="line">C.utf8</span><br><span class="line">en_AG</span><br><span class="line">en_AG.utf8</span><br><span class="line">en_AU.utf8</span><br><span class="line">en_BW.utf8</span><br><span class="line">en_CA.utf8</span><br><span class="line">en_DK.utf8</span><br><span class="line">en_GB.utf8</span><br><span class="line">en_HK.utf8</span><br><span class="line">en_IE.utf8</span><br><span class="line">en_IL</span><br><span class="line">en_IL.utf8</span><br><span class="line">en_IN</span><br><span class="line">en_IN.utf8</span><br><span class="line">en_NG</span><br><span class="line">en_NG.utf8</span><br><span class="line">en_NZ.utf8</span><br><span class="line">en_PH.utf8</span><br><span class="line">en_SG.utf8</span><br><span class="line">en_US.utf8</span><br><span class="line">en_ZA.utf8</span><br><span class="line">en_ZM</span><br><span class="line">en_ZM.utf8</span><br><span class="line">en_ZW.utf8</span><br><span class="line">POSIX</span><br><span class="line">zh_CN.utf8</span><br><span class="line">zh_SG.utf8</span><br></pre></td></tr></table></figure>

<p>当前系统是什么语系呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# locale</span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">LANGUAGE=zh_CN:zh:en_US:en</span><br><span class="line">LC_CTYPE=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_NUMERIC=zh_CN.UTF-8</span><br><span class="line">LC_TIME=zh_CN.UTF-8</span><br><span class="line">LC_COLLATE=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_MONETARY=zh_CN.UTF-8</span><br><span class="line">LC_MESSAGES=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_PAPER=zh_CN.UTF-8</span><br><span class="line">LC_NAME=zh_CN.UTF-8</span><br><span class="line">LC_ADDRESS=zh_CN.UTF-8</span><br><span class="line">LC_TELEPHONE=zh_CN.UTF-8</span><br><span class="line">LC_MEASUREMENT=zh_CN.UTF-8</span><br><span class="line">LC_IDENTIFICATION=zh_CN.UTF-8</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<p>系统默认语系查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/sysconfig/i18n</span><br><span class="line">LANG=&quot;zh_CN.UTF-8&quot;</span><br></pre></td></tr></table></figure>

<p>默认语系是下次重启之后系统所使用的语系，而当前系统语系是当前系统使用的语系。如果系统重启，会从默认语系配置文件&#x2F;etc&#x2F;sysconfig&#x2F;i18n中读出语系，然后赋予变量LANG让这个语系生效。</p>
<p>关于Linux支持中文的问题。是不是只要定义了语系为中文语系，如zh_CN.UTF-8就可以正确显示中文呢？这个要分情况，如果我们在图形界面中，或者是使用远程连接工具(如secureCRT)，只要正确设置了语系，那么是可以正确显示中文的。当然远程工具也要配置正确的语系环境。如果是纯字符界面(本地终端tty1-tty6)是不能显示中文的，因为Linux的纯字符界面是不能显示中文这么复杂的编码的。如果非要在纯字符界面显示中文，那么只能安装中文插件，如zhcon等。</p>
<h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h4><table>
<thead>
<tr>
<th>位置参数变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$n</td>
<td>n为数字，$0代表命令本身，$1-9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}</td>
</tr>
<tr>
<td>$*</td>
<td>这个变量代表命令行中所有的参数，$*把所有的参数看成一个整本</td>
</tr>
<tr>
<td>$@</td>
<td>这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</td>
</tr>
<tr>
<td>$#</td>
<td>这个变量代表命令行中所有参数的个数</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author：Ben（E-mail：17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给num1变量赋值是第一个参数</span></span><br><span class="line">num1=$1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给num2变量赋值是第二个参数</span></span><br><span class="line">num2=$2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">求和</span></span><br><span class="line">sum=$(( $num1 + $num2 ))</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author：Ben（E-mail：17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印所有位置参数个数</span></span><br><span class="line">echo &quot;A total of $# parameters&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印所有位置参数值</span></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">    do</span><br><span class="line">        echo &quot;The parameters is: $i&quot;</span><br><span class="line">    done</span><br><span class="line">x=1</span><br><span class="line">for y in &quot;$@&quot;</span><br><span class="line">    do</span><br><span class="line">        echo &quot;The parameter$x is: $y&quot;</span><br><span class="line">        x=$(( $x + 1 ))</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>



<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><table>
<thead>
<tr>
<th>预定义变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$?</td>
<td>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0(具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确了。</td>
</tr>
<tr>
<td>$$</td>
<td>当前进程的进程号(PID)</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的进程号(PID)</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~/test$ls</span><br><span class="line">12  nginx-test  nginx-test.zip</span><br><span class="line">ben@ben-NBLK-WAX9X:~/test$echo $?</span><br><span class="line">0</span><br><span class="line">ben@ben-NBLK-WAX9X:~/test$ls install.log</span><br><span class="line">ls: 无法访问 &#x27;install.log&#x27;: 没有那个文件或目录</span><br><span class="line">ben@ben-NBLK-WAX9X:~/test$echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出当前进程的PID，这个PID就是这个脚本执行时，生成的进程的PID</span></span><br><span class="line">echo &quot;The current process is $$&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/root目录下查找hello.sh文件，&amp;是把命令放入后台执行</span></span><br><span class="line">find /root -name hello.sh &amp;</span><br><span class="line">echo &quot;The last on Daemon process is $!&quot;</span><br></pre></td></tr></table></figure>



<h4 id="接收键盘输入"><a href="#接收键盘输入" class="headerlink" title="接收键盘输入"></a>接收键盘输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# read [选项] [变量名]</span><br><span class="line">选项：</span><br><span class="line">  -p &quot;提示信息&quot;:    在等待read输入时，输出提示信息</span><br><span class="line">  -t 秒数:          read命令会一直等待用户输入，使用此选项可以指定等待时间</span><br><span class="line">  -n 字符数:        read命令只接受指定的字符数，就会执行</span><br><span class="line">  -s:              隐藏输入的数据，适用于机密信息的输入</span><br><span class="line">变量名：变量名可以自定义，如果不指定变量名，会把输入保存入默认变量REPLY。如果只提供了一个变量名，则整个输入行赋予该变量。如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -t 30 -p &quot;Please input your name: &quot; name</span><br><span class="line">echo &quot;Name is $name&quot;</span><br><span class="line"></span><br><span class="line">read -s -t 30 -p &quot;Please enter your age: &quot; age</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调整输出格式</span></span><br><span class="line">echo -e &quot;\n&quot;</span><br><span class="line">echo &quot;Age is $age&quot;</span><br><span class="line"></span><br><span class="line">read -n 1 -t 30 -p &quot;Please select your gender[M/F]: &quot; gender</span><br><span class="line">echo -e &quot;\n&quot;</span><br><span class="line">echo &quot;Sex is $gender&quot;</span><br></pre></td></tr></table></figure>



<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h4><p>如果需要进行数值运算，可以采用以下三种方法中的任意一种：</p>
<ul>
<li><p>使用declare声明变量类型</p>
<p>既然所有变量的默认类型是字符串型，那么只要把变量声明为整数型就可以了。使用declare命令就可以实现声明变量的类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# declare [+/-][选项] 变量名</span><br><span class="line">选项：</span><br><span class="line">  -：      给变量设定类型属性</span><br><span class="line">  +：      取消变量的类型属性</span><br><span class="line">  -a：     将变量声明为数组型</span><br><span class="line">  -i：     将变量声明为整数型(integer)</span><br><span class="line">  -r：     将变量声明为只读变量。注意，一旦设置为只读变量，既不能修改变量的值，也不能删除变量，甚至不能通过+r取消只读属性</span><br><span class="line">  -x：     将变量声明为环境变量</span><br><span class="line">  -p：     显示指定变量的被声明的类型</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=11</span><br><span class="line">ben@ben-NBLK-WAX9X:~$bb=22</span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -i cc=$aa+$bb</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $cc</span><br><span class="line">33</span><br></pre></td></tr></table></figure>



<p>【数组变量类型】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$name[0]=&quot;zhang san&quot;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$name[1]=&quot;li si&quot;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$name[2]=&quot;tong gang&quot;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $&#123;name&#125;</span><br><span class="line">zhang san</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $&#123;name[1]&#125;</span><br><span class="line">li si</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $&#123;name[*]&#125;</span><br><span class="line">zhang san li si tong gang</span><br></pre></td></tr></table></figure>

<p>数组的下标是从0开始的，在调用数组值时，需要使用${数组[下标]}的方式来读取。不过上面并没有把name变量声明为数组型，其实只要在定义变量时采用了“变量名[下标]”的格式，这个变量就会被系统认为是数组型了，不用强制声明。</p>
<p>环境变量</p>
<p>其实也可以使用declare命令把变量声明为环境变量，和export命令的作用是一样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# declare -x test=123</span><br></pre></td></tr></table></figure>



<p>【只读属性】</p>
<p>一旦给变量设定了只读属性，那么这个变量既不能修改变量的值，也不能删除变量，甚至不能使用“+r”选项取消只读属性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$declare -r test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量值不能修改</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$test=456</span><br><span class="line">bash: test: 只读变量</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量只读属性不能取消</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare +r test</span><br><span class="line">bash: declare: test: 只读变量</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量不能删除</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$unset test</span><br><span class="line">bash: unset: test: 无法取消设定：只读variable</span><br></pre></td></tr></table></figure>

<p>不过这个变量只是命令行声明的，所以只要重新登录或重启，这个变量就会消失。</p>
<p>【查询变量属性和取消变量属性】</p>
<p>变量属性的查询使用“-p”选项，变量属性的取消使用“+”选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询cc变量类型</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -p cc</span><br><span class="line">declare -i cc=&quot;33&quot;    # int</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询name变量类型</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -p name</span><br><span class="line">declare -a name=([0]=&quot;zhang san&quot; [1]=&quot;li si&quot; [2]=&quot;tong gang&quot;)    # 数组</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询<span class="built_in">test</span>变量类型</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -p test</span><br><span class="line">declare -rx test         # 只读+环境变量</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消<span class="built_in">test</span>变量环境变量属性</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare +x test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询<span class="built_in">test</span>变量类型</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -p test</span><br><span class="line">declare -r test             # 只读</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用expr或let数值运算工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=11</span><br><span class="line">ben@ben-NBLK-WAX9X:~$bb=22</span><br><span class="line">ben@ben-NBLK-WAX9X:~$dd=$(expr $aa + $bb)</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $dd</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<p>使用expr命令进行运算时，要注意“+”号左右两侧必须有空格，否则运算不执行。</p>
<p>至于let命令，和expr命令基本类似，都是Linux中的运算命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=11</span><br><span class="line">ben@ben-NBLK-WAX9X:~$bb=22</span><br><span class="line">ben@ben-NBLK-WAX9X:~$let ee=$aa+$bb</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $ee</span><br><span class="line">33</span><br><span class="line">ben@ben-NBLK-WAX9X:~$n=20</span><br><span class="line">ben@ben-NBLK-WAX9X:~$let n+=1</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $n</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>let命令对格式要求比expr命令宽松，所以推荐使用let命令进行数值运算。</p>
</li>
<li><p>使用“$((运算式))”或“$[运算式]”方式运算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=11</span><br><span class="line">ben@ben-NBLK-WAX9X:~$bb=22</span><br><span class="line">ben@ben-NBLK-WAX9X:~$ff=$(( $aa+$bb ))</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $ff</span><br><span class="line">33</span><br><span class="line">ben@ben-NBLK-WAX9X:~$gg=$[ $aa+$bb ]</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $gg</span><br><span class="line">33</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这三种数值运算方式，可以按照自己的习惯来进行使用，不过推荐使用“$((运算式))”的方式。</p>
<h4 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h4><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>13</td>
<td>-，+</td>
<td>单目负、单目正</td>
</tr>
<tr>
<td>12</td>
<td>!，~</td>
<td>逻辑非、按位取反或补码</td>
</tr>
<tr>
<td>11</td>
<td>*，&#x2F;，%</td>
<td>乘、除、取模</td>
</tr>
<tr>
<td>10</td>
<td>+，-</td>
<td>加，减</td>
</tr>
<tr>
<td>9</td>
<td>&lt;&lt;，&gt;&gt;</td>
<td>按位左移，按位右移</td>
</tr>
<tr>
<td>8</td>
<td>&lt;&#x3D;，&gt;&#x3D;，&lt;，&gt;</td>
<td>小于等于、大于等于、小于、大于</td>
</tr>
<tr>
<td>7</td>
<td>&#x3D;&#x3D;，!&#x3D;</td>
<td>等于、不等于</td>
</tr>
<tr>
<td>6</td>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>5</td>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>4</td>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>3</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>2</td>
<td>||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>1</td>
<td>&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;、&#x3D;，%&#x3D;，&amp;&#x3D;，^&#x3D;，|&#x3D;，&lt;&lt;&#x3D;，&gt;&gt;&#x3D;</td>
<td>赋值、运算且赋值</td>
</tr>
</tbody></table>
<p>运算符优先级表明在每个表达式或子表达式中哪一个运算对象首先被求值，数值越大优先级越高，具有较高优先级级别的运算符先于较低级别的运算符进行求值运算。</p>
<p>加减乘除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=$(( (11+3)*3/2 ))</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $aa</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>取模运算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$bb=$(( 14%3 ))</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $bb</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>逻辑与</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$cc=$(( 1 &amp; 0 ))</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $cc</span><br><span class="line">0</span><br></pre></td></tr></table></figure>



<h3 id="变量的测试与内容置换"><a href="#变量的测试与内容置换" class="headerlink" title="变量的测试与内容置换"></a>变量的测试与内容置换</h3><table>
<thead>
<tr>
<th>变量置换方式</th>
<th>变量y没有设置</th>
<th>变量y为空值</th>
<th>变量y设置值</th>
</tr>
</thead>
<tbody><tr>
<td>x&#x3D;${y-新值}</td>
<td>x&#x3D;新值</td>
<td>x为空</td>
<td>x&#x3D;$y</td>
</tr>
<tr>
<td>x&#x3D;${y:-新值}</td>
<td>x&#x3D;新值</td>
<td>x&#x3D;新值</td>
<td>x&#x3D;$y</td>
</tr>
<tr>
<td>x&#x3D;${y+新值}</td>
<td>x为空</td>
<td>x&#x3D;新值</td>
<td>x&#x3D;新值</td>
</tr>
<tr>
<td>x&#x3D;${y:+新值}</td>
<td>x为空</td>
<td>x为空</td>
<td>x&#x3D;新值</td>
</tr>
<tr>
<td>x&#x3D;${y&#x3D;新值}</td>
<td>x&#x3D;新值，y&#x3D;新值</td>
<td>x为空，y值不变</td>
<td>x&#x3D;$y，y值不变</td>
</tr>
<tr>
<td>x&#x3D;${y:&#x3D;新值}</td>
<td>x&#x3D;新值，y&#x3D;新值</td>
<td>x&#x3D;新值，y&#x3D;新值</td>
<td>x&#x3D;$y，y值不变</td>
</tr>
<tr>
<td>x&#x3D;${y?新值}</td>
<td>新值输出到标准错误输出(屏幕)</td>
<td>x为空</td>
<td>x&#x3D;$y</td>
</tr>
<tr>
<td>x&#x3D;${y:?新值}</td>
<td>新值输出到标准错误输出</td>
<td>新值输出到标准错误输出</td>
<td>x&#x3D;$y</td>
</tr>
</tbody></table>
<p>如果大括号内没有”:”，则变量y为空，还是没有设置，处理方法是不同的；如果大括号内有“:”，则变量y不论是为空，还是没有设置，处理方法是一样的。</p>
<p>如果大括号内是“-”或“+”，则在改变变量x值的时候，变量y是不改变的；如果大括号内是“&#x3D;”，则在改变变量x的同时，变量y的值也会改变。</p>
<p>如果大括号内是“?”，则当变量y不存在或为空时，会把“新值”当成报错输出到屏幕上。</p>
<p>变量y没有设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量y没有设置</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$unset y</span><br><span class="line">ben@ben-NBLK-WAX9X:~$x=$&#123;y-new&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量x等于新值</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $x</span><br><span class="line">new</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量y不存在</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $y</span><br><span class="line"></span><br><span class="line">ben@ben-NBLK-WAX9X:~$</span><br></pre></td></tr></table></figure>

<p>变量y为空</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量y为空</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$y=&quot;&quot;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$x=$&#123;y-new&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">则变量x为空</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $x</span><br><span class="line"></span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $y</span><br><span class="line"></span><br><span class="line">ben@ben-NBLK-WAX9X:~$</span><br></pre></td></tr></table></figure>

<p>变量y有值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$y=old</span><br><span class="line">ben@ben-NBLK-WAX9X:~$x=$&#123;y-new&#125;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $x</span><br><span class="line">old</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $y</span><br><span class="line">old</span><br><span class="line">ben@ben-NBLK-WAX9X:~$</span><br></pre></td></tr></table></figure>

<h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><h3 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# source 配置文件</span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# . 配置文件</span><br></pre></td></tr></table></figure>



<h3 id="环境变量配置文件-1"><a href="#环境变量配置文件-1" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h3><h4 id="登录时生效的环境变量配置文件"><a href="#登录时生效的环境变量配置文件" class="headerlink" title="登录时生效的环境变量配置文件"></a>登录时生效的环境变量配置文件</h4><p>在Linux系统登录时主要生效的环境变量配置文件有以下五个：</p>
<ul>
<li>&#x2F;etc&#x2F;profile</li>
<li>&#x2F;etc&#x2F;profile.d&#x2F;*.sh</li>
<li>~&#x2F;.bash_profile</li>
<li>~&#x2F;.bashrc</li>
<li>&#x2F;etc&#x2F;bashrc</li>
</ul>
<p>环境变量配置文件调用过程</p>
<ul>
<li><p>在用户登录过程先调用&#x2F;etc&#x2F;profile文件</p>
<p>在这个环境变量配置文件中会定义这些默认环境变量：</p>
<ul>
<li>USER变量：根据登录的用户，给这个变量赋值(就是让USER变量的值是当前用户)。</li>
<li>LOGNAME变量：根据USER变量的值，给这个变量赋值。</li>
<li>MAIL变量：根据登录的用户，定义用户的邮箱为&#x2F;var&#x2F;spool&#x2F;mail&#x2F;用户名。</li>
<li>PATH变量：根据登录用户的UID是否为0，判断PATH变量是否包含&#x2F;sbin、&#x2F;usr&#x2F;sbin和、&#x2F;usr&#x2F;local&#x2F;sbin这三个系统命令目录。</li>
<li>HOSTNAME变量：更改主机名，给这个变量赋值。</li>
<li>HISTSIZE变量：定义历史命令的保存条数。</li>
<li>umask：定义umask默认权限。注意&#x2F;etc&#x2F;profile文件中的umask权限是在“有用户登录过程(也就是输入了用户名和密码)”时才会生效。</li>
<li>调用&#x2F;etc&#x2F;profile.d&#x2F;*.sh文件，也就是调用&#x2F;etc&#x2F;profile.d&#x2F;目录下所有以.sh结尾的文件。</li>
</ul>
</li>
<li><p>由&#x2F;etc&#x2F;profile文件调用&#x2F;etc&#x2F;profile.d&#x2F;*.sh文件</p>
<p>这个目录中所有以.sh结尾的文件都会被&#x2F;etc&#x2F;profile文件调用，这里最常用的就是lang.sh文件，而这个文件又会调用&#x2F;etc&#x2F;sysconfig&#x2F;i18n文件。</p>
</li>
<li><p>由&#x2F;etc&#x2F;profile文件调用~&#x2F;.bash_profile文件</p>
<p>~&#x2F;.bash_profile文件主要实现两个功能：</p>
<ul>
<li>调用了~&#x2F;.bashrc文件。</li>
<li>在PATH变量后面加入了“:$HOME&#x2F;bin”这个目录。也就是说，如果我们在自己的家目录中建立bin目录，然后把自己的脚本放入“~&#x2F;bin”目录，就可以直接执行脚本，而不用通过目录执行了。</li>
</ul>
</li>
<li><p>由<del>&#x2F;.bash_profile文件调用</del>&#x2F;.bashrc文件</p>
<p>在~&#x2F;.bashrc文件中主要实现了：</p>
<ul>
<li>定义默认别名。</li>
<li>调用&#x2F;etc&#x2F;bashrc</li>
</ul>
</li>
<li><p>由~&#x2F;.bashrc调用了&#x2F;etc&#x2F;bashrc文件</p>
<p>在&#x2F;etc&#x2F;bashrc文件中主要定义了这些内容：</p>
<ul>
<li>PS1变量：也就是用户的提示符，如果想要永久修改提示符，就要在这个文件中修改。</li>
<li>umask：定义umask默认权限。这个文件中定的umask是针对”没登录过程(也就是不需要输入用户名和密码时，比如从一个终端切换到另一个终端，或进入子shell)”时生效的。如果是“有用户登录过程”，则是&#x2F;etc&#x2F;profile文件中的umask生效。</li>
<li>PATH变量：会给PATH变量追加值，当然也是在“没有登录过程”时才生效。</li>
<li>调用&#x2F;etc&#x2F;profile.d&#x2F;*.sh文件，这也是在”没有用户登录过程”时才调用。在“有用户登录过程”时，&#x2F;etc&#x2F;profile.d&#x2F;*.sh文件已经被&#x2F;etc&#x2F;profile文件调用过了。</li>
</ul>
</li>
</ul>
<p>这样五个环境变量配置文件会被依次调用，如果是我们自己定义的环境变量，如果你的修改是打算对所有用户生效的，那么可以放入&#x2F;etc&#x2F;profile环境变量配置文件；如果你的修改只是给自己使用的，那么可以放入<del>&#x2F;.bash_profile或</del>&#x2F;.bashrc这两个配置文件中的任一个。</p>
<p>如果我们误删除了这些环境变量，比如删除了&#x2F;etc&#x2F;bashrc文件，或删除了<del>&#x2F;.bashrc文件，那么这些文件中配置就会失效(</del>&#x2F;.bashrc_profile文件会调用&#x2F;etc&#x2F;profile文件)。那提示符就会变成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-bash-4.1#</span><br></pre></td></tr></table></figure>



<h4 id="注销时生效的环境变量配置文件"><a href="#注销时生效的环境变量配置文件" class="headerlink" title="注销时生效的环境变量配置文件"></a>注销时生效的环境变量配置文件</h4><p>在用户退出登录时，只会调用一个环境变量配置文件，就是~&#x2F;.bash_logout。这个文件默认没有写入任何内容，可是如果我们希望在退出登录时执行一些操作，比如清除历史命令，备份某些数据，就可以把命令写入这个文件。</p>
<h4 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h4><p>还有一些环境变量配置文件，最常见的就是~&#x2F;bash_history文件，也就是历史命令保存文件。</p>
<h3 id="Shell登录信息"><a href="#Shell登录信息" class="headerlink" title="Shell登录信息"></a>Shell登录信息</h3><h4 id="etc-issue"><a href="#etc-issue" class="headerlink" title="&#x2F;etc&#x2F;issue"></a>&#x2F;etc&#x2F;issue</h4><p>我们在登录tty1-6这六个本地终端时，会有几行的欢迎界面。这些欢迎信息是保存在&#x2F;etc&#x2F;issue文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/issue</span><br><span class="line">CentOS release 7.9 (Final)</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure>

<p>可以支持的转义符可以通过man agetty命令查询。下表中列出常见的转义符作用：</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>显示当前系统日期</td>
</tr>
<tr>
<td>\s</td>
<td>显示操作系统名称</td>
</tr>
<tr>
<td>\l</td>
<td>显示登录的终端号，这个比较常用。</td>
</tr>
<tr>
<td>\m</td>
<td>显示硬件体系结构，如i386、i686等</td>
</tr>
<tr>
<td>\n</td>
<td>显示主机名</td>
</tr>
<tr>
<td>\o</td>
<td>显示域名</td>
</tr>
<tr>
<td>\r</td>
<td>显示内核版本</td>
</tr>
<tr>
<td>\t</td>
<td>显示当前系统时间</td>
</tr>
<tr>
<td>\u</td>
<td>显示当前登录用户的序列号</td>
</tr>
</tbody></table>
<h4 id="etc-issue-net"><a href="#etc-issue-net" class="headerlink" title="&#x2F;etc&#x2F;issue.net"></a>&#x2F;etc&#x2F;issue.net</h4><p>&#x2F;etc&#x2F;issue是在本地终端登录时显示欢迎信息的。如果是远程登录(如ssh远程登录，或telnet远程登录)需要显示欢迎信息，则需要配置&#x2F;etc&#x2F;issue.net这个文件了。使用这个文件时需要注意两个点：</p>
<ul>
<li>在&#x2F;etc&#x2F;issue文件中支持的转义符，在&#x2F;etc&#x2F;issue.net文件中不能使用。</li>
<li>ssh远程登录是否显示&#x2F;etc&#x2F;issue.net的欢迎信息，是由ssh的配置文件决定的。</li>
</ul>
<p>如果需要ssh远程登录可以查看&#x2F;etc&#x2F;issue.net的欢迎信息，那么首先需要修改ssh的配置文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/ssh/sshd_config</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">no default banner path</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Banner none</span></span><br><span class="line">Banner /etc/issue.net</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这样在ssh远程登录时，也可以显示欢迎信息，只是不再可以识别“\d”和“\l”等信息了。</p>
<h4 id="etc-motd"><a href="#etc-motd" class="headerlink" title="&#x2F;etc&#x2F;motd"></a>&#x2F;etc&#x2F;motd</h4><p>&#x2F;etc&#x2F;motd文件也是显示欢迎信息的，这个文件和&#x2F;etc&#x2F;issue及&#x2F;etc&#x2F;issue.net文件的区别是：&#x2F;etc&#x2F;issue及&#x2F;etc&#x2F;issue.net是在用户登录之前显示欢迎信息，而&#x2F;etc&#x2F;motd是在用户输入用户名和密码，正确登录之后显示欢迎信息。在&#x2F;etc&#x2F;motd文件中的欢迎信息，不论是本地登录，还是远程登录都可以显示。</p>
<h3 id="定义Bash快捷键"><a href="#定义Bash快捷键" class="headerlink" title="定义Bash快捷键"></a>定义Bash快捷键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# stty 关键字 快捷键</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义ctrl+p快捷键为强制终止，<span class="string">&quot;^&quot;</span>字符只要手工输入即可</span></span><br><span class="line">[root@localhost ~]# stty intr ^p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询所有快捷键</span></span><br><span class="line">[root@localhost ~]# stty -a</span><br><span class="line">intr = ^P; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O;</span><br><span class="line">min = 1; time = 0;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>Shell编程</title>
    <url>/2025/02/27/Shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>正则表达式用来在文件中匹配符合条件的字符串，通配符用来匹配符合条件的文件名。其实这种区别只在Shell当中适用，因为用来文件当中搜索字符串的命令如grep、awk、sed等命令可以支持正则表达式，而在系统当中搜索文件的命令如ls、find、cp这些命令不支持正则表达式，所以只能使用Shell自己的通配符来进行匹配了。</p>
<h4 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>前一个字符匹配0次或任意多次</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符外任意一个字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配行首。例如^hello会匹配以hello开头的行</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾。例如hello$会匹配以hello结尾的行</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中指定的任意一个字符，只匹配一个字符。例如[aoeiu]匹配任意一个元音字母</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配除中括号的字符以外的任意一个字符。例如[^0-9]匹配任意一位非数字字符</td>
</tr>
<tr>
<td>\</td>
<td>转义符。用于取消特殊符号的转义</td>
</tr>
<tr>
<td>\{n\}</td>
<td>表示其前面的字符恰好出现n次。例如[0-9]\{4\}匹配4位数字</td>
</tr>
<tr>
<td>\{n, \}</td>
<td>表示其前面的字符出现不小于n次。例如[0-9]\{2, \}表示两位及以上的数字</td>
</tr>
<tr>
<td>\{n,m\}</td>
<td>表示其前面的字符至少出现n次，最多出现m次。例如[a-z]\{6,8\}匹配6到8位的小写字母。</td>
</tr>
</tbody></table>
<p>练习文件建立：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“a*”前一个字符匹配0次，或任意多次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“aa*”代表这行字符串最少要有一个a</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;aa*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“.”匹配除了换行符外任意一个字符，只能匹配一个字符，这个字符可以是任意字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s..d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# grep &quot;s.*d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“^”代表匹配行首，比如“^M”会匹配以大写“M”开头的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^M&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure>

<p>“$”代表匹配行尾，比如“n$”会匹配以小写“n”结尾的行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;n$&quot; test_rule.txt</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure>

<p>“^$”则会匹配空白行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^$&quot; test_rule.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“[]”会匹配中括号中指定任意一个字符，注意只能匹配一个字符。比如[ao]会匹配a或o</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s[ao]id&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“[^]”匹配除中括号的字符以外的任意一个字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[^a-z]&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">5555nice!</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“\“转义符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;\.$&quot; test_rule.txt</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“\{n\}”表示其前面的字符恰好出现n次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a\&#123;3\&#125;&quot; test_rule.txt</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br></pre></td></tr></table></figure>

<p>“\{n,\}”会匹配前面的字符出现最少n次。比如“^[0-9]\{3, \}[a-z]”这个正则就能匹配最少用连续三个数字开头的字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[0-9]\&#123;3,\&#125;[a-z]&quot; test_rule.txt</span><br><span class="line">123despise him.</span><br><span class="line">5555nice!</span><br></pre></td></tr></table></figure>

<p>“\{n,m\}”匹配其前面的字符至少出现n次，最多出现m次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;sa\&#123;1,3\&#125;i&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br></pre></td></tr></table></figure>



<h4 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h4><p>在正则表达式中应该还可以支持一些元字符，比如“+”、“?”、“|”、“()”。其实Linux是支持这些元字符的，只是grep命令默认不支持而已。如果想要支持这些元字符，必须使用egrep命令或grep -E选项，所以我们又把这些元字符称作扩展元字符。</p>
<p>如果查询grep的帮助，对egrep的说明就是和grep -E选项一样的命令，所以我们可以把这两个命令当做别名来对待。</p>
<table>
<thead>
<tr>
<th>扩展元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>前一个字符匹配1次或任意多次。如“go+gle”会匹配“gogle”、“google”或“gooogle”等。</td>
</tr>
<tr>
<td>?</td>
<td>前一个字符匹配0次或1次。如”colou?r”可以匹配“colour”或“color”。</td>
</tr>
<tr>
<td>|</td>
<td>匹配两个或多个分支的选择。如”was|his”会匹配既包含“was”的行，也匹配包含”his”的行。</td>
</tr>
<tr>
<td>()</td>
<td>匹配其整体为一个字符，即模式单元。可以理解为由多个单字符组成的大字符。如“(dog)+”会匹配“dog”、“dogdog”、“dogdogdog”等。因为被()包含的字符会当成一个整体。</td>
</tr>
</tbody></table>
<h3 id="字符截取和替换命令"><a href="#字符截取和替换命令" class="headerlink" title="字符截取和替换命令"></a>字符截取和替换命令</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f 列号：         提取第几列</span><br><span class="line">  -d 分隔号：       按照指定分隔符分割列</span><br><span class="line">  -c 字符范围：      不依赖分隔符来区分列，而是通过字符范围(行首为0)来进行字段提取。“n-”表示从第n个字符到行尾；&quot;n-m&quot;表示从第n个字符到第m个字符；&quot;-                     m&quot;表示从第1个字符到第m个字符。</span><br></pre></td></tr></table></figure>

<p>cut命令的默认分隔符是制表符，也就是“tab”键。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    Gender  Mark</span><br><span class="line">1       Liming  M       86</span><br><span class="line">2       Sc      M       90</span><br><span class="line">3       Tg      M       83</span><br></pre></td></tr></table></figure>

<p>提取第二列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2 test.txt</span><br><span class="line">Name</span><br><span class="line">Liming</span><br><span class="line">Sc</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure>

<p>提取多列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2,3 test.txt</span><br><span class="line">Name	Gender</span><br><span class="line">Liming	M</span><br><span class="line">Sc	M</span><br><span class="line">Tg	M</span><br></pre></td></tr></table></figure>

<p>按照字符进行提取：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut -c 8- test.txt        # &quot;8-&quot;代表提取所有行的第8个字符到结尾</span><br><span class="line">	Gender	Mark</span><br><span class="line">g	M	86</span><br><span class="line">90</span><br><span class="line">83</span><br></pre></td></tr></table></figure>

<p>以“:”作为分隔符提取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut -d &quot;:&quot; -f 1,3 /etc/passwd</span><br><span class="line">root:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>a）printf格式化输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;输出类型输出格式&#x27; 输出内容</span><br><span class="line">输出类型：</span><br><span class="line">  %ns:        输出字符串。n是数字指代输出几个字符</span><br><span class="line">  %ni:        输出整数。n是数字指代输出几个数字</span><br><span class="line">  %m.nf:      输出浮点数。m和n是数字，指代输出的整数位和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。</span><br><span class="line">输出格式：</span><br><span class="line">  \a：         输出警告声音</span><br><span class="line">  \b：         输出退格键，也就是Backspace键</span><br><span class="line">  \f：         清除屏幕</span><br><span class="line">  \n:          换行</span><br><span class="line">  \r:          回车，也就是Enter键</span><br><span class="line">  \t:          水平输出退格键，也就是Tab键</span><br><span class="line">  \v:          垂直输出退格键，也就是Tab键</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>使用printf输出test.txt文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s&#x27; $(cat test.txt)</span><br><span class="line">IDNamePHPLinuxMySQLAverage1Liming82958687.662Sc74968785.663Tg99839391.66[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>如果不指定输出格式，则会把所有输出内容连在一起输出。其实文本的输出本身就是这样的，cat等文本输出命令之所以可以按照格式漂亮的输出，那是因为cat命令已经设定了输出格式。为了用printf输出合理的格式，可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意在<span class="built_in">printf</span>命令的单引号中，只能识别格式输出符号，而手工输入的空格是无效的</span></span><br><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %s\t %s\t %s\t %s\t \n&#x27; $(cat test.txt)</span><br><span class="line">ID	 Name	 PHP	 Linux	 MySQL	 Average	 </span><br><span class="line">1	 Liming	 82	 95	 86	 87.66	 </span><br><span class="line">2	 Sc	 74	 96	 87	 85.66	 </span><br><span class="line">3	 Tg	 99	 83	 93	 91.66</span><br></pre></td></tr></table></figure>

<p>如果不想把成绩当成字符串输出，而是按照整形和浮点型输出，则要这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %i\t %i\t %i\t %8.2f\t \n&#x27; $(cat test.txt | grep -v Name)</span><br><span class="line">1	 Liming	 82	 95	 86	    87.66	 </span><br><span class="line">2	 Sc	 74	 96	 87	    85.66	 </span><br><span class="line">3	 Tg	 99	 83	 93	    91.66</span><br></pre></td></tr></table></figure>



<p>b）awk基本使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;...&#x27; 文件名</span><br><span class="line">条件(Pattern)：</span><br><span class="line">    一般使用关系表达式作为条件。这些关系表达式非常多。如：</span><br><span class="line">    x &gt; 10    判断变量x是否大于10</span><br><span class="line">    x == y    判断变是x是否等于变量y</span><br><span class="line">    A`B       判断字符串A中是否包含能匹配B表达式的子字符串</span><br><span class="line">    A!`B      判断字符串A中是否不包含能匹配B表达式的子字符串</span><br><span class="line">动作(Action)：</span><br><span class="line">    格式化输出</span><br><span class="line">    流程控制语句</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出第二列和第六列</span></span><br><span class="line">[root@localhost ~]# awk &#x27;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>



<p>c）awk的条件</p>
<table>
<thead>
<tr>
<th>条件的类型</th>
<th>条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>awk保留字</td>
<td>BEGIN</td>
<td>在awk程序一开始时，尚未读取任何数据之前执行。BEGIN后的动作只在程序开始时执行一次。</td>
</tr>
<tr>
<td></td>
<td>END</td>
<td>在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td></td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td></td>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td></td>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td></td>
<td>&#x3D;&#x3D;</td>
<td>等于。用于判断两个值是否相等，如果是给变量赋值，请使用“&#x3D;”号</td>
</tr>
<tr>
<td></td>
<td>!&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td></td>
<td>A~B</td>
<td>判断字符串A中是否包含能匹配B表达式的子字符串</td>
</tr>
<tr>
<td></td>
<td>A!~B</td>
<td>判断字符串B中是否不包含能匹配B表达式的子字符串</td>
</tr>
<tr>
<td>正则表达式</td>
<td>&#x2F;正则&#x2F;</td>
<td>如果在“&#x2F;&#x2F;”中可以写入字符，也可以支持正则表达式</td>
</tr>
</tbody></table>
<ul>
<li><p>BEGIN</p>
<p>BEGIN是awk的保留字，是一种特殊的条件类型。BEGIN的执行时机是“在awk程序一开始时，尚未读取任何数据之前执行”。一旦BEGIN后的动作执行一次，当awk开始从文件中读入数据，BEGIN的条件就不再成立，所以BEGIN定义的动作只能被执行一次。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">awk命令只要检测不到完整的单引号不会执行，所以这个命令的换行不用加入<span class="string">&quot;\&quot;</span></span></span><br><span class="line">[root@localhost ~]# awk &#x27;BEGIN&#123;printf &quot;This is a transcript \n&quot;&#125; </span><br><span class="line">&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">This is a transcript </span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>
</li>
<li><p>END</p>
<p>END也是awk保留字，不过刚好和BEGIN相反。END是在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;END&#123;printf &quot;The END \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br><span class="line">The END</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算符</p>
<p>查看平均成绩大于等于87分的学员是谁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$6 &gt;= 87&#123;printf $2 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">Liming</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure>

<p>加入条件之后，只有条件成立动作才会执行，如果条件不满足，则运作不运行。通过这个实验，大家可以发现，虽然awk是列提取命令，但是也要按行来读入的。这个命令的执行过程是这样的：</p>
<p>1）如果有BEGIN条件，则先执行BEGIN定义的动作</p>
<p>2）如果没有BEGIN条件，则读入第一行，把第一行的数据依次赋予$0、$1、$2等变量。其中$0代表此行的整体数据，$1代表第一字段，$2代表第二字段。</p>
<p>3）依据条件类型判断动作是否执行。如果条件符合，则执行动作，否则读入下一行数据。如果没有条件，则每行都执行动作。</p>
<p>4）读入下一行数据，重复执行以上步骤。</p>
<p>查看Sc用户的平均成绩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$2 ~ &quot;Sc&quot;&#123;printf $6 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">85.66</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式</p>
<p>如果想让awk识别字符串，必须使用“&#x2F;&#x2F;”包含，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印LiMing的成绩</span></span><br><span class="line">[root@localhost ~]# awk &#x27;/Liming/ &#123;print&#125;&#x27; test.txt </span><br><span class="line">1	Liming	82	95	86	87.66</span><br></pre></td></tr></table></figure>

<p>当使用df命令查看分区使用情况时，如果只想看真正的系统分区的使用状况，而不想查看光盘和临时分区的使用状况，则可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -h | awk &#x27;/sda[0-9]/ &#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>4）awk内置变量</p>
<table>
<thead>
<tr>
<th>awk内置变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>代表目前awk所读入的整行数据。我们已知awk是一行一行读入数据的，$0就代表当前读入行的整行数据。</td>
</tr>
<tr>
<td>$n</td>
<td>代表目前读入行的第n个字段。</td>
</tr>
<tr>
<td>NF</td>
<td>当前行拥有的字段(列)总数。</td>
</tr>
<tr>
<td>NR</td>
<td>当前awk所处理的行，是总数据的第几行。</td>
</tr>
<tr>
<td>FS</td>
<td>用户定义分隔符。awk的默认分隔符是任何空格，如果想要使用其他分隔符(如”：”)，就需要FS变量定义。</td>
</tr>
<tr>
<td>ARGC</td>
<td>命令行参数个数。</td>
</tr>
<tr>
<td>ARGV</td>
<td>命令行参数数组。</td>
</tr>
<tr>
<td>FNR</td>
<td>当前文件中的当前记录数(对输入文件起始为1)。</td>
</tr>
<tr>
<td>OFMT</td>
<td>数值的输出格式(默认为%.6g)。</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段的分隔符(默认为空格)。</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符(默认为换行符)。</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符(默认为换行符)。</td>
</tr>
</tbody></table>
<p>查询可以登录的用户的用户名和UID：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root	0</span><br><span class="line">ben	1000</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号:&quot; NR &quot;\t 字段数: &quot; NF &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root	0	 行号:1	 字段数: 7</span><br><span class="line">ben	1000	 行号:2	 字段数: 7</span><br></pre></td></tr></table></figure>

<p>查看sshd这个伪用户的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $1==&quot;sshd&quot; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号：&quot; NR &quot;\t 字段数：&quot; NF &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>5）awk流程控制</p>
<p>统计PHP成绩的总分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR==2&#123;php1=$3&#125; NR==3&#123;php2=$3&#125; NR==4&#123;php3=$3;total=php1+php2+php3;print &quot;total php is &quot; total&#125;&#x27; test.txt</span><br><span class="line">total php is 255</span><br></pre></td></tr></table></figure>

<ul>
<li>“NR&#x3D;&#x3D;2{php1&#x3D;$3}”：条件是NR&#x3D;&#x3D;2，动作是php1&#x3D;$3，指如果输入数据是第二行(第一行是标题行)，就把第二行的第三字段的值赋予变量“php1”。</li>
<li>“NR&#x3D;&#x3D;3{php2&#x3D;$3}”：如果输入数据是第三行，就把第三行的第三字段的值赋予变量“php2”。</li>
<li>‘NR&#x3D;&#x3D;4{php3&#x3D;$3;total&#x3D;php1+php2+php3;print “total php is “ total}’：如果输入数据是第四行，就把第四行的第三字段的值赋予变量“php3”；然后定义变量total的值为‘php1+php2+php3’；然后输出”total php is “关键字，后面加变量total的值。</li>
</ul>
<p>在awk编程中，因为命令语句非常长，在输入格式时需要注意以下内容：</p>
<ul>
<li>多个条件{动作}可以用空格分割，也可以用回车分割。</li>
<li>在一个动作中，如果需要执行多个命令，需要用“;”分割，或用回车分割。</li>
<li>在awk中，变量的赋值与调用都不需要加入“$”符。</li>
<li>条件中判断两个值是否相同，请使用”&#x3D;&#x3D;”，以便和变量赋值进行区分。</li>
</ul>
<p>如果Linux成绩大于90，就是一个好学生：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;&#123;if (NR&gt;=2)&#123;if ($3&gt;90) printf $2 &quot; is a good student!\n&quot;&#125;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure>

<p>其实awk中if判断语句，完全可以直接利用awk自带的条件来取代：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR&gt;=2&#123;test=$3&#125; test&gt;90&#123;printf $2 &quot; is a good student!\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure>



<p>6）awk函数</p>
<p>awk编程也允许在编程时使用函数，awk函数定义方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名 (参数列表) &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一简单的函数，使用函数来打印test.txt的学员姓名和平均成绩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;function test(a,b) &#123;printf a &quot;\t&quot; b &quot;\n&quot;&#125; &#123;test($2,$6)&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>



<p>7）awk中调用脚本</p>
<p>对于小的单行程序来说，将脚本作为命令行自变量传递给awk是非常简单的，而对于多行程序就比较难处理。当程序是多行的时候，使用外部脚本是很适合的。首先在外部文件中写好脚本，然后可以使用awk的-f选项，使其读入脚本并且执行。</p>
<p>例如，我们可以先编写一个awk脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim pass.awk</span><br><span class="line">BEGIN	&#123;FS=&quot;:&quot;&#125;</span><br><span class="line">&#123;print $1 &quot;\t&quot; $3&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以使用”-f”选项来调用这个脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk -f pass.awk /etc/passwd</span><br><span class="line">root	0</span><br><span class="line">daemon	1</span><br><span class="line">bin	2</span><br><span class="line">sys	3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>sed主要是用来将数据进行选取、替换、删除和新增的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed [选项] &#x27;[动作]&#x27; 文件名</span><br><span class="line">选项：</span><br><span class="line">  -n:              一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。</span><br><span class="line">  -e:              允许对输入数据应用多条sed命令编辑。</span><br><span class="line">  -f 脚本文件名:    从sed脚本中读入sed操作。和awk命令的-f非常类似。</span><br><span class="line">  -r:              在sed中支持扩展正则表达式。</span><br><span class="line">  -i:              用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出</span><br><span class="line">动作：</span><br><span class="line">  a \n:             追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  c \n:             行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用&quot;\&quot;代表数据未完结。</span><br><span class="line">  i \n:             插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  d:               删除，删除指定的行。</span><br><span class="line">  p:               打印，输出指定的行。</span><br><span class="line">  s:               字串替换，用一个字符串替换另外一个字符串。格式为&quot;行范围 s/旧字串/新字串/g&quot;（和vim中的替换格式类似）</span><br></pre></td></tr></table></figure>

<p>对sed命令要注意，sed所做的修改并不会直接改变文件的内容(如果是用管道符接收的命令的输出，这种情况连文件都没有)，而是把修改结果只显示到屏幕上，除非使用“-i”选项才会直接修改文件。</p>
<ul>
<li><p>行数据操作</p>
<p>【查看】</p>
<p>查看test.txt的第二行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2p&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>“p”命令确实输出了第二行数据，但是sed命令还会把所有数据都输出一次。如果想指定输出某行数据，需要”-n”选项的帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed -n &#x27;2p&#x27; test.txt</span><br><span class="line">1       Liming  82      95      86      87.66</span><br></pre></td></tr></table></figure>



<p>【删除】</p>
<p>删除第二行到第四行的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,4d&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件本身并没有修改</span></span><br><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>



<p>【追加】</p>
<p>“a“会在指定行后面追加入数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2a hello&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">hello</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>



<p>【插入】</p>
<p>“i”会在指定行前面插入数据:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# sed -n &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>



<p>【替换】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2c No such person&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No such person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat test.txt | sed &#x27;2c No sucn person&#x27;</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No sucn person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>sed命令默认情况下是不会修改文件内容的，如果确定需要让sed命令直接处理文件的内容，可以使用”-i”选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed -i &#x27;2c No such person&#x27; test.txt</span><br></pre></td></tr></table></figure>


</li>
<li><p>字符串替换</p>
<p>“c”动作是进行整行替换的，如果仅仅想替换行中的部分数据，就要使用“s”动作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/旧字串/新字串/g&#x27; 文件名</span><br></pre></td></tr></table></figure>

<p>在第三行中，把74替换成99：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3s/74/99/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      99      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>把第四行注释掉：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;4s/^/#/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3       Tg      99      83      93      91.66</span></span><br></pre></td></tr></table></figure>

<p>“-e”选项可以同时执行多个sed动作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed -e &#x27;s/Liming//g;s/Tg//g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1         82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3             99      83      93      91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sort [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f:        忽略大小写</span><br><span class="line">  -b:        忽略每行前面的空白部分</span><br><span class="line">  -n:        以数值型进行排序，默认使用字符串型排序</span><br><span class="line">  -r:        反向排序</span><br><span class="line">  -u:        删除重复行。就是uniq命令</span><br><span class="line">  -t:        指定分隔符，默认分隔符是制表符</span><br><span class="line">  -k n[,m]:  按照指定的字段范围排序。从第n字段开始，m字段结束(默认到行尾)</span><br></pre></td></tr></table></figure>

<p>sort命令默认是用每行开头第一个字符来进行排序的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sort /etc/passwd</span><br><span class="line">_apt:x:105:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:109:116:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">avahi:x:115:121:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>反向排序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sort -r /etc/passwd</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">whoopsie:x:120:125::/nonexistent:/bin/false</span><br><span class="line">uuidd:x:107:114::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果想要指定排序的字段，需要先使用“-t”选项指定分隔符，并使用“-k”选项指定字段号。例如按照UID字段排序&#x2F;etc&#x2F;passwd文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然“-k”选项可以直接使用“-k 3”，代表从第三字段到行尾排序（第一个字符先排序，如果一致，第二个字符再排序，直到行尾）。</p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>uniq命令是用来取消重复行的命令，其实和”sort -u”选项是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uniq [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -i:        忽略大小写</span><br></pre></td></tr></table></figure>



<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>统计命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# wc [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -l:        只统计行数</span><br><span class="line">  -w:        只统计单词数</span><br><span class="line">  -m:        只统计字符数</span><br></pre></td></tr></table></figure>



<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="按照文件类型进行判断"><a href="#按照文件类型进行判断" class="headerlink" title="按照文件类型进行判断"></a>按照文件类型进行判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b 文件</td>
<td>判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）</td>
</tr>
<tr>
<td>-c 文件</td>
<td>判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真）</td>
</tr>
<tr>
<td>-d 文件</td>
<td>判断该文件是否存在，并且是否为目录文件（是目录为真）</td>
</tr>
<tr>
<td>-e 文件</td>
<td>判断该文件是否存在（存在为真）</td>
</tr>
<tr>
<td>-f 文件</td>
<td>判断该文件是否存在，并且是否为普通文件（是普通文件为真）</td>
</tr>
<tr>
<td>-L 文件</td>
<td>判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）</td>
</tr>
<tr>
<td>-p 文件</td>
<td>判断该文件是否存在，并且是否为管道文件（是管道文件为真）</td>
</tr>
<tr>
<td>-s 文件</td>
<td>判断该文件是否存在，并且是否为非空（非空为真）</td>
</tr>
<tr>
<td>-S 文件</td>
<td>判断该文件是否存在，并且是否为套接字文件（是套接字文件为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# [ -e /root/sh/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">0        # 判断结果为0，/root/sh/目录是存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -e /root/test/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">1        # 判断结果为0，/root/test/目录是不存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -d /root/sh ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个判断命令如果正确执行，则打印<span class="string">&quot;yes&quot;</span>，否则打印<span class="string">&quot;no&quot;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="按照文件权限进行判断"><a href="#按照文件权限进行判断" class="headerlink" title="按照文件权限进行判断"></a>按照文件权限进行判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-r 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真）</td>
</tr>
<tr>
<td>-w 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有写权限（有写权限为真）</td>
</tr>
<tr>
<td>-x 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）</td>
</tr>
<tr>
<td>-u 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真）</td>
</tr>
<tr>
<td>-g 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真）</td>
</tr>
<tr>
<td>-k 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SBIT权限（有SBIT权限为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll test.txt</span><br><span class="line">-rw-rw-r-- 1 ben ben 187  2月 28 02:09 test.txt</span><br><span class="line">[root@localhost ~]# [ -w test.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="两个文件之间进行比较"><a href="#两个文件之间进行比较" class="headerlink" title="两个文件之间进行比较"></a>两个文件之间进行比较</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>文件1 -nt 文件2</td>
<td>判断文件1的修改时间是否比文件2的新（如果新则为真）</td>
</tr>
<tr>
<td>文件1 -ot 文件2</td>
<td>判断文件1的修改时间是否比文件2的旧（如果旧则为真）</td>
</tr>
<tr>
<td>文件1 -ef 文件2</td>
<td>判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建个硬链接</span></span><br><span class="line">[root@localhost ~]# ln /tmp/test.txt /tmp/stu.txt</span><br><span class="line">[root@localhost ~]# [ /tmp/test.txt -ef /tmp/stu.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="两个整数之间比较"><a href="#两个整数之间比较" class="headerlink" title="两个整数之间比较"></a>两个整数之间比较</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>整数1 -eq 整数2</td>
<td>判断整数1是否和整数2相等（相等为真）</td>
</tr>
<tr>
<td>整数1 -ne 整数2</td>
<td>判断整数1是否和整数2不相等（不相等为真）</td>
</tr>
<tr>
<td>整数1 -gt 整数2</td>
<td>判断整数1是否大于整数2（大于为真）</td>
</tr>
<tr>
<td>整数1 -lt 整数2</td>
<td>判断整数1是否小于整数2（小于为真）</td>
</tr>
<tr>
<td>整数1 -ge 整数2</td>
<td>判断整数1是否大于等于整数2（大于等于为真）</td>
</tr>
<tr>
<td>整数1 -le 整数2</td>
<td>判断整数1是否小于等于整数2（小于等于为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# [ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br><span class="line">[root@localhost ~]# [ 23 -le 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-z 字符串</td>
<td>判断字符串是否为空（为空返回真）</td>
</tr>
<tr>
<td>-n 字符串</td>
<td>判断字符串是否为非空（非空返回真）</td>
</tr>
<tr>
<td>字符串1 &#x3D;&#x3D; 字符串2</td>
<td>判断字符串1是否和字符串2相等（相等返回真）</td>
</tr>
<tr>
<td>字符串1 !&#x3D; 字符串2</td>
<td>判断字符串1 是否和字符串2不相等（不相等返回真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给name赋值</span></span><br><span class="line">[root@localhost ~]# name=ben</span><br><span class="line">[root@localhost ~]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# bb=22</span><br><span class="line">[root@localhost ~]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>判断1 -a 判断2</td>
<td>逻辑与，判断1和判断2都成立，最终的结果为真</td>
</tr>
<tr>
<td>判断1 -o 判断2</td>
<td>逻辑或，判断1和判断2有一个成立，最终的结果就为真</td>
</tr>
<tr>
<td>! 判断</td>
<td>逻辑非，使原始的判断式取反</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line">[root@localhost ~]# [ ! -n &quot;$aa&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>“!”和“-n”之间必须加入空格，否则会报错的。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h4><p>a）单分支if条件语句</p>
<p>单分支条件语句最为简单，就是只有一个判断条件，如果符合条件则执行某个程序，否则什么事情都不做。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>单分支条件语句需要注意几个点：</p>
<ul>
<li><p>if语句使用fi结尾，和一般语言使用大括号结尾不同。</p>
</li>
<li><p>[ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格。</p>
</li>
<li><p>then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">	then</span><br><span class="line">		程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda3&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f1)</span><br><span class="line">if [ $rate -ge 80 ];then</span><br><span class="line">	echo &quot;Warning! /dev/sda3 is full!!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>b）双分支if条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]；then</span><br><span class="line">	条件成立时，执行的程序</span><br><span class="line">else</span><br><span class="line">	条件不成立时，执行的另一个程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步系统时间</span></span><br><span class="line">ntpdate asia.pool.ntp.org &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把当前系统时间按照<span class="string">&quot;年月日&quot;</span>格式赋予变量<span class="built_in">date</span></span></span><br><span class="line">date=$(date +%y%m%d)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计mysql数据库的大小，并把大小赋予size变量</span></span><br><span class="line">size=$(du -sh /var/lib/mysql)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断备份目录是否存在，是否为目录</span></span><br><span class="line">if [ -d  /tmp/dbak ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">	echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">	echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入备份目录</span></span><br><span class="line">	cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">	tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除临时文件</span></span><br><span class="line">	rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果判断为假，则建立备份目录</span></span><br><span class="line">	mkdir /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">	echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">	echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入备份目录</span></span><br><span class="line">	cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">	tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除临时文件</span></span><br><span class="line">	rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>在工作中，服务器上的服务经常会宕机。如果我们对服务器监控不好，就会造成服务器中服务宕机了，而管理员却不知道的情况，这时我们可以写一个脚本来监听本机的服务，如果服务停止或宕机了，可以自动重启这些服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用nmap命令扫描服务器，并截取apache服务的状态，赋予变量port</span></span><br><span class="line">port=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">if [ &quot;$port&quot; == &quot;open&quot; ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">则证明apache正常启动，在正常日志中写入一句话即可</span></span><br><span class="line">	echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/autostart-acc.log</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">否则证明apache没有启动，自动启动apache</span></span><br><span class="line">	/etc/rc.d/init.d/httpd start &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">并在错误日志中记录自动启动apache的时间</span></span><br><span class="line">	echo &quot;$(date) restart httpd!!&quot; &gt;&gt; /tmp/autostart-err.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>c）多分支if条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式1 ];then</span><br><span class="line">	当条件判断式1成立时，执行程序1</span><br><span class="line">elif [ 条件判断式2 ];then</span><br><span class="line">	当条件判断式2成立时，执行程序2</span><br><span class="line">else</span><br><span class="line">	当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>判断用户输入的是什么文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">！/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email:17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接收键盘的输入，并赋予变量file</span></span><br><span class="line">read -p &quot;Please input a filename: &quot; file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file变量是否为空</span></span><br><span class="line">if [ -z &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;Error,please input a filename&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出程序，并返回1</span></span><br><span class="line">	exit 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否存在</span></span><br><span class="line">elif [ ! -e &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;Your input is not a file!&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出程序，并返回2</span></span><br><span class="line">	exit 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为普通文件</span></span><br><span class="line">elif [ -f &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;$file is a regulare file!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为目录文件</span></span><br><span class="line">elif [ -d &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;$file is a directory!&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;$file is an other file!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="多分支case条件语句"><a href="#多分支case条件语句" class="headerlink" title="多分支case条件语句"></a>多分支case条件语句</h4><p>case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">	&quot;值1&quot;)</span><br><span class="line">		如果变量的值等于值1，则执行程序1</span><br><span class="line">		;;</span><br><span class="line">	&quot;值2&quot;)</span><br><span class="line">		如果变量的值等于值2，则执行程序2</span><br><span class="line">		;;</span><br><span class="line">	...</span><br><span class="line">	*)</span><br><span class="line">		如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">		;;</span><br><span class="line">esac	</span><br></pre></td></tr></table></figure>

<p>这个语句需要注意以下内容：</p>
<ul>
<li><p>case语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行“*)”（“*”代表所有其他值）中的程序。</p>
</li>
<li><p>case语句以“case”开头，以“esac”结尾。</p>
</li>
<li><p>每个分支程序之后要通过“;;”双分号结尾，代表该程序段结束。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please choose yes/no: &quot; -t 30 cho</span><br><span class="line">case $cho in </span><br><span class="line">	&quot;yes&quot;)</span><br><span class="line">		echo &quot;Your choose is yes!&quot;</span><br><span class="line">		;;</span><br><span class="line">	&quot;no&quot;)</span><br><span class="line">		echo &quot;Your choose is no!&quot;</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		echo &quot;Your choose is error!&quot;</span><br><span class="line">		;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环是固定循环，也就是在循环时已经知道需要进行几次循环，有时也把for循环称为计数循环。</p>
<p>语法一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>这种语法中for循环的次数，取决于in后面值的个数（空格分隔），有几个值就循环几次，并且每次循环都把值赋予变量。</p>
<p>打印时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for time in morning noon afternoon evening</span><br><span class="line">	do</span><br><span class="line">		echo &quot;This time is $time&quot;</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>批量解压缩脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入压缩目录</span></span><br><span class="line">cd /lamp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把所有tar.gz结尾的文件的文件覆盖到ls.log临时文件中</span></span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line">for i in $(cat ls.log)</span><br><span class="line">	do</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">解压缩</span></span><br><span class="line">		tar -zxf $i &amp;&gt;/dev/null</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件ls.log</span></span><br><span class="line">rm -rf /lamp/ls.log</span><br></pre></td></tr></table></figure>



<p>语法二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>这种语法需要注意：</p>
<ul>
<li>初始值：在循环开始时，需要给某个变量赋予初始值，如i&#x3D;1;</li>
<li>循环控制条件：用于指定变量循环的次数，如i&lt;&#x3D;100，则只要i的值小于等于100，循环就会继续;</li>
<li>变量变化：每次循环之后，变量该如何变化，如i&#x3D;i+1。代表每次循环之后，变量i的值都加1。</li>
</ul>
<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for (( i=1;i&lt;=100;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum of 1+2+...+100 is : $s&quot;</span><br></pre></td></tr></table></figure>

<p>批量添加指定数量的用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入用户名，把输入保存入变量name</span></span><br><span class="line">read -p &quot;Please input user name: &quot; -t 30 name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入添加用户的数量，把输入保存入变量num</span></span><br><span class="line">read -p &quot;Please input the number of users: &quot; -t num</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入初始密码，把输入保存入变量pass</span></span><br><span class="line">read -p &quot;Please input the password of users: &quot; -t pass</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断三个变量不为空</span></span><br><span class="line">if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;#pass&quot; ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">判断变量num的值是否为数字</span></span><br><span class="line">	y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line">	if [ -z &quot;$y&quot; ];then</span><br><span class="line">		for (( i=1;i&lt;=$num;i=i+1 ))</span><br><span class="line">			do</span><br><span class="line">				# 添加用户</span><br><span class="line">				/usr/sbin/useradd $name$i &amp;&gt;/dev/null</span><br><span class="line">				# 修改用户密码</span><br><span class="line">				echo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null</span><br><span class="line">			done</span><br><span class="line">	fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>批量删除用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">user=$(cat /etc/passwd | grep &quot;/bin/bash&quot; | grep -v &quot;root&quot; | cut -d &quot;:&quot; -f 1)</span><br><span class="line">for i in $user</span><br><span class="line">	do</span><br><span class="line">		userdel -r $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>对while循环来讲，只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。</p>
<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+ 1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure>



<h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><p>until循环和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until [ 条件判断式 ]</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">until [ $i -gt 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure>



<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名（）&#123;</span><br><span class="line">	程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">function sum () &#123;</span><br><span class="line">	s=0</span><br><span class="line">	for (( i=0;i&lt;=$1;i=i+1 ))</span><br><span class="line">		do</span><br><span class="line">			s=$(( $i+$s ))</span><br><span class="line">		done</span><br><span class="line">	echo &quot;The sum of 1+2+3+...+$l is: $s&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line">y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line"></span><br><span class="line">if [ -z $y ];then</span><br><span class="line">	sum $num</span><br><span class="line">else</span><br><span class="line">	echo &quot;Error!! Please input a number!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="特殊流程控制语名"><a href="#特殊流程控制语名" class="headerlink" title="特殊流程控制语名"></a>特殊流程控制语名</h4><p>a）exit语句</p>
<p>系统是有exit命令的，用于退出当前用户的登录状态。可是在shell脚本中，exit语句是用来退出当前脚本的。也就是说，在Shell脚本中，只要碰到了exit语句，后续的程序就不再执行，而是直接退出脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit [返回值]</span><br></pre></td></tr></table></figure>

<p>如果exit命令之后定义了返回值，那么这个脚本执行之后的返回值就是我们自己定义的返回值。可以通过$?这个变量来查看返回值。如果exit之后没有定义返回值，脚本执行之后的返回值是执行exit语句之前，最后执行的一条命令的返回值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line"></span><br><span class="line">y=$(echo $num | sed &quot;s/[0-9]//g&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断变量num的值如果不为空，则输出报错信息，并且退出脚本，退出返回值为18</span></span><br><span class="line">[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18</span><br><span class="line"></span><br><span class="line">echo &quot;The number is: $num&quot;</span><br></pre></td></tr></table></figure>



<p>b）break语句</p>
<p>当程序执行到break语句时，会结束整个当前循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		if [ $i -eq 4 ];then</span><br><span class="line">			break</span><br><span class="line">		fi</span><br><span class="line">		echo $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<p>c）continue语句</p>
<p>continue也是结束流程控制的语句。continue语句只会结束单次当前循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		if [ $i -eq 4 ];then</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		echo $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>Terraform</title>
    <url>/2025/02/28/Terraform/</url>
    <content><![CDATA[<h2 id="Terraform工作流程"><a href="#Terraform工作流程" class="headerlink" title="Terraform工作流程"></a>Terraform工作流程</h2><p>Terraform是一个基础设施即代码(IaC)工具，通过以下几个步骤来管理基础设施：</p>
<ul>
<li><p>配置文件（.tf文件）</p>
<p>用户首先通过编写Terraform配置文件来定义所需的基础设施。这些文件使用HCL（HashiCorp Configuration Language）语言，描述资源的类型、属性和配置。</p>
</li>
<li><p>初始化（terraform init）</p>
<p>在开始Terraform之前，用户需要运行terraform init命令。这一步会初始化工作目录，下载所需的提供程序(如AWS、Azure等)，并准备后续的操作。</p>
</li>
<li><p>生成执行计划（terraform plan）</p>
<p>使用terraform plan命令，Terraform会读取配置文件并生成执行计划，展示将要执行的操作（如创建、更新或删除资源）。这一步允许用户预览即将进行的变更，避免意外操作。</p>
</li>
<li><p>应用变更（terraform apply）</p>
<p>在确认执行计划后，用户可以运行terraform apply命令，Terraform会根据生成的计划实际执行相应的操作，创建、更新或删除云资源。</p>
</li>
<li><p>状态管理</p>
<p>Terraform会维护一个状态文件（terraform.tfstate），记录当前基础设施的状态。这个文件用于跟踪资源的实际状态，以便在后续操作中进行对比和管理。</p>
</li>
<li><p>变更管理</p>
<p>当需要对基础设施进行更改时，用户只需要修改配置文件，然后重复执行plan和apply流程。Terraform会自动识别资源的变更，并进行相应的更新。</p>
</li>
<li><p>销毁资源（terraform destory）</p>
<p>当不再需要某些资源时，用户可以运行terraform destory命令，Terraform会删除所有配置文件中定义的资源，确保清理工作整洁。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
  </entry>
  <entry>
    <title>Argo CD</title>
    <url>/2025/03/14/argo-cd/</url>
    <content><![CDATA[<h2 id="ArgoCD简介"><a href="#ArgoCD简介" class="headerlink" title="ArgoCD简介"></a>ArgoCD简介</h2><p>Argo CD是一个基于Kubernetes的声明式的GitOps工具。</p>
<h3 id="GitOps"><a href="#GitOps" class="headerlink" title="GitOps"></a>GitOps</h3><p>GitOps是以Git为基础，使用CI&#x2F;CD来更新运行在云原生环境的应用，它秉承了DevOps的核心理念——“构建它并交付它(you built it you ship it)”。</p>
<p>当开发人员将开发完成的代码推送到git仓库会触发CI制作镜像并推送到镜像仓库。</p>
<p>CI处理完成后，可以手动或者自动修改应用配置，再将其推送到git仓库。</p>
<p>GitOps会同时对比目标状态和当前状态，如果两者不一致会触发CD将新的配置部署到集群中。</p>
<p>其中，目标状态是Git中的状态，现有状态是集群里的应用状态。</p>
<h3 id="ArgoCD"><a href="#ArgoCD" class="headerlink" title="ArgoCD"></a>ArgoCD</h3><p>Argo CD 遵循GitOps模式，使用Git存储库存储所需应用程序的配置。</p>
<p>Kubernetes清单可以通过以下几种方式指定：</p>
<ul>
<li>kustomize</li>
<li>helm</li>
<li>ksonnet</li>
<li>jsonnet</li>
<li>基于YAML&#x2F;json</li>
<li>配置管理插件配置的任何自定义配置管理工具</li>
</ul>
<p>Argo CD实现为kubernetes控制器，它持续监视运行中的应用程序，并将当前的活动状态与期望的目标状态进行比较(如Git repo中指定的那样)。如果已部署的应用程序的活动状态偏离了目标状态，则认为是OutOfSync。Argo CD报告和可视化这些差异，同时提供了方法，可以自动或手动将活动状态同步回所需的目录状态。在Git repo中对所需目标状态所做的任何修改都可以自动应用并反映到指定的目标环境中。</p>
<h3 id="ArgoCD优势"><a href="#ArgoCD优势" class="headerlink" title="ArgoCD优势"></a>ArgoCD优势</h3><ul>
<li>应用定义、配置和环境信息是声明式的，并且可以进行版本控制。</li>
<li>应用部署和生命周期管理是全自动化的，是可审计的，清晰易懂。</li>
<li>Argo CD是一个独立的部署工具，支持对多个环境、多个Kubernetes集群上的应用进行统一部署和管理。</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>官方文档：<a href="https://argo-cd.readthedocs.io/en/stable/">https://argo-cd.readthedocs.io/en/stable/</a></li>
</ul>
]]></content>
      <categories>
        <category>DevOps</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Argo Events</title>
    <url>/2023/03/14/argo-events/</url>
    <content><![CDATA[<h2 id="Argo-Events概述"><a href="#Argo-Events概述" class="headerlink" title="Argo Events概述"></a>Argo Events概述</h2><p>在kubernetes集群中，工作流程的触发通常依赖于特定事件的发生，而Argo Events则提供了一种强大的方式来监控外部事件，并将这些事件映射到集群内的操作或任务执行。Argo Events是Argo项目中的一部分，它与Argo Workflows一起使用，能够在事件发生时启动工作流，形成自动化的DevOps流程。</p>
<p>Argo Events是一种事件驱动的工作流程自动化工具。它允许Kubernetes集群根据外部或内部事件触发工作流程。这些事件可以是来自外部系统的HTTP请求、GitHub Webhook、Kafka消息、S3对象创建，或者Kubernetes内部资源的变化。通过Argo Events，我们可以定义触发器(Trigger)，并将它们与事件源(Event Source)关联，从而在事件发生时执行相应的操作，比如启动一个工作流。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在理解Argo Events如何触发Kubernetes工作流之前，需要熟悉几个核心组件：</p>
<ul>
<li>Event Source：这是事件的来源，可以是HTTP、Webhook、定时器(Cron)、消息队列(如Kafka)、对象存储(如S3)等。</li>
<li>Sensor：传感器负责监听Event Source中发生的事件，并在符合条件时触发相应的操作。Sensor会将事件处理为一个或多个触发器(Trigger)。</li>
<li>EventBus：通过Event Source和Sensor来充当Argo-Events的传输层。EventBus有三种实现：NATS(已弃用)、Jetstream和Kafka。</li>
<li>Trigger：触发器是事件到达时执行的操作。Trigger可以是Kubernetes中的任何资源，比如启动工作流(Workflow)，执行Pod，或者触发其他Kubernetes原生资源。</li>
</ul>
<p>这三个组件构成了Argo Events的核心架构，使得它能够实现事件驱动的工作流自动化。</p>
<h2 id="具体工作流程"><a href="#具体工作流程" class="headerlink" title="具体工作流程"></a>具体工作流程</h2><h3 id="安装Argo-Workflows"><a href="#安装Argo-Workflows" class="headerlink" title="安装Argo Workflows"></a>安装Argo Workflows</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export ARGO_WORKFLOWS_VERSION=3.5.4</span><br><span class="line">kubectl create namespace argo</span><br><span class="line">kubectl apply -n argo -f https://github.com/argoproj/argo-workflows/releases/download/v$ARGO_WORKFLOWS_VERSION/install.yaml</span><br></pre></td></tr></table></figure>



<h3 id="安装Argo-Events"><a href="#安装Argo-Events" class="headerlink" title="安装Argo Events"></a>安装Argo Events</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create namespace argo-events</span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-events/stable/manifests/install.yaml</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Install with a validating admission controller</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/argoproj/argo-events/stable/manifests/install-validating-webhook.yaml</span><br></pre></td></tr></table></figure>



<h3 id="运行eventbus-pod"><a href="#运行eventbus-pod" class="headerlink" title="运行eventbus pod"></a>运行eventbus pod</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -n argo-events -f https://raw.githubusercontent.com/argoproj/argo-events/stable/examples/eventbus/native.yaml</span><br></pre></td></tr></table></figure>



<h3 id="配置Event-Source"><a href="#配置Event-Source" class="headerlink" title="配置Event Source"></a>配置Event Source</h3><p>通过定义一个EventSource来指定事件的来源。假设通过HTTP Webhook来触发工作流，可以定义如下的EventSource资源：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">EventSource</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webhook</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">12000</span></span><br><span class="line">        <span class="attr">targetPort:</span> <span class="number">12000</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">foo:</span> <span class="string">bar</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">foo:</span> <span class="string">bar</span></span><br><span class="line">  <span class="attr">webhook:</span></span><br><span class="line">    <span class="comment"># event-source can run multiple HTTP servers. Simply define a unique port to start a new HTTP server</span></span><br><span class="line">    <span class="attr">example:</span></span><br><span class="line">      <span class="comment"># port to run HTTP server on</span></span><br><span class="line">      <span class="attr">port:</span> <span class="string">&quot;12000&quot;</span></span><br><span class="line">      <span class="comment"># endpoint to listen to</span></span><br><span class="line">      <span class="attr">endpoint:</span> <span class="string">/example</span></span><br><span class="line">      <span class="comment"># HTTP request method to allow. In this case, only POST requests are accepted</span></span><br><span class="line">      <span class="attr">method:</span> <span class="string">POST</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#    example-foo:</span></span><br><span class="line"><span class="comment">#      port: &quot;12000&quot;</span></span><br><span class="line"><span class="comment">#      endpoint: /example2</span></span><br><span class="line"><span class="comment">#      method: POST</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment to use secure webhook</span></span><br><span class="line"><span class="comment">#    example-secure:</span></span><br><span class="line"><span class="comment">#      port: &quot;13000&quot;</span></span><br><span class="line"><span class="comment">#      endpoint: &quot;/secure&quot;</span></span><br><span class="line"><span class="comment">#      method: &quot;POST&quot;</span></span><br><span class="line"><span class="comment">#      # k8s secret that contains the cert</span></span><br><span class="line"><span class="comment">#      serverCertSecret:</span></span><br><span class="line"><span class="comment">#        name: my-secret</span></span><br><span class="line"><span class="comment">#        key: cert-key</span></span><br><span class="line"><span class="comment">#      # k8s secret that contains the private key</span></span><br><span class="line"><span class="comment">#      serverKeySecret:</span></span><br><span class="line"><span class="comment">#        name: my-secret</span></span><br><span class="line"><span class="comment">#        key: pk-key</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个名为webhook的事件源，它通过一个HTTP POST请求触发。在实际应用中，可以将这个事件源与外部系统(如GitHub或Jenkins)集成，用以响应事件。</p>
<h3 id="配置Sensor"><a href="#配置Sensor" class="headerlink" title="配置Sensor"></a>配置Sensor</h3><p>事件源只是监听事件的入口，接下来我们需要通过Sensor将事件与触发操作关联。Sensor负责捕捉事件并触发工作流。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Sensor</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">webhook</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">serviceAccountName:</span> <span class="string">operate-workflow-sa</span></span><br><span class="line">  <span class="attr">dependencies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-dep</span></span><br><span class="line">      <span class="attr">eventSourceName:</span> <span class="string">webhook</span></span><br><span class="line">      <span class="attr">eventName:</span> <span class="string">example</span></span><br><span class="line">  <span class="attr">triggers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">template:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">webhook-workflow-trigger</span></span><br><span class="line">        <span class="attr">k8s:</span></span><br><span class="line">          <span class="attr">operation:</span> <span class="string">create</span></span><br><span class="line">          <span class="attr">source:</span></span><br><span class="line">            <span class="attr">resource:</span></span><br><span class="line">              <span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line">              <span class="attr">kind:</span> <span class="string">Workflow</span></span><br><span class="line">              <span class="attr">metadata:</span></span><br><span class="line">                <span class="attr">generateName:</span> <span class="string">webhook-</span></span><br><span class="line">              <span class="attr">spec:</span></span><br><span class="line">                <span class="attr">entrypoint:</span> <span class="string">whalesay</span></span><br><span class="line">                <span class="attr">arguments:</span></span><br><span class="line">                  <span class="attr">parameters:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">                    <span class="comment"># the value will get overridden by event payload from test-dep</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">hello</span> <span class="string">world</span></span><br><span class="line">                <span class="attr">templates:</span></span><br><span class="line">                <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whalesay</span></span><br><span class="line">                  <span class="attr">inputs:</span></span><br><span class="line">                    <span class="attr">parameters:</span></span><br><span class="line">                    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">                  <span class="attr">container:</span></span><br><span class="line">                    <span class="attr">image:</span> <span class="string">docker/whalesay:latest</span></span><br><span class="line">                    <span class="attr">command:</span> [<span class="string">cowsay</span>]</span><br><span class="line">                    <span class="attr">args:</span> [<span class="string">&quot;<span class="template-variable">&#123;&#123;inputs.parameters.message&#125;&#125;</span>&quot;</span>]</span><br><span class="line">          <span class="attr">parameters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">src:</span></span><br><span class="line">                <span class="attr">dependencyName:</span> <span class="string">test-dep</span></span><br><span class="line">                <span class="attr">dataKey:</span> <span class="string">body</span></span><br><span class="line">              <span class="attr">dest:</span> <span class="string">spec.arguments.parameters.0.value</span></span><br></pre></td></tr></table></figure>



<h3 id="暴露Event-source-pod"><a href="#暴露Event-source-pod" class="headerlink" title="暴露Event-source pod"></a>暴露Event-source pod</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl -n argo-events port-forward svc/webhook-eventsource-svc 12000:12000</span><br></pre></td></tr></table></figure>



<h3 id="触发工作流"><a href="#触发工作流" class="headerlink" title="触发工作流"></a>触发工作流</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -d &#x27;&#123;&quot;message&quot;:&quot;this is my first webhook&quot;&#125;&#x27; -H &quot;Content-Type: application/json&quot; -X POST http://localhost:12000/example</span><br></pre></td></tr></table></figure>

<p>当外部系统(比如GitHub或Jenkins)向EventSource指定的Webhook发送HTTP请求时，Sensor将捕获事件并启动工作流。此时，一个新的工作流将在Kubernetes集群中运行，并执行定义好的任务。</p>
<h3 id="验证工作流"><a href="#验证工作流" class="headerlink" title="验证工作流"></a>验证工作流</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl -n argo-events get workflows | grep &quot;webhook&quot;</span><br></pre></td></tr></table></figure>



<h2 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h2><p>在现实的企业DevOps场景中，Argo Events常用于自动化CI&#x2F;CD流程。例如，某公司利用Argo Events和GitHub Webhook集成，实现代码提交时自动触发Kubernetes集群中的测试工作流。</p>
<p>具体场景如下：</p>
<ul>
<li>开发人员在GitHub上向主分支推送代码。</li>
<li>GitHub的Webhook向Kubernetes集群发送POST请求。</li>
<li>EventSource接收到Webhook请求，并将事件传递给Sensor。</li>
<li>Sensor捕获事件并启动一个CI工作流。</li>
<li>工作流运行集成测试，验证代码的正确性。</li>
<li>测试成功后，工作流自动生成新的Docker镜像并推送到容器注册中心。</li>
</ul>
<p>这一流程实现了完全自动化的持续集成，不仅减少了手动操作的时间，也提高了代码交付的质量和速度。</p>
<h2 id="事件过滤与复杂场景"><a href="#事件过滤与复杂场景" class="headerlink" title="事件过滤与复杂场景"></a>事件过滤与复杂场景</h2><p>在复杂的场景中，往往需要对事件进行过滤和处理。Argo Events支持多种条件来控制何时触发工作流。比如，可以基于事件的内容、时间或其他自定义条件进行过滤。</p>
<p>假设我们只想在特定的时间范围内(比如工作日的9点到18点)触发工作流，我们可以在Sensor中定义时间窗口来限制事件的触发。也可以基于Webhook的数据内容来判断是否执行工作流，进一步增强自动化的灵活性。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">filters:</span></span><br><span class="line">	<span class="attr">time:</span></span><br><span class="line">	  <span class="attr">schedule:</span> <span class="string">&quot;0 9 * * 1-5&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个配置只允许在工作日的9点之后触发工作流，确保在合适的时间内进行自动化操作。</p>
<h2 id="安全性与扩展性"><a href="#安全性与扩展性" class="headerlink" title="安全性与扩展性"></a>安全性与扩展性</h2><p>为了确保系统的安全性，在使用Argo Events时通常会对事件源和传感器进行身份验证和授权。可以在Webhook事件源中增加TLS配置，确保传输安全，或者通过认证机制限制特定来源的请求。</p>
<p>在扩展性方面，Argo Events能够支持大量并发事件。得益于Kubernetes的弹性架构，多个EventSource和Sensor可以并行运行，处理大在规模的事件流。这使得它特别适用于具有复杂事件流和大规模集群的环境，比如金融交易系统、物联网平台等。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>官方文档：<a href="https://argoproj.github.io/argo-events/">https://argoproj.github.io/argo-events/</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Argo Rollouts</title>
    <url>/2025/03/14/argo-rollouts/</url>
    <content><![CDATA[<h2 id="Argo-Rollouts简介"><a href="#Argo-Rollouts简介" class="headerlink" title="Argo Rollouts简介"></a>Argo Rollouts简介</h2><p>Argo Rollouts是一个Kubernetes Operator实现，它为Kubernetes提供更加高级的部署能力，如蓝绿、金丝雀、金丝雀分析、实验和渐进式交付功能，为云原生应用和服务实现自动化、基于GitOps的逐步交付。</p>
<p>支持如下特性：</p>
<ul>
<li>蓝绿更新策略</li>
<li>金丝雀更新策略</li>
<li>更加细粒度、加权流量拆分</li>
<li>自动回滚</li>
<li>手动判断</li>
<li>可定制的指标查询和业务KPI分析</li>
<li>Ingress控制器集成：NGINX，ALB</li>
<li>Metrics指标集成：Prometheus、Wavefront、Kayenta、Web、Kubernetes Jobs、Datadog、New Relic、Graphite、InfluxDB</li>
</ul>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>与Deployment对象类似，Argo Rollout控制器将管理ReplicaSets的创建、缩放和删除，这些ReplicaSet由Rollout资源中的spec.template定义，使用与Deployment对象相同的pod模板。</p>
<p>当spec.template变更时，这会向Argo Rollouts控制器发出信号，表示将引入新的ReplicaSet，控制器将使用spec.strategy字段内的策略来确定从旧ReplicaSet到新ReplicaSet的rollout将如何进行，一旦这个新的ReplicaSet被放大(可以选择通过一个Analysis)，控制器会将其标记为稳定。</p>
<p>如果在spec.template从稳定的ReplicaSet过渡到新的ReplicaSet的过程中发生另一次变更(即在发布过程中更改了应用程序版本)，那么之前的新ReplicaSet将缩小，并且控制器将尝试反映更新spec.template字段的ReplicaSet。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Argo Workflows</title>
    <url>/2023/03/14/argo-workflows/</url>
    <content><![CDATA[<h2 id="Argo-Workflows简介"><a href="#Argo-Workflows简介" class="headerlink" title="Argo Workflows简介"></a>Argo Workflows简介</h2><p>Argo Workflows是一个开源项目，为Kubernetes提供container-native工作流程，其主要通过Kubernetes CRD实现的。</p>
<p>特点如下：</p>
<ul>
<li>工作流的每一步都是一个容器</li>
<li>将多步骤工作流建模为一系列任务，或者使用有向无环图（DAG）描述任务之间的依赖关系</li>
<li>可以在短时间内轻松运行用于机器学习或数据处理的计算密集型作业。</li>
<li>在Kubernetes上运行CI&#x2F;CD Pipeline，无需复杂的软件配置</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装Argo-Workflows"><a href="#安装Argo-Workflows" class="headerlink" title="安装Argo Workflows"></a>安装Argo Workflows</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ARGO_WORKFLOWS_VERSION=&quot;v3.6.5&quot;</span><br><span class="line">kubectl create namespace argo</span><br><span class="line">kubectl apply -n argo -f &quot;https://github.com/argoproj/argo-workflows/releases/download/$&#123;ARGO_WORKFLOWS_VERSION&#125;/quick-start-minimal.yaml&quot;</span><br></pre></td></tr></table></figure>



<h3 id="安装Argo-Workflows-CLI"><a href="#安装Argo-Workflows-CLI" class="headerlink" title="安装Argo Workflows CLI"></a>安装Argo Workflows CLI</h3><p>Mac&#x2F;Linux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Detect OS</span></span><br><span class="line">ARGO_OS=&quot;darwin&quot;</span><br><span class="line">if [[ uname -s != &quot;Darwin&quot; ]]; then</span><br><span class="line">  ARGO_OS=&quot;linux&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Download the binary</span></span><br><span class="line">curl -sLO &quot;https://github.com/argoproj/argo-workflows/releases/download/v3.6.5/argo-$ARGO_OS-amd64.gz&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unzip</span></span><br><span class="line">gunzip &quot;argo-$ARGO_OS-amd64.gz&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Make binary executable</span></span><br><span class="line">chmod +x &quot;argo-$ARGO_OS-amd64&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Move binary to path</span></span><br><span class="line">mv &quot;./argo-$ARGO_OS-amd64&quot; /usr/local/bin/argo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Test installation</span></span><br><span class="line">argo version</span><br></pre></td></tr></table></figure>

<p>argo命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交一个workflow至kubernetes</span></span><br><span class="line">argo submit hello-world.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出当前所有workflows</span></span><br><span class="line">argo list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取某个特定workflow的信息</span></span><br><span class="line">argo get hello-world-xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印某个workflow的日志</span></span><br><span class="line">argo logs hello-world-xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除workflow</span></span><br><span class="line">argo delete hello-world-xxx</span><br></pre></td></tr></table></figure>



<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Workflow"><a href="#Workflow" class="headerlink" title="Workflow"></a>Workflow</h3><p>Workflow是Argo中最重要的资源，其主要有两个重要功能：</p>
<ul>
<li>它定义要执行的工作流</li>
<li>它存储工作流的状态</li>
</ul>
<p>要执行的工作流定义在Workflow.spec字段中，其主要包括templates和entrypoint，如：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Workflow</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">hello-world-</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">workflows.argoproj.io/archive-strategy:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">workflows.argoproj.io/description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      This is a simple hello world example.</span></span><br><span class="line"><span class="string"></span><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoint:</span> <span class="string">hello-world</span>          <span class="comment"># 工作流的入口点，即工作流启动时首先执行的模板</span></span><br><span class="line">  <span class="attr">templates:</span>                       <span class="comment"># 模板</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">echo</span>]</span><br><span class="line">      <span class="attr">args:</span> [<span class="string">&quot;hello world&quot;</span>]</span><br></pre></td></tr></table></figure>



<h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><p>templates是列表结构，主要分为两类：</p>
<ul>
<li>定义具体的工作流</li>
<li>调用其他模板提供并行控制</li>
</ul>
<h4 id="定义具体的工作流"><a href="#定义具体的工作流" class="headerlink" title="定义具体的工作流"></a>定义具体的工作流</h4><p>定义具体的工作流有4种类别，如下：</p>
<ul>
<li>Container</li>
<li>Script</li>
<li>Resource</li>
<li>Suspend</li>
</ul>
<p><strong>Container</strong></p>
<p>container是最常见的模板类型，它将调度一个container，其模板规范和K8S的容器规范相同，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-world</span></span><br><span class="line">  <span class="attr">container:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">echo</span>]</span><br><span class="line">    <span class="attr">args:</span> [<span class="string">&quot;hello world&quot;</span>]</span><br></pre></td></tr></table></figure>



<p><strong>Script</strong></p>
<p>Script是Container的另一种包装实现，其定义方式和Container相同，只是增加了source字段用于自定义脚本，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gen-random-int</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">python:alpine3.6</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">python</span>]</span><br><span class="line">    <span class="attr">source:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      import random</span></span><br><span class="line"><span class="string">      i = random.randint(1, 100)</span></span><br><span class="line"><span class="string">      print(i)</span></span><br></pre></td></tr></table></figure>

<p>脚本的输出结果会根据调用方式自动导出到tasks.{NAME}.outputs.result或steps.{NAME}.outputs.result中。</p>
<p><strong>Resource</strong></p>
<p>Resource主要用于直接在K8S集群上执行集群资源操作，可以get,create,apply,delete,replace,patch集群资源。如下在集群中创建一个ConfigMap类型资源：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">k8s-owner-reference</span></span><br><span class="line">  <span class="attr">resource:</span></span><br><span class="line">    <span class="attr">action:</span> <span class="string">create</span></span><br><span class="line">    <span class="attr">manifest:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      apiVersion: v1</span></span><br><span class="line"><span class="string">      kind: ConfigMap</span></span><br><span class="line"><span class="string">      metadata:</span></span><br><span class="line"><span class="string">        generateName: owned-eg-</span></span><br><span class="line"><span class="string">      data:</span></span><br><span class="line"><span class="string">        some: value</span></span><br></pre></td></tr></table></figure>



<p><strong>Suspend</strong></p>
<p>Suspend主要用于暂停，可以暂停一段时间，也可以手动恢复，命令使用argo resume进行恢复。定义格式如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">delay</span></span><br><span class="line">  <span class="attr">suspend:</span></span><br><span class="line">    <span class="attr">duration:</span> <span class="string">&quot;20s&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="调用其他模板提供并行控制"><a href="#调用其他模板提供并行控制" class="headerlink" title="调用其他模板提供并行控制"></a>调用其他模板提供并行控制</h4><p>调用其他模板也有两种类别：</p>
<ul>
<li>Steps</li>
<li>Dag</li>
</ul>
<p><strong>Steps</strong></p>
<p>Steps主要是通过定义一系列步骤来定义任务，其结构是“list of lists”，外部列表将顺序进行，内部列表将并行执行。如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-hello-hello</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step1</span></span><br><span class="line">      <span class="attr">template:</span> <span class="string">prepare-data</span></span><br><span class="line">  <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step2a</span></span><br><span class="line">      <span class="attr">template:</span> <span class="string">run-data-first-half</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">step2b</span></span><br><span class="line">      <span class="attr">template:</span> <span class="string">run-data-second-half</span></span><br></pre></td></tr></table></figure>

<p>其中step1和step2是顺序执行，而step2a和step2b是并行执行。</p>
<p>还可以通过when来进行条件判断。如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Workflow</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">coinflip-</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoint:</span> <span class="string">coinflip</span></span><br><span class="line">  <span class="attr">templates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">coinflip</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">flip-coin</span></span><br><span class="line">        <span class="attr">template:</span> <span class="string">flip-coin</span></span><br><span class="line">    <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">heads</span></span><br><span class="line">        <span class="attr">template:</span> <span class="string">heads</span></span><br><span class="line">        <span class="attr">when:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;steps.flip-coin.outputs.result&#125;&#125;</span> == heads&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tails</span></span><br><span class="line">        <span class="attr">template:</span> <span class="string">tails</span></span><br><span class="line">        <span class="attr">when:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;steps.flip-coin.outputs.result&#125;&#125;</span> == tails&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">flip-coin</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">python:alpine3.6</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">python</span>]</span><br><span class="line">      <span class="attr">source:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        import random</span></span><br><span class="line"><span class="string">        result = &quot;heads&quot; if random.randint(0,1) == 0 else &quot;tails&quot;</span></span><br><span class="line"><span class="string">        print(result)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">heads</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">alpine:3.6</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">sh</span>, <span class="string">-c</span>]</span><br><span class="line">      <span class="attr">args:</span> [<span class="string">&quot;echo \&quot;it was heads\&quot;&quot;</span>]</span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tails</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">alpine:3.6</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">sh</span>, <span class="string">-c</span>]</span><br><span class="line">      <span class="attr">args:</span> [<span class="string">&quot;echo \&quot;it was tails\&quot;&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>除了使用when进行条件判断，还可以进行循环操作，示例代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Workflow</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">loops-</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoint:</span> <span class="string">loop-example</span></span><br><span class="line">  <span class="attr">templates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">loop-example</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">print-message</span></span><br><span class="line">        <span class="attr">template:</span> <span class="string">whalesay</span></span><br><span class="line">        <span class="attr">arguments:</span></span><br><span class="line">          <span class="attr">parameters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">            <span class="attr">value:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;item&#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">withItems:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">hello</span> <span class="string">world</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">goodbye</span> <span class="string">world</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whalesay</span></span><br><span class="line">    <span class="attr">inputs:</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">docker/whalesay:latest</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">cowsay</span>]</span><br><span class="line">      <span class="attr">args:</span> [<span class="string">&quot;<span class="template-variable">&#123;&#123;inputs.parameters.message&#125;&#125;</span>&quot;</span>]</span><br></pre></td></tr></table></figure>



<p><strong>Dag</strong></p>
<p>Dag主要用于定义任务的依赖关系，可以设置开始特定任务之前必须完成其他任务，没有任何依赖关系的任务将立即执行。示例代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">diamond</span></span><br><span class="line">  <span class="attr">dag:</span></span><br><span class="line">    <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">A</span></span><br><span class="line">      <span class="attr">template:</span> <span class="string">echo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">B</span></span><br><span class="line">      <span class="attr">dependencies:</span> [<span class="string">A</span>]</span><br><span class="line">      <span class="attr">template:</span> <span class="string">echo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">C</span></span><br><span class="line">      <span class="attr">dependencies:</span> [<span class="string">A</span>]</span><br><span class="line">      <span class="attr">template:</span> <span class="string">echo</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">D</span></span><br><span class="line">      <span class="attr">dependencies:</span> [<span class="string">B</span>, <span class="string">C</span>]</span><br><span class="line">      <span class="attr">template:</span> <span class="string">echo</span></span><br></pre></td></tr></table></figure>

<p>其中A会立即执行，B和C会依赖A，D依赖B和C。</p>
<h3 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h3><p>在argo的Workflow中允许使用变量，示例代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Workflow</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">hello-world-parameters-</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoint:</span> <span class="string">whalesay</span></span><br><span class="line">  <span class="attr">arguments:</span></span><br><span class="line">    <span class="attr">parameters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">hello</span> <span class="string">world</span></span><br><span class="line">  <span class="attr">templates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whalesay</span></span><br><span class="line">      <span class="attr">inputs:</span></span><br><span class="line">        <span class="attr">parameters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">      <span class="attr">container:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker/whalesay</span></span><br><span class="line">        <span class="attr">command:</span> [ <span class="string">cowsay</span> ]</span><br><span class="line">        <span class="attr">args:</span> [ <span class="string">&quot;<span class="template-variable">&#123;&#123;inputs.parameters.message&#125;&#125;</span>&quot;</span> ] </span><br></pre></td></tr></table></figure>

<p>首先在spec字段定义arguments，定义变量message，其值是hello world，然后在templates字段中需要先定义一个inputs字段，用于templates的输入参数，然后再使用双大括号形式引用变量。</p>
<p>变量还可以进行一些函数运算，主要有：</p>
<ul>
<li>filter: 过滤</li>
<li>asInt: 转换为Int</li>
<li>asFloat: 转换为float</li>
<li>string: 转换为String</li>
<li>toJson: 转换为Json</li>
</ul>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filter([1, 2], &#123; # &gt; 1&#125;)</span><br><span class="line">asInt(inputs.parameters[&quot;my-int-param&quot;])</span><br><span class="line">asFloat(inputs.parameters[&quot;my-float-param&quot;])</span><br><span class="line">string(1)</span><br><span class="line">toJson([1, 2])</span><br></pre></td></tr></table></figure>



<h3 id="制品库"><a href="#制品库" class="headerlink" title="制品库"></a>制品库</h3><p>在安装argo的时候，已经安装了minio作为制品库，那么到底该如何使用呢？</p>
<p>示例代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Workflow</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">artifact-passing-</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoint:</span> <span class="string">artifact-example</span></span><br><span class="line">  <span class="attr">templates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">artifact-example</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">generate-artifact</span></span><br><span class="line">        <span class="attr">template:</span> <span class="string">whalesay</span></span><br><span class="line">    <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">consume-artifact</span></span><br><span class="line">        <span class="attr">template:</span> <span class="string">print-message</span></span><br><span class="line">        <span class="attr">arguments:</span></span><br><span class="line">          <span class="attr">artifacts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">            <span class="attr">from:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;steps.generate-artifact.outputs.artifacts.hello-art&#125;&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whalesay</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">docker/whalesay:latest</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">sh</span>, <span class="string">-c</span>]</span><br><span class="line">      <span class="attr">args:</span> [<span class="string">&quot;sleep 1; cowsay hello world | tee /tmp/hello_world.txt&quot;</span>]</span><br><span class="line">    <span class="attr">outputs:</span></span><br><span class="line">      <span class="attr">artifacts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello-art</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/tmp/hello_world.txt</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">print-message</span></span><br><span class="line">    <span class="attr">inputs:</span></span><br><span class="line">      <span class="attr">artifacts:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/tmp/message</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">alpine:latest</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">sh</span>, <span class="string">-c</span>]</span><br><span class="line">      <span class="attr">args:</span> [<span class="string">&quot;cat /tmp/message&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>其分为两步：</p>
<ul>
<li>首先生成制品</li>
<li>然后获取制品</li>
</ul>
<h3 id="WorkflowTemplate"><a href="#WorkflowTemplate" class="headerlink" title="WorkflowTemplate"></a>WorkflowTemplate</h3><p>WorkflowTemplate是Workflow的模板，可以从WorkflowTemplate内部或集群上其他Workflow和WorkflowTemplate引用它们。</p>
<p>WorkflowTemplate和template的区别：</p>
<ul>
<li>template只是Workflow中template下的一个任务，当我们定义一个Workflow时，至少需要定义一个template</li>
<li>WorkflowTemplate是驻留在集群中的Workflow的定义，它是Workflow的定义，因为它包含模板，可以从WorkflowTemplate内部或集群上其他Workflow和WorkflowTemplate引用它们。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">WorkflowTemplate</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">workflow-template-1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoint:</span> <span class="string">whalesay-template</span></span><br><span class="line">  <span class="attr">arguments:</span></span><br><span class="line">    <span class="attr">parameters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">hello</span> <span class="string">world</span></span><br><span class="line">  <span class="attr">templates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whalesay-template</span></span><br><span class="line">      <span class="attr">inputs:</span></span><br><span class="line">        <span class="attr">parameters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">      <span class="attr">container:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">docker/whalesay</span></span><br><span class="line">        <span class="attr">command:</span> [<span class="string">cowsay</span>]</span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&quot;<span class="template-variable">&#123;&#123;inputs.parameters.message&#125;&#125;</span>&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>创建WorkflowTemplate，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">argo template create workflowtemplate.yaml</span><br></pre></td></tr></table></figure>

<p>在Workflow中引用，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Workflow</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">workflow-template-hello-world-</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoint:</span> <span class="string">whalesay</span></span><br><span class="line">  <span class="attr">templates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whalesay</span></span><br><span class="line">    <span class="attr">steps:</span>                              <span class="comment"># 引用模板必须在steps/dag/template下</span></span><br><span class="line">      <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">call-whalesay-template</span></span><br><span class="line">          <span class="attr">templateRef:</span>                  <span class="comment"># 应用模板字段</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">workflow-template-1</span>   <span class="comment"># WorkflowTemplate名</span></span><br><span class="line">            <span class="attr">template:</span> <span class="string">whalesay-template</span> <span class="comment"># 具体的template名</span></span><br><span class="line">          <span class="attr">arguments:</span>                    <span class="comment"># 参数</span></span><br><span class="line">            <span class="attr">parameters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="ClusterWorkflowTemplate"><a href="#ClusterWorkflowTemplate" class="headerlink" title="ClusterWorkflowTemplate"></a>ClusterWorkflowTemplate</h3><p>ClusterWorkflowTemplate创建的是一个集群范围内的WorkflowTemplate，其他workflow可以引用它。</p>
<p>示例代码如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterWorkflowTemplate</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-workflow-template-whalesay-template</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">templates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whalesay-template</span></span><br><span class="line">    <span class="attr">inputs:</span></span><br><span class="line">      <span class="attr">parameters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">    <span class="attr">container:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">docker/whalesay</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">cowsay</span>]</span><br><span class="line">      <span class="attr">args:</span> [<span class="string">&quot;<span class="template-variable">&#123;&#123;inputs.parameters.message&#125;&#125;</span>&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>在workflow中使用templateRef去引用它，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Workflow</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">workflow-template-hello-world-</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoint:</span> <span class="string">whalesay</span></span><br><span class="line">  <span class="attr">templates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">whalesay</span></span><br><span class="line">    <span class="attr">steps:</span>          </span><br><span class="line">      <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">call-whalesay-template</span></span><br><span class="line">          <span class="attr">templateRef:</span>                  <span class="comment">#引用模板</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">cluster-workflow-template-whalesay-template</span>   <span class="comment"># ClusterWorkflow名</span></span><br><span class="line">            <span class="attr">template:</span> <span class="string">whalesay-template</span> <span class="comment"># 具体的模板名</span></span><br><span class="line">            <span class="attr">clusterScope:</span> <span class="literal">true</span>          <span class="comment"># 表示是ClusterWorkflow</span></span><br><span class="line">          <span class="attr">arguments:</span>                    <span class="comment">#  参数</span></span><br><span class="line">            <span class="attr">parameters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">message</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>以简单的CI&#x2F;CD流程实践，来实践argo workflow应该如何做。</p>
<p>CI&#x2F;CD的整个流程很简单，即：拉代码—&gt;编译—&gt;构建镜像—&gt;上传镜像—&gt;部署。</p>
<p>定义一个workflowTemplate，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">WorkflowTemplate</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">workflows.argoproj.io/description:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      Checkout out from Git, build and deploy application.</span></span><br><span class="line"><span class="string"></span>    <span class="attr">workflows.argoproj.io/maintainer:</span> <span class="string">&#x27;@joker&#x27;</span></span><br><span class="line">    <span class="attr">workflows.argoproj.io/tags:</span> <span class="string">java,</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">workflows.argoproj.io/version:</span> <span class="string">&#x27;&gt;= 2.9.0&#x27;</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">devops-java</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">entrypoint:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">arguments:</span></span><br><span class="line">    <span class="attr">parameters:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">gitlab-test.coolops.cn:32080/root/springboot-helloworld.git</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">branch</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">image</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/rookieops/myapp:202103101613</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache-image</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/rookieops/myapp</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dockerfile</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">Dockerfile</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">devops-cd-repo</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">gitlab-test.coolops.cn:32080/root/devops-cd.git</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gitlabUsername</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">devops-argo</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">gitlabPassword</span></span><br><span class="line">        <span class="attr">value:</span> <span class="string">devops123456</span></span><br><span class="line">  <span class="attr">templates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">main</span></span><br><span class="line">      <span class="attr">steps:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">            <span class="attr">template:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">            <span class="attr">template:</span> <span class="string">Build</span></span><br><span class="line">        <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">BuildImage</span></span><br><span class="line">            <span class="attr">template:</span> <span class="string">BuildImage</span></span><br><span class="line">        <span class="bullet">-</span> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">            <span class="attr">template:</span> <span class="string">Deploy</span></span><br><span class="line">    <span class="comment"># 拉取代码</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">      <span class="attr">script:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/rookieops/maven:3.5.0-alpine</span></span><br><span class="line">        <span class="attr">workingDir:</span> <span class="string">/work</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sh</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          git clone --branch &#123;&#123;workflow.parameters.branch&#125;&#125; http://&#123;&#123;workflow.parameters.gitlabUsername&#125;&#125;:&#123;&#123;workflow.parameters.gitlabPassword&#125;&#125;@&#123;&#123;workflow.parameters.repo&#125;&#125; .</span></span><br><span class="line"><span class="string"></span>        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/work</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">work</span></span><br><span class="line">    <span class="comment"># 编译打包  </span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">      <span class="attr">script:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/rookieops/maven:3.5.0-alpine</span></span><br><span class="line">        <span class="attr">workingDir:</span> <span class="string">/work</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sh</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">mvn</span> <span class="string">-B</span> <span class="string">clean</span> <span class="string">package</span> <span class="string">-Dmaven.test.skip=true</span> <span class="string">-Dautoconfig.skip</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/work</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">work</span></span><br><span class="line">    <span class="comment"># 构建镜像  </span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">BuildImage</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-config</span></span><br><span class="line">        <span class="attr">secret:</span></span><br><span class="line">          <span class="attr">secretName:</span> <span class="string">docker-config</span></span><br><span class="line">      <span class="attr">container:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/rookieops/kaniko-executor:v1.5.0</span></span><br><span class="line">        <span class="attr">workingDir:</span> <span class="string">/work</span></span><br><span class="line">        <span class="attr">args:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--context=.</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--dockerfile=&#123;&#123;workflow.parameters.dockerfile&#125;&#125;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--destination=&#123;&#123;workflow.parameters.image&#125;&#125;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--skip-tls-verify</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--reproducible</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--cache=true</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">--cache-repo=&#123;&#123;workflow.parameters.cache-image&#125;&#125;</span></span><br><span class="line">        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/work</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">work</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">docker-config</span></span><br><span class="line">            <span class="attr">mountPath:</span> <span class="string">/kaniko/.docker/</span></span><br><span class="line">    <span class="comment"># 部署  </span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">      <span class="attr">script:</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com/rookieops/kustomize:v3.8.1</span></span><br><span class="line">        <span class="attr">workingDir:</span> <span class="string">/work</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">sh</span></span><br><span class="line">        <span class="attr">source:</span> <span class="string">|</span></span><br><span class="line"><span class="string">           git remote set-url origin http://&#123;&#123;workflow.parameters.gitlabUsername&#125;&#125;:&#123;&#123;workflow.parameters.gitlabPassword&#125;&#125;@&#123;&#123;workflow.parameters.devops-cd-repo&#125;&#125;</span></span><br><span class="line"><span class="string">           git config --global user.name &quot;Administrator&quot;</span></span><br><span class="line"><span class="string">           git config --global user.email &quot;coolops@163.com&quot;</span></span><br><span class="line"><span class="string">           git clone http://&#123;&#123;workflow.parameters.gitlabUsername&#125;&#125;:&#123;&#123;workflow.parameters.gitlabPassword&#125;&#125;@&#123;&#123;workflow.parameters.devops-cd-repo&#125;&#125; /work/devops-cd</span></span><br><span class="line"><span class="string">           cd /work/devops-cd</span></span><br><span class="line"><span class="string">           git pull</span></span><br><span class="line"><span class="string">           cd /work/devops-cd/devops-simple-java</span></span><br><span class="line"><span class="string">           kustomize edit set image &#123;&#123;workflow.parameters.image&#125;&#125;</span></span><br><span class="line"><span class="string">           git commit -am &#x27;image update&#x27;</span></span><br><span class="line"><span class="string">           git push origin master</span></span><br><span class="line"><span class="string"></span>        <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/work</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">work</span></span><br><span class="line">  <span class="attr">volumeClaimTemplates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">work</span></span><br><span class="line">      <span class="attr">metadata:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">work</span></span><br><span class="line">      <span class="attr">spec:</span></span><br><span class="line">        <span class="attr">storageClassName:</span> <span class="string">nfs-client-storageclass</span></span><br><span class="line">        <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">storage:</span> <span class="string">1Gi</span> </span><br></pre></td></tr></table></figure>

<p>使用kaniko来创建镜像，不用挂载docker.sock，但是push镜像的时候需要config.json，所以首先需要创建一个secret，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="string">secret</span> <span class="string">generic</span> <span class="string">docker-config</span> <span class="string">--from-file=.docker/config.json</span> <span class="string">-n</span> <span class="string">argo</span></span><br></pre></td></tr></table></figure>

<p>创建WorkflowTemplate，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">argo</span> <span class="string">template</span> <span class="string">create</span> <span class="string">-n</span> <span class="string">argo</span> <span class="string">devops-java.yaml</span></span><br></pre></td></tr></table></figure>

<p>创建Workflow，可以手动创建，如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">argoproj.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Workflow</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">workflow-template-devops-java-</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">workflowTemplateRef:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">devops-java</span></span><br></pre></td></tr></table></figure>



<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>官方文档：<a href="https://argo-workflows.readthedocs.io/en/latest/">https://argo-workflows.readthedocs.io/en/latest/</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s网络组件-Flannel</title>
    <url>/2022/03/31/k8s-Flannel%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="Flannel概述"><a href="#Flannel概述" class="headerlink" title="Flannel概述"></a>Flannel概述</h2><p>Flannel是CoreOS维护的一个网络组件，Flannel为每个Pod提供全局唯一的IP，Flannel使用ETCD来存储Pod子网与NodeIP之间的关系。Flannel守护进程在每台主机上运行，并负责维护ETCD信息和路由数据包。</p>
<h2 id="Flannel部署"><a href="#Flannel部署" class="headerlink" title="Flannel部署"></a>Flannel部署</h2><h3 id="默认配置部署"><a href="#默认配置部署" class="headerlink" title="默认配置部署"></a>默认配置部署</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://github.com/flannel-io/flannel/releases/latest/download/kube-flannel.yml</span><br></pre></td></tr></table></figure>



<h3 id="定制化部署"><a href="#定制化部署" class="headerlink" title="定制化部署"></a>定制化部署</h3><p>kubeadm部署时指定Pod网段:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure>

<p>指定controller-manager中配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /opt/kubernetes/cfg/kube-controller-manager.conf</span><br><span class="line">--allocate-node-cidrs=true \    # 允许node自动分配网络</span><br><span class="line">--cluster-cidr=10.244.0.0/16 \  # 指定Pod网络网段，需要与Flannel网段对应</span><br></pre></td></tr></table></figure>

<p>Flannel配置文件中配置Flannel网段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kube-flannel.yml</span></span><br><span class="line">net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,    # Flannel网段</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;    # 工作模式</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>kubelet开启cni支持：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/opt/kubernetes/cfg/kubelet.conf</span></span><br><span class="line">KUBELET_OPTS=&quot;--logtostderr=false \</span><br><span class="line">--v=4 \</span><br><span class="line">--log-dir=/opt/kubernetes/logs \</span><br><span class="line">--network-plugin=cni \    # 开启cni支持</span><br><span class="line">...</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>



<h2 id="Flannel工作模式及原理"><a href="#Flannel工作模式及原理" class="headerlink" title="Flannel工作模式及原理"></a>Flannel工作模式及原理</h2><h3 id="Flannel网络模型"><a href="#Flannel网络模型" class="headerlink" title="Flannel网络模型"></a>Flannel网络模型</h3><p>Flannel会为每个节点分配一个独立的子网(Pod CIDR)如10.244.1.0&#x2F;24，节点上的所有Pod从该子网获取IP。</p>
<p>Flannel支持多种数据转发方式：</p>
<ul>
<li>UDP：最早支持的一种方式。由于性能最差，目前已经弃用。</li>
<li>VXLAN（默认方式）：Overlay Network方案，源数据包封装在另一种网络包里面进行路由转发和通信。</li>
<li>Host-GW：Flannel通过在各个节点上的Agent进程，将容器网络的路由信息刷到主机的路由表上，这样一来所有的主机都有整个容器网络的路由数据了。</li>
</ul>
<h3 id="同一节点内Pod通信流程"><a href="#同一节点内Pod通信流程" class="headerlink" title="同一节点内Pod通信流程"></a>同一节点内Pod通信流程</h3><p>特点：全程无封包&#x2F;解包，不经过Flannel的Overlay（如VXLAN），延迟极低(等同主机内进程通信)。</p>
<img src="/2022/03/31/k8s-Flannel%E5%8E%9F%E7%90%86/2025-03-31_16-08.png" class="">

<p>通信步骤：</p>
<p>1）Pod 1发起请求</p>
<p>数据包从Pod 1的eth0发出，源IP：10.244.1.10，目的IP：10.244.1.11。</p>
<p>2）数据包到达主机网格栈</p>
<p>pod和缩主机网络通过veth pair组件连接，实现跨网络命名空间通信。Pod的eth0是veth pair的一端，另一端在主机命名空间(vethxxxx)。</p>
<p>pod 1的eth0对端是主机的vethxxxx，数据包通过此虚拟设备进入主机内核协议栈。</p>
<p>主机路由表(ip route show)  包含了Flannel添加的路由规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip route show | grep cni0</span></span><br><span class="line">10.244.1.0/24 dev cni0 proto kernel scope link src 10.244.1.10</span><br></pre></td></tr></table></figure>

<p>目标IP匹配了该路由，数据包被转发到cni0网桥。</p>
<p>3）通过cni0网桥直达pod 2</p>
<p>cni0是节点上所有pod的共享网桥，维护MAC地址表。</p>
<p>数据包通过网桥直接转发到Pod 2对应的Vethxxxx(无需ARP查询，因MAC地址已学习)。</p>
<p>4）数据包进入pod 2的eth0</p>
<p>通过vethxxxx进入pod 2的eth0，完成通信。</p>
<p>验证命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看网桥连接的veth</span></span><br><span class="line">brctl show cni0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看具体的veth对</span></span><br><span class="line">ip link show vethxxxx</span><br></pre></td></tr></table></figure>



<h3 id="跨节点Pod通信流程（VXLAN模式）"><a href="#跨节点Pod通信流程（VXLAN模式）" class="headerlink" title="跨节点Pod通信流程（VXLAN模式）"></a>跨节点Pod通信流程（VXLAN模式）</h3> <img src="/2022/03/31/k8s-Flannel%E5%8E%9F%E7%90%86/2025-03-31_17-03.png" class="">

<p>通信步骤：</p>
<p>1）Pod 1发起请求</p>
<p>数据包从Pod 1的eth0发出(源IP：10.244.1.10，目标IP：10.244.2.10)，通过veth pair进入节点的主机网络栈。</p>
<p>2）节点1内核路由表匹配</p>
<p>节点通过目标IP(10.244.2.10)匹配路由，数据包被转发到flannel.1设备。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip route show</span></span><br><span class="line">10.244.0.0/16 via 10.244.0.0 dev flannel.1</span><br></pre></td></tr></table></figure>

<p>3）ARP解析</p>
<p>节点1查询flannel.1的ARP表，获取目标Pod所在节点2的flannel.1设备的MAC地址。通过节点1查询FDB表可查询节点2 Fannel.1 MAC地址对应节点IP。Flannel通过Kubernetes API或etcd维护节点间的ARP和FDB（Forwarding Database）表。</p>
<p>查看节点flannel.1的ARP表和FDB：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看ARP表</span></span><br><span class="line">[root@localhost ~]# ip neigh show dev flannel.1</span><br><span class="line">10.244.1.0 lladdr ca:2a:a4:59:b6:55 PERMANENT</span><br><span class="line">10.244.2.0 lladdr d2:d0:1b:a7:a9:cd PERMANENT</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看fdb表</span></span><br><span class="line">[root@localhost ~]# bridge fdb show  dev flannel.1</span><br><span class="line">d2:d0:1b:a7:a9:cd dst 192.168.31.61 self permanent</span><br><span class="line">ca:2a:a4:59:b6:55 dst 192.168.31.63 self permanent</span><br></pre></td></tr></table></figure>

<p>4）VXLAN封装</p>
<p>封装外层报文(外层源IP：192.168.31.62，外层目标IP：192.168.31.63，VXLAN Header：VNI（VXLAN Network Identifier, 默认为1）标识Flannel网络)，内层仍为pod 1至pod 2的IP报文。</p>
<p>5）通过物理网络传输</p>
<p>封装后的UDP报文（默认端口8472）通过节点1的物理网卡（如eth0）发出，经过底层网络（如交换机、路由器）到达节点2。</p>
<p>6）节点2解封装</p>
<p>节点2的eth0收到UDP报文(目标端口8472)，内核识别VXLAN报文（根据VNI标识），剥离外层IP&#x2F;UDP头，根据VNI将内层数据包交给flannel.1。</p>
<p>VXLAN封包&#x2F;解封包是由VTEP设备处理的。</p>
<p>7）路由到目标Pod 2</p>
<p>节点2根据路由表将数据包导向cni0网桥。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ip route show | grep cni0</span></span><br><span class="line">10.244.2.0/24 dev cni0 proto kernel scope link src 10.244.2.1</span><br></pre></td></tr></table></figure>

<p>通过cni0和veth pair将数据包转发到Pod 2的eth0。</p>
<h3 id="跨节点Pod通信流程-Host-GW模式"><a href="#跨节点Pod通信流程-Host-GW模式" class="headerlink" title="跨节点Pod通信流程(Host-GW模式)"></a>跨节点Pod通信流程(Host-GW模式)</h3><p>Flannel的host-gw模式是一种高性能的Kubernetes网络插件工作模式，它通过主机的路由表直接转发跨节点Pod的流量，无需封装(如VXLAN或IPIP)，原理类似于静态路由配置。</p>
<p>优点：</p>
<ul>
<li>高性能：由于不涉及封包和解包，性能损失很小。</li>
<li>简单实现：直接通过路由表进行数据转发，无需隧道技术。</li>
</ul>
<p>缺点：</p>
<ul>
<li>网络要求高：宿主机之间必须二层网络连通，要求集群所有节点处于同一网络中。</li>
<li>路由表复杂：在大规模集群中，路由表的动态更新存在一定压力。</li>
</ul>
<img src="/2022/03/31/k8s-Flannel%E5%8E%9F%E7%90%86/2025-04-01_12-06.png" class="">

<p>通信步骤：</p>
<p>1）Pod 1发起请求</p>
<p>数据包从Pod 1的eth0发出(源IP：10.244.1.10，目标IP：10.244.2.10)，通过veth pair进入节点的主机网络栈。</p>
<p>2）节点1内核路由表匹配</p>
<p>节点1根据路由表匹配到10.244.1.0&#x2F;24的下一跳是192.168.31.63(节点2)。</p>
<p>3）通过物理网络传输</p>
<p>节点1通过物理网络(如eth0)直接将流量发给节点B。</p>
<p>4）节点2内核路由表匹配</p>
<p>节点B收到流量后，根据本地路由表将流量转发到cni0，继而转发至Pod 2。</p>
<h3 id="VXLAN与Host-GW模式对比"><a href="#VXLAN与Host-GW模式对比" class="headerlink" title="VXLAN与Host-GW模式对比"></a>VXLAN与Host-GW模式对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>VXLAN</th>
<th>Host-GW</th>
</tr>
</thead>
<tbody><tr>
<td>跨VLAN支持</td>
<td>支持</td>
<td>不支持(需一二层网络)</td>
</tr>
<tr>
<td>性能</td>
<td>较低(封装开销)</td>
<td>高(直接路由)</td>
</tr>
<tr>
<td>配置复杂度</td>
<td>低(自动隧道)</td>
<td>中(需路由可达)</td>
</tr>
<tr>
<td>底层网络要求</td>
<td>仅需UDP 8472端口</td>
<td>需节点间二层互通</td>
</tr>
<tr>
<td>适用场景</td>
<td>云环境、跨子网</td>
<td>裸机、同机房集群</td>
</tr>
</tbody></table>
<p>参考</p>
<ul>
<li><a href="https://bbs.huaweicloud.com/blogs/432292">Flannel网络分析</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s-k8s安装</title>
    <url>/2025/04/16/k8s-k8s%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="kind安装方式"><a href="#kind安装方式" class="headerlink" title="kind安装方式"></a>kind安装方式</h2><h3 id="kind安装"><a href="#kind安装" class="headerlink" title="kind安装"></a>kind安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ $(uname -m) = x86_64 ] &amp;&amp; curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.27.0/kind-linux-amd64</span><br><span class="line">chmod +x ./kind</span><br><span class="line">sudo mv ./kind /usr/local/bin/kind</span><br></pre></td></tr></table></figure>



<h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>1）创建集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认name创建集群</span></span><br><span class="line">kind create cluster</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定name创建集群</span></span><br><span class="line">kind create cluster --name kind-2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定配置文件创建集群（用于配置多节点）</span></span><br><span class="line">kind create cluster --config config.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看集群</span></span><br><span class="line">kind get clusters</span><br><span class="line">kind</span><br><span class="line">kind-2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubectl指定context</span></span><br><span class="line">kubectl cluster-info --context kind-kind</span><br></pre></td></tr></table></figure>



<p>2）配置集群（高可用）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# more config.yaml</span><br><span class="line">kind: Cluster</span><br><span class="line">apiVersion: kind.x-k8s-io/v1alpha4</span><br><span class="line">nodes:</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: control-plane</span><br><span class="line">- role: worker</span><br><span class="line">- role: worker</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# kind create cluster --config config.yaml</span><br></pre></td></tr></table></figure>



<p>3）删除集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除name为kind集群</span></span><br><span class="line">kind delete cluster </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除name为kind-2集群</span></span><br><span class="line">kind delete cluster --name kind-2</span><br></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li></li>
</ul>
<h2 id="Minikube安装方式"><a href="#Minikube安装方式" class="headerlink" title="Minikube安装方式"></a>Minikube安装方式</h2>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s网络组件-calico</title>
    <url>/0202/04/01/k8s%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-calico/</url>
    <content><![CDATA[<h2 id="Calico概述"><a href="#Calico概述" class="headerlink" title="Calico概述"></a>Calico概述</h2><p>Calico是一个纯三层的数据中心网络方案，Calico支持广泛的平台，包括Kubernetes、OpenStack等。</p>
<p>Calico在每一个计算节点利用Linux Kernel实现了一个高效的虚拟路由器(yRouter)来负责数据转发，而每个yRouter通过BGP协议负责把自己运行的workload的路由信息向整个Calico网络内传播。</p>
<p>此外，Calico项目还实现了Kubernetes网络策略，提供ACL功能。</p>
<h2 id="BGP概述"><a href="#BGP概述" class="headerlink" title="BGP概述"></a>BGP概述</h2><p>实际上，Calico项目提供的网络解决方案，与Flannel的host-gw模式几乎一样。也就是说，Calico也是基于路由表实现容器数据包转发，但不同于Flannel使用Flannel进程来维护路由信息的做法，Calico项目使用BGP协议来自动维护整个集群的路由信息。</p>
<p>BGP英文全称是Border Gateway Protocol，即边界网关协议，它是一种自治系统间的动态路由发现协议，与其他BGP系统交换网络可达信息。</p>
<p>为了能让你更清楚理解BGP，举个例子：</p>
<img src="/0202/04/01/k8s%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-calico/2025-04-02_05-42.png" class="">

<p>在这个图中，有两个自治系统(autonomous system，简称为AS)：AS 1和AS 2。</p>
<p>在互联网中，一个自治系统(AS)是一个有权自主决定在本系统中应用何种路由协议的小型单位。这个网络单位可以是一个简单的网络，也可以是一个由一个或多个普通的网络管理员来控制的网络群体，它是一个单独的可管理的网络单元(例如一所大学，一个企业或者一个公司个体)。一个自治系统有时也被称为一个路由选择域(routing domain)。一个自治系统将会分配一个全局的唯一的16位号码，有时我们把这个号码叫做自治系统号(ASN)。</p>
<p>在正常情况下，自治系统之间不会有任何来往。如果两个自治系统里的主机要通过IP地址直接进行通信。我们就必须使用路由器把这两个自治系统连接起来，BGP协议就是让他们互联的一种方式。</p>
<h2 id="Calico-BGP模式"><a href="#Calico-BGP模式" class="headerlink" title="Calico BGP模式"></a>Calico BGP模式</h2><h3 id="Calico-BGP实现"><a href="#Calico-BGP实现" class="headerlink" title="Calico BGP实现"></a>Calico BGP实现</h3><img src="/0202/04/01/k8s%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-calico/2025-04-02_06-10.png" class="">

<p>Calico主要由三部分组成：</p>
<ul>
<li>Felix：以DaemonSet方式部署，运行在每一个Node节点上，主要负责维护宿主机上路由规则以及ACL实现。</li>
<li>BGP Client(BIRD)：主要负责把Felix写入Kernel的路由信息分发到集群Calico网络。</li>
<li>Etcd：分布式键值存储，保存Calico的策略和网络配置状态。</li>
<li>calicoctl：允许你从简单的命令行界面实现高级策略和网络。</li>
</ul>
<h3 id="Calico-BGP原理"><a href="#Calico-BGP原理" class="headerlink" title="Calico BGP原理"></a>Calico BGP原理</h3><img src="/0202/04/01/k8s%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-calico/2025-04-02_06-17.png" class="">

<p>Pod 1访问Pod 2大致流程如下：</p>
<ul>
<li>数据包从容器1出，到达Veth Pair另一端(宿主机上，以cali前缀开头)。</li>
<li>宿主机根据路由规则，将数据包转发给下一跳(网关)。</li>
<li>到达Node 2，根据路由规则将数据包转发给cali设备，从而到达容器2。</li>
</ul>
<p>其中，这里最核心的“下一跳”路由规则，就是由Calico的Felix进程负责维护的，这些路由规则信息，则是通过BGP Client也就是BIRD组件，使用BGP协议传输而来的。</p>
<p>不难发现，Calico项目实际上将集群里的所有节点，都当作是连边界路由器来处理，它们一起组成了一个全连通的网络，互相之间通过BGP协议交换路由规则，这些节点，我们称为BGP Peer。</p>
<h2 id="Calico-IPIP模式"><a href="#Calico-IPIP模式" class="headerlink" title="Calico IPIP模式"></a>Calico IPIP模式</h2><h3 id="IPIP原理"><a href="#IPIP原理" class="headerlink" title="IPIP原理"></a>IPIP原理</h3><img src="/0202/04/01/k8s%E7%BD%91%E7%BB%9C%E7%BB%84%E4%BB%B6-calico/2025-04-02_06-32.png" class="">

<p>Pod 1访问Pod 2大致流程如下：</p>
<ul>
<li>数据包从容器1出，到达Veth Pair另一端(宿主机上，以cali前缀开头)。</li>
<li>进入IP隧道设备（tunl0），由Linux内核IPIP驱动封装在宿主机网络的IP包中（新的IP包目的地址是原IP包的下一跳地址，即192.168.32.63），这样就成Node1到Node2的数据包。</li>
<li>数据包经过路由器三层转发到Node2。</li>
<li>Node2收到数据包后，网络协议栈会使用IPIP驱动进行解包，从中拿到原的IP包。</li>
<li>然后根据路由规则，根据路由规则将数据包转发给cali设备，从而到达容器2。</li>
</ul>
<p>不难看到，当Calico使用IPIP模式的时候，集群的网络性能会因为额外的封包和解包工作而下降，所以建议你将所有宿主机节点放在一个子网里，避免使用IPIP。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>基本原理</title>
    <url>/2024/03/29/kafka-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="Kafka概念"><a href="#Kafka概念" class="headerlink" title="Kafka概念"></a>Kafka概念</h2><p>Kafka是最初由Linkedin公司开发，是一个分布式、支持分区（partition）的、多副本（replica）和基于zookeeper协调的分布式消息系统。它的最大的特性就是可以<strong>实时</strong>的处理大量数据以满足各种需求场景比如基于hadoop的批处理系统、低延迟的实时系统、storm&#x2F;Spark流式处理引擎、web&#x2F;nginx日志、访问日志和消息服务等等。用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p>
<h3 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h3><p>当今社会各种应用系统诸如商业、社交、搜索、浏览等像信息工厂一样不断的生产出各种信息，在大数据时代，我们面临如下几个挑战：</p>
<ul>
<li>如何收集这些巨大的信息</li>
<li>如何分析它</li>
<li>如何及时做到如上两点</li>
</ul>
<p>以上几种挑战形成了一个业务需求模型，即生产者生产（produce）各种信息，消费者消费（consume）（处理分析）这些信息，而在生产者与消费者之间，需要一个沟通两者的桥梁——消息系统。从一个微观层面来说，这种需求也可理解为不同的系统之间如何传递消息。</p>
<p>kafka即是解决上述这类问题的一个框架，它实现了生产者和消费者之间的无缝连接。</p>
<h3 id="Kafka特性"><a href="#Kafka特性" class="headerlink" title="Kafka特性"></a>Kafka特性</h3><ul>
<li>高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几这毫秒。</li>
<li>可扩展性：kafka集群支持热扩展。</li>
<li>持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失。</li>
<li>容错性：允许集群中节点失败（若副本数量为n，则允许n-1节点失败）。</li>
<li>高并发：支持数千个客户端同时读写。</li>
</ul>
<h3 id="Kafka场景应用"><a href="#Kafka场景应用" class="headerlink" title="Kafka场景应用"></a>Kafka场景应用</h3><ul>
<li>日志收集：可以用kafka收集各种服务的log，通过kafka以统一接口服务的方式开放给各种消费者，例如hadoop、Hbase、Solr等。</li>
<li>消息系统：解耦生产者和消费者和缓存消息等。</li>
<li>用户活动跟踪：kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到hadoop、数据仓库中做离线分析和挖掘。</li>
<li>运营指标：kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。</li>
<li>流式处理：比如spark streaming和storm</li>
<li>事件源</li>
</ul>
<h3 id="Kafka重要设计思想"><a href="#Kafka重要设计思想" class="headerlink" title="Kafka重要设计思想"></a>Kafka重要设计思想</h3><ul>
<li>Consumergroup：各个consumer可以组成一个组，每个消息只能被组中的一个Consumer消费，如果一个消息可以被多个Consumer消费的话，那么这些Consumer必须在不同的组。</li>
<li>消息状态：在kafka中，消息的状态被保存在Consumer中，broker不会关心哪个消息被消费了，被谁消费了，只记录一个offset值（指向partition中下一个要被消费的消息位置），这就意味着如果Consumer处理不好的话，broker上的一个消息可能会被消费多次。</li>
<li>消息持久化：kafka中会把消息持久化到本地文件系统中，并且保持极高的效率。</li>
<li>消息有效期：kafka会长久保留其中的消息，以便Consumer可以多次消费，当然其中很多细节是可配置的。</li>
<li>批量发送：kafka支持以消息集合为单位进行批量发送，以提高push效率。</li>
<li>push-and-pull：kafka中的Producer和Consumer采用的是push-and-pull模式，即Producer只管向broker push消息，Consumer只管从broker pull消息，两者对消息的生产和消费是异步的。</li>
<li>kafka集群中的broker之间的关系：不是主从关系，各个broker在集群中地位一样，我们可以随意的增加或删除任何一个broker节点。</li>
<li>负载均衡方面：kafka提供了一个metadata API来管理broker之间的负载。</li>
<li>同步异步：Producer采用异步push方式，极大提高kafka系统的吞吐率（可以通过参数控制是采用同步还是异步方式）。</li>
<li>分区(partition)机制：kafka的broker端支持消息分区，Producer可以决定把消息发到哪个分区，在一个分区中消息的顺序就是Producer发送消息的顺序，一个主题中可以有多个分区，具体分区的数量是可以配置的。分区的意义很重大，后面的内容会逐渐体现。</li>
<li>离线数据装载：kafka由于对可拓展的数据持久化的支持，它也非常适合向hadoop或者数据仓库中进行数据装载。</li>
<li>插件支持：现在不少活跃的社区已经开发出不少插件来拓展kafka的功能，如用来配合storm、hadoop、flume相关的插件。</li>
</ul>
<h2 id="Kafka架构原理"><a href="#Kafka架构原理" class="headerlink" title="Kafka架构原理"></a>Kafka架构原理</h2><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费大规模的网站中的所有动作流数据，具有高性能、持久化、多副本备份、横向扩展能力。</p>
<h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><img src="/2024/03/29/kafka-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/2025-03-29_22-22.png" class="">

<ul>
<li>Producer: 生产者，消息的产生者，是消息的入口。</li>
<li>Broker：kafka实例，每个服务器上有一个或多个kafka的实例。</li>
<li>Topic：消息的主题，可以理解为消息的分类，kafka的数据就保存在topic。在每个broker上都可以创建多个topic。</li>
<li>Partition：Topic的分区，每个topic可以有多个分区，分区的作用是做负载，提高kafka的吞吐量。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹。</li>
<li>Replication：每个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。Follower和Leader绝对是在不同的机器，同一机器对同一分区也只可能存放一个副本（包括自己）。</li>
<li>Message：每一条发送的消息主体。</li>
<li>Consumer：消费者，即消息的消费方，是消息的出口。</li>
<li>Consumer Group：多个消费者组成一个消费者组，在kafka的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一topic的不同的分区的数据，这是为了提高kafka的吞吐量。</li>
<li>Zookeeper：kafka集群依赖zookeeper来保存集群的元信息，来保证第系统的可用性。</li>
</ul>
<h3 id="工作流程分析"><a href="#工作流程分析" class="headerlink" title="工作流程分析"></a>工作流程分析</h3><p><strong>发送流程</strong></p>
<p>发送流程具体如下：</p>
<ul>
<li>Producer先从集群获取分区的Leader。</li>
<li>Producer将消息发送给Leader。</li>
<li>Leader将消息写入本地文件。</li>
<li>Follower从Leader pull消息。</li>
<li>Followers将消息写入本地，然后向Leader发送ACK。</li>
<li>Leader收到所有副本的ACK，然后向Producer发送ACK。</li>
</ul>
<p>需要注意的是，Producer在写入数据的时候永远只找Leader，不会直接将数据写入Follower。Follower是<strong>主动</strong>找Leader同步数据的。</p>
<p>Producer采用push模式将数据发布到broker，每条消息追到分区中，顺序写入磁盘，所以保证同一分区内的数据是有序的。</p>
<p>上面说到数据会写入到不同的分区，那kafka为什么要做分区呢？</p>
<p>分区的主要目的是：</p>
<ul>
<li>方便扩展：因为一个topic可以有多个partition，所以我们可以通过扩展机器去轻松的应对日益增长的数据量。</li>
<li>提高并发：以partition为读写单位，可以多个消费者同时消费数据，提高了消息的处理效率。</li>
</ul>
<p>熟悉负载均衡的朋友应该知道，当我们向某个服务器发送请求的时候，服务端可能会对请求做一个负载，将流量分发到不同的服务器，那在kafka中，如果某个topic有多个partition，Producer又怎么知道该将数据发往哪个partition呢？</p>
<p>在kafka中有几个原则：</p>
<ul>
<li>partition在写入的时候可以指定需要写入的partition，如果有指定，则写入对应的partition。</li>
<li>如果没有指定partition，但是设置了数据的key，则会根据key的值hash出一个partition。</li>
<li>如果既没指定partition，又没有设置key，则会轮询选出一个partition。</li>
</ul>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx原理</title>
    <url>/2025/03/12/nginx%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="Nginx概述"><a href="#Nginx概述" class="headerlink" title="Nginx概述"></a>Nginx概述</h2><p>Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔、赛索耶夫为俄罗斯访问第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。</p>
<p>Nginx是一款轻量级的Web服务器&#x2F;反向代理服务器及电子邮件(IMAP&#x2F;POP3)代理服务器，在BSD-like协议下发行。其特点是占有内存少，并发能力强。</p>
<h2 id="Nginx工作原理"><a href="#Nginx工作原理" class="headerlink" title="Nginx工作原理"></a>Nginx工作原理</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步与异步的重点在消息通知的方式上，也就是调用结果的通知方式不同。</p>
<p>同步：当一个同步调用发出去后，调用者要一直等待调用的结果通知后，才能进行后续的执行。</p>
<p>异步：当一个异步调用发出去后，调用者不必一直等待调用结果的返回，异步调用要想获得结果，一般有两种方式：</p>
<ul>
<li>主动轮询异步调用的结果；</li>
<li>被调用方通过callback(回调通知)来通知调用方调用结果。</li>
</ul>
<p>实例解释：</p>
<p>同步取快递：小明收到快递将送达的短信，在楼下一直等到快递送达。</p>
<p>异步取快递：小时收到快递将送达的短信，快递到楼下后，小明再下楼去取。</p>
<p>异步取快递，小明知道快递到达楼下有两种方式：</p>
<ul>
<li>不停的电话问快递小哥到了没有，即主动轮询；</li>
<li>快递小哥到楼下后，打电话通知小明，然后小明下楼取快递，既定回调通知。</li>
</ul>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞与非阻塞的重点在于进&#x2F;线程等待消息时候的行为，也就是在等待消息的时候，当前进&#x2F;线程是挂起状态，还是非挂起状态。</p>
<p>阻塞：调用在发出去后，在消息返回之前，当前进&#x2F;线程会被挂起，直到有消息返回，当前进&#x2F;线程才会被激活。</p>
<p>非阻塞：调用在发出去后，不会阻塞当前进&#x2F;线程，而会立即返回。</p>
<p>同步与异步，重点在于消息通知的方式；阻塞与非阻塞，重点在于等消息时候的行为。所以，就出现了四种重合方式：</p>
<ul>
<li><p>同步阻塞</p>
<p>小明收到信息后，啥都不干，等快递。</p>
</li>
<li><p>同步非阻塞</p>
<p>小明收到信息后，边刷微博，边等着取快递。</p>
</li>
<li><p>异步阻塞</p>
<p>小明收到信息后，啥都不干，一直等着快递员通知他取快递。</p>
</li>
<li><p>异步非阻塞</p>
<p>小明收到信息后，边刷着微博，边等快递员通知他取快递。</p>
</li>
</ul>
<p>大部分程序的I&#x2F;O模型都是同步阻塞的，单个进程每次只在一个文件描述符上执行I&#x2F;O操作，每次I&#x2F;O系统调用都会阻塞，直到完成数据传输，传统的服务器采用的就是同步阻塞的多进程模型。一个server采用一个进程负责一个request的方式，一个进程负责一个request，直到会话结束。进程数就是并发数，而操作系统支持的进程数是有限的，且进程数越多，调度的开销也越大，因此无法面对高并发。</p>
<h3 id="epoll模型"><a href="#epoll模型" class="headerlink" title="epoll模型"></a>epoll模型</h3><p>Nginx采用了异步非阻塞的方式工作。先了解一下I&#x2F;O多路复用中的epoll模型：</p>
<p>当连接有I&#x2F;O事件产生的时候，epoll就会去告诉进程哪个连接有I&#x2F;O事件产生，然后进程就去处理这个事件。</p>
<p>例如：小明家楼下有一个收发室，每次有快递到了，门卫就先代收并做了标记；然后通知小明去取送给小明的快递。</p>
<h3 id="Nginx工作原理-1"><a href="#Nginx工作原理-1" class="headerlink" title="Nginx工作原理"></a>Nginx工作原理</h3><p>Nginx配置use epoll后，以异步非阻塞方式工作，能够轻松处理百万级的并发连接。</p>
<p>处理过程：</p>
<p>每进来一个request，会有一个worker进程去处理。但不是全程的处理，处理到可能发生阻塞的地方。比如向后端服务器转发request，并等待请求返回。那么，这个处理的worker不会这么傻等着，他会在发送完请求后，注册一个事件：“如果后端服务器返回了，告诉我一声，我再接着干”。于是他就休息去了。此时如果再有新的request进来，他就可以很快再按这种方式处理。而一旦后端服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。通过这种快速处理，快速释放请求的方式，达到同样的配置可以处理更大并发量的目的。</p>
<h2 id="Nginx工作模式"><a href="#Nginx工作模式" class="headerlink" title="Nginx工作模式"></a>Nginx工作模式</h2><h3 id="master-worker模式"><a href="#master-worker模式" class="headerlink" title="master-worker模式"></a>master-worker模式</h3><p>该模式下，nginx启动成功后，会有一个master进程和至少一个worker进程。master进程负责处理系统信号，加载配置，管理worker进程(启动，杀死，监控，发送消息&#x2F;信号等)。worker进程负责处理具体的业务逻辑，也就是说，对外部来说，真正提供服务的是worker进程。生产环境下一般使用这种模式，这个模式有以下优点：</p>
<ul>
<li>稳定性高，只要还有worker进程存活，就能够提供服务，并且一个worker进程挂掉master进程会立即启动一个新的worker进程，保证worker进程数量不变，降低服务中断的概率。</li>
<li>配合linux的cpu亲和性配置，可以充分利用多核cpu的优势，提升性能。</li>
<li>处理信号&#x2F;配置重新加载&#x2F;升级时可以做到尽可能少或者不中断服务(热重启)。</li>
</ul>
<h3 id="单进程模式"><a href="#单进程模式" class="headerlink" title="单进程模式"></a>单进程模式</h3><p>单进程模式下，nginx启动后只有一个进程，nginx的所有工作都由这个进程负责。由于只有一个进程，因此可以很方便地利用gdb等工具进行调试。该模式下不支持nginx的平滑升级功能，任何的信号处理都可能造成服务中断，并且由于是单进程，进程挂掉后，在没有外部监控的情况下，无法重启服务。因此，该模式一般只在开发阶段和调试时使用，生产环境下不会使用。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>nginx配置详解</title>
    <url>/2025/03/13/nginx%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="配置文件结构"><a href="#配置文件结构" class="headerlink" title="配置文件结构"></a>配置文件结构</h2><p>nginx配置文件通常位于&#x2F;etc&#x2F;nginx&#x2F;nginx.conf和&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;目录。其中&#x2F;etc&#x2F;nginx&#x2F;nginx.conf用于存放全局配置信息。&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;目录用于存放业务配置信息。</p>
<h3 id="nginx-conf"><a href="#nginx-conf" class="headerlink" title="nginx.conf"></a>nginx.conf</h3><p>nginx.conf配置文件主要存放全局配置信息，主要有以下几个部分组成：</p>
<ul>
<li>全局块：配置影响Nginx全局的指令。</li>
<li>events块：配置影响Nginx服务器与客户端网络连接的指令。</li>
<li>http块：配置HTTP服务器相关指令。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="comment"># 定义运行nginx的用户和用户组</span></span><br><span class="line"><span class="attribute">worker_processes</span>	auto;</span><br><span class="line"><span class="comment"># 定义工作进程数，通常设置为CPU核心数</span></span><br><span class="line"><span class="attribute">error_log</span>	/home/wwwlogs/nginx_error.log	<span class="literal">crit</span>;</span><br><span class="line"><span class="comment"># 定义错误日志文件路径</span></span><br><span class="line"><span class="attribute">pid</span>		/usr/local/nginx/logs/nginx.pid;</span><br><span class="line"><span class="comment"># 定义Nginx主进程的PID文件路径</span></span><br><span class="line">events&#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="comment"># 使用epoll模型</span></span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">51200</span>;</span><br><span class="line">    <span class="comment"># 每个工作进程的最大连接数</span></span><br><span class="line">    <span class="attribute">multi_accept</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 允许一个工作进程同时接受多个连接</span></span><br><span class="line">&#125;</span><br><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types;</span><br><span class="line">    <span class="comment"># 包含MIME类型配置文件</span></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    <span class="comment"># 默认MIME类型</span></span><br><span class="line">    <span class="attribute">log_format</span> main</span><br><span class="line">        <span class="string">&#x27;<span class="variable">$remote_addr</span> - &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &quot;<span class="variable">$http_user_agent</span>&quot; &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$request_length</span> <span class="variable">$request_time</span> <span class="variable">$upstream_addr</span> &#x27;</span></span><br><span class="line">        <span class="string">&#x27;<span class="variable">$upstream_response_length</span> <span class="variable">$upstream_response_time</span> <span class="variable">$upstream_status</span>&#x27;</span>;</span><br><span class="line">    <span class="comment"># 定义日志格式</span></span><br><span class="line">    <span class="attribute">access_log</span> /var/log/nginx/access.log main;</span><br><span class="line">    <span class="comment"># 定义访问日志文件路径和格式</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 开启高效文件传输模式</span></span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 防止网络阻塞</span></span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 防止网络延迟</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">    <span class="comment"># 保持连接的超时时间</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 开启Gzip压缩</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">    <span class="comment"># 定义需要压缩的文件类型</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="comment"># 包含基他配置文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="etc-nginx-conf-d-default-con"><a href="#etc-nginx-conf-d-default-con" class="headerlink" title="&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.con"></a>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.con</h3><p>default.conf用于存放业务配置信息，主要有以下几部分组成：</p>
<ul>
<li>server块：配置虚拟主机的相关指令。</li>
<li>location块：配置请求的路由和处理规则。</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="comment"># 监听端口</span></span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line">    <span class="comment"># 定义服务器名称(域名)</span></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">        <span class="comment"># 定义根目录</span></span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        <span class="comment"># 定义默认首页文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /api &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        <span class="comment"># 反向代理到后端服务器</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="comment"># 将客户端请求的原始Host字段(即域名)传递给后端服务器。</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="comment"># 将客户端的真实IP传递给后端服务器。$remote_addr是nginx内置变量，表示客户端的真实IP地址</span></span><br><span class="line">        <span class="attribute">proxy_set</span> header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="comment"># 传递客户端IP列表。包含客户端请求经过的所有代理服务器的IP地址列表，格式为client,proxy1,proxy2。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /static/ &#123;</span><br><span class="line">        <span class="attribute">alias</span> /var/www/static/;</span><br><span class="line">        <span class="comment"># 定义静态文件目录</span></span><br><span class="line">        <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">        <span class="comment"># 设置缓存时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">503</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">    <span class="comment"># 定义错误页面</span></span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>注意配置文件中的结尾有“;”作为结束。</p>
</li>
<li><p>每次实验修改完配置文件后需要重新加载nginx配置才会生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">栓检查配置文件语法</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载配置文件</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h3 id="nginx状态统计"><a href="#nginx状态统计" class="headerlink" title="nginx状态统计"></a>nginx状态统计</h3><ul>
<li><p>安装nginx时将–with-http_stub_status_module模块开启。</p>
</li>
<li><p>修改nginx配置文件(写入要访问的server标签中)</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> /nginx_status &#123;</span><br><span class="line">    <span class="attribute">stub_status</span>	<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">access_log</span>	<span class="literal">off</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端访问网址：<a href="http://ip/nginx_status">http://IP/nginx_status</a></p>
<ul>
<li>Active connections：表示当前的活动连接数；</li>
<li>server accetps handled request：表示已经处理的连接信息。三个数字依次表示已处理的连接数、成功的TCP握手次数、已处理的请求数。</li>
</ul>
</li>
</ul>
<h3 id="目录保护"><a href="#目录保护" class="headerlink" title="目录保护"></a>目录保护</h3><ul>
<li><p>原理和apache的目录保护原理一样。</p>
</li>
<li><p>在状态统计的location中添加：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">auth_basic</span> <span class="string">&quot;Welcome to nginx_status!&quot;</span>;</span><br><span class="line"><span class="attribute">auth_basic_user_file</span>	/usr/local/nginx/html/htpasswd.nginx;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用http的命令htpasswd进行用户密码文件的创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">htpasswd -c /usr/local/nginx/html/htpasswd.nginx user</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启nginx并再次访问统计页面</p>
</li>
</ul>
<h3 id="基于IP的身份验证-访问控制"><a href="#基于IP的身份验证-访问控制" class="headerlink" title="基于IP的身份验证(访问控制)"></a>基于IP的身份验证(访问控制)</h3><ul>
<li><p>在状态统计的location中添加：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">allow</span>	<span class="number">192.168.88.1</span>;</span><br><span class="line"><span class="attribute">deny</span>	<span class="number">192.168.88.0</span>/<span class="number">24</span>;</span><br><span class="line"><span class="comment"># 仅允许192.168.88.1访问服务器</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="nginx的虚拟主机-基于域名"><a href="#nginx的虚拟主机-基于域名" class="headerlink" title="nginx的虚拟主机(基于域名)"></a>nginx的虚拟主机(基于域名)</h3><ul>
<li><p>提前准备好两个网站的域名，并且规划好两个网站网页存放目录</p>
</li>
<li><p>在Nginx主配置文件中并列编写两个server标签，并分别写好各自信息</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> 			<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>		blog.atguigu.com;</span><br><span class="line">    <span class="attribute">index</span> 			index.html index htm index.php;</span><br><span class="line">    <span class="attribute">root</span> 			html/blog;</span><br><span class="line">    <span class="attribute">access_log</span>		logs/blog-access.log main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>		bbs.atguigu.com;</span><br><span class="line">    <span class="attribute">index</span> 			index.html index.htm index.php;</span><br><span class="line">    <span class="attribute">root</span>			html/bbs;</span><br><span class="line">    <span class="attribute">access_log</span>		logs/bbs-access.log main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别访问两个不同的域名验证结果</p>
</li>
</ul>
<h3 id="nginx的反向代理"><a href="#nginx的反向代理" class="headerlink" title="nginx的反向代理"></a>nginx的反向代理</h3><p>代理：找别人代替你去完成一件你完成不成的事(代购)，代理的对象是客户端</p>
<p>反向代理：替成厂家卖东西的人就叫反向代理(烟酒代理)，代理的对象是服务器端</p>
<ul>
<li><p>在另外一台机器上安装apache，启动并填写测试页面</p>
</li>
<li><p>在nginx服务器的配置文件中添加（写在某一个网站的server标签内）</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://192.168.88.100:80;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启nginx，并使用客户端访问测试</p>
</li>
</ul>
<h3 id="负载调度-负载均衡"><a href="#负载调度-负载均衡" class="headerlink" title="负载调度(负载均衡)"></a>负载调度(负载均衡)</h3><p>负载均衡（Load Balance）其意思就是将任务分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其他关键任务服务器等，从而共同完成工作任务。</p>
<ul>
<li><p>使用默认的rr轮询算法，修改nginx配置文件</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> bbs &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.88.100:80</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">192.168.88.200:80</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>		http://bbs;			<span class="comment"># 添加反向代理，代理地址填写upstream声明的名字</span></span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;		<span class="comment"># 重写请求头部，保证网站所有页面都可访问成功</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启并设置两台88.100和88.200的主机</p>
<p>安装apache并设置不同的index.html页面内容(设置不同页面是为了看实验效果)</p>
</li>
<li><p>重启nginx，并使用客户端访问测试</p>
</li>
</ul>
<p>rr算法实现加权轮询</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">upstream</span> bbs &#123;</span><br><span class="line">    <span class="attribute">server</span>	<span class="number">192.168.88.100:80</span> weight=<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">server</span>	<span class="number">192.168.88.200:80</span> weight=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="nginx实现https（证书-rewrite）"><a href="#nginx实现https（证书-rewrite）" class="headerlink" title="nginx实现https（证书+rewrite）"></a>nginx实现https（证书+rewrite）</h3><ul>
<li><p>安装nginx时，需要将–with-http_ssl_module模块开启</p>
</li>
<li><p>在对应要进行加密的server标签中添加以下内容开启SSL</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="attribute">ssl</span>							<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>				/usr/local/nginx/conf/ssl/atguigu.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>			/usr/local/nginx/conf/ssl/atguigu.key;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>			<span class="number">5m</span>;</span><br><span class="line">    <span class="attribute">ssl_protocols</span> 				TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span>	<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span> 				<span class="string">&quot;......&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成证书和密钥文件</p>
</li>
<li><p>设置http自动跳转https功能</p>
<p>原有的server标签修改监听端口</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    ......;</span><br><span class="line">    <span class="attribute">listen</span>	<span class="number">443</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增以下server标签(利用虚拟主机+rewrite的功能)</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>		bbs.atguigu.com;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://bbs.atguigu.com permancent;</span><br><span class="line">    <span class="attribute">root</span>			html;</span><br><span class="line">    <span class="attribute">index</span>			index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启nginx，并测试</p>
</li>
</ul>
<h3 id="Nginx防盗链"><a href="#Nginx防盗链" class="headerlink" title="Nginx防盗链"></a>Nginx防盗链</h3><p>Nginx防盗链(Referer-based Access Control)是一种防止其他网站盗用你的资源(如图片、视频、文件等)的技术。通过检查请求头中的Referer字段，Nginx可以判断请求是否来自合法的来源，从而阻止非法盗链。</p>
<p>Nginx防盗链配置</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>                <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>           example.com;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* \.(jpg|jpeg|png|gif|mp4|flv|pdf)$</span> &#123;</span><br><span class="line">        <span class="attribute">valid_referers</span>    <span class="literal">none</span> <span class="literal">blocked</span> example.com <span class="regexp">*.example.com</span>;</span><br><span class="line">        <span class="attribute">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">            <span class="attribute">return</span>        <span class="number">403</span>;</span><br><span class="line">            <span class="comment"># return      302 https://example.com/anti-leech.html;</span></span><br><span class="line">            <span class="comment"># 或者可以重定向到一个提示页面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">root</span>              /var/www/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>location ~* .(jpg|jpeg|png|gif|mp4|flv|pdf)$</p>
<p>匹配需要防盗链的文件类型(图片、视频、PDF等)，~*表示不区分大小写的正则匹配。</p>
</li>
<li><p>valid_referers</p>
<p>定义合法的Rerferer来源：</p>
<ul>
<li><p>none：允许没有Referer字段的请求（如直接访问）。</p>
</li>
<li><p>blocked：允许Referer字段被防火墙或代理修改的请求。</p>
<p>blocked实际效果：</p>
<ul>
<li>如果请求头中没有Referer字段，Nginx会将其视为blocked，并允许请求通过。</li>
<li>如果Referer字段被修改为非标准值（如unknown或空值），Nginx也会将其视为blocked，并允许请求通过。</li>
</ul>
</li>
<li><p>example.com和*.example.com：允许来自example.com及其子域名的请求。</p>
</li>
</ul>
</li>
<li><p>$invalid_referer</p>
<p>如果Referer不在valid_referers列表中，该变量为1，否则为0。</p>
</li>
<li><p>if ($invalid_referer)</p>
<p>如果Referer不合法，执行以下操作：</p>
<ul>
<li>return 403：返回403禁止访问。</li>
<li>return 302 <a href="https://example.com/anti-leech.html%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%B0%E4%B8%80%E4%B8%AA%E6%8F%90%E7%A4%BA%E9%A1%B5%E9%9D%A2%E3%80%82">https://example.com/anti-leech.html：重定向到一个提示页面。</a></li>
</ul>
</li>
<li><p>root &#x2F;var&#x2F;www&#x2F;html：定义资源的根目录。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
  </entry>
  <entry>
    <title>collections模块</title>
    <url>/2019/03/20/python-collections%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><p>  collections模块主要封装了一些关于集合类的相关操作。比如，iterable，Iteratort等等，除此之外，collections还提供了一些除基本数据类型以外的数据集合类型。Counter，deque，OrderDict，defaultdict以及namedtuple</p>
<h3 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h3><ul>
<li>计数器，主要用来计数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;Hello word&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Counter(s))  <span class="comment"># Counter(&#123;&#x27;l&#x27;: 2, &#x27;o&#x27;: 2, &#x27;H&#x27;: 1, &#x27;e&#x27;: 1, &#x27; &#x27;: 1, &#x27;w&#x27;: 1, &#x27;r&#x27;: 1, &#x27;d&#x27;: 1&#125;)</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">55</span>, <span class="number">44</span>, <span class="number">44</span>]</span><br><span class="line">el = Counter(lst)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(el[<span class="number">44</span>])  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>



<h3 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h3><ul>
<li>既可从左边添加数据，也可从右边添加数据</li>
<li>既可从左边获取数据，也可从右边获取数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line">q = deque()</span><br><span class="line"></span><br><span class="line">q.append(<span class="number">11</span>)</span><br><span class="line">q.append(<span class="number">22</span>)</span><br><span class="line">q.appendleft(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q)              <span class="comment"># deque([33, 11, 22])</span></span><br><span class="line"><span class="built_in">print</span>(q[<span class="number">0</span>])           <span class="comment"># 33</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.pop())        <span class="comment"># 22</span></span><br><span class="line"><span class="built_in">print</span>(q.popleft())    <span class="comment"># 33</span></span><br></pre></td></tr></table></figure>



<h3 id="namedtuple-命名元组"><a href="#namedtuple-命名元组" class="headerlink" title="namedtuple(命名元组)"></a>namedtuple(命名元组)</h3><ul>
<li>给元组内的元素进行命名</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">nt = namedtuple(<span class="string">&quot;Point&quot;</span>, [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>])</span><br><span class="line">p = nt(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.x)  <span class="comment"># 1</span></span><br><span class="line"><span class="built_in">print</span>(p.y)  <span class="comment"># 2</span></span><br></pre></td></tr></table></figure>



<h3 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h3><ul>
<li>有序字典，按照存储的顺序保存</li>
</ul>
<h3 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h3><ul>
<li>给字典设置默认值。当key不存在时，直接获取默认值</li>
<li>defaultdict括号内对象必须为可调用对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">dic1 = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">print</span>(dic1[<span class="string">&quot;name&quot;</span>])       <span class="comment"># []</span></span><br><span class="line"><span class="built_in">print</span>(dic1)               <span class="comment"># defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;name&#x27;: []&#125;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"></span><br><span class="line">dic = defaultdict(func)</span><br><span class="line"><span class="built_in">print</span>(dic[<span class="string">&quot;name&quot;</span>])        <span class="comment"># Tom</span></span><br></pre></td></tr></table></figure>

<p> 应用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将lst = [11, 22, 33, 44, 55, 66, 77, 88, 99]大于等于66放入字典&quot;key1&quot;中，小于66放入字典&quot;key2&quot;中</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">lst = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>]</span><br><span class="line">dic = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> el <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="keyword">if</span> el &lt; <span class="number">66</span>:</span><br><span class="line">        dic[<span class="string">&quot;key2&quot;</span>].append(el)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dic[<span class="string">&quot;key1&quot;</span>].append(el)</span><br><span class="line"></span><br><span class="line">dic = <span class="built_in">dict</span>(dic)</span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;key2&#x27;: [11, 22, 33, 44, 55], &#x27;key1&#x27;: [66, 77, 88, 99]&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>configparser模块</title>
    <url>/2019/03/20/python-configparser%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="configparser"><a href="#configparser" class="headerlink" title="configparser"></a>configparser</h2><p>  该模块适用格式与windows ini文件类似的配置文件，可以包含一个或多个节（section），每个节可以有多个参数（键&#x3D;值）</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config[<span class="string">&quot;DEFAULT&quot;</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;sleep&quot;</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">&quot;session-time-out&quot;</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="string">&quot;user-alive&quot;</span>: <span class="number">999999</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config[<span class="string">&quot;TEST-DB&quot;</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;db-ip&quot;</span>: <span class="string">&quot;192.168.17.189&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: <span class="string">&quot;3306&quot;</span>,</span><br><span class="line">    <span class="string">&quot;u_name&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;u_pwd&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config[<span class="string">&quot;168-DB&quot;</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;db-ip&quot;</span>: <span class="string">&quot;152.163.18.168&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: <span class="string">&quot;3306&quot;</span>,</span><br><span class="line">    <span class="string">&quot;u_name&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;u_pwd&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config[<span class="string">&quot;173-DB&quot;</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;db_ip&quot;</span>: <span class="string">&quot;152.163.18.173&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: <span class="string">&quot;3306&quot;</span>,</span><br><span class="line">    <span class="string">&quot;u_name&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;u_pwd&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="写入到文件"><a href="#写入到文件" class="headerlink" title="写入到文件"></a>写入到文件</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;db.ini&quot;</span>, mode=<span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">config.write(f)</span><br><span class="line">f.flush()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>



<h2 id="读取文件信息"><a href="#读取文件信息" class="headerlink" title="读取文件信息"></a>读取文件信息</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>)  <span class="comment"># 读取文件</span></span><br></pre></td></tr></table></figure>



<h3 id="读取章节信息"><a href="#读取章节信息" class="headerlink" title="读取章节信息"></a>读取章节信息</h3><ul>
<li>DEFAULT章节特殊，它是给每个章节都配备的信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件 此时把文件的内容读取到config</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(config.sections())  <span class="comment"># [&#x27;TEST-DB&#x27;, &#x27;168-DB&#x27;, &#x27;173-DB&#x27;]</span></span><br></pre></td></tr></table></figure>



<h3 id="读取特定章节信息"><a href="#读取特定章节信息" class="headerlink" title="读取特定章节信息"></a>读取特定章节信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(config.get(<span class="string">&quot;TEST-DB&quot;</span>, <span class="string">&quot;DB-IP&quot;</span>))  <span class="comment"># 192.168.17.189</span></span><br><span class="line"><span class="built_in">print</span>(config[<span class="string">&quot;TEST-DB&quot;</span>][<span class="string">&quot;DB-IP&quot;</span>])  <span class="comment"># 192.168.17.189</span></span><br></pre></td></tr></table></figure>



<h3 id="增删改操作："><a href="#增删改操作：" class="headerlink" title="增删改操作："></a>增删改操作：</h3><p>  先读取，然后修改，最后写回文件</p>
<h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><p>增加一个章节</p>
<ul>
<li>add_section()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">config.add_section(<span class="string">&quot;189-DB&quot;</span>)</span><br><span class="line">config[<span class="string">&quot;189-DB&quot;</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;db_ip&quot;</span>: <span class="string">&quot;167.76.22.189&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: <span class="string">&quot;3306&quot;</span>,</span><br><span class="line">    <span class="string">&quot;u_name&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;u_pwd&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config.write(<span class="built_in">open</span>(<span class="string">&quot;db.ini&quot;</span>, mode=<span class="string">&quot;w&quot;</span>))结果：</span><br></pre></td></tr></table></figure>

<p> 增加元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line">config[<span class="string">&quot;168-DB&quot;</span>][<span class="string">&quot;code&quot;</span>] = <span class="string">&quot;AFRE&quot;</span></span><br><span class="line"></span><br><span class="line">config.write(<span class="built_in">open</span>(<span class="string">&quot;db.ini&quot;</span>, mode=<span class="string">&quot;w&quot;</span>))结果：</span><br></pre></td></tr></table></figure>



<h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><p>删除章节</p>
<ul>
<li>remove_section(section)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line">config.remove_section(<span class="string">&quot;173-DB&quot;</span>)</span><br><span class="line"></span><br><span class="line">config.write(<span class="built_in">open</span>(<span class="string">&quot;db.ini&quot;</span>, mode=<span class="string">&quot;w&quot;</span>))结果：</span><br></pre></td></tr></table></figure>

<p>删除元素</p>
<ul>
<li>remove_option(section, 元素)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line">config.remove_option(<span class="string">&quot;168-DB&quot;</span>, <span class="string">&quot;code&quot;</span>)</span><br><span class="line"></span><br><span class="line">config.write(<span class="built_in">open</span>(<span class="string">&quot;db.ini&quot;</span>, mode=<span class="string">&quot;w&quot;</span>))结果：</span><br></pre></td></tr></table></figure>



<h4 id="改"><a href="#改" class="headerlink" title="改"></a>改</h4><ul>
<li>set(section, 元素，信息)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line">config.<span class="built_in">set</span>(<span class="string">&quot;168-DB&quot;</span>, <span class="string">&quot;db-ip&quot;</span>, <span class="string">&quot;10.10.10.168&quot;</span>)</span><br><span class="line"></span><br><span class="line">config.write(<span class="built_in">open</span>(<span class="string">&quot;db.ini&quot;</span>, mode=<span class="string">&quot;w&quot;</span>))结果：</span><br></pre></td></tr></table></figure>



<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="遍历key"><a href="#遍历key" class="headerlink" title="遍历key"></a>遍历key</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> config[<span class="string">&quot;168-DB&quot;</span>]:</span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">db-ip</span><br><span class="line">port</span><br><span class="line">u_name</span><br><span class="line">u_pwd</span><br><span class="line">sleep</span><br><span class="line">session-time-out</span><br><span class="line">user-alive</span><br></pre></td></tr></table></figure>

<p>options()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(config.options(<span class="string">&quot;168-DB&quot;</span>))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="string">&#x27;db-ip&#x27;</span>, <span class="string">&#x27;port&#x27;</span>, <span class="string">&#x27;u_name&#x27;</span>, <span class="string">&#x27;u_pwd&#x27;</span>, <span class="string">&#x27;sleep&#x27;</span>, <span class="string">&#x27;session-time-out&#x27;</span>, <span class="string">&#x27;user-alive&#x27;</span>]</span><br></pre></td></tr></table></figure>



<h3 id="遍历items"><a href="#遍历items" class="headerlink" title="遍历items"></a>遍历items</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> config[<span class="string">&quot;168-DB&quot;</span>].items():</span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">结果：</span><br><span class="line">db-ip <span class="number">152.163</span><span class="number">.18</span><span class="number">.168</span></span><br><span class="line">port <span class="number">3306</span></span><br><span class="line">u_name root</span><br><span class="line">u_pwd <span class="number">123456</span></span><br><span class="line">sleep <span class="number">1000</span></span><br><span class="line">session-time-out <span class="number">30</span></span><br><span class="line">user-alive <span class="number">999999</span></span><br></pre></td></tr></table></figure>

<p>items()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line"></span><br><span class="line">config.read(<span class="string">&quot;db.ini&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(config.items(<span class="string">&quot;168-DB&quot;</span>))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[(<span class="string">&#x27;sleep&#x27;</span>, <span class="string">&#x27;1000&#x27;</span>), (<span class="string">&#x27;session-time-out&#x27;</span>, <span class="string">&#x27;30&#x27;</span>), (<span class="string">&#x27;user-alive&#x27;</span>, <span class="string">&#x27;999999&#x27;</span>), (<span class="string">&#x27;db-ip&#x27;</span>, <span class="string">&#x27;152.163.18.168&#x27;</span>), (<span class="string">&#x27;port&#x27;</span>, <span class="string">&#x27;3306&#x27;</span>), (<span class="string">&#x27;u_name&#x27;</span>, <span class="string">&#x27;root&#x27;</span>), (<span class="string">&#x27;u_pwd&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Dictionary</title>
    <url>/2019/03/16/python-dictionary/</url>
    <content><![CDATA[<h2 id="字典的简单介绍"><a href="#字典的简单介绍" class="headerlink" title="字典的简单介绍"></a>字典的简单介绍</h2><ul>
<li>字典(dict)是python中唯一的一个映射类型。是以{ }括起来的键值对组成。</li>
<li>字典(dict)中key必须是不可变的，而value没有要求，可以保存任意类型的数据。</li>
</ul>
<h3 id="字典的保存原理："><a href="#字典的保存原理：" class="headerlink" title="字典的保存原理："></a>字典的保存原理：</h3><p>  字典在保存的时候，采用的是hash算法：根据key来计算出一个内存地址，然后将key-value保存在这个地址中。所以，在dict中存储的key-value中的key必须是可hash的。</p>
<p>  对于可hash，暂可以理解为可以改变的都是不可hash的，那么可哈希就意味着不可变，这个是为了能准确的计算内存地址而规定的。</p>
<ul>
<li>已知的可hash(不可变)的数据类型：int, str, tuple, bool</li>
<li>不可hash(可变)的数据类型：list, dict, set</li>
<li>dict保存的数据不是按照我们添加进去的顺序保存的，是按照hash表的顺序保存的，而hash表不是连续的。所以不能进行切片工作，只能通过key来获取dict中的数据。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line"></span><br><span class="line">print(dic[name]) # Tom</span><br></pre></td></tr></table></figure>



<h2 id="字典的增删改查"><a href="#字典的增删改查" class="headerlink" title="字典的增删改查"></a>字典的增删改查</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li><p>dic[key] &#x3D; value</p>
<p> 若字典中无此key,则添加键值对，若字典中有此key,则为修改value内容</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;:18&#125;</span><br><span class="line"></span><br><span class="line">dic[&quot;hobby&quot;] = &quot;football&quot; </span><br><span class="line">print(dic)  # &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;  增加键-值对</span><br><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line"></span><br><span class="line">dic[&quot;age&quot;] = 20</span><br><span class="line">print(dic) # &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20&#125; 修改value内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>setdefault</li>
</ul>
<p>流程：</p>
<p>a) 判断key是否存在，如果存在，就不执行新增，返回key对应value内容</p>
<p>b) 如果不存在，执行新增，并返回key对应value内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line"></span><br><span class="line">ret = dic.setdefault(&quot;hobby&quot;, &quot;football&quot;)</span><br><span class="line">print(dic)  # &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line">print(ret)  # football</span><br><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line"></span><br><span class="line">ret = dic.setdefault(&quot;name&quot;, &quot;Andy&quot;)</span><br><span class="line">print(dic)  # &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line">print(ret)  # Tom</span><br></pre></td></tr></table></figure>

<p>当采用setdefault方法新增键值对时，若只提供key,则默认value为None</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line"></span><br><span class="line">dic.setdefault(&quot;hobby&quot;)</span><br><span class="line">print(dic) # &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: None&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li>pop</li>
</ul>
<p>根据key删除，有返回值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line"></span><br><span class="line">ret = dic.pop(&quot;hobby&quot;)</span><br><span class="line">print(dic)  # &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;print(ret) # football</span><br></pre></td></tr></table></figure>

<ul>
<li>popitem</li>
</ul>
<p>随机删除(3.5以下为随机删除，3.5以上为删除末尾的，但python底层为随机删除)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line"></span><br><span class="line">dic.popitem()</span><br><span class="line">print(dic)  # &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>del</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据key删除</span><br><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line"></span><br><span class="line">del dic[&quot;hobby&quot;]</span><br><span class="line">print(dic)  # &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>clear</li>
</ul>
<p>清空字典</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line"></span><br><span class="line">dic.clear()</span><br><span class="line">print(dic)  # &#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul>
<li>dic[key] &#x3D; value</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line"></span><br><span class="line">dic[&quot;age&quot;] = 20</span><br><span class="line">print(dic) # &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 20, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>update</li>
</ul>
<p> dic.update(dic1)：把dic1中的内容更新到dic中。如果key重名，则修改替换，如果不存在，则新增</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line">dic1 = &#123;&quot;name&quot;: &quot;Andy&quot;, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line"></span><br><span class="line">dic.update(dic1)</span><br><span class="line"></span><br><span class="line">print(dic) # &#123;&quot;name&quot;: &quot;Andy&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line">print(dic1) # &#123;&quot;name&quot;: &quot;Andy&quot;, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li>print(dic[key])</li>
</ul>
<p>当key不存在时，报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line"></span><br><span class="line">print(dic[&quot;name&quot;])  # Tom</span><br></pre></td></tr></table></figure>

<ul>
<li>get</li>
</ul>
<p>当key不存在时，返回None</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(dic.get(&quot;name&quot;)) # Tom</span><br><span class="line">print(dic.get(&quot;addr&quot;)) # None</span><br></pre></td></tr></table></figure>

<ul>
<li>setdefault</li>
</ul>
<p>当key存在时，则返回value值，但当key不存在时，则新增key-value对。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;</span><br><span class="line"></span><br><span class="line">print(dic.setdefault(&quot;name&quot;)) # Tom</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="其他相关操作"><a href="#其他相关操作" class="headerlink" title="其他相关操作"></a>其他相关操作</h2><h3 id="dic-keys"><a href="#dic-keys" class="headerlink" title="dic.keys()"></a>dic.keys()</h3><p>遍历字典所有key:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for k in dic.keys():</span><br><span class="line">    print(k)</span><br><span class="line">for k in dic:</span><br><span class="line">    print(k）</span><br><span class="line">    print(dic[k]) </span><br></pre></td></tr></table></figure>



<h3 id="dic-values"><a href="#dic-values" class="headerlink" title="dic.values()"></a>dic.values()</h3><p>遍历字典所有value:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for v in dic.values():</span><br><span class="line">    print(v)</span><br></pre></td></tr></table></figure>



<h3 id="dic-items"><a href="#dic-items" class="headerlink" title="dic.items()"></a>dic.items()</h3><p>遍历字典的最好方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for k, v in dic.items():</span><br><span class="line">    print(k, v)</span><br></pre></td></tr></table></figure>



<h3 id="fromkeys"><a href="#fromkeys" class="headerlink" title="fromkeys"></a>fromkeys</h3><ul>
<li>fromkeys属于类dict的一个静态方法</li>
<li>创建新字典，不是在原有基础上增加键值对</li>
<li>如果value为可变数据数据。则所有key都可改动这个数据，一旦改动，所有的value跟着改变</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = dict.fromkeys([&quot;name_1&quot;, &quot;name_2&quot;], [11, 22, 33])</span><br><span class="line"></span><br><span class="line">print(dic) # &#123;&#x27;name_1&#x27;: [11, 22, 33], &#x27;name_2&#x27;: [11, 22, 33]&#125;</span><br><span class="line">dic = dict.fromkeys([``&quot;name_1&quot;``, ``&quot;name_2&quot;``], [11, 22, 33])` `dic[``&#x27;name_1&#x27;``].append(``&quot;hello&quot;``)` `print(dic) # &#123;``&#x27;name_1&#x27;``: [11, 22, 33, ``&#x27;hello&#x27;``], ``&#x27;name_2&#x27;``: [11, 22, 33, ``&#x27;hello&#x27;``]&#125;</span><br></pre></td></tr></table></figure>



<h2 id="dict在迭代过程中删除元素问题"><a href="#dict在迭代过程中删除元素问题" class="headerlink" title="dict在迭代过程中删除元素问题"></a>dict在迭代过程中删除元素问题</h2><h3 id="dict中元素在迭代过程中删除，则报错"><a href="#dict中元素在迭代过程中删除，则报错" class="headerlink" title="dict中元素在迭代过程中删除，则报错"></a>dict中元素在迭代过程中删除，则报错</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line"></span><br><span class="line">for k in dic:</span><br><span class="line">    del dic[k]  # RuntimeError: dictionary changed size during iteration</span><br></pre></td></tr></table></figure>



<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>  可以先把要删除的元素保存在一个list中，然后循环list，删除字典中元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic = &#123;&#x27;k1&#x27;: 11, &quot;k2&quot;: 22, &quot;s1&quot;: 33, &quot;s2&quot;: 44&#125;</span><br><span class="line"></span><br><span class="line">lst = []</span><br><span class="line">for k in dic:</span><br><span class="line">    if &quot;k&quot; in k:</span><br><span class="line">        lst.append(k)</span><br><span class="line"></span><br><span class="line">for i in lst:</span><br><span class="line">    del dic[i]</span><br><span class="line"></span><br><span class="line">print(dic)  # &#123;&#x27;s1&#x27;: 33, &#x27;s2&#x27;: 44&#125;</span><br></pre></td></tr></table></figure>



<h2 id="字典嵌套"><a href="#字典嵌套" class="headerlink" title="字典嵌套"></a>字典嵌套</h2><p>字典里可以嵌套多层列表、字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">        <span class="string">&quot;age&quot;</span>: <span class="number">30</span>,    </span><br><span class="line">        <span class="string">&quot;hobby&quot;</span>: [<span class="string">&quot;football&quot;</span>, <span class="string">&quot;baseball&quot;</span>],</span><br><span class="line">        <span class="string">&quot;wife&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Andy&quot;</span>,</span><br><span class="line">                <span class="string">&quot;age&quot;</span>: <span class="string">&quot;28&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dic.get(<span class="string">&quot;wife&quot;</span>).get(<span class="string">&quot;name&quot;</span>)) <span class="comment"># Andy</span></span><br><span class="line"><span class="built_in">print</span>(dic[<span class="string">&quot;hobby&quot;</span>][<span class="number">1</span>])  <span class="comment"># baseball</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>json模块</title>
    <url>/2019/03/20/python-json%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>json全称：javascript object notation</li>
<li>前后端交互的枢纽：后端通过将程序产生的字典转化成json格式的json字符串(串)，然后通过网络传输，给到前端，前端解析json文件，完成数据交互</li>
</ul>
<h2 id="python字典与json字符串相互转换"><a href="#python字典与json字符串相互转换" class="headerlink" title="python字典与json字符串相互转换"></a>python字典与json字符串相互转换</h2><h3 id="python字典-——-json字符串：dumps"><a href="#python字典-——-json字符串：dumps" class="headerlink" title="python字典 ——&gt; json字符串：dumps"></a>python字典 ——&gt; json字符串：dumps</h3><ul>
<li>ensure_ascii：默认为True。如果ensure_ascii为False, 那么写入的字符串中可以包含非ASCII字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;hobby&quot;</span>: <span class="string">&quot;篮球&quot;</span>, <span class="number">1</span>: <span class="literal">False</span>, <span class="number">2</span>: <span class="literal">None</span>&#125;</span><br><span class="line">s = json.dumps(dic, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;篮球&quot;, &quot;1&quot;: false, &quot;2&quot;: null&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="json字符串-——-python字典：loads"><a href="#json字符串-——-python字典：loads" class="headerlink" title="json字符串 ——&gt; python字典：loads"></a>json字符串 ——&gt; python字典：loads</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;篮球&quot;, &quot;1&quot;: false, &quot;2&quot;: null&#125;&#x27;</span></span><br><span class="line">dic = json.loads(s)</span><br><span class="line"><span class="built_in">print</span>(dic)   <span class="comment"># &#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18, &#x27;hobby&#x27;: &#x27;篮球&#x27;, &#x27;1&#x27;: False, &#x27;2&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="读、写json文件"><a href="#读、写json文件" class="headerlink" title="读、写json文件"></a>读、写json文件</h2><h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h3><ul>
<li>将python字典转换成json字符串，并写入文件中</li>
<li>indent：缩进</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;hobby&quot;</span>: <span class="string">&quot;篮球&quot;</span>, <span class="number">1</span>: <span class="literal">False</span>, <span class="number">2</span>: <span class="literal">None</span>&#125;</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;1.json&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)  <span class="comment"># 把对象打散成json写入到文件中</span></span><br><span class="line">json.dump(dic, f, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br><span class="line">f.close()结果：</span><br></pre></td></tr></table></figure>



<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><ul>
<li>读取json文件，并解析成字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;1.json&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">dic = json.load(f)</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18, &#x27;hobby&#x27;: &#x27;篮球&#x27;, &#x27;1&#x27;: False, &#x27;2&#x27;: None&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="读、写多个json字符串"><a href="#读、写多个json字符串" class="headerlink" title="读、写多个json字符串"></a>读、写多个json字符串</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>  我们可以向同一文件中写入多个json字符串,但是json文件中内容是一行内容。此时读取时无法读取。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">lst = [&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;]</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;2.json&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> el <span class="keyword">in</span> lst:</span><br><span class="line">    json.dump(el, f)</span><br><span class="line">f.close()结果：</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;2.json&quot;</span>)</span><br><span class="line">dic = json.load(f)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">json.decoder.JSONDecodeError: Extra data: line <span class="number">1</span> column <span class="number">9</span> (char <span class="number">8</span>)</span><br></pre></td></tr></table></figure>



<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>  改用dumps和loads，对每一行分别做处理</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">lst = [&#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>&#125;, &#123;<span class="string">&quot;b&quot;</span>: <span class="number">2</span>&#125;, &#123;<span class="string">&quot;c&quot;</span>: <span class="number">3</span>&#125;]</span><br><span class="line"></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;2.json&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> el <span class="keyword">in</span> lst:</span><br><span class="line">    s = json.dumps(el) + <span class="string">&quot;\n&quot;</span></span><br><span class="line">    f.write(s)</span><br><span class="line">f.close()结果：</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;2.json&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    dic = json.loads(line.strip())</span><br><span class="line">    <span class="built_in">print</span>(dic)</span><br><span class="line">f. close()结果：&#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>&#125;&#123;<span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>&#125;&#123;<span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>



<h2 id="json处理类"><a href="#json处理类" class="headerlink" title="json处理类"></a>json处理类</h2><h3 id="将类转换成json字符串"><a href="#将类转换成json字符串" class="headerlink" title="将类转换成json字符串"></a>将类转换成json字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;name&quot;</span>: obj.name, <span class="string">&quot;age&quot;</span>: obj.age&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = json.dumps(p, default=func)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="将json字符串赋给类"><a href="#将json字符串赋给类" class="headerlink" title="将json字符串赋给类"></a>将json字符串赋给类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;&#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">dic</span>):</span><br><span class="line">    <span class="keyword">return</span> Person(dic[<span class="string">&quot;name&quot;</span>], dic[<span class="string">&quot;age&quot;</span>])</span><br><span class="line"></span><br><span class="line">p = json.loads(s, object_hook=func)</span><br><span class="line"><span class="built_in">print</span>(p.name, p.age)  <span class="comment"># Tom  18</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>List</title>
    <url>/2019/03/16/python-list/</url>
    <content><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>  以[ ]括起来，每个元素用”,”隔开，且可以存放各种数据类型。</p>
<p>  列表相比于字符串，不仅可以存放不同的数据类型，而且可存放大量的数据。32位python可以存放：536870912个元素，64位可以存放：1152921504606846975个元素。</p>
<p>  列表是有序的(按照保存的顺序)，有索引，可以切片方便取值。</p>
<p>  列表属于可变数据类型。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [&quot;python&quot;, &quot;java&quot;, &quot;c&quot;,  &quot;c++&quot;, [11, 22,33]]</span><br><span class="line"></span><br><span class="line">print(lst[0])  # python</span><br><span class="line">print(lst[4][0]) # 11</span><br></pre></td></tr></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>  列表切片后得到还是列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33, 44, 55, 66]</span><br><span class="line"></span><br><span class="line">print(lst[0:3]) # [11, 22, 33] </span><br><span class="line">print(lst[1::2]) # [22, 44, 66]</span><br><span class="line">print(lst[2::-1]) # [33,22,11]</span><br></pre></td></tr></table></figure>

<h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><p>1).增</p>
<ul>
<li><p>append</p>
<p>在列表末尾增加元素</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33, 44]lst.append(55)</span><br><span class="line">print(lst) # [11, 22, 33, 44, 55]</span><br></pre></td></tr></table></figure>

<ul>
<li>insert</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22,33]</span><br><span class="line">lst.insert(1, 55)</span><br><span class="line">print(lst) # [11, 55, 22, 33]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>extend</p>
<p>迭代添加，增加的元素须为可迭代对象，且添加位置为末尾</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33]</span><br><span class="line">lst.extend([55, 66]) # [11, 22, 33, 55, 66]</span><br><span class="line">lst.extend(&quot;python&quot;) # [11, 22, 33, 55，66， &#x27;p&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;n&#x27;]</span><br><span class="line">lst.extend(44) # 报错</span><br></pre></td></tr></table></figure>

<p>2).删除</p>
<ul>
<li><p>pop</p>
<p>默认删除列表末尾元素，也可删除指定位置元素，前提得提供索引。该删除有返回值，返回值为删除的元素</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33,  44, 55]</span><br><span class="line">el = lst.pop() # 55</span><br><span class="line">print(lst) # [11, 22, 33, 44]</span><br><span class="line"></span><br><span class="line">lst.pop(2)</span><br><span class="line">print(lst) # [11, 22, 44]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>remove</p>
<p> 根据元素内容进行删除，若列表中有多个相同的元素，则执行remove操作删除的是第一个元素</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33, 44]</span><br><span class="line"></span><br><span class="line">lst.remove(44)</span><br><span class="line">print(lst) # [11, 22, 33]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>del</p>
<p>切片删除</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33, 44, 55, 66]</span><br><span class="line"></span><br><span class="line">del lst[0] </span><br><span class="line">print(lst) # [22, 33, 44, 55, 66]</span><br><span class="line"></span><br><span class="line">del[1:4:2] </span><br><span class="line">print(lst) # [22, 44, 66]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>clear</p>
<p>清空列表</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33, 44, 55]</span><br><span class="line"></span><br><span class="line">lst.clear()</span><br><span class="line">print(lst) # []</span><br></pre></td></tr></table></figure>

<p> 3).修改</p>
<p>  指定索引修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33, 44]</span><br><span class="line"></span><br><span class="line">lst[2] = 55</span><br><span class="line">print(lst) # [11, 22, 55, 44]</span><br></pre></td></tr></table></figure>

<p>  根据切片修改，如果步长不是1，则修改的元素的个数与提供的元素个数须匹配。如果切片没有步长或者步长是1，则不用关心个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33, 44, 55]</span><br><span class="line"></span><br><span class="line">lst[1:4] = &#x27;编程&#x27;</span><br><span class="line">print(lst) # [11, &quot;编&quot;, &quot;程&quot;, 55]lst = [11, 22, 33, 44, 55, 66]lst[1:5:2] = &quot;编程&quot;print(lst) # [11, &quot;编&quot;, 33, &quot;程&quot;, 55, 66]</span><br></pre></td></tr></table></figure>

<p> 4).查询</p>
<p>  列表是一个可打迭代对象，所以可以进行for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in lst:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>



<h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><ul>
<li><p>count</p>
<p>查询某元素出现的次数</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 11, 44, 55, 66]</span><br><span class="line"></span><br><span class="line">c = lst.count(11)</span><br><span class="line">print(c) # 2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sort</p>
<p>默认按升序排列，若需降序排列，只需在括号内添加reverse&#x3D;True</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 44, 33, 22, 55]</span><br><span class="line"></span><br><span class="line">lst.sort()</span><br><span class="line">print(lst) # [11, 22, 33, 44, 55]</span><br><span class="line">lst.sort(reverse=True) </span><br><span class="line">print(lst) # [55, 44, 33, 22, 11]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>reverse</p>
<p>翻转列表，无返回值</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 33, 22, 55, 44]</span><br><span class="line"></span><br><span class="line">lst.reverse()</span><br><span class="line">print(lst) # [44, 55, 22, 33, 11]</span><br></pre></td></tr></table></figure>



<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>  采用降维操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, [33, [&quot;python&quot;, 55]], 66]</span><br><span class="line"></span><br><span class="line">print(lst[1])  # 22</span><br><span class="line"></span><br><span class="line">print(lst[2][0]) # 33</span><br><span class="line"></span><br><span class="line">print(lst[2][1][0]) # p</span><br><span class="line"></span><br><span class="line">lst[2][1][0] = lst[2][1][0].replace(&quot;p&quot;, &quot;P&quot;)</span><br><span class="line"></span><br><span class="line">print(lst) # [11, 22, [33, [&#x27;Python&#x27;, 55]], 66]lst[2].append(77)print(lst) # [11, 22, [33, [&quot;Python&quot;, 55], 77], 66]</span><br></pre></td></tr></table></figure>



<h3 id="循环过程中删除列表元素问题"><a href="#循环过程中删除列表元素问题" class="headerlink" title="循环过程中删除列表元素问题"></a>循环过程中删除列表元素问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33, 44]</span><br><span class="line"></span><br><span class="line">for i in lst:</span><br><span class="line">    lst.remove(i)</span><br><span class="line">print(lst) # [22, 44]</span><br></pre></td></tr></table></figure>

<p>原因：</p>
<p>  在for的运行过程中，会有一个指针来记录当前循环的元素是哪个，一开始这个指针指向第0个，然后获取到第0个元素。紧接着删除第0个。这个时候，原来是第一个的元素会自动的变成第0个。然后指针向后移动一次，指向第1个元素。这时原来的1已经变成了0，也就不会被删除了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33, 44]</span><br><span class="line">del_lst = []</span><br><span class="line"></span><br><span class="line">for i in lst:</span><br><span class="line">    del_lst.append(i)</span><br><span class="line"></span><br><span class="line">for i in del_lst:</span><br><span class="line">    lst.remove(i)</span><br><span class="line"></span><br><span class="line">print(lst)  # []</span><br></pre></td></tr></table></figure>

<p> 注意：由于删除元素会导致元素的索引改变，所以容易出现问题。尽量不要在循环中直接删除元素。可以把要删除的元素添加到另一个列表中然后批量删除。</p>
<h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><ul>
<li>range(start, end, 步长)</li>
<li>获取元素的索引和元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [&quot;语文&quot;, &quot;数学&quot;, &quot;英语&quot;,&quot;高数&quot;,&quot;体育&quot;]</span><br><span class="line">for i in range(len(lst)):</span><br><span class="line">        print(i, lst[i])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>os模块</title>
    <url>/2019/03/20/python-os%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h2><p>  所有和操作系统相关的内容都在os模块中</p>
<h2 id="相关功能"><a href="#相关功能" class="headerlink" title="相关功能"></a>相关功能</h2><h3 id="os-makedirs-“dirname1-dirname2”"><a href="#os-makedirs-“dirname1-dirname2”" class="headerlink" title="os.makedirs(“dirname1&#x2F;dirname2”)"></a>os.makedirs(“dirname1&#x2F;dirname2”)</h3><ul>
<li>可生成多层递归目录</li>
</ul>
<h3 id="os-removedirs-“dirname”"><a href="#os-removedirs-“dirname”" class="headerlink" title="os.removedirs(“dirname”)"></a>os.removedirs(“dirname”)</h3><ul>
<li>如果目录为空，则删除，并递归到上一级目录，如果上一级目录也为空，则删除，以此类推</li>
</ul>
<h3 id="os-mkdir-“driname”"><a href="#os-mkdir-“driname”" class="headerlink" title="os.mkdir(“driname”)"></a>os.mkdir(“driname”)</h3><ul>
<li>生成单级目录，相当于shell中mkdir driname</li>
</ul>
<h3 id="os-rmdir-“dirname”"><a href="#os-rmdir-“dirname”" class="headerlink" title="os.rmdir(“dirname”)"></a>os.rmdir(“dirname”)</h3><ul>
<li>删除单级目录，如果目录不为空则无法删除，报错；相当于shell中rmdir dirname</li>
</ul>
<h3 id="os-listdir-“dirname”"><a href="#os-listdir-“dirname”" class="headerlink" title="os.listdir(“dirname”)"></a>os.listdir(“dirname”)</h3><ul>
<li>列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</li>
</ul>
<h3 id="os-remove-“filename”"><a href="#os-remove-“filename”" class="headerlink" title="os.remove(“filename”)"></a>os.remove(“filename”)</h3><ul>
<li>删除一个文件</li>
</ul>
<h3 id="os-rename-“oldname”-“newname”"><a href="#os-rename-“oldname”-“newname”" class="headerlink" title="os.rename(“oldname”, “newname”)"></a>os.rename(“oldname”, “newname”)</h3><ul>
<li>重命名文件&#x2F;目录</li>
</ul>
<h3 id="os-stat-“path-filename”"><a href="#os-stat-“path-filename”" class="headerlink" title="os.stat(“path&#x2F;filename”)"></a>os.stat(“path&#x2F;filename”)</h3><ul>
<li>获取文件&#x2F;目录信息</li>
</ul>
<p>属性解读：</p>
<p>stat 结构：</p>
<ul>
<li>st_mode: inode 保护模式</li>
<li>st_ino: inode 节点号</li>
<li>st_dev: inode 驻留的设备</li>
<li>st_uid: 所有者的用户ID</li>
<li>st_gid: 所有者的组ID</li>
<li>st_size: 普通文件以字节为单位的大小；包含等待某些特殊文件的数据</li>
<li>st_atime: 上次访问的时间</li>
<li>st_mtime: 最后一次修改的时间</li>
<li>st_ctime: 由操作系统报告的”ctime”。在某些系统上(Unix)是最新的元数据更改的时间，在其它系统上（如Windows）是创建时间（详细信息参见平台的文档）</li>
</ul>
<h3 id="os-system-“bash-command”"><a href="#os-system-“bash-command”" class="headerlink" title="os.system(“bash command”)"></a>os.system(“bash command”)</h3><ul>
<li>运行shell命令，直接显示</li>
</ul>
<h3 id="os-popen-“bash-command”-read"><a href="#os-popen-“bash-command”-read" class="headerlink" title="os.popen(“bash command”).read()"></a>os.popen(“bash command”).read()</h3><ul>
<li>运行shell命令，获取执行结果</li>
</ul>
<h3 id="os-getcwd"><a href="#os-getcwd" class="headerlink" title="os.getcwd()"></a>os.getcwd()</h3><ul>
<li>获取当前工作目录，即当前python脚本工作的目录路径</li>
</ul>
<h3 id="os-chdir-“dirname”"><a href="#os-chdir-“dirname”" class="headerlink" title="os.chdir(“dirname”)"></a>os.chdir(“dirname”)</h3><ul>
<li>改变当前脚本工作目录；相当于shell 下cd</li>
</ul>
<h3 id="os-urandom-n"><a href="#os-urandom-n" class="headerlink" title="os.urandom(n)"></a>os.urandom(n)</h3><ul>
<li>随机生成bytes类型的32个字节长度字符串的方法</li>
</ul>
<h2 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h2><h3 id="os-path-abspath-path"><a href="#os-path-abspath-path" class="headerlink" title="os.path.abspath(path)"></a>os.path.abspath(path)</h3><ul>
<li>返回path规范化的绝对路径</li>
</ul>
<h3 id="os-path-split-path"><a href="#os-path-split-path" class="headerlink" title="os.path.split(path)"></a>os.path.split(path)</h3><ul>
<li>将path分割成目录和文件名，以元组返回</li>
</ul>
<h3 id="os-path-dirname-path"><a href="#os-path-dirname-path" class="headerlink" title="os.path.dirname(path)"></a>os.path.dirname(path)</h3><ul>
<li>返回path的目录。其实就是os.path.split(path)的第一个元素</li>
</ul>
<h3 id="os-path-basename-path"><a href="#os-path-basename-path" class="headerlink" title="os.path.basename(path)"></a>os.path.basename(path)</h3><ul>
<li>返回path最后的文件名。如果path以&#x2F;或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</li>
</ul>
<h3 id="os-path-exists-path"><a href="#os-path-exists-path" class="headerlink" title="os .path.exists(path)"></a>os .path.exists(path)</h3><ul>
<li>如果path存在，返回True，如果path不存在，返回False</li>
</ul>
<h3 id="os-path-isabs-path"><a href="#os-path-isabs-path" class="headerlink" title="os.path.isabs(path)"></a>os.path.isabs(path)</h3><ul>
<li>如果path是绝对路径，返回True</li>
</ul>
<h3 id="os-path-isfile-path"><a href="#os-path-isfile-path" class="headerlink" title="os.path.isfile(path)"></a>os.path.isfile(path)</h3><ul>
<li>如果path是一个存在的文件，返回True, 否则返回False</li>
</ul>
<h3 id="os-path-isdir-path"><a href="#os-path-isdir-path" class="headerlink" title="os .path.isdir(path)"></a>os .path.isdir(path)</h3><ul>
<li>如果path是一个存在的目录，则返回True, 否则返回False</li>
</ul>
<h3 id="os-path-join-path1-path2-…"><a href="#os-path-join-path1-path2-…" class="headerlink" title="os.path.join(path1[, path2[,…]])"></a>os.path.join(path1[, path2[,…]])</h3><ul>
<li>将多个路径组合后返回，第一个绝对路径之前的参数初被忽略</li>
</ul>
<h3 id="os-path-getatime-path"><a href="#os-path-getatime-path" class="headerlink" title="os.path.getatime(path)"></a>os.path.getatime(path)</h3><ul>
<li>返回path所指向的文件或者目录的最后访问时间</li>
</ul>
<h3 id="os-path-getmtime-path"><a href="#os-path-getmtime-path" class="headerlink" title="os.path.getmtime(path)"></a>os.path.getmtime(path)</h3><ul>
<li>返回path所指向的文件或目录的最后修改时间</li>
</ul>
<h3 id="os-path-getsize-path"><a href="#os-path-getsize-path" class="headerlink" title="os.path.getsize(path)"></a>os.path.getsize(path)</h3><ul>
<li>返回path的大小</li>
</ul>
<h2 id="os特殊属性"><a href="#os特殊属性" class="headerlink" title="os特殊属性"></a>os特殊属性</h2><h3 id="os-sep"><a href="#os-sep" class="headerlink" title="os.sep"></a>os.sep</h3><ul>
<li>输出操作系统特定的路径分隔符，win下为”\“, Linux下为”&#x2F;“</li>
</ul>
<h3 id="os-linesep"><a href="#os-linesep" class="headerlink" title="os.linesep"></a>os.linesep</h3><ul>
<li>输出当前平台使用的行终止符，win下为”\r\n”, Linux下为”\n”</li>
</ul>
<h3 id="os-pathsep"><a href="#os-pathsep" class="headerlink" title="os.pathsep"></a>os.pathsep</h3><ul>
<li>输出用于分割文件路径的字符串，win下为”;”, Linux下为”：”</li>
</ul>
<h3 id="os-name"><a href="#os-name" class="headerlink" title="os.name"></a>os.name</h3><ul>
<li>输出字符串指示当前使用来台。win -&gt;”nt”; Linux -&gt;”posix”</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>pickle模块</title>
    <url>/2019/03/20/python-pickle%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>  在存储数据或者网络传输数据的时候，需要对对象进行处理。把对象处理成方便存储和传输的数据格式。这个过程叫<strong>序列化</strong>。</p>
<p>  不同的序列化，结果也不同，但目的是一样的。都是为了存储和传输。</p>
<p>在python中存在三种序列化的方案：</p>
<ul>
<li>pickle：可将python中的任意数据类型转化成bytes并写入到文件中，同样也可以把文件中写好的bytes转换回我们python的数据</li>
<li>shelve：简单另类的一种序列化的方案。有点儿类似redis，可以作为一种小型的数据库来使用</li>
<li>json：将python中常见的字典、列表转化成字符串。是目前前后端数据交互使用频率最高的一种数据格式</li>
</ul>
<h2 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h2><p>  把python对象写入到文件中的一种解决方案，但写入到文件的是bytes.</p>
<h3 id="dumps"><a href="#dumps" class="headerlink" title="dumps"></a>dumps</h3><p>  将python对象序列化为bytes类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s抓老鼠&quot;</span> % <span class="variable language_">self</span>.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = Cat(<span class="string">&quot;jerry&quot;</span>, <span class="number">5</span>)</span><br><span class="line">bs = pickle.dumps(c)</span><br><span class="line"><span class="built_in">print</span>(bs)  <span class="comment"># b&#x27;\x80\x03c__main__\nCat\nq\x00)\x81q\x01&#125;q\x02(X\x04\x00\x00\x00nameq\x03X\x05\x00\x00\x00jerryq\x04X\x03\x00\x00\x00ageq\x05K\x05ub.&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="loads"><a href="#loads" class="headerlink" title="loads"></a>loads</h3><p>  将bytes反序列化为python对象。注：反序列化为对象后，对象定义代码必须存在，否则无法使用对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s抓老鼠&quot;</span> % <span class="variable language_">self</span>.name)</span><br><span class="line"></span><br><span class="line">bs = <span class="string">b&#x27;\x80\x03c__main__\nCat\nq\x00)\x81q\x01&#125;q\x02(X\x04\x00\x00\x00nameq\x03X\x05\x00\x00\x00jerryq\x04X\x03\x00\x00\x00ageq\x05K\x05ub.&#x27;</span></span><br><span class="line">cc = pickle.loads(bs)</span><br><span class="line"><span class="built_in">print</span>(cc.name, cc.age)  <span class="comment"># jerry 5</span></span><br></pre></td></tr></table></figure>



<h3 id="dump-load"><a href="#dump-load" class="headerlink" title="dump &amp;load"></a>dump &amp;load</h3><ul>
<li>dump：将python对象序列化后写入到文件中</li>
<li>load：从文件中读取bytes,并反序列化为对象</li>
<li>对于读写多对象，由于读取时不知文件中写入了多少个对象，导致不好读取，所以一般采用把对象先装进list，然后把list写入至文件中，读取后遍历list即可拿到对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, pwd</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.pwd = pwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = [Person(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;123&quot;</span>), Person(<span class="string">&quot;Linda&quot;</span>, <span class="string">&quot;123&quot;</span>), Person(<span class="string">&quot;john&quot;</span>, <span class="string">&quot;123&quot;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;login&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> el <span class="keyword">in</span> lst:</span><br><span class="line">        pickle.dump(el, f)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;login&quot;</span>, mode=<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lst)):  <span class="comment"># 已知对象个数，对文件进行遍历读取</span></span><br><span class="line">        ret = pickle.load(f)</span><br><span class="line">        <span class="built_in">print</span>(ret.name, ret.pwd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Tom <span class="number">123</span></span><br><span class="line">Linda <span class="number">123</span></span><br><span class="line">john <span class="number">123</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s抓老鼠&quot;</span> % <span class="variable language_">self</span>.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = [Cat(<span class="string">&quot;jerry&quot;</span>, <span class="number">5</span>), Cat(<span class="string">&quot;tomy&quot;</span>, <span class="number">6</span>), Cat(<span class="string">&quot;alpha&quot;</span>, <span class="number">7</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;cat&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(lst, f)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;cat&quot;</span>, mode=<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    ret = pickle.load(f)</span><br><span class="line">    <span class="keyword">for</span> el <span class="keyword">in</span> ret:</span><br><span class="line">        el.eat()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">jerry抓老鼠</span><br><span class="line">tomy抓老鼠</span><br><span class="line">alpha抓老鼠</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>  注册登录程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, username, password</span>):</span><br><span class="line">        <span class="variable language_">self</span>.username = username</span><br><span class="line">        <span class="variable language_">self</span>.password = password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">regist</span>(<span class="params">self</span>):</span><br><span class="line">        uname = <span class="built_in">input</span>(<span class="string">&quot;username: &quot;</span>)</span><br><span class="line">        pwd = <span class="built_in">input</span>(<span class="string">&quot;password: &quot;</span>)</span><br><span class="line">        user = User(uname, pwd)</span><br><span class="line">        pickle.dump(user, <span class="built_in">open</span>(<span class="string">&quot;userinfo&quot;</span>, mode=<span class="string">&quot;wb&quot;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;regist successful!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        uname = <span class="built_in">input</span>(<span class="string">&quot;username: &quot;</span>)</span><br><span class="line">        pwd = <span class="built_in">input</span>(<span class="string">&quot;password: &quot;</span>)</span><br><span class="line">        f = <span class="built_in">open</span>(<span class="string">&quot;userinfo&quot;</span>, mode=<span class="string">&quot;rb&quot;</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                u = pickle.load(f)</span><br><span class="line">                <span class="keyword">if</span> u.username == uname <span class="keyword">and</span> u.password == pwd:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;login successful!&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;login failed!&quot;</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.regist()</span><br><span class="line">        <span class="variable language_">self</span>.regist()</span><br><span class="line">        <span class="variable language_">self</span>.login()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    c = Client()</span><br><span class="line">    c.run()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>random模块</title>
    <url>/2019/03/20/python-random%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>  所有关于随机相关的内容都在random模块中</p>
<h2 id="相关功能"><a href="#相关功能" class="headerlink" title="相关功能"></a>相关功能</h2><h3 id="random-1"><a href="#random-1" class="headerlink" title="random()"></a>random()</h3><ul>
<li>产生(0, 1)之间的小数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">print(random.random())  # 0.2622839912972649</span><br></pre></td></tr></table></figure>



<h3 id="uniform-a-b"><a href="#uniform-a-b" class="headerlink" title="uniform(a, b)"></a>uniform(a, b)</h3><ul>
<li>产生(a, b)之间的小数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">print(random.uniform(3, 10))  # 3.1025846246337134</span><br></pre></td></tr></table></figure>



<h3 id="randint-a-b"><a href="#randint-a-b" class="headerlink" title="randint(a, b)"></a>randint(a, b)</h3><ul>
<li>产生[a, b]之间的整数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">print(random.randint(1, 10)) # 7</span><br></pre></td></tr></table></figure>



<h3 id="randrange-a-b-step"><a href="#randrange-a-b-step" class="headerlink" title="randrange(a, b, step)"></a>randrange(a, b, step)</h3><ul>
<li>产生[a:b:step]里的一个数</li>
<li>step默认等于1</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">print(random.randrange(1, 10, 2)) # 3</span><br></pre></td></tr></table></figure>



<h3 id="choice-string-tuple-list"><a href="#choice-string-tuple-list" class="headerlink" title="choice(string&#x2F;tuple&#x2F;list)"></a>choice(string&#x2F;tuple&#x2F;list)</h3><ul>
<li>产生对象里的其中一个元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">print(random.choice([11, 22, 33, 44, [55, 66, 77]]))  # 44</span><br></pre></td></tr></table></figure>



<h3 id="sample-string-tuple-list-set"><a href="#sample-string-tuple-list-set" class="headerlink" title="sample(string&#x2F;tuple&#x2F;list&#x2F;set)"></a>sample(string&#x2F;tuple&#x2F;list&#x2F;set)</h3><ul>
<li>从对象中任选两个元素，以列表形式返回</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">print(random.sample([11, 22, 33, 44], 2))  # [44, 22]</span><br></pre></td></tr></table></figure>



<h3 id="shuffle-list"><a href="#shuffle-list" class="headerlink" title="shuffle(list)"></a>shuffle(list)</h3><ul>
<li>随机打乱顺序</li>
<li>返回None</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">lst = [11, 22, 33, 44, 55]</span><br><span class="line">random.shuffle(lst)</span><br><span class="line">print(lst)  # [11, 55, 44, 33, 22]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>re模块</title>
    <url>/2019/03/20/python-re%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h2><p>  re模块是python提供的一套关于处理正则表达式的模块。</p>
<h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>作用：搜索</p>
<ul>
<li>搜索到结果就返回。</li>
<li>如果有多个结果，只返回第一个结果，且多次调用，返回的都是第一个结果</li>
<li>如果匹配不上就报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">res = re.search(<span class="string">r&quot;o&quot;</span>, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res.group())   <span class="comment"># o</span></span><br><span class="line"></span><br><span class="line">s = re.search(<span class="string">r&quot;c&quot;</span>, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.group())  <span class="comment"># AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;group&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>作用：从开头匹配</p>
<ul>
<li>如果匹配到了，就返回</li>
<li>如果匹配不到，就报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">res = re.<span class="keyword">match</span>(<span class="string">r&quot;h&quot;</span>, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(res.group())   <span class="comment"># h</span></span><br><span class="line"></span><br><span class="line">s = re.<span class="keyword">match</span>(<span class="string">r&quot;c&quot;</span>, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s.group())  <span class="comment"># AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;group&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h3><p>作用：查找所有，返回list</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">lst = re.findall(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;name Tom age 18 phone 2354786&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;18&#x27;, &#x27;2354786&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于正则表达中的组”()”，findall会优先把匹配结果组里的内容返回</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">lst = re.findall(<span class="string">r&quot;www\.(baidu|qq)\.com&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;baidu&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果想要返回匹配结果，添加”？：”取消权限即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">lst = re.findall(<span class="string">r&quot;www\.(?:baidu|qq)\.com&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(lst)  <span class="comment"># [&#x27;www.baidu.com&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="finditer"><a href="#finditer" class="headerlink" title="finditer"></a>finditer</h3><p>作用：查找所有，返回迭代器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">lst = re.finditer(<span class="string">r&quot;\d+&quot;</span>, <span class="string">&quot;name Tom age 18 phone 2354786&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> el <span class="keyword">in</span> lst:</span><br><span class="line">    <span class="built_in">print</span>(el.group())</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">2354786</span></span><br></pre></td></tr></table></figure>



<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>作用：分割，返回list</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.split(<span class="string">r&quot;[abc]&quot;</span>, <span class="string">&quot;qwerafjbfcd&quot;</span>)  <span class="comment"># 先按a分割，再按b分割，然后按c分割 </span></span><br><span class="line"><span class="built_in">print</span>(ret)  <span class="comment"># [&#x27;qwer&#x27;, &#x27;fj&#x27;, &#x27;f&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在匹配部分加上”()”与不加所得出的结果不同。这个在某些需要保留匹配部分的使用过程是非常重要的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.split(<span class="string">&quot;\d+&quot;</span>, <span class="string">&quot;eva3egon4yuan&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)  <span class="comment"># [&#x27;eva&#x27;, &#x27;egon&#x27;, &#x27;yuan&#x27;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.split(<span class="string">&quot;(\d+)&quot;</span>, <span class="string">&quot;eva3egon4yuan&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)  <span class="comment"># [&#x27;eva&#x27;, &#x27;3&#x27;, &#x27;egon&#x27;, &#x27;4&#x27;, &#x27;yuan&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h3><p>作用：替换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.sub(<span class="string">r&quot;\s&quot;</span>, <span class="string">&quot;__&quot;</span>, <span class="string">&quot;hello world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)  <span class="comment"># hello__world</span></span><br></pre></td></tr></table></figure>

<h3 id="subn"><a href="#subn" class="headerlink" title="subn"></a>subn</h3><p>作用：替换，返回元组（替换的结果，替换次数）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">ret = re.subn(<span class="string">r&quot;\s&quot;</span>, <span class="string">&quot;__&quot;</span>, <span class="string">&quot;name age gender phone&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)  <span class="comment"># (&#x27;name__age__gender__phone&#x27;, 3)</span></span><br></pre></td></tr></table></figure>

<h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><p>作用：将正则表达式编译成一个正则表达式对象，进行预加载</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;\d&#123;3&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">ret = obj.search(<span class="string">&quot;abc333eee&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret.group())  <span class="comment"># 333</span></span><br></pre></td></tr></table></figure>



<h2 id="re-S"><a href="#re-S" class="headerlink" title="re.S"></a>re.S</h2><p>  正则表达式中，”.”表示匹配除”\n”以外的所有字符。对于字符串中有换行，此时正则匹配到的则是多个字符串，而利用re.S，”.”可以匹配”\n”，即得到的就是一个整体字符串。</p>
<h2 id="对单一页面内容的抓取"><a href="#对单一页面内容的抓取" class="headerlink" title="对单一页面内容的抓取"></a>对单一页面内容的抓取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># url</span></span><br><span class="line">url = <span class="string">&quot;url&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取全部内容</span></span><br><span class="line">content = urlopen(url).read().decode()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预加载正则表达</span></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&quot;正则表达&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取特定内容</span></span><br><span class="line">res = obj.search(content).group(<span class="string">&quot;组名&quot;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="对同一结构，多页面内容的抓取"><a href="#对同一结构，多页面内容的抓取" class="headerlink" title="对同一结构，多页面内容的抓取"></a>对同一结构，多页面内容的抓取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预加载正则表达式</span></span><br><span class="line">obj = re.<span class="built_in">compile</span>(<span class="string">r&#x27;&lt;div class=&quot;item&quot;&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?导演: (?P&lt;director&gt;.*?)&amp;nbsp;&amp;nbsp;&amp;nbsp;.*?&lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;(?P&lt;score&gt;.*?)&lt;/span&gt;.*?&lt;span&gt;(?P&lt;people&gt;.*?)人评价&lt;/span&gt;&#x27;</span>, re.S)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_content</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取内容</span></span><br><span class="line"><span class="string">    :param url: 网址</span></span><br><span class="line"><span class="string">    :return: 网页全部内容</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    content = urlopen(url).read().decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_content</span>(<span class="params">content</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    解析内容</span></span><br><span class="line"><span class="string">    :param content: 网页全部内容</span></span><br><span class="line"><span class="string">    :return: 字典形式的所需内容</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    pc = obj.finditer(content)</span><br><span class="line">    <span class="keyword">for</span> el <span class="keyword">in</span> pc:</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: el.group(<span class="string">&quot;name&quot;</span>),</span><br><span class="line">            <span class="string">&quot;director&quot;</span>: el.group(<span class="string">&quot;director&quot;</span>),</span><br><span class="line">            <span class="string">&quot;score&quot;</span>: el.group(<span class="string">&quot;score&quot;</span>),</span><br><span class="line">            <span class="string">&quot;people&quot;</span>: el.group(<span class="string">&quot;people&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取并解析内容，将所需内容写入文件中</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        url = <span class="string">&quot;https://movie.douban.com/top250?start=%s&amp;filter=&quot;</span> % (i*<span class="number">25</span>)</span><br><span class="line">        p = parse_content(get_content(url))</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;movie.txt&quot;</span>, mode=<span class="string">&quot;a&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> el <span class="keyword">in</span> p:</span><br><span class="line">                f.write(<span class="built_in">str</span>(el) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Set</title>
    <url>/2019/03/16/python-set/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>set中的元素：可hash(int, str, tuple, bool)，不重复，底层存储无序</li>
<li>set集合中的元素必须是可hash，但set本身是不可hash，是可变的数据类型</li>
</ul>
<h2 id="应用-重点"><a href="#应用-重点" class="headerlink" title="应用(重点)"></a>应用(重点)</h2><p>  利用set中元素不可重复，可给list去重</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 11, 22, 22, 33, 33, 44, 44, 55, 55]</span><br><span class="line"></span><br><span class="line">lst = list(set(lst))</span><br><span class="line">print(lst)  # [33, 11, 44, 22, 55]  结果无序，但已去重</span><br></pre></td></tr></table></figure>



<h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li><p>add</p>
<p>重复的内容不会被添加到set集合中，新增对象须为可hash数据类型</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#123;11, 22, 33, 44&#125;</span><br><span class="line"></span><br><span class="line">s.add(&quot;hello&quot;)</span><br><span class="line">print(add)  # &#123;33, 11, 44, &#x27;hello&#x27;, 22&#125;</span><br><span class="line"></span><br><span class="line">s.add(11)</span><br><span class="line">print(s)  # &#123;33, 11, 44, &#x27;hello&#x27;, 22&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>update</p>
<p>迭代更新，新增对象可为可hash或不可hash数据类型</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#123;11, 22, 33, 44&#125;</span><br><span class="line"></span><br><span class="line">s.update(&quot;hello&quot;)</span><br><span class="line">print(s)  # &#123;33, &#x27;l&#x27;, 11, 44, &#x27;e&#x27;, 22, &#x27;o&#x27;, &#x27;h&#x27;&#125;</span><br><span class="line">s = &#123;11, 22, 33, 44&#125;</span><br><span class="line"></span><br><span class="line">s.update([55, 66, 77])</span><br><span class="line">print(s)  # &#123;33, 66, 11, 44, 77, 22, 55&#125;</span><br></pre></td></tr></table></figure>



<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li><p>pop</p>
<p>随机弹出一个</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#123;11, 22, 33, 44&#125;</span><br><span class="line"></span><br><span class="line">num = s.pop()</span><br><span class="line">print(s) # &#123;11, 44, 22&#125;</span><br><span class="line">print(num) # 33</span><br></pre></td></tr></table></figure>

<ul>
<li><p>remove</p>
<p>根据元素内容进行删除，若元素不存在，则报错</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#123;11, 22, 33, 44&#125;</span><br><span class="line"></span><br><span class="line">s.remove(11)</span><br><span class="line">print(s)  # &#123;33, 44, 22&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>clear</p>
<p>清空set集合，如果set集合是空的，打印出来是set()，须与dict区分</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#123;11, 22, 33, 44&#125;</span><br><span class="line"></span><br><span class="line">s.clear()</span><br><span class="line">print(s)  # set()</span><br></pre></td></tr></table></figure>



<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul>
<li>set集合中数据没有索引，也没法定位一个元素，所以没有办法进行直接修改</li>
<li>可采用先删除后添加方式完成修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &#123;11, 22, 33, 44&#125;</span><br><span class="line"></span><br><span class="line">s.remove(11)</span><br><span class="line">s.add(55)</span><br><span class="line">print(s)  # &#123;33, 44, 22, 55&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>  set是一个可迭代对象，可进行for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for el in s:</span><br><span class="line">    print(el)</span><br></pre></td></tr></table></figure>



<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><ul>
<li>&amp;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1 &amp; s2)  # &#123;33, 44&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>intersection</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1.intersection(s2)) # &#123;33, 44&#125;</span><br></pre></td></tr></table></figure>



<h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><ul>
<li>|</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1 | s2)  # &#123;33, 22, 55, 11, 44&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>union</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1.union(s2))  # &#123;33, 22, 55, 11, 44&#125;</span><br></pre></td></tr></table></figure>



<h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><p>  s1 - s2：得到s1中单独存在的</p>
<ul>
<li>-</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1 - s2)  # &#123;11, 22&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>difference</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1.difference(s2))  # &#123;11, 22&#125;</span><br></pre></td></tr></table></figure>



<h3 id="反交集"><a href="#反交集" class="headerlink" title="反交集"></a>反交集</h3><p>  s1 ^ s2：得到一个新的集合，里面元素为两集合（s1, s2）不相同的元素</p>
<ul>
<li>^</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1 ^ s2)  # &#123;22, 55, 11&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>symmetric_difference</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1.symmetric_difference(s2))  # &#123;22, 55, 11&#125;</span><br></pre></td></tr></table></figure>



<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><p>  s1 &lt; s2:判断s1是否为s2子集，返回True or False</p>
<ul>
<li>&lt;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1 &lt; s2)  # False</span><br></pre></td></tr></table></figure>

<ul>
<li>issubset</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;11, 22, 33, 44, 55&#125;</span><br><span class="line"></span><br><span class="line">print(s1.issubset(s2)) # True</span><br></pre></td></tr></table></figure>



<h3 id="超集"><a href="#超集" class="headerlink" title="超集"></a>超集</h3><p>  s1 &gt; s2：判断s1是否为s2的超集，也即s2是否为s1的子集，返回True or False</p>
<ul>
<li>&gt;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;11, 22, 33&#125;</span><br><span class="line"></span><br><span class="line">print(s1 &gt; s2)  # True</span><br></pre></td></tr></table></figure>

<ul>
<li>issuperset</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#123;11, 22, 33, 44&#125;</span><br><span class="line">s2 = &#123;11, 22, 33&#125;</span><br><span class="line"></span><br><span class="line">print(s1.issuperset(s2))  # True</span><br></pre></td></tr></table></figure>



<h3 id="frozenset"><a href="#frozenset" class="headerlink" title="frozenset"></a>frozenset</h3><ul>
<li>frozenset是一种不可变，可hash的集合</li>
<li>通过frozenset可将可变的数据类型转换成不可变，可hash的frozenset集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = [44, 55, 66]</span><br><span class="line"></span><br><span class="line">s1 = &#123;11, 22, 33, s&#125;  # 报错  TypeError: unhashable type: &#x27;list&#x27;</span><br><span class="line">s = frozenset([44, 55, 66])print(s)  # frozenset(&#123;66, 44, 55&#125;)</span><br><span class="line"></span><br><span class="line">s1 = &#123;11, 22, 33, s&#125;  # 正常</span><br><span class="line"> </span><br><span class="line">s = frozenset([1,2,3,4,5])</span><br><span class="line">print(s)  # frozenset(&#123;1, 2, 3, 4, 5&#125;)</span><br><span class="line">for el in s:</span><br><span class="line">    print(el)  # 1 2 3 4 5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>shelve模块</title>
    <url>/2019/03/20/python-shelve%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="shelve"><a href="#shelve" class="headerlink" title="shelve"></a>shelve</h2><ul>
<li>shelve提供python的持久化操作。</li>
<li>持久化：把数据写到硬盘上</li>
<li>shelve操作与字典非常类似</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Tom&quot;</span></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;name&quot;</span>])  <span class="comment"># Tom</span></span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure>

<p>文件关闭后无法读取其内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;tom&quot;</span>)</span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">d.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;name&quot;</span>])  <span class="comment"># ValueError: invalid operation on closed shelf</span></span><br></pre></td></tr></table></figure>

<p> 遍历：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;namelist&quot;</span>, writeback=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">d[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">d[<span class="string">&quot;age&quot;</span>] = <span class="number">18</span></span><br><span class="line">d.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;namelist&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:  <span class="comment"># 遍历所有的key</span></span><br><span class="line">    <span class="built_in">print</span>(k)  <span class="comment"># name age</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d.keys():  <span class="comment"># 遍历所有key</span></span><br><span class="line">    <span class="built_in">print</span>(k)  <span class="comment"># name age</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():  <span class="comment"># 遍历所有的键-值对</span></span><br><span class="line">    <span class="built_in">print</span>(k, v)  <span class="comment"># name Tom   age 18</span></span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure>



<h2 id="writeback"><a href="#writeback" class="headerlink" title="writeback"></a>writeback</h2><ul>
<li>把修改的内容自动回写到文件中</li>
</ul>
<h3 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h3><p>shelve.open()默认writeback&#x3D;False，所以，在默认情况下修改字典的数据，修改内容不会写入到文件中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;namedict&quot;</span>)</span><br><span class="line">d[<span class="string">&quot;one&quot;</span>] = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>, <span class="string">&quot;hobby&quot;</span>: <span class="string">&quot;football&quot;</span>&#125;</span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;namedict&quot;</span>)</span><br><span class="line">d[<span class="string">&quot;one&quot;</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Linda&quot;</span></span><br><span class="line">d.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;namedict&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;one&quot;</span>])  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18, &#x27;hobby&#x27;: &#x27;football&#x27;&#125;</span></span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure>

<p> 当writeback&#x3D;True时，修改的数据保存在文件中，再次读取为修改后的结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;namedict&quot;</span>, writeback=<span class="literal">True</span>)</span><br><span class="line">d[<span class="string">&quot;one&quot;</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Linda&quot;</span></span><br><span class="line">d.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;namedict&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;one&quot;</span>])  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;Linda&#x27;, &#x27;age&#x27;: 18, &#x27;hobby&#x27;: &#x27;football&#x27;&#125;</span></span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure>



<h3 id="删除内容"><a href="#删除内容" class="headerlink" title="删除内容"></a>删除内容</h3><p>  在writeback&#x3D;True条件下，删除内容，文件中内容也会被删除</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;namedict&quot;</span>, writeback=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">del</span> d[<span class="string">&quot;one&quot;</span>]</span><br><span class="line">d.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = shelve.<span class="built_in">open</span>(<span class="string">&quot;namedict&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d[<span class="string">&quot;one&quot;</span>])  <span class="comment"># KeyError: b&#x27;one&#x27; 报错</span></span><br><span class="line">d.close()  </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>String</title>
    <url>/2019/03/16/python-string/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>把字符连成串，在python中用’, ‘’, ‘’’, “””引起来的内容被称为字符串</li>
<li>字符串是不可变对象，所有操作都是产生新字符串返回</li>
</ul>
<h2 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h2><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p> 索引就是下标，下标从<strong>0</strong>开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &#x27;python&#x27;</span><br><span class="line"></span><br><span class="line">print(s1[0]) # 获取第一个</span><br><span class="line">print(s1[6]) #越界，报错</span><br><span class="line">print(s1[-1]) # 获取倒数第一个</span><br><span class="line">print(s1[-2]) # 获取倒数第二个</span><br></pre></td></tr></table></figure>



<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><ul>
<li>使用下标来截取部分字符串的内容</li>
<li><strong>语法：str[start: end]</strong></li>
<li>规则：顾头不顾尾，从start 开始截取，截取到end位置，但不包括end</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s2 = &quot;python&quot;</span><br><span class="line">print(s2[0:3]) # pyt</span><br><span class="line">print(s2[4:6]) # on</span><br><span class="line">print(s2[3:]) # hon</span><br><span class="line">print(s2[-1:-3]) # 从-1获取到-5这样是获取不到任何结果的，默认从左往右数</span><br><span class="line">print(s2[-3:-1]) # ho</span><br><span class="line">print(s2[:]) # python</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>步长：</strong></p>
<p> 步长如果是正数，则从左往右取，如果是负数，则从右往左取。默认为1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s3 = &quot;&quot;python&quot;</span><br><span class="line"></span><br><span class="line">print(s3[1:5:2]) # yh</span><br><span class="line">print(s3[-1:-5:-1]) #noht</span><br><span class="line">print(s3[-2::-2]) # otp</span><br></pre></td></tr></table></figure>



<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><ul>
<li>capitalize</li>
</ul>
<p><strong>功能</strong>：对第一个单词首字母大写，对于非第一个单词首字母进行检查，若大写则改为小写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">print(s1.capitalize()) # Hello worlds2 = &quot;heLLo&quot;print(s2.capitalize()) # Hello </span><br></pre></td></tr></table></figure>

<ul>
<li>lower</li>
</ul>
<p><strong>功能</strong>：将字符串全部转换成小写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;HeLLo WoRld&quot;</span><br><span class="line"></span><br><span class="line">print(s1.lower()) # hello world</span><br></pre></td></tr></table></figure>

<ul>
<li>upper</li>
</ul>
<p><strong>功能</strong>：将字符串全部转换成大写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">print(s1.upper()) # HELLO WORLD</span><br></pre></td></tr></table></figure>

<ul>
<li>swapcase</li>
</ul>
<p><strong>功能</strong>：大小写互相转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;Hello World&quot;</span><br><span class="line"></span><br><span class="line">print(s1.swapcase()) # hELLO wORLD</span><br></pre></td></tr></table></figure>

<ul>
<li>casefold</li>
</ul>
<p><strong>功能</strong>：转换成小写</p>
<p>和lower的区别：lower()对某些字符支持不够好。casefold()对所有的字母都有效。比如东欧的一些字母。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s2 = &quot;БBß&quot; # 俄美德字符</span><br><span class="line"></span><br><span class="line">print(s2.casefold()) # 6bss</span><br><span class="line">print(s2.lower()) # 6bß</span><br></pre></td></tr></table></figure>

<ul>
<li>title</li>
</ul>
<p><strong>功能</strong>：每个被特殊字符隔开的字母首字母大写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;hello world&quot;</span><br><span class="line">s2 = &quot;pyt你好hon&quot;</span><br><span class="line"></span><br><span class="line">print(s1.title()) # Hello World</span><br><span class="line">print(s2.title()) # Pyt你好Hon</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="切来切去"><a href="#切来切去" class="headerlink" title="切来切去"></a>切来切去</h3><ul>
<li>center</li>
</ul>
<p><strong>功能</strong>：居中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;python&quot;</span><br><span class="line"></span><br><span class="line">print(s1.center(10)) #  python  </span><br><span class="line">print(s1.center(10, &quot;*&quot;)) # **python**</span><br></pre></td></tr></table></figure>

<ul>
<li>expandtabs</li>
</ul>
<p><strong>功能</strong>：更改tab的长度，默认长度改为8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = “pyth\ton”</span><br><span class="line"></span><br><span class="line">print(s1.expandtabs()) # pyth    on</span><br></pre></td></tr></table></figure>

<ul>
<li>strip</li>
</ul>
<p><strong>功能</strong>：默认去掉左右两端的空白(空格，\n, \t)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;  \n  python  \t  &quot;</span><br><span class="line"></span><br><span class="line">print(s1.strip()) # pythons2 = &quot;hello world&quot;print(s2.lstrip(&quot;h&quot;).rstrip(&quot;d&quot;) # ello worl</span><br></pre></td></tr></table></figure>

<ul>
<li>lstrip</li>
</ul>
<p><strong>功能</strong>：默认去掉左端的空白(空格，\n, \t)</p>
<ul>
<li>rstrip</li>
</ul>
<p><strong>功能</strong>：默认去掉右端的空白(空格，\n, \t)</p>
<ul>
<li>replace</li>
</ul>
<p><strong>功能</strong>：字符串替换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">ret = s1.replace(&quot;o&quot;, &quot;p&quot;) # hellp wprld</span><br><span class="line">ret = s1.replace(&quot;o&quot;, &quot;p&quot;,1) # hellp world</span><br></pre></td></tr></table></figure>

<ul>
<li>split</li>
</ul>
<p><strong>功能</strong>：字符串切割</p>
<ul>
<li>当括号内为无时即s.split()，此时根据空白切割</li>
<li>s.split(“|”, 1),根据字符串s中第一个”|”切割</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;python, java, c, c++, c#&quot;</span><br><span class="line"></span><br><span class="line">print(s1.split(&quot;,&quot;) # [&quot;python&quot;, &quot;java&quot;, &quot;c&quot;, &quot;c++&quot;, &quot;c#&quot;</span><br><span class="line">s = &quot;py|th|on&quot;</span><br><span class="line">print(s.split(&quot;|&quot;, 1))  # [&#x27;py&#x27;, &#x27;th|on&#x27;]</span><br><span class="line">print(int(&quot;  1  &quot;)) # 1 int()会自动去除左右两端的空白</span><br></pre></td></tr></table></figure>

<ul>
<li>join</li>
</ul>
<p><strong>功能</strong>：将列表名元素按给定字符连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">ss = &quot;_&quot;.join(s)</span><br><span class="line">print(ss)  # h_e_l_l_o</span><br><span class="line">lst = [&quot;hello&quot;, &quot;world&quot;]</span><br><span class="line"></span><br><span class="line">s = &quot;_&quot;.join(lst)</span><br><span class="line">print(s) # hello_world</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul>
<li>startswith</li>
</ul>
<p><strong>功能</strong>：判断是否以某个&#x2F;些字符开头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;Beautiful is better than ugly&quot;</span><br><span class="line"></span><br><span class="line">print(s1.startswith(&quot;Beautiful&quot;)) # True</span><br></pre></td></tr></table></figure>

<ul>
<li>endswith</li>
</ul>
<p><strong>功能</strong>：判数是否以某个&#x2F;些字符结尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;Beautiful is better than ugly&quot;</span><br><span class="line"></span><br><span class="line">print(s1.startswith(&quot;ugly&quot;)) # True</span><br></pre></td></tr></table></figure>

<ul>
<li>count</li>
</ul>
<p><strong>功能</strong>：查找某个&#x2F;些字符出现的次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;python&quot;</span><br><span class="line"></span><br><span class="line">print(s1.count(&quot;h&quot;)) # 1print(&quot;hello&quot;.count(&quot;l&quot;, 0, 3)) # 1  判断&quot;hello&quot;[0:3]中&quot;l&quot;出现多少次</span><br></pre></td></tr></table></figure>

<ul>
<li>find</li>
</ul>
<p><strong>功能</strong>：查找某个&#x2F;些字符出现的位置，如果没有返回-1</p>
<p>如果查找的某个字符在字符串中出现多次，则查找所得的结果是第一个字符出现的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;python, java, c, c++, php&quot;</span><br><span class="line"></span><br><span class="line">print(s1.find(&quot;java&quot;)) # 8</span><br></pre></td></tr></table></figure>

<p>切片找：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;python, java, c, c++, php&quot;</span><br><span class="line"></span><br><span class="line">print(s1.find(&quot;java&quot;, 12, 25)) # -1 </span><br></pre></td></tr></table></figure>

<ul>
<li>rfind</li>
</ul>
<p>从字符串末尾开始查找</p>
<ul>
<li>index</li>
</ul>
<p><strong>功能</strong>：求索引位置，如果找不到索引，程序会报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;python, java, c, c++, php&quot;</span><br><span class="line"></span><br><span class="line">print(s1.index(&quot;java&quot;)) # 8</span><br></pre></td></tr></table></figure>

<ul>
<li>rindex</li>
</ul>
<p>从字符串末尾开始查找</p>
<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><ul>
<li>format</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;我叫%s, 今年%d岁了， 我喜欢%s&quot;%(&quot;赛利亚&quot;， 18， &quot;玩&quot;))</span><br><span class="line"></span><br><span class="line">print(&quot;我叫&#123;&#125;, 今年&#123;&#125;岁了， 我喜欢&#123;&#125;&quot;.format(&quot;赛利亚&quot;， 18， &quot;玩&quot;))</span><br><span class="line"></span><br><span class="line">print(&quot;我叫&#123;0&#125;, 今年&#123;2&#125;岁了， 我喜欢&#123;1&#125;&quot;.format(&quot;赛利亚&quot;, &quot;玩&quot;, 18))</span><br><span class="line"></span><br><span class="line">print(&quot;我叫&#123;name&#125;, 今年&#123;age&#125;岁了， 我喜欢&#123;hobby&#125;&quot;.format(name=&quot;赛利亚&quot;, hobby=&quot;玩&quot;, age=18))</span><br></pre></td></tr></table></figure>



<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><ul>
<li>isalnum</li>
</ul>
<p><strong>功能</strong>：是否由字母和数字(int)组成，可以理解为包含isalpha和isnumeric的功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;123.16&quot;</span><br><span class="line">s2= &quot;abc&quot;</span><br><span class="line">s3 = &quot;_abc!@&quot;s4 = &quot;adfgsddfrd123456789壹贰叁肆伍陆柒一二三&quot;</span><br><span class="line"></span><br><span class="line">print(s1.isalnum()) # False</span><br><span class="line">print(s2.isalnum()) # True</span><br><span class="line">print(s3.isalnum()) # Falseprint(s4.isalnum()) # True</span><br></pre></td></tr></table></figure>

<ul>
<li>isalpha</li>
</ul>
<p><strong>功能</strong>：是否由字母组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;123.16&quot;</span><br><span class="line">s2= &quot;abc&quot;</span><br><span class="line">s3 = &quot;_abc!@&quot;s4 = &quot;中国&quot;</span><br><span class="line"></span><br><span class="line">print(s1.isalpha()) # False</span><br><span class="line"></span><br><span class="line">print(s2.isalpha()) # True</span><br><span class="line"></span><br><span class="line">print(s3.isalpha()) # Falseprint(s4.isalpha()) # True</span><br></pre></td></tr></table></figure>

<ul>
<li>isdigit</li>
</ul>
<p><strong>功能</strong>：是否由阿拉伯数字(%d)组成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;123&quot;</span><br><span class="line">s2 = &quot;123.16&quot;</span><br><span class="line"></span><br><span class="line">print(s1.isdigit()) # True</span><br><span class="line">print(s2.isdigit()) # False</span><br></pre></td></tr></table></figure>

<ul>
<li><p>isdecimal</p>
</li>
<li><p>isnumeric</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &quot;123456789壹贰叁肆伍陆柒一二三四五&quot;</span><br><span class="line"></span><br><span class="line">print(a.isnumeric()) # True</span><br></pre></td></tr></table></figure>



<h3 id="计算字符串长度"><a href="#计算字符串长度" class="headerlink" title="计算字符串长度"></a>计算字符串长度</h3><ul>
<li>len</li>
</ul>
<p> len()是python的内置函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;python&quot;</span><br><span class="line"></span><br><span class="line">print(len(s1)) # 6</span><br></pre></td></tr></table></figure>



<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><ul>
<li>可以使用for循环来遍历字符串中的每一个字符</li>
<li>可迭代对象：可以一个一个往外取值的对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s1 = &quot;hello world&quot;</span><br><span class="line"></span><br><span class="line">for c in s1:    </span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>sys模块</title>
    <url>/2019/03/20/python-sys%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><p>  所有和python解释器相关的都在sys模块中</p>
<h2 id="相关功能"><a href="#相关功能" class="headerlink" title="相关功能"></a>相关功能</h2><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><ul>
<li>返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mport sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="string">&#x27;E:\\python_个人\\day 023 re模块&#x27;</span>, <span class="string">&#x27;E:\\python_个人&#x27;</span>, <span class="string">&#x27;C:\\Python36\\python36.zip&#x27;</span>, <span class="string">&#x27;C:\\Python36\\DLLs&#x27;</span>, <span class="string">&#x27;C:\\Python36\\lib&#x27;</span>, <span class="string">&#x27;C:\\Python36&#x27;</span>, <span class="string">&#x27;C:\\Python36\\lib\\site-packages&#x27;</span>, <span class="string">&#x27;E:\\Program Files\\JetBrains\\PyCharm 2018.2.4\\helpers\\pycharm_matplotlib_backend&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>由返回结果可知，返回的是列表，由此，可通过append方法手动增加搜索路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">sys.path.append(<span class="string">&quot;e:/&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[<span class="string">&#x27;E:\\python_个人\\day 023 re模块&#x27;</span>, <span class="string">&#x27;E:\\python_个人&#x27;</span>, <span class="string">&#x27;C:\\Python36\\python36.zip&#x27;</span>, <span class="string">&#x27;C:\\Python36\\DLLs&#x27;</span>, <span class="string">&#x27;C:\\Python36\\lib&#x27;</span>, <span class="string">&#x27;C:\\Python36&#x27;</span>, <span class="string">&#x27;C:\\Python36\\lib\\site-packages&#x27;</span>, <span class="string">&#x27;E:\\Program Files\\JetBrains\\PyCharm 2018.2.4\\helpers\\pycharm_matplotlib_backend&#x27;</span>, <span class="string">&#x27;e:/&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h3 id="argv"><a href="#argv" class="headerlink" title="argv"></a>argv</h3><ul>
<li>命令行参数List，第一个元素是程序本身路径</li>
</ul>
<p>如:在E盘下新建test.py文件，文件里写入import sys&#x2F;print(sys.argv)内容，在cmd下，运行test.py zhang li，则列表里接收到zhang li参数</p>
<h3 id="exit-n"><a href="#exit-n" class="headerlink" title="exit(n)"></a>exit(n)</h3><ul>
<li>退出程序</li>
<li>exit(0)：正常退出</li>
<li>exit(1)：错误退出</li>
</ul>
<h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><ul>
<li>获取Python解释器的版本信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.version)  <span class="comment"># 3.6.6 (v3.6.6:4cf1f54eb7, Jun 27 2018, 03:37:03) [MSC v.1900 64 bit (AMD64)]</span></span><br></pre></td></tr></table></figure>



<h3 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h3><ul>
<li>返回操作系统平台名称</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.platform)  <span class="comment"># win32</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>time模块</title>
    <url>/2019/03/20/python-time%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><ul>
<li>返回从1970年01月01日00点00分00秒到现在一共经过了多少秒。用float表示</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(time.time())  <span class="comment"># 1542203668.0212119</span></span><br></pre></td></tr></table></figure>



<h2 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h2><ul>
<li>根据需求对时间进行任意的格式化</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">s = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 2018-11-14 22:01:40</span></span><br></pre></td></tr></table></figure>

<p>中文：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 中文</span></span><br><span class="line"><span class="keyword">import</span> locale</span><br><span class="line">locale.setlocale(locale.LC_CTYPE, <span class="string">&quot;chinese&quot;</span>)</span><br><span class="line"></span><br><span class="line">s = time.strftime(<span class="string">&quot;%Y年%m月%d日&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 2018年11月18日</span></span><br></pre></td></tr></table></figure>

<p>日期格式化标准：</p>
<ul>
<li>%y：两位数的年份表示(00-99)</li>
<li>%Y：四位数的年份表示(000-999)</li>
<li>%m：月份(01-12)</li>
<li>%d：月内中的一天(0-31)</li>
<li>%H：24小时制小时数(0-23)</li>
<li>%I：12小时制小时数(01-12)</li>
<li>%M：分钟数(00-59)</li>
<li>%a：本地简化星期名称</li>
<li>%A：本地完整星期名称</li>
<li>%b：本地简化的月份名称</li>
<li>%B：本地完整的月份名称</li>
<li>%c：本地相应的日期表示和时间表示</li>
<li>%j：年内的一天(001-366)</li>
<li>%p：本地A.M或P.M的等价符</li>
<li>%U：一年中的星期数(00-53)星期天为星期的开始</li>
<li>%w：星期(0-6)，星期天为星期的开始</li>
<li>%W：一年中的星期数(00-53)星期一为星期的开始</li>
<li>%x：本地相应的日期表示</li>
<li>%X：本地相应的时间表示</li>
<li>%Z：当前时区的名称</li>
<li>%%：%本身</li>
</ul>
<h2 id="结构化时间"><a href="#结构化时间" class="headerlink" title="结构化时间"></a>结构化时间</h2><p>  时间戳不能直接转化成格式化时间，须先转化为结构化时间，再由结构化时间转化为格式化时间</p>
<p>  同理，格式化时间转化为时间戳，须先转化为结构化时间，再由结构化时间转化为时间戳</p>
<h3 id="localtime"><a href="#localtime" class="headerlink" title="localtime"></a>localtime</h3><ul>
<li>东八区时间</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t = time.localtime(<span class="number">1888888888</span>)</span><br><span class="line"><span class="built_in">print</span>(t)  <span class="comment"># time.struct_time(tm_year=2029, tm_mon=11, tm_mday=9, tm_hour=11, tm_min=21, tm_sec=28, tm_wday=4, tm_yday=313, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">s = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, t)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 2029-11-09 11:21:28</span></span><br></pre></td></tr></table></figure>

<h3 id="gmtime"><a href="#gmtime" class="headerlink" title="gmtime"></a>gmtime</h3><ul>
<li>格林尼治时间</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t = time.gmtime(<span class="number">1888888888</span>)</span><br><span class="line"><span class="built_in">print</span>(t)  <span class="comment"># time.struct_time(tm_year=2029, tm_mon=11, tm_mday=9, tm_hour=3, tm_min=21, tm_sec=28, tm_wday=4, tm_yday=313, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">s = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, t)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 2029-11-09 03:21:28</span></span><br></pre></td></tr></table></figure>



<h2 id="时间转换"><a href="#时间转换" class="headerlink" title="时间转换"></a>时间转换</h2><h3 id="时间戳-——-格式化时间"><a href="#时间戳-——-格式化时间" class="headerlink" title="时间戳 ——&gt; 格式化时间"></a>时间戳 ——&gt; 格式化时间</h3><ul>
<li>localtime&#x2F;gmtime + strftime</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">t = time.localtime(<span class="number">1888888888</span>)</span><br><span class="line"><span class="built_in">print</span>(t)  <span class="comment"># time.struct_time(tm_year=2029, tm_mon=11, tm_mday=9, tm_hour=11, tm_min=21, tm_sec=28, tm_wday=4, tm_yday=313, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line">s = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, t)</span><br><span class="line"><span class="built_in">print</span>(s)  <span class="comment"># 2029-11-09 11:21:28</span></span><br></pre></td></tr></table></figure>



<h3 id="格式化时间-——-时间戳"><a href="#格式化时间-——-时间戳" class="headerlink" title="格式化时间 ——&gt; 时间戳"></a>格式化时间 ——&gt; 时间戳</h3><h4 id="strptime-string-格式"><a href="#strptime-string-格式" class="headerlink" title="strptime(string, 格式)"></a>strptime(string, 格式)</h4><p>  将格式化时间转化为结构化时间</p>
<h4 id="mktime"><a href="#mktime" class="headerlink" title="mktime()"></a>mktime()</h4><p>  将结构化时间转化为时间戳</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;2029-11-09 11:21:28&quot;</span></span><br><span class="line"></span><br><span class="line">t = time.strptime(s, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(t)  <span class="comment"># time.struct_time(tm_year=2029, tm_mon=11, tm_mday=9, tm_hour=11, tm_min=21, tm_sec=28, tm_wday=4, tm_yday=313, tm_isdst=-1)</span></span><br><span class="line"></span><br><span class="line">tt = time.mktime(t)</span><br><span class="line"><span class="built_in">print</span>(tt)  <span class="comment"># 1888888888.0</span></span><br></pre></td></tr></table></figure>



<h2 id="时间差"><a href="#时间差" class="headerlink" title="时间差"></a>时间差</h2><p>方法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">begin = <span class="string">&quot;2018-11-14 16:30:00&quot;</span></span><br><span class="line">end = <span class="string">&quot;2018-11-14 18:00:00&quot;</span></span><br><span class="line"></span><br><span class="line">begin_struct_time = time.strptime(begin, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">end_struct_time = time.strptime(end, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line">begin_second = time.mktime(begin_struct_time)</span><br><span class="line">end_second = time.mktime(end_struct_time)</span><br><span class="line"></span><br><span class="line">diff_time_sec = end_second - begin_second</span><br><span class="line"></span><br><span class="line">diff_hour, diff_min_1 = <span class="built_in">divmod</span>(diff_time_sec, <span class="number">3600</span>)</span><br><span class="line">diff_min, diff_sec = <span class="built_in">divmod</span>(diff_min_1, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;时间差是 %s小%s分钟%s秒&quot;</span> % (<span class="built_in">int</span>(diff_hour), <span class="built_in">int</span>(diff_min), <span class="built_in">int</span>(diff_sec)))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">时间差是 <span class="number">1</span>小<span class="number">30</span>分钟<span class="number">0</span>秒</span><br></pre></td></tr></table></figure>

<p> 方法二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">begin = <span class="string">&quot;2018-11-14 16:30:00&quot;</span></span><br><span class="line">end = <span class="string">&quot;2018-11-14 18:00:00&quot;</span></span><br><span class="line"></span><br><span class="line">begin_struct_time = time.strptime(begin, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">end_struct_time = time.strptime(end, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"></span><br><span class="line">begin_second = time.mktime(begin_struct_time)</span><br><span class="line">end_second = time.mktime(end_struct_time)</span><br><span class="line"></span><br><span class="line">diff_time_sec = <span class="built_in">abs</span>(begin_second - end_second)  <span class="comment"># 秒级时间差</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转化成结构化时间</span></span><br><span class="line">t = time.gmtime(diff_time_sec)  <span class="comment"># 用格林尼治时间，否则会有时间差</span></span><br><span class="line"><span class="comment"># time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=1, tm_min=30, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;时间差是%s年 %s月 %s天 %s小时 %s分钟&quot;</span> % (t.tm_year - <span class="number">1970</span>, t.tm_mon - <span class="number">1</span>, t.tm_mday - <span class="number">1</span>, t.tm_hour, t.tm_min))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">时间差是<span class="number">0</span>年 <span class="number">0</span>月 <span class="number">0</span>天 <span class="number">1</span>小时 <span class="number">30</span>分钟</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Tuple</title>
    <url>/2019/03/16/python-tuple/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>俗称不可变的列表，又被称为只读列表</li>
<li>用小括号括起来，里面可放任何数据类型的数据</li>
<li>可查询，循环，切片(切片后得到的还是元组)，但不可修改元素</li>
<li>元组中如果只有一个元素，须添加一个逗号，否则就不是元组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = (11, 22, 33, &#x27;python&#x27;, 44, 55, 66)</span><br><span class="line"></span><br><span class="line">print(t[0]) # 11</span><br><span class="line"></span><br><span class="line">print(t[1:3]) # (22, 33) </span><br><span class="line"></span><br><span class="line">for i in t:</span><br><span class="line">　　print(i) # 11 22 33 python 44 55 66</span><br><span class="line"></span><br><span class="line">t = (1,)</span><br><span class="line">print(type(t)) # &lt;class &#x27;tuple&#x27;&gt;</span><br><span class="line"></span><br><span class="line">t = (1)</span><br><span class="line">print(type(t)) # &lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure>



<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>  元组的不可变指的是元组内第一层元素的内存地址不可变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t = (11, 22, 33, [], 44)</span><br><span class="line"></span><br><span class="line">t[3] = [55,]  # 报错</span><br><span class="line"></span><br><span class="line">t[3].append(55) # (11, 22, 33, [55], 44)</span><br></pre></td></tr></table></figure>

<p> 元组也有count, index, len等方法</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>内置函数一</title>
    <url>/2019/03/16/python-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%B8%80/</url>
    <content><![CDATA[<p>作用域相关</p>
<ul>
<li><p>locals()</p>
<p>功能：返回当前作用域中的名字</p>
</li>
<li><p>globals()</p>
<p>功能：返回全局作用域中的名字</p>
</li>
</ul>
<h2 id="迭代器-生成器相关"><a href="#迭代器-生成器相关" class="headerlink" title="迭代器&#x2F;生成器相关"></a>迭代器&#x2F;生成器相关</h2><ul>
<li><p>range()</p>
<p>功能：生成数据</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [i for i in range(10)]</span><br><span class="line">print(lst)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>iter()</p>
<p>功能：获取迭代器，内部实际使用的是__iter__()方法来获取迭代器</p>
</li>
<li><p>next()</p>
<p>功能：迭代器向下执行一次，内部实际使用了__next__()方法返回迭代器的下一个项目</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br><span class="line">ret = iter(lst)  # 获取迭代器</span><br><span class="line"></span><br><span class="line">print(next(ret)) # 0   执行迭代器</span><br></pre></td></tr></table></figure>



<h2 id="字符串类型代码的执行"><a href="#字符串类型代码的执行" class="headerlink" title="字符串类型代码的执行"></a>字符串类型代码的执行</h2><ul>
<li><p>eval()</p>
<p>功能：执行字符串类型的代码。并返回最终结果</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(eval(&quot;[11, 22, 33, 44]&quot;))  # [11, 22, 33, 44]</span><br><span class="line"></span><br><span class="line">print(eval(&quot;2+2&quot;))  # 4</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    print(666)</span><br><span class="line">eval(&quot;func()&quot;)  # 666</span><br></pre></td></tr></table></figure>



<ul>
<li><p>exec()</p>
<p>功能：执行字符串类型的代码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec(&quot;&quot;&quot;</span><br><span class="line">for i in range(10):</span><br><span class="line">    print(i)</span><br><span class="line">&quot;&quot;&quot;)  # 0 1 2 3 4 5 6 7 8 9</span><br><span class="line"></span><br><span class="line">exec(&quot;&quot;&quot;</span><br><span class="line">def func():</span><br><span class="line">    print(&quot;我是赛利亚&quot;)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">&quot;&quot;&quot;)  # 我是赛利亚</span><br></pre></td></tr></table></figure>

<ul>
<li><p>compile()</p>
<p>功能：将字符串类型的代码编译，有返回值的字符串形式代码用eval()求值，没有返回值的字符串形式代码用exec()执行</p>
<p>参数说明：</p>
<p>1）resource：要执行的代码，动态代码片段</p>
<p>2）文件名：代码存放的文件名，当传入第一个参数的时候，这个参数给空就可以了</p>
<p>3）模式，取值有3个：</p>
</li>
</ul>
<p>​    a) exec：一般放一些流程语句的时候</p>
<p>​    b) eval：resource只存放一个求值表达式</p>
<p>​    c) single：resource存放的代码有交互的时候，mode应为single，但只允话代码只有一行，否则报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code = &quot;&quot;&quot;</span><br><span class="line">for i in range(5):</span><br><span class="line">    print(i)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">c1 = compile(code, &quot;&quot;, mode=&quot;exec&quot;)</span><br><span class="line">exec(c1)  # 0 1 2 3 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code2 = &quot;&quot;&quot;</span><br><span class="line">name = input(&quot;请输入你的名字：&quot;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">c2 = compile(code2, &quot;&quot;, mode=&quot;single&quot;)</span><br><span class="line">exec(c2)</span><br><span class="line">print(name) # Tom</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="输入输出相关"><a href="#输入输出相关" class="headerlink" title="输入输出相关"></a>输入输出相关</h2><ul>
<li><p>input()</p>
<p>功能：获取用户输入的内容</p>
</li>
<li><p>print()</p>
<p>功能：打印输出</p>
</li>
</ul>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><ul>
<li><p>hash()</p>
<p>功能：获取对象的哈希值(int，bool，str，tuple)</p>
<p>注意：</p>
<p>\1) 数字的哈希值就是它本身</p>
<p>\2) 每次调用hash()得到的哈希值不一样(除数字外)，所以哈希值不能做密码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num = 10</span><br><span class="line">s = &quot;Hello&quot;</span><br><span class="line"></span><br><span class="line">print(hash(num))  # 10</span><br><span class="line"></span><br><span class="line"># 第一次调用</span><br><span class="line">print(hash(s))  # 3718209680369926059</span><br><span class="line"></span><br><span class="line"># 再次调用</span><br><span class="line">print(hash(s))  # 263127024043316082</span><br></pre></td></tr></table></figure>

<ul>
<li><p>id()</p>
<p>功能：获取对象的内存地址</p>
</li>
</ul>
<h2 id="与文件相关"><a href="#与文件相关" class="headerlink" title="与文件相关"></a>与文件相关</h2><ul>
<li><p>open()</p>
<p>功能：用于打开一个文件，创建一个文件句柄</p>
</li>
</ul>
<h2 id="模块相关"><a href="#模块相关" class="headerlink" title="模块相关"></a>模块相关</h2><ul>
<li><p><strong>import</strong>()</p>
<p>功能：用于动态加载类和函数</p>
</li>
</ul>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><ul>
<li><p>help()</p>
<p>功能：函数用于查看函数或模块用途的详细说明</p>
</li>
</ul>
<h2 id="调用相关"><a href="#调用相关" class="headerlink" title="调用相关"></a>调用相关</h2><ul>
<li><p>callable()</p>
<p>功能：用于检查一个对象是否是可调用的。如果返回True， object有可能调用失败，但如果返回False，那么调用绝对不会成功</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = 10</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(callable(n)) # False</span><br><span class="line"></span><br><span class="line">print(callable(func)) # True</span><br></pre></td></tr></table></figure>



<h2 id="查看内置属性"><a href="#查看内置属性" class="headerlink" title="查看内置属性"></a>查看内置属性</h2><ul>
<li><p>dir()</p>
<p>功能：查看对象的内置属性，方法。访问的是对象的__dir__()方法</p>
</li>
</ul>
<h2 id="基础数据类型相关"><a href="#基础数据类型相关" class="headerlink" title="基础数据类型相关"></a>基础数据类型相关</h2><h3 id="和数字相关"><a href="#和数字相关" class="headerlink" title="和数字相关"></a>和数字相关</h3><h4 id="a-数据类型"><a href="#a-数据类型" class="headerlink" title="a) 数据类型"></a>a) 数据类型</h4><ul>
<li><p>bool()</p>
<p>功能：将给定的数据转换成bool值。如果不给值，返回False</p>
</li>
<li><p>int()</p>
<p>功能：将给定的数据转换成int值。如果不给值，返回0</p>
</li>
<li><p>float()</p>
<p>功能：将给定的数据转换成float值，也就是小数</p>
</li>
<li><p>complex()</p>
<p>功能：创建一个复数，第一个参数为实部，第二个参数为虚部，或者第一个参数直接用字符串来描述复数</p>
</li>
</ul>
<h4 id="b-进制转换"><a href="#b-进制转换" class="headerlink" title="b) 进制转换"></a>b) 进制转换</h4><ul>
<li><p>bin()</p>
<p>功能：将给的参数转换成二进制</p>
</li>
<li><p>otc()</p>
<p>功能：将给的参数转换成八进制</p>
</li>
<li><p>hex()</p>
<p>功能：将给的参数转换成十六进制</p>
</li>
</ul>
<h4 id="c-数学运算"><a href="#c-数学运算" class="headerlink" title="c) 数学运算"></a>c) 数学运算</h4><ul>
<li><p>abs()</p>
<p>功能：返回绝对值</p>
</li>
<li><p>divmod()</p>
<p>功能：返回商和余数</p>
</li>
<li><p>round()</p>
<p>功能：四舍五入</p>
<p>对于x.5，如果整数个位数为偶数靠近偶数进行舍弃，如果整数个位数为奇数靠近偶数进行舍弃</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(round(4.5)) # 4</span><br><span class="line">print(round(5.5)) # 6</span><br><span class="line">print(round(5.4)) # 5</span><br></pre></td></tr></table></figure>

<ul>
<li><p>pow(a, b)</p>
<p>功能：求a的b次幂，如果有三个参数，则求完次幂后对第三个数取余</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(pow(2, 3)) # 8</span><br><span class="line"></span><br><span class="line">print(pow(2, 3, 5)) # 3</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sum(可迭代对象)</p>
<p>功能：求和</p>
</li>
<li><p>min()</p>
<p>功能：求最小值</p>
</li>
<li><p>max()</p>
<p>功能：求最大值</p>
</li>
</ul>
<h3 id="和数据结构相关"><a href="#和数据结构相关" class="headerlink" title="和数据结构相关"></a>和数据结构相关</h3><h4 id="a-列表和元组"><a href="#a-列表和元组" class="headerlink" title="a) 列表和元组"></a>a) 列表和元组</h4><ul>
<li><p>list()</p>
<p>功能：将一个可迭代对象转换成列表</p>
</li>
<li><p>tuple()</p>
<p>功能：将一个可迭代对象转换成元组</p>
</li>
<li><p>reversed()</p>
<p>功能：将一个序列翻转，返回翻转序列的迭代器</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [1, 2, 3, 4, 5, 6]</span><br><span class="line">ret = reversed(lst)</span><br><span class="line">print(ret)  # &lt;list_reverseiterator object at 0x000001B589038208&gt;</span><br><span class="line"></span><br><span class="line">for i in ret:</span><br><span class="line">    print(i)  # 6 5 4 3 2 1</span><br></pre></td></tr></table></figure>

<ul>
<li><p>slice</p>
<p>功能：列表的切片</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br><span class="line">s = slice(1, 5, 2)</span><br><span class="line">print(lst[s])  # [2, 4]</span><br></pre></td></tr></table></figure>

<h4 id="b）-字符串相关"><a href="#b）-字符串相关" class="headerlink" title="b） 字符串相关"></a>b） 字符串相关</h4><ul>
<li><p>str()</p>
<p>功能：将数据转化成字符串</p>
</li>
<li><p>format()</p>
<p>功能：与具体数据相关，用于计算各种小数，精算等</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 字符串</span><br><span class="line">print(format(&#x27;test&#x27;, &#x27;&lt;20&#x27;))    # 左对齐 </span><br><span class="line">print(format(&#x27;test&#x27;, &#x27;&gt;20&#x27;))    # 右对齐 </span><br><span class="line">print(format(&#x27;test&#x27;, &#x27;^20&#x27;))    # 居中 </span><br><span class="line"></span><br><span class="line"># 数值 </span><br><span class="line">print(format(3, &#x27;b&#x27;))           # ⼆进制 </span><br><span class="line">print(format(97, &#x27;c&#x27;))          # 转换成unicode字符</span><br><span class="line">print(format(11, &#x27;d&#x27;))          # ⼗进制 </span><br><span class="line">print(format(11, &#x27;o&#x27;))          # ⼋进制 </span><br><span class="line">print(format(11, &#x27;x&#x27;))          # ⼗六进制(⼩写字母) </span><br><span class="line">print(format(11, &#x27;X&#x27;))          # ⼗六进制(⼤写字母) </span><br><span class="line">print(format(11, &#x27;n&#x27;))          # 和d一样 </span><br><span class="line">print(format(11))               # 和d一样 </span><br><span class="line"></span><br><span class="line"># 浮点数 </span><br><span class="line">print(format(123456789, &#x27;e&#x27;))           # 科学计数法. 默认保留6位小数 </span><br><span class="line">print(format(123456789, &#x27;0.2e&#x27;))        # 科学计数法. 保留2位小数(小写) </span><br><span class="line">print(format(123456789, &#x27;0.2E&#x27;))        # 科学计数法. 保留2位小数(大写) </span><br><span class="line">print(format(1.23456789, &#x27;f&#x27;))          # 小数点计数法. 保留6位小数 </span><br><span class="line">print(format(1.23456789, &#x27;0.2f&#x27;))       # 小数点计数法. 保留2位小数 </span><br><span class="line">print(format(1.23456789, &#x27;0.10f&#x27;))      # 小数点计数法. 保留10位小数 </span><br><span class="line">print(format(1.23456789e+10000, &#x27;F&#x27;))   # 小数点计数法.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>bytes()</p>
<p>功能：把字符串转化成bytes类型</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;你好&quot;</span><br><span class="line"></span><br><span class="line">bs = bytes(s, encoding=&quot;utf-8&quot;)</span><br><span class="line">print(bs)  # b&#x27;\xe4\xbd\xa0\xe5\xa5\xbd&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>bytearray()</p>
<p>功能：返回一个新字节数组，这个数组里的元素是可变的，并且每个元素的值的范围是[0, 256]</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret = bytearray(&#x27;alex&#x27;, encoding=&#x27;utf-8&#x27;)</span><br><span class="line">print(ret)  # bytearray(b&#x27;alex&#x27;)</span><br><span class="line"></span><br><span class="line">ret[0] = 65</span><br><span class="line">print(ret) # bytearray(b&#x27;Alex&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>memoryview()</p>
<p>功能：查看bytes在内存中的情况</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;你好&quot;</span><br><span class="line">ret = memoryview(s.encode(&quot;utf-8&quot;))</span><br><span class="line">print(ret)  # &lt;memory at 0x0000022FC0071048&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ord()</p>
<p>功能：输入字符找带字符编码的位置</p>
</li>
<li><p>chr()</p>
<p>功能：输入位置数字找出对应的字符</p>
</li>
<li><p>ascii()</p>
<p>功能：在ascii码中就返回这个值，如里不在就返回\u…</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;你好&quot;</span><br><span class="line">print(ascii(s))  # &#x27;\u4f60\u597d&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>repr()</p>
<p>功能：返回一个对象的官方表示形式</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;你好\我叫赛利亚&quot;</span><br><span class="line">print(repr(s)) # &#x27;你好\\我叫赛利亚&#x27;</span><br><span class="line">print(s) #你好\我叫赛利亚</span><br></pre></td></tr></table></figure>

<h4 id="c）-数据集合"><a href="#c）-数据集合" class="headerlink" title="c） 数据集合"></a>c） 数据集合</h4><ul>
<li><p>dict()</p>
<p>功能：创建一个字典</p>
</li>
<li><p>set()</p>
<p>功能：创建一个集合</p>
</li>
<li><p>frozenset()</p>
<p>功能：创建一个冻结的集合，冻结的集合不能进行添加和删除操作</p>
</li>
</ul>
<h4 id="d-其他相关"><a href="#d-其他相关" class="headerlink" title="d) 其他相关"></a>d) 其他相关</h4><ul>
<li><p>len()</p>
<p>功能：返回一个对象中的元素的个数</p>
</li>
<li><p>enumerate(可迭代对象，start&#x3D;0)</p>
<p>功能：获取集合的枚举对象</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33]</span><br><span class="line">for index, el in enumerate(lst):</span><br><span class="line">    print(index, el)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">0 11</span><br><span class="line">1 22</span><br><span class="line">2 33</span><br></pre></td></tr></table></figure>

<ul>
<li><p>all()</p>
<p>功能：可迭代对象中全部是True，结果才是True</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(all([1, 2, 0, True])) # False</span><br></pre></td></tr></table></figure>

<ul>
<li><p>any()</p>
<p>功能：可迭代对象中有一个是True， 结果就是True</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(any([1, 2, 0, True])) # True</span><br></pre></td></tr></table></figure>

<ul>
<li><p>zip()</p>
<p>功能：函数用于将可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的一个可迭代对象zip object。如果各个迭代器的元素不一致，则返回对象长度与最短的对象相同</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst1 = [1, 2, 3]</span><br><span class="line">lst2 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br><span class="line">lst3 = (11, 22, 33, 44, 55)</span><br><span class="line"></span><br><span class="line">print(zip(lst1, lst2, lst3))       #  &lt;zip object at 0x000001E7D275BF48&gt;</span><br><span class="line">print(list(zip(lst1, lst2, lst3))) #[(1, &#x27;a&#x27;, 11), (2, &#x27;b&#x27;, 22), (3, &#x27;c&#x27;, 33)]</span><br><span class="line"></span><br><span class="line">for i in zip(lst1, lst2, lst3):</span><br><span class="line">    print(i)                       # (1, &#x27;a&#x27;, 11)  (2, &#x27;b&#x27;, 22) (3, &#x27;c&#x27;, 33)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>内置函数二</title>
    <url>/2019/03/16/python-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><ul>
<li>表示匿名函数</li>
<li>为了解决一些简单的需求而设计的一句话函数</li>
</ul>
<p>语法： <strong>函数名</strong> &#x3D; <strong>lambda 参数：返回值</strong></p>
<ul>
<li>函数的参数可以有多个，多个参数之间用逗号隔开</li>
<li>匿名函数不管多复杂，只能写一行，且逻辑结束后直接返回数据</li>
<li>返回值和正常的函数一样，可以是任意数据类型</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = lambda n: n ** 2</span><br><span class="line">print(f(10))  # 100</span><br><span class="line">print(f.__name__)  # &lt;lambda&gt;</span><br></pre></td></tr></table></figure>

<p>注：匿明函数并不是说一定没有名字。上面f就是一个函数名。说他是匿明原因是通过__name__查看的时候是没有名字的。统一叫lambda。在调用时没有特别之处，像正常函数调用即可。</p>
<h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a>sorted()</h2><ul>
<li>功能：排序</li>
</ul>
<p>语法：<strong>sorted(Iterable, key&#x3D;None, reverse&#x3D;False)</strong></p>
<ul>
<li>**key:**排序规则(排序函数)，在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数。根据这个函数运算的结果进行排序</li>
<li><strong>reverse</strong>:是否倒叙，默认值为False</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [1, 4, 6, 8, 4, 9, 10]</span><br><span class="line"></span><br><span class="line">print(sorted(lst))  # [1, 4, 4, 6, 8, 9, 10]</span><br></pre></td></tr></table></figure>

<p>与函数组合使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [</span><br><span class="line">    &#123;&quot;name&quot;: &quot;电脑&quot;, &quot;price&quot;: 6000&#125;,</span><br><span class="line">    &#123;&quot;name&quot;: &quot;手表&quot;, &quot;price&quot;: 4000&#125;,</span><br><span class="line">    &#123;&quot;name&quot;: &quot;耳机&quot;, &quot;price&quot;: 1000&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">def func(dic):</span><br><span class="line">    return dic[&quot;price&quot;]</span><br><span class="line"></span><br><span class="line">print(sorted(lst, key=func))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;耳机&#x27;, &#x27;price&#x27;: 1000&#125;, </span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;手表&#x27;, &#x27;price&#x27;: 4000&#125;, </span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;电脑&#x27;, &#x27;price&#x27;: 6000&#125;]</span><br></pre></td></tr></table></figure>

<p>与lambda组合使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [</span><br><span class="line">    &#123;&quot;name&quot;: &quot;电脑&quot;, &quot;price&quot;: 6000&#125;,</span><br><span class="line">    &#123;&quot;name&quot;: &quot;手表&quot;, &quot;price&quot;: 4000&#125;,</span><br><span class="line">    &#123;&quot;name&quot;: &quot;耳机&quot;, &quot;price&quot;: 1000&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sorted(lst, key=lambda dic:dic[&quot;price&quot;]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;耳机&#x27;, &#x27;price&#x27;: 1000&#125;,</span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;手表&#x27;, &#x27;price&#x27;: 4000&#125;,</span><br><span class="line"> &#123;&#x27;name&#x27;: &#x27;电脑&#x27;, &#x27;price&#x27;: 6000&#125;]</span><br></pre></td></tr></table></figure>



<h2 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h2><ul>
<li>功能：筛选</li>
</ul>
<p>语法：<strong>filter(function, Iterable)</strong></p>
<ul>
<li>**function:**用来筛选的函数。在filter中会自动的把Iterable中的元素传递给function。然后根据function返回的True or False来判断是否保留此项数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> portfolio = [</span><br><span class="line">     &#123;&#x27;name&#x27;: &#x27;IBM&#x27;, &#x27;shares&#x27;: 100, &#x27;price&#x27;: 91.1&#125;,</span><br><span class="line">     &#123;&#x27;name&#x27;: &#x27;AAPL&#x27;, &#x27;shares&#x27;: 50, &#x27;price&#x27;: 543.22&#125;,</span><br><span class="line">     &#123;&#x27;name&#x27;: &#x27;FB&#x27;, &#x27;shares&#x27;: 200, &#x27;price&#x27;: 21.09&#125;,</span><br><span class="line">     &#123;&#x27;name&#x27;: &#x27;HPQ&#x27;, &#x27;shares&#x27;: 35, &#x27;price&#x27;: 31.75&#125;,</span><br><span class="line">     &#123;&#x27;name&#x27;: &#x27;YHOO&#x27;, &#x27;shares&#x27;: 45, &#x27;price&#x27;: 16.35&#125;,</span><br><span class="line">     &#123;&#x27;name&#x27;: &#x27;ACME&#x27;, &#x27;shares&#x27;: 75, &#x27;price&#x27;: 115.65&#125;</span><br><span class="line"> ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = list(filter(lambda dic: dic[&quot;price&quot;] &gt; 100, portfolio))</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;AAPL&#x27;, &#x27;shares&#x27;: 50, &#x27;price&#x27;: 543.22&#125;, </span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;ACME&#x27;, &#x27;shares&#x27;: 75, &#x27;price&#x27;: 115.65&#125;</span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><ul>
<li>映射函数</li>
</ul>
<p>语法：<strong>map(function, Iterable)</strong></p>
<ul>
<li>可以对可迭代对象中的每一个元素进行映射。分别去执行function,保留最后的执行结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst1 = [1, 2, 3, 4, 5]</span><br><span class="line">lst2 = [2, 4, 6, 8, 10]</span><br><span class="line"></span><br><span class="line">print(list(map(lambda x, y: x + y, lst1, lst2)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">[3, 6, 9, 12, 15]</span><br></pre></td></tr></table></figure>



<h2 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass()"></a>issubclass()</h2><ul>
<li>判断xxx类是否是yyy类型的子类</li>
<li>可以隔代判断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Foo(Base):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class Bar(Foo):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(issubclass(Bar, Foo))   # True</span><br><span class="line">print(issubclass(Foo, Bar))   # False</span><br><span class="line">print(issubclass(Bar, Base))  # True</span><br></pre></td></tr></table></figure>



<h2 id="type"><a href="#type" class="headerlink" title="type()"></a>type()</h2><ul>
<li>返回xxx是什么类型</li>
<li>可以精准的返回数据类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">&quot;hello&quot;</span>))  <span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = Person()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Person))  <span class="comment"># &lt;class &#x27;type&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(obj))     <span class="comment"># &lt;class &#x27;__main__.Person&#x27;&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance()"></a>isinstance()</h2><ul>
<li>判断xxx对象是否是xxx类型</li>
<li>可以判断该对象是否是xxx家族体系中的(只能往上判断)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Persian_Cat(Cat):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">kitty = Cat()</span><br><span class="line">print(isinstance(kitty, Cat))           # True</span><br><span class="line">print(isinstance(kitty, Persian_Cat))   # False</span><br><span class="line">print(isinstance(kitty, Animal))        # True</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>初识函数</title>
    <url>/2019/03/16/python-%E5%88%9D%E8%AF%86%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数定义及调用"><a href="#函数定义及调用" class="headerlink" title="函数定义及调用"></a>函数定义及调用</h2><ul>
<li>函数：对功能和动作的封装</li>
<li>使用def关键字来定义函数</li>
<li>使用”函数名()”可调用函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def 函数名():</span><br><span class="line">    函数体函数名()  # 调用函数</span><br></pre></td></tr></table></figure>



<h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><ul>
<li>函数名就是变量名，其命名规范与变量名命名规范一致</li>
<li>函数名存储的是函数的内存地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    pass</span><br><span class="line">print(func) # &lt;function func at 0x0000023A55019A60&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数名可以赋值给其他变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    print(&quot;Hello World!&quot;)</span><br><span class="line"></span><br><span class="line">ret = func</span><br><span class="line">ret()  # Hello World!</span><br></pre></td></tr></table></figure>

<ul>
<li>函数名可以当做容器类的元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func_1():</span><br><span class="line">    print(&quot;-----1-----&quot;)</span><br><span class="line"></span><br><span class="line">def func_2():</span><br><span class="line">    print(&quot;-----2-----&quot;)</span><br><span class="line"></span><br><span class="line">def func_3():</span><br><span class="line">    print(&quot;-----3-----&quot;)</span><br><span class="line"></span><br><span class="line">def func_4():</span><br><span class="line">    print(&quot;-----4-----&quot;)</span><br><span class="line"></span><br><span class="line">lst = [func_1, func_2, func_3, func_4]</span><br><span class="line">for i in lst:</span><br><span class="line">    i()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">-----1-----</span><br><span class="line">-----2-----</span><br><span class="line">-----3-----</span><br><span class="line">-----4-----</span><br></pre></td></tr></table></figure>

<ul>
<li>函数名可以为函数的参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func_1():</span><br><span class="line">    print(&quot;-----1-----&quot;)</span><br><span class="line"></span><br><span class="line">def func_2():</span><br><span class="line">    print(&quot;-----2-----&quot;)</span><br><span class="line"></span><br><span class="line">def func(fn):</span><br><span class="line">    fn()</span><br><span class="line"></span><br><span class="line">func(func_1)  # -----1-----</span><br></pre></td></tr></table></figure>

<ul>
<li>函数名可以为函数的返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    def func_1():</span><br><span class="line">        print(&quot;-----func_1-----&quot;)</span><br><span class="line">    return func_1</span><br><span class="line"></span><br><span class="line">func()()  # -----func_1-----</span><br></pre></td></tr></table></figure>

<p>打印函数名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    def func_1():</span><br><span class="line">        print(&quot;-----func_1-----&quot;)</span><br><span class="line">    return func_1</span><br><span class="line"></span><br><span class="line">print(func.__name__)  # func</span><br></pre></td></tr></table></figure>

<h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>  执行完函数后，可以使用return来返回结果</p>
<ul>
<li>return作用：终止函数运行</li>
<li>如果函数体无return，则调用函数返回None</li>
<li>如果函数体有return，但return后未有值，则返回None</li>
<li>如果函数体有return，且return后有一个值或变量名，则返回值或变量名所指向的值</li>
<li>如果函数体有return，且return后有多个值，则多个值以元组形式返回给调用者，调用者可直接解构成多个变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def operation(a, b):</span><br><span class="line">    sum = a + b</span><br><span class="line">    sub = a - b</span><br><span class="line">    qud = a * b</span><br><span class="line">    qut = a / b</span><br><span class="line">    return sum, sub, qud, qut</span><br><span class="line"></span><br><span class="line">x, y, z, w = operation(1, 2)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="形参"><a href="#形参" class="headerlink" title="形参"></a>形参</h3><p>  写在函数声明的位置的变量</p>
<h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def regist(id, name, age, gender):</span><br><span class="line">    print(id, name, age, gender)</span><br><span class="line"></span><br><span class="line">regist(1, &quot;Tom&quot;, 18, &quot;男&quot;)  # 1 Tom 18 男</span><br></pre></td></tr></table></figure>



<h4 id="默认值参数"><a href="#默认值参数" class="headerlink" title="默认值参数"></a>默认值参数</h4><p>  默认值参数可以把函数共性的参数问题进行提炼，以减少输入，提高输入效率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def regist(id, name, age, gender=&quot;男&quot;):</span><br><span class="line">    print(id, name, age, gender)</span><br><span class="line"></span><br><span class="line">regist(1, &quot;Tom&quot;, 18) # 1 Tom 18 男</span><br></pre></td></tr></table></figure>



<h4 id="混合参数-位置参数-默认值参数"><a href="#混合参数-位置参数-默认值参数" class="headerlink" title="混合参数(位置参数+默认值参数)"></a>混合参数(位置参数+默认值参数)</h4><p>  位置参数在前，默认值参数在后，否则报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def regist(id, name, gender=&quot;男&quot;, age):</span><br><span class="line">    print(id, name, age, gender)</span><br><span class="line"></span><br><span class="line">regist(1, &quot;Tom&quot;, 18) # SyntaxError: non-default argument follows default argument</span><br></pre></td></tr></table></figure>



<h4 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h4><p>a.动态接收位置参数——*args</p>
<ul>
<li>*表示动态传参，可以接受所有的位置参数</li>
<li>传参的时候自动的把实参打包成元组，交给形参</li>
<li>动态传参可以不传参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func(*args):</span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line">func(11, 22, 33, 44, 55, 66)  # (11, 22, 33, 44, 55, 66)</span><br><span class="line">def func(*args):</span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line">func()  # ()</span><br></pre></td></tr></table></figure>

<p>b.动态接收关键字参数——**kwargs</p>
<ul>
<li>接收到的内容放在字典里</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func(**kwargs):</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(a=11, b=22, c=33, d=44, e=55) # &#123;&#x27;a&#x27;: 11, &#x27;b&#x27;: 22, &#x27;c&#x27;: 33, &#x27;d&#x27;: 44, &#x27;e&#x27;: 55&#125;</span><br></pre></td></tr></table></figure>

<h4 id="形参顺序"><a href="#形参顺序" class="headerlink" title="形参顺序"></a>形参顺序</h4><p>顺序：位置参数，*args，默认值参数，**kwargs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func(a, *args, b=&quot;&quot;, **kwargs):</span><br><span class="line">    print(a, args, b, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(11, 22, 33, 44, b=&quot;男&quot;, c=66, d=77,) # 11 (22, 33, 44) 男 &#123;&#x27;c&#x27;: 66, &#x27;d&#x27;: 77&#125;</span><br></pre></td></tr></table></figure>

<h3 id="打散"><a href="#打散" class="headerlink" title="打散"></a>打散</h3><ul>
<li>* + string&#x2F;list&#x2F;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(*[1, 2, 3, 4, 5, 6]) # 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>

<ul>
<li>** + dict</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func(**kwargs):</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">func(**&#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18, &quot;hobby&quot;: &quot;football&quot;&#125;)  # &#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18, &#x27;hobby&#x27;: &#x27;football&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="无敌传参"><a href="#无敌传参" class="headerlink" title="无敌传参"></a>无敌传参</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func(*args, **kwargs):</span><br><span class="line">    print(args, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(11, 22, 33, 44, a=55, b=66, c=77, d=88)  #(11, 22, 33, 44) &#123;&#x27;a&#x27;: 55, &#x27;b&#x27;: 66, &#x27;c&#x27;: 77, &#x27;d&#x27;: 88&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实参"><a href="#实参" class="headerlink" title="实参"></a>实参</h3><p>  在函数调用的时候给函数传递的值。实际执行的时候给函数传递的信息</p>
<h4 id="位置参数-1"><a href="#位置参数-1" class="headerlink" title="位置参数"></a>位置参数</h4><p>  按照形参顺序给把各实参赋值给相应的形参</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def introduction(name, age):</span><br><span class="line">    print(&quot;My name is %s, I&#x27;m %s years old.&quot; % (name, age))</span><br><span class="line"></span><br><span class="line">introduction(&quot;Tom&quot;, 18)  # My name is Tom, I&#x27;m 18 years old.</span><br><span class="line">def introduction(name, age):</span><br><span class="line">    print(&quot;My name is %s, I&#x27;m %s years old.&quot; % (name, age))</span><br><span class="line"></span><br><span class="line">introduction(18, &quot;Tom&quot;)  # My name is 18, I&#x27;m Tom years old.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>  根据形参声明的变量名来传递信息，关键字实参不需要考虑形参顺序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def introduction(name, age):</span><br><span class="line">    print(&quot;My name is %s, I&#x27;m %s years old.&quot; % (name, age))</span><br><span class="line"></span><br><span class="line">introduction(age=18, name=&quot;Tom&quot;) # My name is Tom, I&#x27;m 18 years old.</span><br></pre></td></tr></table></figure>



<h4 id="混合参数-位置参数-关键字参数"><a href="#混合参数-位置参数-关键字参数" class="headerlink" title="混合参数(位置参数+关键字参数)"></a>混合参数(位置参数+关键字参数)</h4><p>  位置参数在前，关键字参数在后，否则报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def introduction(name, age, sex):</span><br><span class="line">    print(&quot;My name is %s, I&#x27;m %s years old %s&quot; % (name, age, sex))</span><br><span class="line"></span><br><span class="line">introduction(&quot;Tom&quot;, sex=&quot;boy&quot;, age=18) # My name is Tom, I&#x27;m 18 years old boy</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def introduction(name, age, sex):</span><br><span class="line">    print(&quot;My name is %s, I&#x27;m %s years old %s&quot; % (name, age, sex))</span><br><span class="line"></span><br><span class="line">introduction(&quot;Tom&quot;, sex=&quot;boy&quot;, 18) # SyntaxError: positional argument follows keyword argument</span><br></pre></td></tr></table></figure>

<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>  给函数传递信息的时候将实际参数交给形式参数的过程</p>
<h2 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h2><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><ul>
<li>内置命名空间：存放python解释器为我们提供的名字，list，tuple，str，int这些都是内置命名空间</li>
<li>全局命名空间：py文件中，函数外声明的变量都属于全局命名空间</li>
<li>局部命名空间：在函数中声明的变量会放在局部命名空间</li>
<li>加载顺序：内置命名空间—&gt;全局命名空间—&gt;局部命名空间(函数被执行的时候)</li>
<li>取值顺序：局部命名空间—&gt;全局命名空间—&gt;内置命名空间</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><ul>
<li>全局作用域：全局命名空间 + 内置命名空间</li>
<li>局部作用域：局部命名空间</li>
<li>变量可从局部向全局寻找，但不可从全局向局部寻找</li>
</ul>
<h3 id="locals-和-globals"><a href="#locals-和-globals" class="headerlink" title="locals() 和 globals()"></a>locals() 和 globals()</h3><ul>
<li>locals()：查看当前作用域中的名字，如果在函数中调用locals()，则查看局部作用域中的名字，如果在函数外调用locals()，则查看全局作用域中的名字</li>
<li>globals()：查看全局作用域中(内置+全局)中的名字</li>
</ul>
<h3 id="global-和-nonlocal"><a href="#global-和-nonlocal" class="headerlink" title="global 和 nonlocal"></a>global 和 nonlocal</h3><h4 id="global"><a href="#global" class="headerlink" title="global"></a>global</h4><ul>
<li>如果函数内部未引入全局变量，则函数可以使用全局变量，但无法修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 10</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    b = a + 10</span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line"></span><br><span class="line">func()  # 10 20</span><br></pre></td></tr></table></figure>

<ul>
<li>如果利用global在函数内引入全局变量，则在函数内部可对全局变量进行修改</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 10</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">    global a</span><br><span class="line">    a = 20</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">print(a)  # 20 20</span><br></pre></td></tr></table></figure>

<ul>
<li>如果利用global在函数内部引入全局变量，而函数外无此变量，则此局部变量升华为全局变量，即此变量为全局变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    global a</span><br><span class="line">    a = 20</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line">print(a)  # 20 20 </span><br></pre></td></tr></table></figure>



<h4 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h4><ul>
<li>在局部命名空间，引入上一层名称空间中的名字，如果上一层没有，继续往上一层中寻找，如果整个局部命名空间都无，则报错</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func1():</span><br><span class="line">    a = 10</span><br><span class="line">    def func2():</span><br><span class="line">        nonlocal a</span><br><span class="line">        a = 20</span><br><span class="line">        print(a)</span><br><span class="line">    print(a)</span><br><span class="line">    func2()</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">func1() # 10 20 20</span><br></pre></td></tr></table></figure>



<h2 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h2><ul>
<li>函数内部可以嵌套函数</li>
<li>每一层都会产生独自的名称空间，在寻找变量时，则为向上一层一层寻找。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func1():</span><br><span class="line">    a = 10</span><br><span class="line">    def func2():</span><br><span class="line">        def func3():</span><br><span class="line">            nonlocal a</span><br><span class="line">            a = 20</span><br><span class="line">        print(a)</span><br><span class="line">        func3()</span><br><span class="line">    print(a)</span><br><span class="line">    func2()</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line">func1()  # 10 10 20 </span><br></pre></td></tr></table></figure>



<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>  内层函数对外层函数的变量的引用</p>
<p>作用：</p>
<ul>
<li>保护变量不受侵害</li>
<li>可以让一个变量常驻内存</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def outer():</span><br><span class="line">    name = &quot;Tom&quot;</span><br><span class="line">    def inner():</span><br><span class="line">        print(name)</span><br><span class="line">    inner()</span><br><span class="line"></span><br><span class="line">outer() # Tom</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h3 id="检测函数是否为闭包"><a href="#检测函数是否为闭包" class="headerlink" title="检测函数是否为闭包"></a>检测函数是否为闭包</h3><p>  可以使用__closure__来检测函数是否为闭包</p>
<ul>
<li>如果返回cell，则为闭包</li>
<li>如果返回None，则不是闭包</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def outer():</span><br><span class="line">    name = &quot;Tom&quot;</span><br><span class="line">    def inner():</span><br><span class="line">        print(name)</span><br><span class="line">    inner()</span><br><span class="line">    print(inner.__closure__)</span><br><span class="line"></span><br><span class="line">outer()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">Tom</span><br><span class="line">(&lt;cell at 0x000001F751868588: str object at 0x000001F7518F80A0&gt;,)</span><br></pre></td></tr></table></figure>



<h3 id="变量常驻内存说明"><a href="#变量常驻内存说明" class="headerlink" title="变量常驻内存说明"></a>变量常驻内存说明</h3><p>  函数外边调用内部函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def outer():</span><br><span class="line">    name = &quot;Tom&quot;</span><br><span class="line">    def inner():</span><br><span class="line">        print(name)</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">ret = outer()</span><br><span class="line">ret()  # Tom</span><br></pre></td></tr></table></figure>

<p>   如果一个函数执行完毕，则这个函数中的变量以及局部命名空间中的内容都将会被销毁。但由于外界可以通过ret()去访问内部函数。那这个时候内部函数访问的时间和时机就不一定了。如果此时，闭包中变量被销毁了，那么内部函数将不能正常执行。所以，Python规定，如果在内部函数中访问了外层函数的变量，那么这个么变量将不会消亡。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>初识面向象</title>
    <url>/2019/03/20/python-%E5%88%9D%E8%AF%86%E9%9D%A2%E5%90%91%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h2><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><ul>
<li>特点：一切以事物的流程为核心</li>
<li>优点：负责的问题流程化，编写相对简单</li>
<li>缺点：可扩展性差</li>
</ul>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul>
<li>特点：一切以对象为中心</li>
<li>优点：可扩展性强</li>
<li>缺点：编程的复杂度高于面向过程</li>
</ul>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>类是对事物的总结，抽象的概念，类用来描述对象</li>
<li><strong>init</strong>():称为初始化方法，对对象进行初始化操作，创建对象的时候自动调用这个方法</li>
</ul>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul>
<li>对象是类的实例化的结果</li>
<li>对象能执行哪些方法，都由类来决定，类中定义了什么，对象就拥有什么</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class User(object):</span><br><span class="line">    def __init__(self, username, password):</span><br><span class="line">        self.username = username</span><br><span class="line">        self.password = password</span><br><span class="line"></span><br><span class="line">    def login(self, uname, pwd):</span><br><span class="line">        if self.username == uname and self.password == pwd:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u1 = User(&quot;尝试了就好&quot;, &quot;123&quot;)</span><br><span class="line">ret = u1.login(input(&quot;username:&quot;).strip(), input(&quot;password:&quot;).strip())</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>



<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>xxx &#x3D; 类名()</p>
<ul>
<li>先自动执行__new__()来开辟内存，此时新开辟出来的内存区域是空的</li>
<li>再自动调用__init__()来完成对象的初始化工作</li>
</ul>
<h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ul>
<li>在面向对象思想中，是把一些看似无关紧要的内容组合到一起统一进行存储和使用。面向对象中表现为对属性和方法进行封装</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>子类可以自动拥有父类中除了私有属性外的其他所有内容</li>
<li>一个类可以同时继承多个父类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;----run----&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line">cat.run()  # ----run----</span><br></pre></td></tr></table></figure>



<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ul>
<li>同一个对象，多种形态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Animal is running...&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Dog is running...&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;Cat is running...&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Observer():</span><br><span class="line">    def observe(self, animal):</span><br><span class="line">        animal.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dg = Dog()</span><br><span class="line">ct = Cat()</span><br><span class="line"></span><br><span class="line">ob = Observer()</span><br><span class="line">ob.observe(dg)</span><br><span class="line">ob.observe(ct)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Dog is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>包</title>
    <url>/2019/03/20/python-%E5%8C%85/</url>
    <content><![CDATA[<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>  包是一种通过”.模块名”来组织python模块名称空间的方式。我们创建的每个文件夹都可以被称之为包。python2中规定，包内必须存在_<em>init</em>_.py文件。创建包的目的不是为了运行，而是被导入使用。包只是一种形式而已。</p>
<ul>
<li>本质：一种模块</li>
</ul>
<h3 id="被称之为包所具备的条件："><a href="#被称之为包所具备的条件：" class="headerlink" title="被称之为包所具备的条件："></a>被称之为包所具备的条件：</h3><ul>
<li>文件夹</li>
<li>有__init__.py文件（python2中必须有，python3可省略，但最好保留）</li>
</ul>
<h3 id="导入包时执行的三个动作"><a href="#导入包时执行的三个动作" class="headerlink" title="导入包时执行的三个动作"></a>导入包时执行的三个动作</h3><ul>
<li>判断文件夹是否已经被导入。如果已导入，则不会再重复导入，也就不会执行下面两个操作</li>
<li>开辟一片内存空间，在该空间中执行包的_<em>init</em>_.py文件</li>
<li>创建包的名字。并使用该名称作为该包在当前模块中引用的名字</li>
</ul>
<h3 id="包的注意事项："><a href="#包的注意事项：" class="headerlink" title="包的注意事项："></a>包的注意事项：</h3><ul>
<li>关于包相关的导入语句也分为import和from xxx import xxx两种，但无论使用哪种，无论在什么位置，在导入时都必须遵循一个原则：凡是在导入带点的，点左边都是一个包，否则报错。可以带一连串的点，如a.b.c</li>
<li>import导入文件时，产生名称空间中的名字来源于文件。import包，产生的名称空间中的名字同样来源于文件。即包下的_<em>init</em>_.py文件，导入包的本质就是导入该文件。</li>
<li>包A和包B下同名模块也不会冲突。如A.a和B.a来自两个不同的名称空间</li>
<li>导包时，需注意sys.path路径范围，否则易超出范围而报错。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.makedirs(<span class="string">&#x27;glance/api&#x27;</span>)</span><br><span class="line">os.makedirs(<span class="string">&#x27;glance/cmd&#x27;</span>)</span><br><span class="line">os.makedirs(<span class="string">&#x27;glance/db&#x27;</span>)</span><br><span class="line"></span><br><span class="line">l = []</span><br><span class="line"></span><br><span class="line">l.append(<span class="built_in">open</span>(<span class="string">&#x27;glance/__init__.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">l.append(<span class="built_in">open</span>(<span class="string">&#x27;glance/api/__init__.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">l.append(<span class="built_in">open</span>(<span class="string">&#x27;glance/api/policy.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">l.append(<span class="built_in">open</span>(<span class="string">&#x27;glance/api/versions.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">l.append(<span class="built_in">open</span>(<span class="string">&#x27;glance/cmd/__init__.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">l.append(<span class="built_in">open</span>(<span class="string">&#x27;glance/cmd/manage.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">l.append(<span class="built_in">open</span>(<span class="string">&#x27;glance/db/__init__.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">l.append(<span class="built_in">open</span>(<span class="string">&#x27;glance/db/models.py&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(<span class="keyword">lambda</span> f: f.close(), l)</span><br></pre></td></tr></table></figure>

<p>各文件中写有如下内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># policy.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from policy.py&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># versions.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_resource</span>(<span class="params">conf</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from version.py: &quot;</span>, conf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># manage.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from manage.py&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># models.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">register_models</span>(<span class="params">engine</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from models.py: &quot;</span>, engine)</span><br></pre></td></tr></table></figure>



<h2 id="包的导入方式"><a href="#包的导入方式" class="headerlink" title="包的导入方式"></a>包的导入方式</h2><h3 id="import-xxx"><a href="#import-xxx" class="headerlink" title="import xxx"></a>import xxx</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与glance文件夹同目录下test.py</span></span><br><span class="line"><span class="keyword">import</span> glance.db.models</span><br><span class="line"></span><br><span class="line">glance.db.models.register_models(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="keyword">from</span> models.py:  mysql</span><br></pre></td></tr></table></figure>



<h3 id="from-xxx-import-xxx"><a href="#from-xxx-import-xxx" class="headerlink" title="from xxx import xxx"></a>from xxx import xxx</h3><p>  采用from xxx import xxx这种形式，import后面不可以出现”.”。也就是说，from a.b import c是正确的，而from a import b.c是错误的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与glance文件夹同目录下test.py</span></span><br><span class="line"><span class="keyword">from</span> glance.db.models <span class="keyword">import</span> register_models</span><br><span class="line"></span><br><span class="line">register_models(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="keyword">from</span> models.py:  mysql</span><br></pre></td></tr></table></figure>



<h2 id="init-py"><a href="#init-py" class="headerlink" title="_init_.py"></a>_<em>init</em>_.py</h2><p>  不论使用哪种方式导入一个包，只要是第一次导入包或者是包的任何其它部分。都会先执行_<em>init</em>_.py文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># glance文件夹下的__init__.py文件</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我是glance的__init__.py文件&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与glance文件夹同目录下test.py</span></span><br><span class="line"><span class="keyword">import</span> glance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">我是glance的__init__.py文件</span><br></pre></td></tr></table></figure>



<h2 id="绝对导入"><a href="#绝对导入" class="headerlink" title="绝对导入"></a>绝对导入</h2><p>  绝对导入，是按sys.path路径寻找包，如果包不在sys.path列表中，可将包移至路径中。也可append包路径到sys.path中，但一般不这样做。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># policy.py</span></span><br><span class="line"><span class="keyword">from</span> glance.api.versions <span class="keyword">import</span> create_resource</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    create_resource(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from policy.py&quot;</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与glance文件夹同目录下的test.py</span></span><br><span class="line"><span class="keyword">from</span> glance.api.policy <span class="keyword">import</span> get</span><br><span class="line"></span><br><span class="line">get()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">我是glance的__init__.py文件</span><br><span class="line"><span class="keyword">from</span> version.py:  mysql</span><br><span class="line"><span class="keyword">from</span> policy.py</span><br></pre></td></tr></table></figure>



<h2 id="相对导入"><a href="#相对导入" class="headerlink" title="相对导入"></a>相对导入</h2><p>  在相对导入中，python不允许你运行的程序导包的时候超过当前包的范围。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># policy.py</span></span><br><span class="line"><span class="keyword">from</span> ..cmd <span class="keyword">import</span> manage</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    manage.main()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from policy.py&quot;</span>)</span><br><span class="line"></span><br><span class="line">get()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">ValueError: attempted relative <span class="keyword">import</span> beyond top-level package</span><br></pre></td></tr></table></figure>

<p>如果在包内使用了相对导入，那么在使用该包内信息的时候，只能在包外面导入</p>
<p>在包内导入则报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># policy.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> versions</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    versions.create_resource(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from policy.py&quot;</span>)</span><br><span class="line"></span><br><span class="line">get()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">&#x27;versions&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在包外导入，运行成功：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># policy.py</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> versions</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    versions.create_resource(<span class="string">&quot;mysql&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from policy.py&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与glance文件夹同目录下的test.py</span></span><br><span class="line"><span class="keyword">from</span> glance.api.policy <span class="keyword">import</span> get</span><br><span class="line"></span><br><span class="line">get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">我是glance的__init__.py文件</span><br><span class="line"><span class="keyword">from</span> version.py:  mysql</span><br><span class="line"><span class="keyword">from</span> policy.py</span><br></pre></td></tr></table></figure>



<h2 id="单独导入一个包"><a href="#单独导入一个包" class="headerlink" title="单独导入一个包"></a>单独导入一个包</h2><p>  单独导入一个包glance,，如果在包中_<em>init</em>_.py文件中并没有关于子包的加载，此时导入的glance什么都做不了。</p>
<p>  在_<em>init</em>_.py中加载子包可以使用绝对路径加载，也可使用相对路径加载</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># glance文件夹下的__init__.py文件</span></span><br><span class="line"><span class="keyword">from</span> glance <span class="keyword">import</span> api</span><br><span class="line"><span class="comment"># glance/api/__init__.py文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> glance.api <span class="keyword">import</span> policy</span><br><span class="line"><span class="comment"># glance/api/policy.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from policy.py&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与glance文件夹同目录下的test.py</span></span><br><span class="line"><span class="keyword">import</span> glance</span><br><span class="line"></span><br><span class="line">glance.api.policy.get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="keyword">from</span> policy.py</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>区分函数与方法</title>
    <url>/2019/03/20/python-%E5%8C%BA%E5%88%86%E5%87%BD%E6%95%B0%E4%B8%8E%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="通过print打印区分"><a href="#通过print打印区分" class="headerlink" title="通过print打印区分"></a>通过print打印区分</h2><ul>
<li>函数在打印的时候，显示的是function</li>
<li>方法在打印的时候，显示的是method</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func)  <span class="comment"># &lt;function func at 0x0000022343CD1F28&gt;</span></span><br><span class="line"></span><br><span class="line">c = Animal()</span><br><span class="line"><span class="built_in">print</span>(c.run)  <span class="comment"># &lt;bound method Animal.run of &lt;__main__.Animal object at 0x0000022344128400&gt;&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="MethodType与FunctionType"><a href="#MethodType与FunctionType" class="headerlink" title="MethodType与FunctionType"></a>MethodType与FunctionType</h2><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul>
<li>通过<strong>对象.方法名</strong>，得到的是<strong>方法</strong>类型</li>
<li>通过<strong>类名.方法名</strong>，得到的是<strong>函数</strong>类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> FunctionType, MethodType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fn = Foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(fn.run, MethodType))     <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(Foo.run, FunctionType))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>通过<strong>对象.方法名</strong>，得到的是<strong>函数</strong>类型</li>
<li>通过<strong>类名.方法名</strong>，得到的是<strong>函数</strong>类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> FunctionType, MethodType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">fn = Foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(fn.run, FunctionType))   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(Foo.run, FunctionType))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul>
<li>通过<strong>对象.方法名</strong>，得到的是<strong>方法</strong>类型</li>
<li>通过<strong>类名.方法名</strong>，得到的是<strong>方法</strong>类型</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> FunctionType, MethodType</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">fn = Foo()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(fn.run, MethodType))   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(Foo.run, MethodType))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2019/03/20/python-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式(Singleton Pattern)， 是一种常用的软件设计模式。该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p>
<p>例如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个AppConfig的类来读取配置文件的信息。如果在程序运行期间，有很多地方需要使用配置文件的内容，即很多地方都需要创建AppConfig对象的实例，这就导致系统中存在多个AppConfig的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似AppConfig这样的类，我们希望在程序运行期间只存在一个实例对象。</p>
<h2 id="创建单例对象"><a href="#创建单例对象" class="headerlink" title="创建单例对象"></a>创建单例对象</h2><p>在Python中，可用多种方法实现单例模式：</p>
<ul>
<li>使用模块</li>
<li>使用_<em>new</em>_</li>
<li>使用装饰器(decorator)</li>
<li>使用元类(metaclass)</li>
</ul>
<h3 id="使用-new"><a href="#使用-new" class="headerlink" title="使用 _new_"></a>使用 _<em>new</em>_</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            cls._instance = <span class="built_in">super</span>().__new__(cls, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">one = Singleton()</span><br><span class="line">two = Singleton()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;one&quot;</span>, one)  <span class="comment"># one &lt;__main__.Singleton object at 0x00000289BFAFA978&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;two&quot;</span>, two)  <span class="comment"># two &lt;__main__.Singleton object at 0x00000289BFAFA978&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="使用模块"><a href="#使用模块" class="headerlink" title="使用模块"></a>使用模块</h3><p>  Python的模块就是天然的单例模式，因为模块在第一次导入时，会生成.pyc文件，当第二次导入时，就会直接加载.pyc文件，而不会再次执行模块代码。因此，只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果想要一个单例类，可以考虑这样做：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">My_Singleton</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br></pre></td></tr></table></figure>

<p>  将上面的代码保存在文件mysingleton.py中，然后这样使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure>



<h2 id="单例模式优缺点"><a href="#单例模式优缺点" class="headerlink" title="单例模式优缺点"></a>单例模式优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>实例控制</p>
<p>  单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例</p>
<p>灵活性</p>
<p>  因为类控制了实例化过程，所以类可以灵活更改实例化过程</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>开销</p>
<p>  虽然数量很少，但如果每对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题</p>
<p>可能的开发混淆</p>
<p>  使用单例对象(尤其在类库中定义的对象)时，开发人员必须记住自己不能使用new关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类</p>
<p>对象生存期</p>
<p>  不能解决删除单个对象的问题。在提供内存管理的语言中(例如基于.NET Framework的语言)，只有单例类能够导致实例被取消分配，因为它包含对该实例的私有引用。在某些语言中(如c++)，其他类可以删除对象实例，但这样会导致单例类中出现悬浮引用</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2019/03/20/python-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="提取父类"><a href="#提取父类" class="headerlink" title="提取父类"></a>提取父类</h2><ul>
<li>在父类中定义好方法，在这个方法中什么都不用干。就抛出一个异常就可以了。这样所有的子类都必须重写这个方法。否则，访问时就会报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;子类没有实现该方法&quot;</span>)   <span class="comment"># NotImplementedError 没有实现的错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Normal</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">denglu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Admin</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目经理总入口</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准备验证码...&quot;</span>)</span><br><span class="line">    obj.login()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;进入主页...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = Normal()</span><br><span class="line">m = Member()</span><br><span class="line">a = Admin()</span><br><span class="line"></span><br><span class="line">login(n)</span><br><span class="line">login(m)  <span class="comment"># 报错</span></span><br><span class="line">login(a)</span><br></pre></td></tr></table></figure>



<h2 id="使用抽象类（不推荐）"><a href="#使用抽象类（不推荐）" class="headerlink" title="使用抽象类（不推荐）"></a>使用抽象类（不推荐）</h2><ul>
<li>使用抽象类描述父类，在抽象类中给出一个抽象方法。这样子类就不得不给出抽象方法的具体实现，否则报错，也可以起到约束的效果</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>python不能直接实现抽象类，需借助abc模块实现，ABCMeta是实现抽象基础类的元类，由它生成抽象类，只能被继承，不能实例化。</li>
<li>抽象类不能创建对象</li>
<li>抽象类中可以有正常的方法</li>
<li>子类必须重写父类中的抽象方法，否则子类也是一个抽象类</li>
<li>接口：类中全部方法都是抽象方法</li>
<li>如果一个类中包含了抽象方法。那么这个类一定是一个抽象类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Normal</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">denglu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Admin</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = Normal()</span><br><span class="line">n.login()</span><br><span class="line"></span><br><span class="line">m = Member()  <span class="comment"># 报错 Can&#x27;t instantiate abstract class Member with abstract methods login  </span></span><br><span class="line">m.login()</span><br><span class="line"></span><br><span class="line">a = Admin()</span><br><span class="line">a.login()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>小数据池</title>
    <url>/2019/03/15/python-%E5%B0%8F%E6%95%B0%E6%8D%AE%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="小数据池"><a href="#小数据池" class="headerlink" title="小数据池"></a>小数据池</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>  python程序是由代码块构成的，一个代码块的文本作为pythont程序执行的单元</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官方文档：</span><br><span class="line">     A Python program is constructed from code blocks. A block is a piece of Python program text that is executed as a unit. The following are blocks: a module, a function body, and a class definition. Each command typed interactively is a block. A script file (a file given as standard input to the interpreter or specified as a command line argument to the interpreter) is a code block. A script command (a command specified on the interpreter command line with the ‘-c‘ option) is a code block. The string argument passed to the built-in functions eval() and exec() is a code block. A code block is executed in an execution frame. A frame contains some administrative information (used for debugging) and determines where and how execution continues after the code block’s execution has completed.</span><br></pre></td></tr></table></figure>

<p>一个代码块：</p>
<ul>
<li>一个模块(module)</li>
<li>一个函数(function)</li>
<li>一个类(class)</li>
<li>每一个command命令</li>
<li>一个文件(file)</li>
<li>eval()</li>
<li>exec()</li>
</ul>
<h3 id="id"><a href="#id" class="headerlink" title="id()"></a>id()</h3><p>  通过id()可以查看到一个变量表示的值在内存中的地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;hello&quot;</span><br><span class="line">print(id(s)) # 2305859175064</span><br></pre></td></tr></table></figure>



<h3 id="is-和-区别"><a href="#is-和-区别" class="headerlink" title="is 和 &#x3D;&#x3D; 区别"></a>is 和 &#x3D;&#x3D; 区别</h3><ul>
<li><p>&#x3D;&#x3D;：判断左右两端的值是否相等</p>
</li>
<li><p>is：判断左右两端内容的内存地址是否一致。如果返回True,那可以确定这两个变量使用的是同一个对象</p>
<p>如果内存地址相同，则值一定是相等的，如果值相等，则不一定同一对象</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(a == b)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1000</span></span><br><span class="line">b = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a == b) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(a <span class="keyword">is</span> b) <span class="comment"># False 在command命令下为False, 在.py文件中（例如pycharm中）得到的结果为True。（详情见下面）</span></span><br></pre></td></tr></table></figure>



<h3 id="小数据池-1"><a href="#小数据池-1" class="headerlink" title="小数据池"></a>小数据池</h3><ul>
<li>一种缓存机制，也被称为驻留机制。各大编程语言中都有类似的东西。网上搜索常量池，小数据池指的是同一个内容</li>
<li>小数据池只针对：int(整数)， string(字符串)， bool(布尔值)。其他数据类型不存在驻留机制</li>
</ul>
<p>优点：能够提高字符串、整数的处理速度。省略了创建对象的过程。</p>
<p>缺点：在”池”中创建或者插入新的内容会花费更多的时间。</p>
<p>1.整数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">官方文档：</span><br><span class="line">    The current implementation keeps an array of integer objects for all integers between -5 and 256, when you create an int in that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behavior of Python in this case is undefined.</span><br></pre></td></tr></table></figure>

<ul>
<li>在python中，-5~256会被加到小数据池中，每次使用都是同一个对象</li>
<li>在使用的时候，内存中只会创建一个该数据的对象，保存在小数据池中。当使用的时候直接从小数据池中获取对象的内存引用，而不需要重新创建一个新的数据，这样会节省更多的内存区域。</li>
</ul>
<p>2.字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Incomputer science, string interning is a method of storing only onecopy of each distinct string value, which must be immutable. Interning strings makes </span><br><span class="line">some stringprocessing tasks more time- or space-efficient at the cost of requiring moretime when the string is created or interned. The distinct values are</span><br><span class="line"> stored ina string intern pool. –引⾃自维基百科</span><br></pre></td></tr></table></figure>

<ul>
<li>如果字符串的长度是0或者1，都会默认进行缓存。（中文字符无效）</li>
<li>字符串长度大于1，但是字符串中只包含数字，字母，下划线时会被缓存。</li>
<li>用乘法得到的字符串：1）乘数为1，仅包含数字，字母，下划线时会被缓存。如果包含其他字符，而长度&lt;&#x3D; 1也会被驻存(中文字符除外)。2）乘数大于1，仅包含数字，字母，下划线时会被缓存，但字符串长度不能大于20</li>
<li>指定驻留：可以通过sys模块中的intern()函数来指定要驻留的内容。(详情见sys模块相关内容)</li>
</ul>
<h3 id="代码块缓存机制"><a href="#代码块缓存机制" class="headerlink" title="代码块缓存机制"></a>代码块缓存机制</h3><p>  在代码块内缓存机制是不一样的：</p>
<ul>
<li>在执行同一个代码块的初始化对象的命令时，会检查其值是否已经存在，如果存在，会将其重用。换句话说：执行同一个代码块时，遇到初始化对象的命令时，他会将初始化的这个变量与值存储在一个字典中，再遇到新的初始化对象命令时，先在字典中查询其值是否已经存在，如果存在，那么它会重复使用这个字典中的之前的这个值。即两变量指向同一个内存地址。</li>
<li>如果是不同的代码块，则判断这两个变量是否满足小数据池的数据，如果满足，则两变量指向同一个地址。如果不满足，则得到两个不同的对象，即两变量指向的是不同的内存地址。</li>
</ul>
<p>注意：对于同一个代码块，只针对单纯创建变量，才会采用缓存机制，对于创建变量并同时做相关运算，则无。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 1000</span><br><span class="line">b = 1000</span><br><span class="line"></span><br><span class="line">print(id(a)) # 2135225709680</span><br><span class="line">print(id(b)) # 2135225709680</span><br><span class="line">print(a is b)  # True  .py文件运行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 1000</span><br><span class="line">b = 10*100</span><br><span class="line"></span><br><span class="line">print(id(a)) # 1925536396400</span><br><span class="line">print(id(b)) # 1925536643952</span><br><span class="line">print(a is b) # False  .py文件运行</span><br></pre></td></tr></table></figure>



<h3 id="小数据池与代码块缓存机制区别与联系"><a href="#小数据池与代码块缓存机制区别与联系" class="headerlink" title="小数据池与代码块缓存机制区别与联系"></a>小数据池与代码块缓存机制区别与联系</h3><ul>
<li>小数据池与代码块对缓存数据类型要求不一致，代码块只针对单纯创建变量有效，而对整数大小，字符串字符要求及长度无限制。</li>
<li>对于代码块缓存机制：如果不满足代码块缓存机制，则判断是否满足小数据池数据，如果满足，则采用小数据池缓存机制。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = 5*5</span><br><span class="line">b = 25</span><br><span class="line"></span><br><span class="line">print(id(a))  # 1592487712</span><br><span class="line">print(id(b))  # 1592487712</span><br><span class="line"></span><br><span class="line">print(a is b)  # True  .py文件运行</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &quot;Incomputer science, string interning is a method of storing only onecopy of each distinct string value&quot;</span><br><span class="line">b = &quot;Incomputer science, string interning is a method of storing only onecopy of each distinct string value&quot;</span><br><span class="line"></span><br><span class="line">print(id(a)) # 2926961023256</span><br><span class="line">print(id(b)) # 2926961023256</span><br><span class="line"></span><br><span class="line">print(a is b) # True  .py文件运行</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>异常</title>
    <url>/2019/03/20/python-%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>程序在运行过程中产生的错误</li>
</ul>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul>
<li>产生异常：python解释器调用代码，出现错误，系统自动产生一个异常对象，并把错误返回给调用方</li>
<li>捕获异常：通过try…except可以对系统产生的异常进行捕获</li>
<li>处理异常：如果except捕获到了相对应的异常，则在except代码块里处理异常，否则python解释器将错误返回调用者</li>
<li>别名：指接收到的异常对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    代码块</span><br><span class="line">except 异常名称 as 别名: </span><br><span class="line">    代码块</span><br><span class="line">except 异常名称 as 别名:</span><br><span class="line">    代码块</span><br><span class="line">...</span><br><span class="line">else:</span><br><span class="line">    不产生异常时执行这里的代码</span><br><span class="line">finally:</span><br><span class="line">    不管有无异常，都执行这里的代码</span><br></pre></td></tr></table></figure>



<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>  Exception是所有异常的基类。换句话说，所有的错误都是Exception的子类对象。</p>
<h2 id="抛出异常（raise）"><a href="#抛出异常（raise）" class="headerlink" title="抛出异常（raise）"></a>抛出异常（raise）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cul</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">type</span>(a) == <span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">type</span>(a) == <span class="built_in">float</span>) <span class="keyword">and</span> (<span class="built_in">type</span>(b) == <span class="built_in">int</span> <span class="keyword">or</span> <span class="built_in">type</span>(b) == <span class="built_in">float</span>):</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;参数数据类型有误&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(cul(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># 参数数据类型有误</span></span><br><span class="line">    <span class="built_in">print</span>(traceback.format_exc())  <span class="comment"># 获取堆栈信息</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现了错误&quot;</span>)  <span class="comment"># 出现了错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(traceback.format_exc())结果：</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;E:/python_个人/day 019/临时.py&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(cul(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>))</span><br><span class="line">  File <span class="string">&quot;E:/python_个人/day 019/临时.py&quot;</span>, line <span class="number">8</span>, <span class="keyword">in</span> cul</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">&quot;参数数据类型有误&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="自定义异常（慎用）"><a href="#自定义异常（慎用）" class="headerlink" title="自定义异常（慎用）"></a>自定义异常（慎用）</h2><ul>
<li>自定义一个类，并继承Exception类，类中内容全部继承Exception。就自定义了一个异常</li>
<li>名字须符合规范</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenderError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="variable language_">self</span>.gender = gender</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gender_judge</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="keyword">if</span> obj.gender != <span class="string">&quot;男&quot;</span>:</span><br><span class="line">        <span class="keyword">raise</span> GenderError(<span class="string">&quot;性别不对&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">p2 = Person(<span class="string">&quot;Linda&quot;</span>, <span class="string">&quot;女&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gender_judge(p1)</span><br><span class="line">    gender_judge(p2)</span><br><span class="line"><span class="keyword">except</span> GenderError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)  <span class="comment"># 性别不对</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>推导式</title>
    <url>/2019/03/16/python-%E6%8E%A8%E5%AF%BC%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h2><ul>
<li>写点：[结果 for 变量 in 可迭代对象 if 判断]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [i for i in range(1, 20) if i % 2 == 0]</span><br><span class="line">print(lst) # [2, 4, 6, 8, 10, 12, 14, 16, 18]</span><br></pre></td></tr></table></figure>



<h2 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h2><ul>
<li>写法：[结果 for 变量 in 可迭代对象 if 判断]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33]</span><br><span class="line">dic = &#123;i: lst[i] for i in range(len(lst))&#125;</span><br><span class="line">print(dic)  # &#123;0: 11, 1: 22, 2: 33&#125;</span><br></pre></td></tr></table></figure>



<h2 id="集合推导式"><a href="#集合推导式" class="headerlink" title="集合推导式"></a>集合推导式</h2><ul>
<li>写法：[结果 for 变量 in 可迭代对象 if 判断]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [1, 8, 33, 44, -1, -8, 12]</span><br><span class="line">s = &#123;abs(i) for i in lst&#125;</span><br><span class="line">print(s)  # &#123;1, 33, 8, 44, 12&#125;</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>推导式比较耗内存。一次加载。而生成器表达式几乎不占用内存。使用的时候才分配和使用内存。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>文件操作</title>
    <url>/2019/03/15/python-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;文件操作.txt&quot;, mode=&#x27;r&#x27;, encoding=&quot;utf-8&quot;)</span><br><span class="line">...</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>open：表示打开一个文件</li>
<li>f：变量，操控文件操作.txt文件的句柄。为一个可迭代对象</li>
<li>f.flush()：刷新管道，在向文件里写内容时，管道里也会有数据，使用f.flush()可将管道里数据写入到文件里。</li>
<li>f.close()：关闭文件</li>
</ul>
<h3 id="写入模式（w）"><a href="#写入模式（w）" class="headerlink" title="写入模式（w）"></a>写入模式（w）</h3><ul>
<li>如果文件名不存在，则创建文件，然后再写入</li>
<li>如果文件名已存在，则先清空文件内容，然后再写入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;送别.txt&quot; mode=&quot;w&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">f.write(&quot;下马饮君酒， 问君何所之？\n&quot;)</span><br><span class="line">f.write(&quot;君言不得意， 归卧南山陲。\n&quot;)</span><br><span class="line">f.write(&quot;但去莫复问， 白云无尽时。\n&quot;)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>



<h3 id="只读模式（r）"><a href="#只读模式（r）" class="headerlink" title="只读模式（r）"></a>只读模式（r）</h3><ul>
<li>read()</li>
</ul>
<p>1.read()：一次性全都读取出来。弊端：占内存。如果文件过大，容易导致内存崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;送别.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">content = f.read()</span><br><span class="line">print(content)f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">下马饮君酒， 问君何所之？</span><br><span class="line">君言不得意， 归卧南山陲。</span><br><span class="line">但去莫复问， 白云无尽时。</span><br></pre></td></tr></table></figure>

<p>2.read(n)：读取n个字符。需要注意的是，如果再次读取，那么会在当前位置继续去读，而不是从头读。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;送别.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">content = f.read(5)</span><br><span class="line">print(content)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">下马饮君酒</span><br></pre></td></tr></table></figure>

<ul>
<li>readline()：一次读取一行数据。但每次读取出来的数据末尾都会有一个\n。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;送别.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">content = f.readline()</span><br><span class="line">print(content)f.close()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">下马饮君酒， 问君何所之？</span><br></pre></td></tr></table></figure>

<ul>
<li>readlines()：一次性全都读取出来，返回的是列表，如果文件过大，容易出现内存崩溃的问题。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;送别.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">content = f.readlines()</span><br><span class="line">print(content)f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[&#x27;下马饮君酒， 问君何所之？\n&#x27;, &#x27;君言不得意， 归卧南山陲。\n&#x27;, &#x27;但去莫复问， 白云无尽时。&#x27;]</span><br></pre></td></tr></table></figure>

<ul>
<li>循环读取</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;送别.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">for line in f:</span><br><span class="line">    print(line.strip())</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">下马饮君酒， 问君何所之？</span><br><span class="line">君言不得意， 归卧南山陲。</span><br><span class="line">但去莫复问， 白云无尽时。</span><br></pre></td></tr></table></figure>



<h3 id="追加模式（a）"><a href="#追加模式（a）" class="headerlink" title="追加模式（a）"></a>追加模式（a）</h3><ul>
<li>在追加模式下，我们写入的内容会追加在文件的结尾</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;送别.txt&quot;, mode=&quot;a&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">f.write(&quot;- 王维&quot;)f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">下马饮君酒， 问君何所之？</span><br><span class="line">君言不得意， 归卧南山陲。</span><br><span class="line">但去莫复问， 白云无尽时。</span><br><span class="line">- 王维</span><br></pre></td></tr></table></figure>



<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><ul>
<li>如果文件夹命名为n或t时，此时\n，\t会被识别为转义字符，防止转义，可以路径前加”r”禁止转义。</li>
</ul>
<h3 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h3><p>从磁盘根目录找文件</p>
<ul>
<li>Windows：E:\python\送别.txt</li>
<li>Linux：\user\bin\xxx</li>
</ul>
<h3 id="相对路径（用的多）"><a href="#相对路径（用的多）" class="headerlink" title="相对路径（用的多）"></a>相对路径（用的多）</h3><p>指相对于当前程序所在的文件夹</p>
<ul>
<li>例如文件在上一层文件下的送别.txt：..&#x2F;送别.txt</li>
</ul>
<h2 id="读写字节（rb，wb，ab）"><a href="#读写字节（rb，wb，ab）" class="headerlink" title="读写字节（rb，wb，ab）"></a>读写字节（rb，wb，ab）</h2><ul>
<li>b：bytes，读取和写入的是字节</li>
<li>应用：用来操作非文本文件（图片， 音频， 视频）</li>
<li>在这些模式下，不能选择encoding字符集</li>
</ul>
<h3 id="rb"><a href="#rb" class="headerlink" title="rb"></a>rb</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;送别.txt&quot;, mode=&quot;rb&quot;)</span><br><span class="line">content = f.read()</span><br><span class="line">print(content)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">b&#x27;\xe4\xb8\x8b\xe9\xa9\xac\xe9\xa5\xae\xe5\x90\x9b\xe9\x85\x92\xef\xbc\x8c \xe9\x97\xae\xe5\x90\x9b\xe4\xbd\x95\xe6\x89\x80\xe4\xb9\x8b\xef\xbc\x9f\r\n\xe5\x90\x9b\xe8\xa8\x80\xe4\xb8\x8d\xe5\xbe\x97\xe6\x84\x8f\xef\xbc\x8c \xe5\xbd\x92\xe5\x8d\xa7\xe5\x8d\x97\xe5\xb1\xb1\xe9\x99\xb2\xe3\x80\x82\r\n\xe4\xbd\x86\xe5\x8e\xbb\xe8\x8e\xab\xe5\xa4\x8d\xe9\x97\xae\xef\xbc\x8c \xe7\x99\xbd\xe4\xba\x91\xe6\x97\xa0\xe5\xb0\xbd\xe6\x97\xb6\xe3\x80\x82&#x27;</span><br></pre></td></tr></table></figure>



<h3 id="wb"><a href="#wb" class="headerlink" title="wb"></a>wb</h3><p>  wb模式下，可以不指定打开文件的编码。但是在写文件的时候必须将字符串转化成utf-8的bytes数据，否则报错：TypeError: a bytes-like object is required, not ‘str’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;送别.txt&quot;, mode=&quot;wb&quot;)</span><br><span class="line">f.write(&quot;   五言古诗&quot;.encode(&quot;utf-8&quot;))</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">   五言古诗</span><br></pre></td></tr></table></figure>



<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>将图片(长城.jpg)从C盘复制到D盘：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1 = open(r&quot;c:\长城.jpg&quot;, mode=&quot;rb&quot;)</span><br><span class="line">f2 = open(r&quot;d:\长城.jpg&quot;, mode=&quot;wb&quot;)</span><br><span class="line"></span><br><span class="line">for line in f1:</span><br><span class="line">    f2.read(line)</span><br><span class="line"></span><br><span class="line">f1.close()</span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure>



<h2 id="扩展（-）"><a href="#扩展（-）" class="headerlink" title="扩展（+）"></a>扩展（+）</h2><h3 id="r-读写"><a href="#r-读写" class="headerlink" title="r+(读写)"></a>r+(读写)</h3><ul>
<li>先读后写（正常）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># place.txt:</span><br><span class="line"># 北京</span><br><span class="line"># 上海</span><br><span class="line"># 深圳</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = open(&quot;place.txt&quot;, mode=&quot;r+&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">content = f.read()</span><br><span class="line">f.write(&quot;广州&quot;)</span><br><span class="line">print(content)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">北京</span><br><span class="line">上海</span><br><span class="line">深圳</span><br><span class="line"></span><br><span class="line"># place.txt:</span><br><span class="line"># 北京</span><br><span class="line"># 上海</span><br><span class="line"># 深圳</span><br><span class="line"># 广州</span><br></pre></td></tr></table></figure>

<p>注意：在r+模式下，不论读取多少内容，再次写入时，都是在末尾写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">送别.txt:</span><br><span class="line">下马饮 君酒，问君何所之?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = open(&quot;送别.txt&quot;, mode=&quot;r+&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">content = f.read(3)</span><br><span class="line">f.write(&quot;\n君言不得意，归卧南山陲。&quot;)</span><br><span class="line">print(content)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">下马饮</span><br><span class="line"></span><br><span class="line">送别.txt:</span><br><span class="line">下马饮君酒，问君何所之?</span><br><span class="line">君言不得意，归卧南山陲。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>先写后读（错误示范）</p>
<p>如果直接写入的话，则在开头写入，覆盖开头的内容</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">place.txt:</span><br><span class="line">北京</span><br><span class="line">上海</span><br><span class="line">深圳</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = open(&quot;place.txt&quot;, mode=&quot;r+&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">f.write(&quot;广州&quot;)</span><br><span class="line">content = f.read()</span><br><span class="line">print(content)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">上海</span><br><span class="line">深圳</span><br><span class="line"></span><br><span class="line">place.txt:</span><br><span class="line">广州</span><br><span class="line">上海</span><br><span class="line">深圳</span><br></pre></td></tr></table></figure>



<h3 id="w-写读"><a href="#w-写读" class="headerlink" title="w+(写读)"></a>w+(写读)</h3><ul>
<li>如果文件存在，则先清空，再写入，如果文件不存在，则先创建文件，再写入。</li>
<li>写入东西后，光标在末尾，再次读取时，读取内容为空白</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;introduction.txt&quot;, mode=&quot;w+&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">f.write(&quot;你好，我叫赛利亚&quot;)</span><br><span class="line">content = f.read()</span><br><span class="line">print(content)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br></pre></td></tr></table></figure>

<p>a+(追加写读)</p>
<ul>
<li>不论光标在何处，写入时，都是在末尾写入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = open(&quot;introduction.txt&quot;, mode=&quot;a+&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">f.write(&quot;祝你玩的愉快！&quot;)</span><br><span class="line">content = f.read()</span><br><span class="line">print(content)</span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">introduction.txt:</span><br><span class="line">你好，我叫赛利亚祝你玩的愉快！</span><br></pre></td></tr></table></figure>



<h2 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h2><h3 id="seek-参数1-参数2"><a href="#seek-参数1-参数2" class="headerlink" title="seek(参数1, 参数2)"></a>seek(参数1, 参数2)</h3><ul>
<li>参数1：偏移量，表示移动多少个单位。</li>
<li>参数2：表示从什么位置进行偏移。0表示开头，1表示当前位置，2表示末尾。把光标移动至文件的开头：seek(0)；移至末尾：seek(0, 2)</li>
<li>功能：移动光标</li>
<li>特点：以字节为单位</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">introduction.txt:</span><br><span class="line">你好，我叫赛利亚</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = open(&quot;introduction.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">f.seek(3)</span><br><span class="line">content = f.read(3)</span><br><span class="line">print(content)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">好，我</span><br></pre></td></tr></table></figure>



<h3 id="tell"><a href="#tell" class="headerlink" title="tell()"></a>tell()</h3><p>程序返回当前光标的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">introduction.txt:</span><br><span class="line">你好，我叫赛利亚</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = open(&quot;introduction.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">content = f.read(3)</span><br><span class="line">print(f.tell())  # 9</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>



<h3 id="truncate"><a href="#truncate" class="headerlink" title="truncate()"></a>truncate()</h3><p>默认从开头截取到光标位置，后面的内容将会被删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">introduction.txt:</span><br><span class="line">你好，我叫赛利亚</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = open(&quot;introduction.txt&quot;, mode=&quot;r+&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">f.seek(3)</span><br><span class="line">f.truncate()</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">introduction.txt:</span><br><span class="line">你</span><br></pre></td></tr></table></figure>

<p>truncate(n)：从开头载取到n位置，后面的内容将会被删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">introduction.txt:</span><br><span class="line">你好，我叫赛利亚</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = open(&quot;introduction.txt&quot;, mode=&quot;r+&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">f.truncate(3)</span><br><span class="line">f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">introduction.txt:</span><br><span class="line">你</span><br></pre></td></tr></table></figure>



<h2 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h2><p>  文件操作没有直接修改文件功能，只能将文件中的内容读取到内存中，将信息修改完毕，然后将源文件删除，将新的文件的名字改成老文件的名字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">with open(&quot;唐诗&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f1,\</span><br><span class="line">    open(&quot;唐诗_副本&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;) as f2:</span><br><span class="line">    for line in f1:</span><br><span class="line">        line = line.replace(&quot;?&quot;, &quot;。&quot;)</span><br><span class="line">        f2.write(line)</span><br><span class="line"></span><br><span class="line">os.remove(&quot;唐诗&quot;)  # 删除源文件</span><br><span class="line">os.rename(&quot;唐诗_副本&quot;, &quot;唐诗&quot;)  # 把副本改名为源文件</span><br></pre></td></tr></table></figure>



<h2 id="文件操作应用"><a href="#文件操作应用" class="headerlink" title="文件操作应用"></a>文件操作应用</h2><h3 id="文本文件的复制"><a href="#文本文件的复制" class="headerlink" title="文本文件的复制"></a>文本文件的复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1 = open(r&quot;C:\日记本.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line">f2 = open(r&quot;D：\日记本.txt&quot;, mode=&quot;w&quot;, encoding=&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">for line in f1:</span><br><span class="line">    f2.write(line)</span><br><span class="line"></span><br><span class="line">f1.close()</span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure>



<h3 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data.txt:</span><br><span class="line">序号，名称，价格，库存</span><br><span class="line">1，苹果，5，6000</span><br><span class="line">2，榴莲，20，5000</span><br><span class="line">3，香蕉，3，2000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with open(&quot;data.txt&quot;, mode=&quot;r&quot;, encoding=&quot;utf-8&quot;) as f:</span><br><span class="line">    titles = f.readline().strip()</span><br><span class="line">    t_list = titles.split(&quot;,&quot;)</span><br><span class="line"></span><br><span class="line">    lst = []</span><br><span class="line">    for line in f:</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        line = line.strip().split(&quot;,&quot;)</span><br><span class="line">        for i in range(len(line)):</span><br><span class="line">            dic[t_list[i]] = line[i]</span><br><span class="line">        lst.append(dic)</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[&#123;&#x27;序号&#x27;: &#x27;1&#x27;, &#x27;名称&#x27;: &#x27;苹果&#x27;, &#x27;价格&#x27;: &#x27;5&#x27;, &#x27;库存&#x27;: &#x27;6000&#x27;&#125;, &#123;&#x27;序号&#x27;: &#x27;2&#x27;, &#x27;名称&#x27;: &#x27;榴莲&#x27;, &#x27;价格&#x27;: &#x27;20&#x27;, &#x27;库存&#x27;: &#x27;5000&#x27;&#125;, &#123;&#x27;序号&#x27;: &#x27;3&#x27;, &#x27;名称&#x27;: &#x27;香蕉&#x27;, &#x27;价格&#x27;: &#x27;3&#x27;, &#x27;库存&#x27;: &#x27;2000&#x27;&#125;]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>日志</title>
    <url>/2019/03/20/python-%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h2 id="basicConfig"><a href="#basicConfig" class="headerlink" title="basicConfig"></a>basicConfig</h2><ul>
<li>导入logging模块</li>
<li>简单配置一下logging</li>
<li>出现异常的时候（except），向日志里写错误信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=<span class="string">&quot;x1.log&quot;</span>,</span><br><span class="line">                    <span class="built_in">format</span>=<span class="string">&quot;%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s&quot;</span>,</span><br><span class="line">                    datefmt=<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, level=<span class="number">30</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    logging.error(traceback.format_exc())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出现错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>filename：文件名</li>
<li>format：数据的格式化输出，最终在日志文件中的样子。时间-名称-级别-模块：错误信息</li>
<li>datefmt：时间的格式</li>
<li>level:错误的级别权重，当错误的级别权重大于等于leval的时候才会写入文件</li>
</ul>
<p>CRITICAL &#x3D; 50</p>
<p>FATAL &#x3D; CRITICAL</p>
<p>ERROR &#x3D; 40</p>
<p>WARNING &#x3D; 30</p>
<p>WARN &#x3D; WARNING</p>
<p>INFO &#x3D; 20</p>
<p>DEBUG &#x3D; 10</p>
<p>LOG &#x3D; 0</p>
<h2 id="FileHandler"><a href="#FileHandler" class="headerlink" title="FileHandler"></a>FileHandler</h2><ul>
<li>可实现日志分开记录</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"></span><br><span class="line">file_handler = logging.FileHandler(<span class="string">&quot;x2.log&quot;</span>, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">file_handler.setFormatter(logging.Formatter(fmt=<span class="string">&quot;%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s&quot;</span>))</span><br><span class="line"></span><br><span class="line">logger1 = logging.Logger(<span class="string">&quot;系统A&quot;</span>, level=<span class="number">30</span>)</span><br><span class="line">logger1.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line">logger1.error(<span class="string">&quot;出现错误&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_handler = logging.FileHandler(<span class="string">&quot;x3.log&quot;</span>, <span class="string">&quot;a&quot;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">file_handler.setFormatter(logging.Formatter(fmt=<span class="string">&quot;%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s&quot;</span>))</span><br><span class="line"></span><br><span class="line">logger2 = logging.Logger(<span class="string">&quot;系统B&quot;</span>, level=<span class="number">30</span>)</span><br><span class="line">logger2.addHandler(file_handler)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    logger2.error(traceback.format_exc())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;出错了&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>模块语法</title>
    <url>/2019/03/20/python-%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>  模块就是一个包含python定义和声明的文件，文件名就是模块的名字加上.py后缀。换句话说，所有的py文件都可以看成是一个模块。</p>
<p>  模块名有两个：py文件名， _<em>main</em>_</p>
<h3 id="模块的四个通用类别"><a href="#模块的四个通用类别" class="headerlink" title="模块的四个通用类别"></a>模块的四个通用类别</h3><ul>
<li>使用python编写的py文件</li>
<li>已被编译为共享库或者DLL或C或者C++的扩展</li>
<li>包好一组模块的包</li>
<li>使用c编写并连接到python解释器的内置模块</li>
</ul>
<h3 id="使用模块的好处"><a href="#使用模块的好处" class="headerlink" title="使用模块的好处"></a>使用模块的好处</h3><ul>
<li>可以把代码进行分类</li>
<li>可以实现代码的重用</li>
</ul>
<h3 id="导入模块时执行的三个动作"><a href="#导入模块时执行的三个动作" class="headerlink" title="导入模块时执行的三个动作"></a>导入模块时执行的三个动作</h3><ul>
<li>先在sys.modules中查看当前导入的模块是否已经被导入。如果已导入，则不会再重复导入，也就不会执行下面两个操作</li>
<li>开辟一片内存空间，在该空间中执行模块中的代码</li>
<li>创建模块的名字。并使用该名称作为该模块在当前模块中引用的名字</li>
</ul>
<p>使用globals()查看模块的名称空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">globals</span>())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">&#123;<span class="string">&#x27;__name__&#x27;</span>: <span class="string">&#x27;__main__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__package__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__loader__&#x27;</span>: &lt;_frozen_importlib_external.SourceFileLoader <span class="built_in">object</span> at <span class="number">0x00000275FF8DC2B0</span>&gt;, <span class="string">&#x27;__spec__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;__annotations__&#x27;</span>: &#123;&#125;, <span class="string">&#x27;__builtins__&#x27;</span>: &lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">&#x27;__file__&#x27;</span>: <span class="string">&#x27;E:/python_个人/day 024 模块的语法/临时/临时.py&#x27;</span>, <span class="string">&#x27;__cached__&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;random&#x27;</span>: &lt;module <span class="string">&#x27;random&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;C:\\Python36\\lib\\random.py&#x27;</span>&gt;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入模块的顺序"><a href="#导入模块的顺序" class="headerlink" title="导入模块的顺序"></a>导入模块的顺序</h3><ul>
<li>先引入内置模块</li>
<li>再引入第三方模块</li>
<li>最后引入自己定义的模块</li>
</ul>
<h2 id="导入模块的两种方式"><a href="#导入模块的两种方式" class="headerlink" title="导入模块的两种方式"></a>导入模块的两种方式</h2><h3 id="import-xxx"><a href="#import-xxx" class="headerlink" title="import xxx"></a>import xxx</h3><ul>
<li>应用场景：当不确定要使用模块中哪些功能时。</li>
<li>设置别名：import xxx as xxx</li>
</ul>
<p>模块在导入的时候会创建其自己的名称空间。所以，在使用模块中的变量的时候一般是不会产生冲突的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test模块：</span><br><span class="line"></span><br><span class="line">main_person_one = <span class="string">&quot;Jhon&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(main_person_one) </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用方</span></span><br><span class="line"><span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line">main_person_one = <span class="string">&quot;Tom&quot;</span></span><br><span class="line"></span><br><span class="line">test.foo()  <span class="comment"># Jhon</span></span><br><span class="line"><span class="built_in">print</span>(main_person_one)  <span class="comment"># Tom</span></span><br></pre></td></tr></table></figure>

<p>在模块中使用global</p>
<ul>
<li>global表示把全局的内容引入到局部，但这个全局指的是py文件。换句话说，global指向的是模块内部，并不会改变外部模块的内容</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模块test中</span></span><br><span class="line"></span><br><span class="line">main_person_one = <span class="string">&quot;Jhon&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="keyword">global</span> main_person_one</span><br><span class="line">    main_person_one = <span class="string">&quot;Tom&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(main_person_one)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用方</span></span><br><span class="line"><span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line">main_person_one = <span class="string">&quot;Linda&quot;</span></span><br><span class="line"></span><br><span class="line">test.foo()  <span class="comment"># Tom</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test.main_person_one)  <span class="comment"># Tom</span></span><br><span class="line"><span class="built_in">print</span>(main_person_one)  <span class="comment"># Linda</span></span><br></pre></td></tr></table></figure>



<h3 id="from-xxx-import-xxx"><a href="#from-xxx-import-xxx" class="headerlink" title="from xxx import xxx"></a>from xxx import xxx</h3><p>  使用from xxx import xxx 时，与import方式一样，python也会给模块创建名称空间。但不同的是，import会把整个模块内容引入过来，而from方式则是部分引入。当一个模块中的内容过多时，可以采用此方式选择性的导入要使用的内容</p>
<ul>
<li>应用场景：当确定要使用模块中哪些功能时</li>
<li>设置别名：from xxx import xxx as xxx</li>
<li>from xxx import *：导入所有内容</li>
</ul>
<p>当从一个模块中引入一个变量时，如果当前文件中出现了重名的变量时，会覆盖掉模块引入的那个变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test模块：</span></span><br><span class="line"></span><br><span class="line">main_person_one = <span class="string">&quot;Jhon&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(main_person_one)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用方</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> main_person_one, foo</span><br><span class="line"></span><br><span class="line">main_person_one = <span class="string">&quot;Tom&quot;</span></span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># Jhon</span></span><br><span class="line"><span class="built_in">print</span>(main_person_one)  <span class="comment"># Tom</span></span><br></pre></td></tr></table></figure>



<h2 id="修改模块变量的方式-慎用"><a href="#修改模块变量的方式-慎用" class="headerlink" title="修改模块变量的方式(慎用)"></a>修改模块变量的方式(慎用)</h2><ul>
<li>方式：模块名.变量名 &#x3D; 值 ， 只能通过import方式修改</li>
<li>后果：当某一调用方对模块变量进行修改后，所有调用方拿到的这个变量的值都发生变化，因为模块只会导入一次，共享名称空间。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test模块：</span></span><br><span class="line"></span><br><span class="line">main_person_one = <span class="string">&quot;Jhon&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(main_person_one)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用方</span></span><br><span class="line"><span class="keyword">import</span> test</span><br><span class="line"></span><br><span class="line">test.main_person_one = <span class="string">&quot;Tom&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(test.main_person_one)  <span class="comment"># Tom</span></span><br></pre></td></tr></table></figure>



<h2 id="name"><a href="#name" class="headerlink" title="_name_"></a>_<em>name</em>_</h2><p>  每个模块在完成代码编写后，都需对其功能进行测试，此时需要对其编写测试代码。但被调用方导入时不需执行测试代码。此时可以利用__name__过滤掉测试代码的执行</p>
<p>  在python中，每个模块都有自己的__name__，但__name__的值是不定的。当把一个模块作为程序的入口时，此时该模块的__name__是”__main__“，而如果把模块导入时，此时模块内部的__name__就是该模块自身的名字</p>
<p>运行test模块时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test模块：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;----test----&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(__name__)  <span class="comment"># __main__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    foo()  <span class="comment"># ----test----</span></span><br></pre></td></tr></table></figure>

<p>运行调用方时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 调用方</span><br><span class="line">import test结果：test  # 即 test模块中，__name__ = test</span><br></pre></td></tr></table></figure>



<h2 id="all"><a href="#all" class="headerlink" title="_all_"></a>_<em>all</em>_</h2><p>  在模块中设置__all__， 可以限制模块可允许的导入内容，只对from xxx import * 有效</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test模块</span></span><br><span class="line">__all__ = [<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>]</span><br><span class="line">x = <span class="number">2</span></span><br><span class="line">y = <span class="number">3</span></span><br><span class="line">z = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----test-----&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调用方</span></span><br><span class="line"><span class="keyword">from</span> test <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 2</span></span><br><span class="line"><span class="built_in">print</span>(z)  <span class="comment"># NameError: name &#x27;z&#x27; is not defined</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2019/03/20/python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>正则表达式是对字符串操作的一种逻辑公式，一般使用正则表达式对字符串进行匹配和过滤</li>
<li>正则表达式由普通字符和元字符组成</li>
<li>优点：灵活，功能性强，逻辑性强</li>
<li>缺点：上手难，一旦上手，会爱上这个东西</li>
<li>工具：各大文本编辑器一般都有正则匹配功能。在线测试网址：<a href="http://tool.chinaz.com/regex/">http://tool.chinaz.com/regex/</a></li>
</ul>
<h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>  普通字符包含大小写字母、数字。在匹配普通字符时直接写就好。比如”abc”匹配的就是”abc”</p>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><h3 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h3><p>  用[ ]括起来，在[ ]中出现的内容会被匹配。例如：[abc]匹配a或b或c</p>
<ul>
<li>[a-z]：匹配a到z之间的一个字母</li>
<li>[0-9]：匹配所有阿拉伯数字的一个</li>
<li>[a-zA-Z0-9]：匹配a-z或A-Z或0-9其中的一个</li>
</ul>
<h3 id="简单元字符"><a href="#简单元字符" class="headerlink" title="简单元字符"></a>简单元字符</h3><ul>
<li><strong>.</strong>：匹配换行符以外的任意字符</li>
<li>\w：匹配字母或数字或下划线</li>
<li>\s：匹配任意的空白符</li>
<li>\d：匹配数字</li>
<li>\n：匹配一个换行符</li>
<li>\t：匹配一个制表符</li>
<li>\b：匹配一个单词的结尾</li>
<li>^：匹配字符串的开始</li>
<li>$：匹配字符串的结尾</li>
<li>\W：匹配非字母或数字或下划线</li>
<li>\D：匹配非数字</li>
<li>\S：匹配非空白符</li>
<li>a|b：匹配字符a或字符b</li>
<li>()：匹配括号内的表达式，也表示一个组</li>
<li>[…]：匹配字符组中的字符</li>
<li>[^…]：匹配除了字符中字符的所有字符</li>
</ul>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul>
<li>*：重复0次或更多次</li>
<li>+：重复一次或更多次</li>
<li>？：重复0次或一次</li>
<li>{n}：重复n次</li>
<li>{n, }：重复n次或更多次</li>
<li>{n, m}：重复n到m次</li>
</ul>
<h2 id="贪婪匹配与惰性匹配"><a href="#贪婪匹配与惰性匹配" class="headerlink" title="贪婪匹配与惰性匹配"></a>贪婪匹配与惰性匹配</h2><h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><p>  量词中的*，+，{}都属于贪婪匹配，就是尽可能多的匹配到结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>：hello world</span><br><span class="line">reg: h.*</span><br><span class="line">此时匹配的结果：hello world</span><br><span class="line"><span class="built_in">str</span>：&lt;div&gt;hello&lt;/div&gt;</span><br><span class="line">reg：&lt;.*&gt;</span><br><span class="line">此时匹配的结果：&lt;div&gt;hello&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="惰性匹配"><a href="#惰性匹配" class="headerlink" title="惰性匹配"></a>惰性匹配</h3><p>  在使用.*后面如果加了”?”则是尽可能的少匹配</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>：hello world</span><br><span class="line">reg：h.*?</span><br><span class="line">此时匹配的结果：h</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>：&lt;div&gt;hello&lt;/div&gt;</span><br><span class="line">reg：&lt;.*?&gt;</span><br><span class="line">此时匹配的结果：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>  在正则中使用()进行分组。</p>
<p>  例如要匹配一个相对复杂的身份证号。身份证号分成两种。老的身份证号有15位，而新的身份证号有18位。并且新身份证号结尾可能是x</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">正则为：</span><br><span class="line">^([1-9]\d&#123;16&#125;[0-9x]|[1-9]\d&#123;14&#125;)$</span><br></pre></td></tr></table></figure>



<h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>  在正则表达式中，有很多有特殊意义的元字符，比如\n和\s等。如果要在正则中匹配正常的”\n”而不是换行就需要对”&quot;进行转义。</p>
<p>  同理，在python中，对于\n,\s等也是有特殊意义的，如果要得到”\n”也需要对”&quot;进行转义，所以，如果需要匹配字符\n，在正则表达及python表达中需要写成如下表格形式。</p>
<table>
<thead>
<tr>
<th><strong>目标</strong></th>
<th><strong>正则</strong></th>
<th><strong>python</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>\n</td>
<td>\\n</td>
</tr>
</tbody></table>
<p>表1 “\n”转义</p>
<p>  此时可以利用r”\n”不转义，即上表中python中正则表达可写为：r”\n”</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深浅拷贝</title>
    <url>/2019/03/15/python-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title="&#x3D;"></a>&#x3D;</h2><ul>
<li>没有产生新对象，都是内存地址的赋值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst1 = [11, 22, 33, 44]</span><br><span class="line">lst2 = lst1</span><br><span class="line">print(id(lst1)) # 1916361712712</span><br><span class="line">print(id(lst2)) # 1916361712712</span><br><span class="line"></span><br><span class="line">lst1.append(&quot;hello&quot;)</span><br><span class="line">print(lst1)  # [11, 22, 33, 44, &#x27;hello&#x27;]</span><br><span class="line">print(lst2)  # [11, 22, 33, 44, &#x27;hello&#x27;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dic1 = &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line">dic2 = dic1</span><br><span class="line">print(id(dic1)) # 2020711820888</span><br><span class="line">print(id(dic2)) # 2020711820888</span><br><span class="line">dic1[&quot;hobby&quot;]  = &quot;football&quot;</span><br><span class="line"></span><br><span class="line">print(dic1)  # &#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18, &#x27;hobby&#x27;: &#x27;football&#x27;&#125;</span><br><span class="line">print(dic2)  # &#123;&#x27;name&#x27;: &#x27;Tom&#x27;, &#x27;age&#x27;: 18, &#x27;hobby&#x27;: &#x27;football&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>  对于list，set，dict来说，变量1 &#x3D; 变量2，其实就相当于把变量2内容的内存地址交给变量1，并不是复制一份内容，所以一变，都变。 </p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><ul>
<li>优点：省内存</li>
<li>缺点：只拷贝第一层内容</li>
<li>浅拷贝方法：copy()，对于list，还有lst[:]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst1 = [11, 22, 33]</span><br><span class="line">lst2 = lst1[:]</span><br><span class="line"></span><br><span class="line">print(id(lst1))  # 1744651035720</span><br><span class="line">print(id(lst2))  # 1744651035848</span><br><span class="line"></span><br><span class="line">lst1.append(44)</span><br><span class="line"></span><br><span class="line">print(lst1) # [11, 22, 33, 44]</span><br><span class="line">print(lst2) # [11, 22, 33]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst1 = [11, 22, 33, [44, 55]]</span><br><span class="line">lst2 = lst1.copy()</span><br><span class="line"></span><br><span class="line">print(id(lst1))  # 2081315824712</span><br><span class="line">print(id(lst2))  # 2081316649864</span><br><span class="line"></span><br><span class="line">lst1[3].append(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">print(lst1) # [11, 22, 33, [44, 55, &#x27;hello&#x27;]]</span><br><span class="line">print(lst2) # [11, 22, 33, [44, 55, &#x27;hello&#x27;]]</span><br></pre></td></tr></table></figure>



<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><ul>
<li><p>深拷贝把内部元素完全进行拷贝复制。</p>
<p>深拷贝方法：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">s2 = copy.deepcopy(s1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import copy</span><br><span class="line"></span><br><span class="line">lst1 = [11, 22, 33, [44, 55]]</span><br><span class="line">lst2 = copy.deepcopy(lst1)</span><br><span class="line"></span><br><span class="line">print(id(lst1))  # 1236356428872</span><br><span class="line">print(id(lst2))  # 1236356430152</span><br><span class="line"></span><br><span class="line">lst1[3].append(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">print(lst1) # [11, 22, 33, [44, 55, &#x27;hello&#x27;]]</span><br><span class="line">print(lst2) # [11, 22, 33, [44, 55]]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器</title>
    <url>/2019/03/16/python-%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>生成器本质就是迭代器</li>
<li>生成器对象可以直接进行for循环</li>
</ul>
<h3 id="生成器特点"><a href="#生成器特点" class="headerlink" title="生成器特点"></a>生成器特点</h3><ul>
<li>省内存</li>
<li>惰性机制</li>
<li>只能向前，不能反复</li>
</ul>
<h3 id="生成器获取方式"><a href="#生成器获取方式" class="headerlink" title="生成器获取方式"></a>生成器获取方式</h3><ul>
<li>通过生成器函数</li>
<li>通过生成器表达式</li>
</ul>
<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ul>
<li>可以把函数分段运行</li>
<li>作用和return一样，也是返回数据</li>
</ul>
<h3 id="普通函数与生成器函数区别"><a href="#普通函数与生成器函数区别" class="headerlink" title="普通函数与生成器函数区别"></a>普通函数与生成器函数区别</h3><p>普通函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    print(&quot;111&quot;)</span><br><span class="line">    return 222</span><br><span class="line"></span><br><span class="line">ret = func()</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">111</span><br><span class="line">222</span><br></pre></td></tr></table></figure>

<p>生成器函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    print(&quot;111&quot;)</span><br><span class="line">    yield 222</span><br><span class="line"></span><br><span class="line">ret = func()</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&lt;generator object func at 0x0000018007451C50&gt;</span><br></pre></td></tr></table></figure>

<p>所以：</p>
<ul>
<li>当函数中存在yield，那么这个函数就是一个生成器函数</li>
<li>当执行生成器函数时，实则为获取这个生成器</li>
</ul>
<h3 id="获取生成器"><a href="#获取生成器" class="headerlink" title="获取生成器"></a>获取生成器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    print(&quot;111&quot;)</span><br><span class="line">    yield 222</span><br><span class="line"></span><br><span class="line">ret = func()  # 获取到生成器</span><br></pre></td></tr></table></figure>



<h3 id="执行生成器"><a href="#执行生成器" class="headerlink" title="执行生成器"></a>执行生成器</h3><ul>
<li>通过__next__()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    print(&quot;111&quot;)</span><br><span class="line">    yield 222</span><br><span class="line"></span><br><span class="line">gener = func()</span><br><span class="line">ret = gener.__next__()  # 打印 111，222返回给ret</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p>当程序运行完最后一个yield，那么后面继续执行__next__()，程序会报错，但后面内容还会执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    print(&quot;111&quot;)</span><br><span class="line">    yield 222</span><br><span class="line">    print(&quot;333&quot;)</span><br><span class="line">    yield 444</span><br><span class="line">    print(&quot;555&quot;)</span><br><span class="line"></span><br><span class="line">gener = func()</span><br><span class="line">print(gener.__next__())  # 111 222</span><br><span class="line">print(gener.__next__())  # 333 444</span><br><span class="line">print(gener.__next__())  # 555 StopIteration</span><br></pre></td></tr></table></figure>

<ul>
<li><p>通过send()</p>
<p>send()和__next__()一样都可以让生成器执行到下一个yield，但send()可以给上一个yield的位置变量传递值。当执行完最后一个yield，再继续执行send()时，程序报错，但还可给最后一个yield位置变量传递值。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    print(&quot;111&quot;)</span><br><span class="line">    a = yield 222</span><br><span class="line">    print(&quot;a = &quot;, a)</span><br><span class="line">    print(&quot;333&quot;)</span><br><span class="line">    b = yield 444</span><br><span class="line">    print(&quot;b = &quot;, b)</span><br><span class="line"></span><br><span class="line">gener = func()</span><br><span class="line">gener.__next__()  # 111</span><br><span class="line">print(gener.send(&quot;1&quot;))  # a = 1 333 444</span><br><span class="line">print(gener.send(&quot;2&quot;))  # b = 2  StopIteration</span><br></pre></td></tr></table></figure>

<p> send和__next__()区别：</p>
<ul>
<li>send和__next__()都是让生成器向下走一次</li>
<li>send可以给上一个yield的位置传递值，不能给最后一个yield发送值。在第一次执行生成器代码的时候不能使用send()</li>
</ul>
<h3 id="利用for循环获取生成器内部元素"><a href="#利用for循环获取生成器内部元素" class="headerlink" title="利用for循环获取生成器内部元素"></a>利用for循环获取生成器内部元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    yield 111</span><br><span class="line">    yield 222</span><br><span class="line">    yield 333</span><br><span class="line">    yield 444</span><br><span class="line"></span><br><span class="line">gen = func()</span><br><span class="line">for i in gen:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">111</span><br><span class="line">222</span><br><span class="line">333</span><br><span class="line">444</span><br></pre></td></tr></table></figure>



<h3 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h3><p>  可以直接把可迭代对象中的每一个数据作为生成器的结果进行返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def gen():</span><br><span class="line">    lst = [11, 22, 33, 44, 55, 66]</span><br><span class="line">    yield from lst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = gen()</span><br><span class="line">for i in ret:</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">33</span><br><span class="line">44</span><br><span class="line">55</span><br><span class="line">66</span><br></pre></td></tr></table></figure>

<p>此时，上述代码相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def gen():</span><br><span class="line">    lst = [11, 22, 33, 44, 55, 66]</span><br><span class="line">    yield lst[0]</span><br><span class="line">    yield lst[1]</span><br><span class="line">    yield lst[2]</span><br><span class="line">    yield lst[3]</span><br><span class="line">    yield lst[4]</span><br><span class="line">    yield lst[5]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ret = gen()</span><br><span class="line">for i in ret:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>



<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><h3 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h3><ul>
<li>（结果 for 变量 in 可迭代对象 if 条件筛选）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gen = (i for i in range(10))</span><br><span class="line">print(gen)  # &lt;generator object &lt;genexpr&gt; at 0x000002CE52D91C50&gt;</span><br></pre></td></tr></table></figure>



<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>本质是迭代器</li>
<li>省内存</li>
<li>惰性机制</li>
<li>只能向前，不能反复</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>1）list ()可把传递进来的数据转化成列表，list里面包含for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g = (i for i in range(10))</span><br><span class="line"></span><br><span class="line">print(list(g))  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    print(111)</span><br><span class="line">    yield 222</span><br><span class="line"></span><br><span class="line">g = func()</span><br><span class="line">g1 = (i for i in g)</span><br><span class="line">g2 = (i for i in g1)</span><br><span class="line"></span><br><span class="line">print(list(g)) # 111 [222]</span><br><span class="line">print(list(g1)) # []</span><br><span class="line">print(list(g2)) # []</span><br></pre></td></tr></table></figure>

<p> 3）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def add(a, b):</span><br><span class="line">    return a + b</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    for r_i in range(4):</span><br><span class="line">        yield r_i</span><br><span class="line"></span><br><span class="line">g = test()</span><br><span class="line"></span><br><span class="line">for n in [2, 10]:</span><br><span class="line">    g = (add(n, i) for i in g)</span><br><span class="line"></span><br><span class="line">print(list(g))  # 20 21 22 23</span><br></pre></td></tr></table></figure>

<p>此代码相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def add(a, b):</span><br><span class="line">    return a + b</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    for r_i in range(4):</span><br><span class="line">        yield r_i</span><br><span class="line"></span><br><span class="line">g1 = test()</span><br><span class="line"></span><br><span class="line">n = 2</span><br><span class="line">g2 = (add(n, i) for i in g1)</span><br><span class="line"></span><br><span class="line">n = 10</span><br><span class="line">g3 = (add(n, i) for i in g2)</span><br><span class="line"></span><br><span class="line">print(list(g3)) # n = 10, g3 = (add(n, i) for i in (add(n, i) for i in g1))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>类与类之间的关系</title>
    <url>/2019/03/20/python-%E7%B1%BB%E4%B8%8E%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h2><ul>
<li>在方法中给方法传递一个对象</li>
<li>此种关系，类与类之间的关系是最轻的</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 植物大战僵尸</span><br><span class="line">class Plant(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    植物类</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, name, attack, hp):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化</span><br><span class="line">        :param name:植物名</span><br><span class="line">        :param attack: 攻击力</span><br><span class="line">        :param hp: 血量</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.attack = attack</span><br><span class="line">        self.hp = hp</span><br><span class="line"></span><br><span class="line">    def fight(self, zombie):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        攻击js,使js掉血</span><br><span class="line">        :param js: 攻击对象</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        zombie.hp -= self.attack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Zombie(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    僵尸类</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, name, hp, attack):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化</span><br><span class="line">        :param name: 僵尸名</span><br><span class="line">        :param hp: 血量</span><br><span class="line">        :param attack: 攻击力</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.hp = hp</span><br><span class="line">        self.attack = attack</span><br><span class="line"></span><br><span class="line">    def eat(self, plant):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        僵尸吃plant</span><br><span class="line">        :param plant: 吃的对象</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        plant.hp -= self.attack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lvluo = Plant(&quot;绿萝&quot;, 20, 100)</span><br><span class="line">js1 = Zombie(&quot;僵尸1号&quot;, 100, 5)</span><br><span class="line"></span><br><span class="line">lvluo.fight(js1)</span><br><span class="line">js1.eat(lvluo)</span><br><span class="line"></span><br><span class="line">print(lvluo.hp)  # 95</span><br><span class="line">print(js1.hp)    # 80</span><br></pre></td></tr></table></figure>



<h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><ul>
<li>两种事物必须是互相关联的，但是在某些特殊情况下是可以更改和更换的</li>
<li>一对多：一的一方埋集合，多的一方埋实体</li>
</ul>
<h3 id="一对一关系"><a href="#一对一关系" class="headerlink" title="一对一关系"></a>一对一关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Person类</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, name, id=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化</span><br><span class="line">        :param name: 姓名</span><br><span class="line">        :param id: 身份证号码</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.id = id</span><br><span class="line"></span><br><span class="line">    def display(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        展示有无身份证</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if self.id:</span><br><span class="line">            print(&quot;我叫%s, 我的身份证号码为%s&quot; % (self.name, self.id))</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;我未成年，没有身份证！！！&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Id(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Id类</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, name, num):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化</span><br><span class="line">        :param name: 姓名</span><br><span class="line">        :param num: 身份证号</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p_id = Id(&quot;Tom&quot;, 123456789)</span><br><span class="line">p1 = Person(&quot;Tom&quot;, p_id.num)</span><br><span class="line">p1.display()  # 我叫Tom, 我的身份证号码为123456789</span><br></pre></td></tr></table></figure>



<h3 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Teacher(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Teacher类</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, name, lst=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化</span><br><span class="line">        :param name: 姓名</span><br><span class="line">        :param lst: 学生列表</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        if lst == None:</span><br><span class="line">            self.lst = []</span><br><span class="line">        else:</span><br><span class="line">            self.lst = lst</span><br><span class="line"></span><br><span class="line">    def add(self, student):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        添加学生</span><br><span class="line">        :param student: 学生对象</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.lst.append(student)</span><br><span class="line"></span><br><span class="line">    def display(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        打印学生姓名</span><br><span class="line">        :return: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        for el in self.lst:</span><br><span class="line">            print(el.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Student(object):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    Student类</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, name, num):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化</span><br><span class="line">        :param name: 姓名</span><br><span class="line">        :param num: 学号</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line"># 创建对象</span><br><span class="line">t = Teacher(&quot;Tom&quot;)</span><br><span class="line">s1 = Student(&quot;andy&quot;, 1)</span><br><span class="line">s2 = Student(&quot;Linda&quot;, 2)</span><br><span class="line"></span><br><span class="line"># 把学生添加给老师</span><br><span class="line">t.add(s1)</span><br><span class="line">t.add(s2)</span><br><span class="line"></span><br><span class="line">t.display()</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">andy</span><br><span class="line">Linda</span><br></pre></td></tr></table></figure>



<h2 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h2><ul>
<li>在具体继承关系中，访问方法时，self永远都是指向创建对象时的对象。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def __init__(self, num):</span><br><span class="line">        self.num = num</span><br><span class="line">    </span><br><span class="line">    def func1(self):</span><br><span class="line">        print(self.num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(Base):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">obj = Foo(123)  # 调用__init__方法，自己没有，找父类</span><br><span class="line">obj.func1()  # 123</span><br></pre></td></tr></table></figure>

<p> Next：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def __init__(self, num):</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    def func1(self):</span><br><span class="line">        print(self.num)</span><br><span class="line">        self.func2()</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(&quot;Base.func2&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(Base):</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(&quot;Foo.func2&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Foo(123)</span><br><span class="line">obj.func1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">123</span><br><span class="line">Foo.func</span><br></pre></td></tr></table></figure>

<p> Next：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def __init__(self, num):</span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    def func1(self):</span><br><span class="line">        print(self.num)</span><br><span class="line">        self.func2()</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(111, self.num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(Base):</span><br><span class="line"></span><br><span class="line">    def func2(self):</span><br><span class="line">        print(222, self.num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lst = [Base(1), Base(2), Foo(3)]</span><br><span class="line">for obj in lst:</span><br><span class="line">    obj.func1()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">1</span><br><span class="line">111 1</span><br><span class="line">2</span><br><span class="line">111 2</span><br><span class="line">3</span><br><span class="line">222 3</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>类成员</title>
    <url>/2019/03/20/python-%E7%B1%BB%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="实例变量-字段"><a href="#实例变量-字段" class="headerlink" title="实例变量(字段)"></a>实例变量(字段)</h3><ul>
<li>每个实例都应该拥有的变量</li>
<li>实例变量中隐含着一个创建这个对象的类。通过这个类就能找到类中定义的全部内容，包括方法和属性信息等</li>
<li>访问：对象.变量名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name  # 实例变量</span><br><span class="line">        self.age = age    # 实例变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person(&quot;Tom&quot;, 18)</span><br><span class="line">print(p1.name)  # Tom  访问实例变量</span><br><span class="line"></span><br><span class="line">p1.name = &quot;Andy&quot;  # 修改实例变量的值</span><br><span class="line">print(p1.name)  # Andy</span><br></pre></td></tr></table></figure>



<h3 id="类变量-静态变量"><a href="#类变量-静态变量" class="headerlink" title="类变量(静态变量)"></a>类变量(静态变量)</h3><ul>
<li>直接写在类中的变量，所有对象共享</li>
<li>访问：类名.变量名，对象.变量名(不推荐，且只能访问，不能修改)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    count = 0  # 类变量</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        Foo.count += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Foo.count)    # 0 访问类变量</span><br><span class="line">Foo()</span><br><span class="line">Foo()</span><br><span class="line">Foo()</span><br><span class="line">print(Foo.count)  # 3</span><br></pre></td></tr></table></figure>



<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="成员方法-实例方法）"><a href="#成员方法-实例方法）" class="headerlink" title="成员方法(实例方法）"></a>成员方法(实例方法）</h3><ul>
<li>对象直接访问的方法</li>
<li>访问：对象.方法名()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class User(object):</span><br><span class="line"></span><br><span class="line">    def login(self):  # 实例方法</span><br><span class="line">        print(&quot;欢迎登录&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u = User()</span><br><span class="line">u.login()  # 调用实例方法</span><br></pre></td></tr></table></figure>



<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul>
<li>cls指类本身，不管用对象还是用类去访问类方法，默认传递进去的是类</li>
<li>调用：类名.方法名()，对象.方法名()(不推荐)</li>
</ul>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@classmethod</span><br><span class="line">def 方法名(cls):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def add(cls, a, b):  # 类方法</span><br><span class="line">        print(cls)</span><br><span class="line">        return a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(Foo)</span><br><span class="line">print(Foo.add(1, 2))</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">&lt;class &#x27;__main__.Foo&#x27;&gt;</span><br><span class="line">&lt;class &#x27;__main__.Foo&#x27;&gt;</span><br><span class="line">3</span><br></pre></td></tr></table></figure>



<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li>当出现一个方法不需要使用到实例变量和类变量时，就可以选择使用静态方法</li>
<li>调用：类名.方法名()，对象.方法名()(不推荐)</li>
</ul>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@staticmethod</span><br><span class="line">def 方法名.():</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def welcome():</span><br><span class="line">        print(&quot;---Welcoming---&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foo.welcome()  # ---Welcoming---</span><br></pre></td></tr></table></figure>



<h2 id="私有"><a href="#私有" class="headerlink" title="私有"></a>私有</h2><p>  在Python中使用”__”作为方法或者变量的前缀，那么这个方法或者变量就是一个私有的</p>
<p>  如果类中存在继承关系，子类是无法继承父类的私有内容的</p>
<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3><ul>
<li>私有变量不能直接访问，但可通过在公共方法中访问私有变量的值</li>
<li>实例变量，类变量都可为私有</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, salary):</span><br><span class="line">        self.__salary = salary</span><br><span class="line"></span><br><span class="line">    def sal(self):</span><br><span class="line">        print(self.__salary)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person(50000)</span><br><span class="line">print(p1.__salary)  # 报错</span><br><span class="line">p1.sal()  # 50000</span><br></pre></td></tr></table></figure>



<h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><ul>
<li>私有方法只能在类中自己调用，类外面不能直接访问，可定义公共方法，在公共方法中调用私有方法</li>
<li>实例方法，类方法，静态方法都可变为私有</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, salary):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.__salary = salary</span><br><span class="line"></span><br><span class="line">    def __sal(self):</span><br><span class="line">        print(self.__salary)</span><br><span class="line"></span><br><span class="line">    def display(self):</span><br><span class="line">        self.__sal()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person(&quot;Tom&quot;, 50000)</span><br><span class="line">p1.display()  # 50000</span><br></pre></td></tr></table></figure>



<h2 id="属性-property"><a href="#属性-property" class="headerlink" title="属性(@property)"></a>属性(@property)</h2><ul>
<li>通过方法改造过来的一种变量的写法</li>
</ul>
<p>注意：</p>
<ul>
<li>方法参数只能有一个self</li>
<li>调用时不需要写括号，直接当成属性变量</li>
<li>需要有返回值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, birthday):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthday = birthday</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return 2018 - self.birthday</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(&quot;Tom&quot;, 1994)</span><br><span class="line">print(p.age)  # 24</span><br></pre></td></tr></table></figure>

<p>增加方法，使之可以赋值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__num = 100</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def num(self):</span><br><span class="line">        return self.__num</span><br><span class="line"></span><br><span class="line">    @num.setter</span><br><span class="line">    def num(self, new_num):</span><br><span class="line">        self.__num = new_num</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">print(t.num)  # 100</span><br><span class="line">t.num = 50</span><br><span class="line">print(t.num)  # 50</span><br></pre></td></tr></table></figure>

<p> property另一种表达方式：</p>
<p>  <strong>property(fget&#x3D;None, fset&#x3D;None, fdel&#x3D;None, doc&#x3D;None)</strong></p>
<ul>
<li>fget:获取属性值的函数。</li>
<li>fset:设置属性值的函数。</li>
<li>fdel:删除属性值的函数。</li>
<li>doc:为该属性创建一个docstring。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Test(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.__num = 100</span><br><span class="line"></span><br><span class="line">    def getnum(self):</span><br><span class="line">        return self.__num</span><br><span class="line"></span><br><span class="line">    def setnum(self, new_num):</span><br><span class="line">        self.__num = new_num</span><br><span class="line"></span><br><span class="line">    num = property(getnum, setnum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Test()</span><br><span class="line">print(p1.num)  # 100</span><br><span class="line">p1.num = 50</span><br><span class="line">print(p1.num)  # 50</span><br></pre></td></tr></table></figure>



<h2 id="类特殊成员"><a href="#类特殊成员" class="headerlink" title="类特殊成员"></a>类特殊成员</h2><h3 id="new"><a href="#new" class="headerlink" title="_new_()"></a>_<em>new</em>_()</h3><ul>
<li>构造方法</li>
<li>在创建对象时，系统自动先执行__new__()来开辟内存，此时新开辟出来的内存区域是空的</li>
</ul>
<h3 id="init"><a href="#init" class="headerlink" title="_init_()"></a>_<em>init</em>_()</h3><ul>
<li>初始化</li>
<li>在__new__()调用完后，紧接着系统自动调用__init__()来完成对象的初始化工作</li>
</ul>
<h3 id="str"><a href="#str" class="headerlink" title="_str_()"></a>_<em>str</em>_()</h3><ul>
<li>获取对象的描述信息</li>
<li>触发：<strong>print(对象)</strong></li>
</ul>
<h3 id="repr"><a href="#repr" class="headerlink" title="_repr_()"></a><strong>_<em>repr</em>_()</strong></h3><ul>
<li>调用：<strong>print(repr(对象))</strong></li>
</ul>
<h3 id="call"><a href="#call" class="headerlink" title="_call_()"></a><strong>_<em>call</em>_()</strong></h3><ul>
<li>触发：<strong>对象()</strong></li>
</ul>
<h3 id="del"><a href="#del" class="headerlink" title="_del_()"></a><strong>_<em>del</em>_()</strong></h3><ul>
<li>在删除对象或者程序结束，对象内存空间删除时，系统都会自动调用一次del方法</li>
</ul>
<h3 id="getitem"><a href="#getitem" class="headerlink" title="_getitem_()"></a>_<em>getitem</em>_()</h3><ul>
<li>触发：<strong>对象[key]</strong></li>
</ul>
<h3 id="setitem"><a href="#setitem" class="headerlink" title="_setitem_()"></a>_<em>setitem</em>_()</h3><ul>
<li>触发：<strong>对象[key] &#x3D; value</strong></li>
</ul>
<h3 id="delitem"><a href="#delitem" class="headerlink" title="_delitem_()"></a><strong>_<em>delitem</em>_()</strong></h3><ul>
<li>触发：<strong>del 对象[key]</strong></li>
</ul>
<h3 id="add"><a href="#add" class="headerlink" title="_add_()"></a><strong>_<em>add</em>_()</strong></h3><ul>
<li>触发：<strong>对象 + 对象</strong></li>
</ul>
<h3 id="enter"><a href="#enter" class="headerlink" title="_enter_()"></a><strong>_<em>enter</em>_()</strong></h3><ul>
<li>触发：<strong>with 对象 as 变量：</strong></li>
</ul>
<h3 id="exit"><a href="#exit" class="headerlink" title="_exit_()"></a><strong>_<em>exit</em>_()</strong></h3><ul>
<li>触发：**with 对象 as 变量：**退出时</li>
</ul>
<h3 id="iter"><a href="#iter" class="headerlink" title="_iter_()"></a>_<em>iter</em>_()</h3><ul>
<li>触发：当遍历对象时</li>
</ul>
<h3 id="hash"><a href="#hash" class="headerlink" title="_hash_()"></a>_<em>hash</em>_()</h3><ul>
<li>调用：<strong>print(hash(对象))</strong></li>
</ul>
<h3 id="gt"><a href="#gt" class="headerlink" title="_gt_()"></a><strong>_<em>gt</em>_()</strong></h3><ul>
<li>触发：<strong>对象1 &gt; 对象2</strong></li>
</ul>
<h3 id="lt"><a href="#lt" class="headerlink" title="_lt_()"></a><strong>_<em>lt</em>_()</strong></h3><ul>
<li>触发：<strong>对象1 &lt; 对象2</strong></li>
</ul>
<h3 id="ge"><a href="#ge" class="headerlink" title="_ge_()"></a><strong>_<em>ge</em>_()</strong></h3><ul>
<li>触发：<strong>对象1 &gt;&#x3D; 对象2</strong></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>类的约束</title>
    <url>/2019/03/20/python-%E7%B1%BB%E7%9A%84%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="提取父类"><a href="#提取父类" class="headerlink" title="提取父类"></a>提取父类</h2><ul>
<li>在父类中定义好方法，在这个方法中什么都不用干。就抛出一个异常就可以了。这样所有的子类都必须重写这个方法。否则，访问时就会报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;子类没有实现该方法&quot;</span>)   <span class="comment"># NotImplementedError 没有实现的错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Normal</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">denglu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Admin</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目经理总入口</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;准备验证码...&quot;</span>)</span><br><span class="line">    obj.login()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;进入主页...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = Normal()</span><br><span class="line">m = Member()</span><br><span class="line">a = Admin()</span><br><span class="line"></span><br><span class="line">login(n)</span><br><span class="line">login(m)  <span class="comment"># 报错</span></span><br><span class="line">login(a)</span><br></pre></td></tr></table></figure>



<h2 id="使用抽象类（不推荐）"><a href="#使用抽象类（不推荐）" class="headerlink" title="使用抽象类（不推荐）"></a>使用抽象类（不推荐）</h2><ul>
<li>使用抽象类描述父类，在抽象类中给出一个抽象方法。这样子类就不得不给出抽象方法的具体实现，否则报错，也可以起到约束的效果</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul>
<li>python不能直接实现抽象类，需借助abc模块实现，ABCMeta是实现抽象基础类的元类，由它生成抽象类，只能被继承，不能实例化。</li>
<li>抽象类不能创建对象</li>
<li>抽象类中可以有正常的方法</li>
<li>子类必须重写父类中的抽象方法，否则子类也是一个抽象类</li>
<li>接口：类中全部方法都是抽象方法</li>
<li>如果一个类中包含了抽象方法。那么这个类一定是一个抽象类</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(metaclass=ABCMeta):</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Normal</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">denglu</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Admin</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n = Normal()</span><br><span class="line">n.login()</span><br><span class="line"></span><br><span class="line">m = Member()  <span class="comment"># 报错 Can&#x27;t instantiate abstract class Member with abstract methods login  </span></span><br><span class="line">m.login()</span><br><span class="line"></span><br><span class="line">a = Admin()</span><br><span class="line">a.login()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>继承</title>
    <url>/2019/03/20/python-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="判断继承"><a href="#判断继承" class="headerlink" title="判断继承"></a>判断继承</h2><h3 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass"></a>issubclass</h3><ul>
<li>判断xxx类是否是yyy类型的子类</li>
<li>可以隔代判数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span>(<span class="title class_ inherited__">Foo</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Bar, Foo))   <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Foo, Bar))   <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">issubclass</span>(Bar, Base))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>



<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><ul>
<li>python支持多继承，一个类可以拥有多个父类</li>
<li>经典类：在python2.2之前版本使用的是经典类，经典类在基类的根如果什么都不写，表示继承xxx</li>
<li>新式类：在python2.2之后版本使用的是新式类，新式类的特点是基类的根是object</li>
<li>python3使用的都是新式类，如果基类谁都不继承。那这个类会默认继承object</li>
</ul>
<h2 id="MRO"><a href="#MRO" class="headerlink" title="MRO"></a>MRO</h2><p>  在多继承中，当多个父类出现了重名方法时，此时就涉及到如何查找父类方法的问题，即MRO(method resolution order)问题。</p>
<p>  在python中，不同的版本中使用的是不同的算法来完成MRO的</p>
<h3 id="经典类的MRO"><a href="#经典类的MRO" class="headerlink" title="经典类的MRO"></a>经典类的MRO</h3><ul>
<li>采用的是树型结构的深度优先遍历（先序）,即根-左-右。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">A</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span>(B, C):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>(E, B):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">G</span>(F, D):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">H</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(H, G):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p> 继承关系图如下：</p>
<p> <img src="/python-%E7%BB%A7%E6%89%BF.assets/1427763-20181113194621417-491962360.png" alt="1427763-20181113194621417-491962360"></p>
<p>​                                                                                                                                     图1 继承关系图</p>
<p><strong>类的MRO：Foo —&gt; H —&gt; G —&gt; F —&gt; E —&gt; B —&gt; A —&gt;D —&gt; C</strong></p>
<h3 id="新式类的MRO—C3算法"><a href="#新式类的MRO—C3算法" class="headerlink" title="新式类的MRO—C3算法"></a>新式类的MRO—C3算法</h3><p>官方网址：<a href="https://www.python.org/download/releases/2.3/mro/?tdsourcetag=s_pctim_aiomsg">https://www.python.org/download/releases/2.3/mro/?tdsourcetag=s_pctim_aiomsg</a></p>
<p>步骤：</p>
<ul>
<li>先拆分</li>
<li>再合并：从下向上合并，拿出每一项的头和后一项的身体进行比较，如果出现了，就过，从后一项的头继续去比较，如果不出现就拿出来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    pass</span><br><span class="line">class B(A):</span><br><span class="line">    pass</span><br><span class="line">class C(A):</span><br><span class="line">    pass</span><br><span class="line">class D(B, C):</span><br><span class="line">    pass</span><br><span class="line">class E(C, A):</span><br><span class="line">    pass</span><br><span class="line">class F(D, E):</span><br><span class="line">    pass</span><br><span class="line">class M(F, E):</span><br><span class="line">    pass</span><br><span class="line">class N:</span><br><span class="line">    pass</span><br><span class="line">class P(M,N):</span><br><span class="line">    pass</span><br><span class="line">class G(P):</span><br><span class="line">    pass</span><br><span class="line">class O:</span><br><span class="line">    pass</span><br><span class="line">class X(O):</span><br><span class="line">    pass</span><br><span class="line">class H(G, X, F):</span><br><span class="line">    pass</span><br><span class="line">print(H.__mro__)结果：(&lt;class &#x27;__main__.H&#x27;&gt;, &lt;class &#x27;__main__.G&#x27;&gt;, &lt;class &#x27;__main__.P&#x27;&gt;, &lt;class &#x27;__main__.M&#x27;&gt;, &lt;class &#x27;__main__.X&#x27;&gt;, &lt;class &#x27;__main__.F&#x27;&gt;, &lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.E&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.N&#x27;&gt;, &lt;class &#x27;__main__.O&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br></pre></td></tr></table></figure>

<p><strong>1) 先拆分：设L为查找方法的MRO顺序</strong></p>
<p>L(H) &#x3D; H + L(G) + L(X) + L(F) + GXF</p>
<p>L(G) &#x3D; G + L(P) + P</p>
<p>L(X) &#x3D; X + L(O) + O</p>
<p>L(F) &#x3D; F + L(D) + L(E) + DE</p>
<p>L(P) &#x3D; P + L(M) + L(N) + MN</p>
<p>L(D) &#x3D; D + L(B) + L(C) + BC</p>
<p>L(E) &#x3D; E + L(C) + A + CA</p>
<p>L(M) &#x3D; M + L(F) + L(E) + FE</p>
<p><strong>2) 合并：</strong></p>
<p>L(H) &#x3D; H + L(G) + L(X) + L(F) + GXF   &#x3D;&#x3D;&#x3D;&#x3D;&gt;HGPMXFDBECANO</p>
<p>L(G) &#x3D; G + L(P) + P                 &#x3D;&#x3D;&#x3D;&#x3D;&gt;GPMFDBECAN</p>
<p>L(X) &#x3D; X + L(O) + O                 &#x3D;&#x3D;&#x3D;&#x3D;&gt;XO</p>
<p>L(F) &#x3D; F + L(D) + L(E) + DE          &#x3D;&#x3D;&#x3D;&#x3D;&gt;FDBECA</p>
<p>L(P) &#x3D; P + L(M) + L(N) + MN         &#x3D;&#x3D;&#x3D;&#x3D;&gt;PMFDBECAN</p>
<p>L(D) &#x3D; D + L(B) + L(C) + BC          &#x3D;&#x3D;&#x3D;&#x3D;&gt;DBCA</p>
<p>L(E) &#x3D; E + L(C) + A + CA            &#x3D;&#x3D;&#x3D;&#x3D;&gt;ECA</p>
<p>L(M) &#x3D; M + L(F) + L(E) + FE          &#x3D;&#x3D;&#x3D;&#x3D;&gt;MFDBECA</p>
<p>L(C) &#x3D; C + L(A)                   &#x3D;&#x3D;&#x3D;&#x3D;&gt;CA</p>
<p>L(N) &#x3D; N                        &#x3D;&#x3D;&#x3D;&#x3D;&gt;N</p>
<p>L(B) &#x3D; B + L(A) + A                &#x3D;&#x3D;&#x3D;&#x3D;&gt;BA</p>
<p><strong>类的MRO：H—&gt;G—&gt;P—&gt;M—&gt;X—&gt;F—&gt;D—&gt;B—&gt;E—&gt;C—&gt;A—&gt;N—&gt;O</strong></p>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><h3 id="访问父类的初始化方法"><a href="#访问父类的初始化方法" class="headerlink" title="访问父类的初始化方法"></a>访问父类的初始化方法</h3><p>  这样子类和父类初始化方法中相同的代码可不必都写，直接用父类的就好</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c</span>):</span><br><span class="line">        <span class="variable language_">self</span>.a = a</span><br><span class="line">        <span class="variable language_">self</span>.b = b</span><br><span class="line">        <span class="variable language_">self</span>.c = c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">Base</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, b, c, d</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(a, b, c)</span><br><span class="line">        <span class="variable language_">self</span>.d = d</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = Foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">vars</span>(f))    <span class="comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="实现子类方法调用父类-MRO-中的方法"><a href="#实现子类方法调用父类-MRO-中的方法" class="headerlink" title="实现子类方法调用父类(MRO)中的方法"></a>实现子类方法调用父类(MRO)中的方法</h3><ul>
<li>**super().方法名()：**执行MRO中下一个方法</li>
<li>**super(类名，self).方法名()：**定位到该类，执行MRO中该类下一个类的方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Biology</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----biology-----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">Biology</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----Animal-----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().move()   <span class="comment"># 找MRO中的下一个</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----Cat-----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = Cat()</span><br><span class="line">c.move()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># -----Animal-----</span></span><br><span class="line"><span class="comment"># -----Cat-----</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Biology</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;----biology-----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">Biology</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----Animal-----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Animal, <span class="variable language_">self</span>).move()   <span class="comment"># 定位到Animal，找Animal下一个</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;-----Cat-----&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c = Cat()</span><br><span class="line">c.move()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="comment"># ----biology-----</span></span><br><span class="line"><span class="comment"># -----Cat-----</span></span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;init&quot;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.val = v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Add2</span>(<span class="title class_ inherited__">Init</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Add2&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>(Add2, <span class="variable language_">self</span>).__init__(val)</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.val)</span><br><span class="line">        <span class="variable language_">self</span>.val += <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mult</span>(<span class="title class_ inherited__">Init</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Mult&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>(Mult, <span class="variable language_">self</span>).__init__(val)</span><br><span class="line">        <span class="variable language_">self</span>.val *= <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HaHa</span>(<span class="title class_ inherited__">Init</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;哈哈&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>(HaHa, <span class="variable language_">self</span>).__init__(val)</span><br><span class="line">        <span class="variable language_">self</span>.val /= <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pro</span>(Add2,Mult,HaHa): <span class="comment">#</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Incr</span>(<span class="title class_ inherited__">Pro</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="built_in">super</span>(Incr, <span class="variable language_">self</span>).__init__(val)</span><br><span class="line">        <span class="variable language_">self</span>.val += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Incr(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(p.val)   <span class="comment"># Add2 Mult 哈哈 init 5.0 8.0c = Add2(2) print(c.val)  # Add2 init 2 4</span></span><br></pre></td></tr></table></figure>

<p><strong>MRO：</strong></p>
<p><strong>Incr</strong>： Incr —&gt; Pro —&gt; Add2 —&gt; Mult —&gt; HaHa —&gt; Init</p>
<p><strong>Add2</strong>： Add2 —&gt; Init</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>编码</title>
    <url>/2019/03/15/python-%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="编码种类"><a href="#编码种类" class="headerlink" title="编码种类"></a>编码种类</h2><h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><ul>
<li>基于拉丁字母的一套电脑编码系统</li>
<li>其最多只能用8位来表示(一字节)</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Bin(二进制)</strong></th>
<th><strong>Dec(十进制)</strong></th>
<th><strong>缩写&#x2F;字符</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>01000001</td>
<td>65</td>
<td>A</td>
<td>大写字母A</td>
</tr>
<tr>
<td>01100001</td>
<td>97</td>
<td>a</td>
<td>小写字母a</td>
</tr>
</tbody></table>
<h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><ul>
<li>国标码(GB2312)的扩展码</li>
<li>一个字符占用16bit，两字节</li>
<li>最多可容纳2**16 &#x3D; 65536字符</li>
<li>程序无法跨平台使用</li>
</ul>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><ul>
<li>万国码，目的把全世界所有国家的文字信息进行编码</li>
<li>一个字符占用32位，四字节</li>
</ul>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><ul>
<li>可变长度的编码</li>
<li>每个字符占用的字节数不定，根据文字内容进行编码。</li>
</ul>
<p>不同字符占用字节数：</p>
<ul>
<li>英文：1字节</li>
<li>欧洲文字：2字节</li>
<li>中文：3字节</li>
</ul>
<h2 id="单位转换"><a href="#单位转换" class="headerlink" title="单位转换"></a>单位转换</h2><ul>
<li>8bit &#x3D; 1 byte</li>
<li>1024byte &#x3D; 1KB</li>
<li>1024KB &#x3D; 1MB</li>
<li>1024MB &#x3D; 1GB</li>
<li>1024GB &#x3D; 1TB</li>
<li>1024TB &#x3D; 1PB</li>
<li>1024PB &#x3D; 1EB</li>
<li>1024EB &#x3D; 1ZB</li>
<li>1024ZB &#x3D; 1YB</li>
<li>1024YB &#x3D; 1NB</li>
<li>1024NB &#x3D; 1DB</li>
</ul>
<h2 id="编码和解码"><a href="#编码和解码" class="headerlink" title="编码和解码"></a>编码和解码</h2><ul>
<li>python2中默认使用的是ASCII码。所以不支持中文。如果需要在Python2中更改编码。需要在文件的开始编写：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># _*_ encoding:utf-8 _*_</span><br></pre></td></tr></table></figure>

<ul>
<li><p>python3中，内存中使用的是unicode码。</p>
<p>在python3内存中，在程序运行阶段，使用的是unicode编码。因为unicode是万国码。什么内容都可以进行显示。那么在数据传输和存储时由于unicode比较浪费空间和资源。需要把unicode转存成UTF-8或GBK进行存储。</p>
<p>编码之后的数据是<strong>bytes</strong>类型的数据。</p>
</li>
</ul>
<h3 id="bytes的表现形式："><a href="#bytes的表现形式：" class="headerlink" title="bytes的表现形式："></a>bytes的表现形式：</h3><ul>
<li>英文：英文的表现形式和字符串相差不大，前面多个”b”</li>
<li>中文：中文编码之后的结果根据编码的不同，编码结果也不同，一个中文的UTF-8编码是3个字节，一个GBK的中文编码是2个字节。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &quot;hello&quot;</span><br><span class="line">b = &quot;中&quot;</span><br><span class="line"></span><br><span class="line">print(a.encode(&quot;utf-8&quot;))  # b&#x27;hello&#x27;</span><br><span class="line">print(b.encode(&quot;utf-8&quot;))  # b&#x27;\xe4\xb8\xad&#x27;</span><br><span class="line">print(b.encode(&quot;gbk&quot;))    # b&#x27;\xd6\xd0&#x27;</span><br></pre></td></tr></table></figure>



<h3 id="编码和解码-1"><a href="#编码和解码-1" class="headerlink" title="编码和解码"></a>编码和解码</h3><ul>
<li><p>**encode()：**编码</p>
</li>
<li><p>**decode()：**解码</p>
<p>以何种编码编码，就须以该种编码解码。否则，解码不成功，得不到想要的内容。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = &quot;编码&quot;</span><br><span class="line">print(a.encode(&quot;utf-8&quot;)) # b&#x27;\xe7\xbc\x96\xe7\xa0\x81&#x27;</span><br><span class="line"></span><br><span class="line">b = b&#x27;\xe7\xbc\x96\xe7\xa0\x81&#x27;</span><br><span class="line">print(b.decode(&quot;utf-8&quot;))  # 编码</span><br></pre></td></tr></table></figure>

<p>  不同编码之间的转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GBK 转换成 UTF-8</span><br><span class="line">s = &quot;我是文字&quot;</span><br><span class="line">bs = s.encode(&quot;gbk&quot;)</span><br><span class="line"></span><br><span class="line"># 把GBK转换成unicode，也就是解码</span><br><span class="line">s = bs.decode(&quot;gbk&quot;)</span><br><span class="line"></span><br><span class="line"># 重新编码成UTF-8</span><br><span class="line">bss = s.encode(&quot;utf-8&quot;)</span><br><span class="line"></span><br><span class="line">print(bss)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器</title>
    <url>/2019/03/16/python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>  装饰器本质上就是一个python函数，可以让其他函数在不需要做任何代码变动的前提下，增加额外的功能。装饰器的返回值也是一个函数对象。</p>
<h2 id="装饰器种类"><a href="#装饰器种类" class="headerlink" title="装饰器种类"></a>装饰器种类</h2><h3 id="不带参数的装饰器"><a href="#不带参数的装饰器" class="headerlink" title="不带参数的装饰器"></a>不带参数的装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        start = time.time()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(time.time() - start)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer          </span><span class="comment"># ===&gt; func1 = timer(func1）</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func1()</span><br></pre></td></tr></table></figure>



<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(time.time() - start)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer        </span><span class="comment"># ===&gt; func1 = timer(func1)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func1(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="带返回值的装饰器"><a href="#带返回值的装饰器" class="headerlink" title="带返回值的装饰器"></a>带返回值的装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(time.time() - start)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer        </span><span class="comment"># ===&gt; func1 = timer(func1)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func1&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer        </span><span class="comment"># ===&gt; func2 = timer(func2)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in func2 and get a:%s&quot;</span> % (a))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;func2 over&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func1(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(func2(<span class="string">&quot;aaaa&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>  当查看函数信息的方法时，在此处失效：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(time.time() - start)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个主页信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from index&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(index.__doc__)</span><br><span class="line"><span class="built_in">print</span>(index.__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="literal">None</span></span><br><span class="line">inner</span><br></pre></td></tr></table></figure>

<p>  解决方案：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start = time.time()</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="built_in">print</span>(time.time() - start)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个主页信息&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from index&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(index.__doc__)</span><br><span class="line"><span class="built_in">print</span>(index.__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">这是一个主页信息</span><br><span class="line">index</span><br></pre></td></tr></table></figure>



<h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><p>  装饰器完美的遵循了 开放封闭原则</p>
<h3 id="对扩展开放"><a href="#对扩展开放" class="headerlink" title="对扩展开放"></a>对扩展开放</h3><p>  任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以必须允许代码扩展、添加新功能。</p>
<h3 id="对修改封闭"><a href="#对修改封闭" class="headerlink" title="对修改封闭"></a>对修改封闭</h3><p>  我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候对其进行修改，很有可能影响其他已经在使用该函数的用户。</p>
<h2 id="装饰器的固定结构"><a href="#装饰器的固定结构" class="headerlink" title="装饰器的固定结构"></a>装饰器的固定结构</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;执行函数之前要做的&quot;&quot;&quot;</span></span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;执行函数之后要做的&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;执行函数之前要做的&quot;&quot;&quot;</span></span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;执行函数之后要做的&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>



<h2 id="装饰器带参数"><a href="#装饰器带参数" class="headerlink" title="装饰器带参数"></a>装饰器带参数</h2><p>  应用场景：如果有成千上万个函数使用了一个装饰器，现在想把这些装饰器取消掉</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>(<span class="params">flag</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">timer</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;执行函数之前要做的&quot;</span>)</span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;执行函数之后要做的&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> timer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer(<span class="params"><span class="literal">False</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>



<h2 id="多个装饰器装饰一个函数"><a href="#多个装饰器装饰一个函数" class="headerlink" title="多个装饰器装饰一个函数"></a>多个装饰器装饰一个函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper1</span>(<span class="params">func</span>):   <span class="comment"># func = f</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner1</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;wrapper1, before func&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;wrapper1, after func&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrapper2</span>(<span class="params">func</span>):  <span class="comment"># func = inner1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner2</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;wrapper2, before func&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;wrapper2, after func&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrapper2    </span><span class="comment"># f = wrapper2(f) ===&gt; f = inner2</span></span><br><span class="line"><span class="meta">@wrapper1    </span><span class="comment"># 先装饰wrapper1 ---&gt; f = wrapper1(f) ===&gt; f = inner1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in f&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f()   <span class="comment"># ===&gt; inner2()</span></span><br></pre></td></tr></table></figure>

<p>  规律：</p>
<p>  对于n个装饰器装饰同一个函数，例如靠近函数名f的为@outer_1，最上层为@outer_n，那么执行f()时，执行顺序为：</p>
<ul>
<li>第n个装饰器执行f()前要做的 —&gt; 第n-1个装饰器执行f()前要做的 —&gt; …—&gt;第1个装饰器执行f()前要做的 —&gt;</li>
<li>f() —&gt;</li>
<li>第1个装饰器执行f()要做的 —&gt; 第二个装饰器执行f()后要做的 —&gt;…—&gt;第n个装饰器执行f()后要做的</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器</title>
    <url>/2019/03/16/python-%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li>Iterable：可迭代对象，内部包含__iter__()函数</li>
<li>Iterator：迭代器，内部包含__iter__()和__next__()函数</li>
</ul>
<p>特点：</p>
<ul>
<li>节省内存</li>
<li>惰性机制</li>
<li>不能反复，只能向下执行</li>
</ul>
<h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><h4 id="判断一个对象是否为可迭代对象"><a href="#判断一个对象是否为可迭代对象" class="headerlink" title="判断一个对象是否为可迭代对象"></a>判断一个对象是否为可迭代对象</h4><ul>
<li>通过dir函数来查看类中定义的方法中是否有__iter__方法</li>
</ul>
<p>如果__iter__能找到，那么这个类的对象就是一个可迭代对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">str</span>))<span class="built_in">print</span>(<span class="built_in">dir</span>(<span class="built_in">list</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__getnewargs__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mod__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__rmod__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;capitalize&#x27;</span>, <span class="string">&#x27;casefold&#x27;</span>, <span class="string">&#x27;center&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;encode&#x27;</span>, <span class="string">&#x27;endswith&#x27;</span>, <span class="string">&#x27;expandtabs&#x27;</span>, <span class="string">&#x27;find&#x27;</span>, <span class="string">&#x27;format&#x27;</span>, <span class="string">&#x27;format_map&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;isalnum&#x27;</span>, <span class="string">&#x27;isalpha&#x27;</span>, <span class="string">&#x27;isdecimal&#x27;</span>, <span class="string">&#x27;isdigit&#x27;</span>, <span class="string">&#x27;isidentifier&#x27;</span>, <span class="string">&#x27;islower&#x27;</span>, <span class="string">&#x27;isnumeric&#x27;</span>, <span class="string">&#x27;isprintable&#x27;</span>, <span class="string">&#x27;isspace&#x27;</span>, <span class="string">&#x27;istitle&#x27;</span>, <span class="string">&#x27;isupper&#x27;</span>, <span class="string">&#x27;join&#x27;</span>, <span class="string">&#x27;ljust&#x27;</span>, <span class="string">&#x27;lower&#x27;</span>, <span class="string">&#x27;lstrip&#x27;</span>, <span class="string">&#x27;maketrans&#x27;</span>, <span class="string">&#x27;partition&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>, <span class="string">&#x27;rfind&#x27;</span>, <span class="string">&#x27;rindex&#x27;</span>, <span class="string">&#x27;rjust&#x27;</span>, <span class="string">&#x27;rpartition&#x27;</span>, <span class="string">&#x27;rsplit&#x27;</span>, <span class="string">&#x27;rstrip&#x27;</span>, <span class="string">&#x27;split&#x27;</span>, <span class="string">&#x27;splitlines&#x27;</span>, <span class="string">&#x27;startswith&#x27;</span>, <span class="string">&#x27;strip&#x27;</span>, <span class="string">&#x27;swapcase&#x27;</span>, <span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;translate&#x27;</span>, <span class="string">&#x27;upper&#x27;</span>, <span class="string">&#x27;zfill&#x27;</span>][<span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__delitem__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__iadd__&#x27;</span>, <span class="string">&#x27;__imul__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__reversed__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__setitem__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;append&#x27;</span>, <span class="string">&#x27;clear&#x27;</span>, <span class="string">&#x27;copy&#x27;</span>, <span class="string">&#x27;count&#x27;</span>, <span class="string">&#x27;extend&#x27;</span>, <span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;remove&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>通过isinstance()函数</li>
</ul>
<p>如果返回值为True,则该对象为可迭代对象，否则不是。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line"></span><br><span class="line">lst = [11, 22, 33]</span><br><span class="line"></span><br><span class="line">print(isinstance(lst, Iterable))  # True</span><br></pre></td></tr></table></figure>



<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><ul>
<li>迭代器本身是可迭代的，所以类中有__iter__方法。</li>
</ul>
<h4 id="判断一个对象是否为迭代器"><a href="#判断一个对象是否为迭代器" class="headerlink" title="判断一个对象是否为迭代器"></a>判断一个对象是否为迭代器</h4><ul>
<li>通过dir函数来查看类中定义的方法中是否有__next__方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33]</span><br><span class="line">ret = lst.__iter__()</span><br><span class="line"></span><br><span class="line">print(&quot;__next__&quot; in dir(ret))  # True</span><br></pre></td></tr></table></figure>

<ul>
<li>通过isinstance()函数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from collections import Iterator</span><br><span class="line"></span><br><span class="line">lst = [11, 22, 33]</span><br><span class="line">ret = lst.__iter__()</span><br><span class="line"></span><br><span class="line">print(isinstance(ret, Iterator))  # True</span><br></pre></td></tr></table></figure>



<h4 id="迭代器取值"><a href="#迭代器取值" class="headerlink" title="迭代器取值"></a>迭代器取值</h4><p>  通过__next__获取迭代器数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33]</span><br><span class="line">ret = lst.__iter__()</span><br><span class="line"></span><br><span class="line">print(ret.__next__())</span><br><span class="line">print(ret.__next__())</span><br><span class="line">print(ret.__next__())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<p>  如果获取元素个数超过迭代器元素的长度，则报错StopIteration</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33]</span><br><span class="line">ret = lst.__iter__()</span><br><span class="line"></span><br><span class="line">print(ret.__next__())</span><br><span class="line">print(ret.__next__())</span><br><span class="line">print(ret.__next__())</span><br><span class="line">print(ret.__next__())  # StopIteration</span><br></pre></td></tr></table></figure>



<h4 id="for循环内部代码"><a href="#for循环内部代码" class="headerlink" title="for循环内部代码"></a>for循环内部代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ret = lst.__iter__()</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    try:</span><br><span class="line">        el = ret.__next__()</span><br><span class="line">        print(el)</span><br><span class="line">    except StopIteration:</span><br><span class="line">        break</span><br></pre></td></tr></table></figure>



<h3 id="可迭代对象-—–-迭代器"><a href="#可迭代对象-—–-迭代器" class="headerlink" title="可迭代对象 —–&gt; 迭代器"></a>可迭代对象 —–&gt; 迭代器</h3><ul>
<li>可迭代对象不一定是迭代器，但可通过__iter__方法转换成迭代器</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lst = [11, 22, 33]</span><br><span class="line">ret = lst.__iter__()</span><br><span class="line"></span><br><span class="line">print(&quot;__next__&quot; in dir(ret))  # True</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>递归函数</title>
    <url>/2019/03/16/python-%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>在函数中调用函数本身，就是递归</li>
<li>在python中递归的深度最大为1000，但实际达不到1000</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func():</span><br><span class="line">    print(&quot;-----func-----&quot;)</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li>可以使用递归来遍历各种树形结构，比如文件夹系统：可以使用递归来遍历该文件夹中的所有文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def func(filepath, n):</span><br><span class="line">    files_list = os.listdir(filepath)  # 获取当前文件夹中的所有文件</span><br><span class="line">    for file in files_list:</span><br><span class="line">        file_d = os.path.join(filepath, file)  # 拼接文件的真实路径</span><br><span class="line">        if os.path.isdir(file_d):  # 递归入口  判断文件是否为文件夹</span><br><span class="line">            print(&quot;\t&quot;*n, file)</span><br><span class="line">            func(file_d, n+1)  #</span><br><span class="line">        else:</span><br><span class="line">            print(&quot;\t&quot;*n, file)  # 递归出口</span><br></pre></td></tr></table></figure>



<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul>
<li>优点：每次能够除掉一半的数据，查找效率高</li>
<li>要求：查找的序列必须是有序序列</li>
</ul>
<h3 id="非递归算法"><a href="#非递归算法" class="headerlink" title="非递归算法"></a>非递归算法</h3><h4 id="利用索引"><a href="#利用索引" class="headerlink" title="利用索引"></a>利用索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 让用户输入一个数n. 判断这个n是否出现在lst中</span></span><br><span class="line">lst = [<span class="number">4</span>, <span class="number">56</span>, <span class="number">178</span>, <span class="number">253</span>, <span class="number">625</span>, <span class="number">1475</span>, <span class="number">2580</span>, <span class="number">3574</span>, <span class="number">15963</span>]</span><br><span class="line"></span><br><span class="line">left = <span class="number">0</span></span><br><span class="line">right = <span class="built_in">len</span>(lst) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数n：&quot;</span>))</span><br><span class="line"><span class="keyword">while</span> left &lt;= right:</span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> lst[mid] &gt; num:</span><br><span class="line">        right = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> lst[mid] &lt; num:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这个数在lst中&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这个数不在lst中&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><h4 id="利用索引-1"><a href="#利用索引-1" class="headerlink" title="利用索引"></a>利用索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 让用户输入一个数n. 判断这个n是否出现在lst中</span></span><br><span class="line">lst = [<span class="number">4</span>, <span class="number">56</span>, <span class="number">178</span>, <span class="number">253</span>, <span class="number">625</span>, <span class="number">1475</span>, <span class="number">2580</span>, <span class="number">3574</span>, <span class="number">15963</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">lst, num, left, right</span>):</span><br><span class="line">    <span class="keyword">if</span> left &gt; right:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    mid = (left + right) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> lst[mid] &gt; num:</span><br><span class="line">        right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> binary_search(lst, num, left, right)</span><br><span class="line">    <span class="keyword">elif</span> lst[mid] &lt; num:</span><br><span class="line">        left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> binary_search(lst, num, left, right)</span><br><span class="line">    <span class="keyword">else</span>:<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数n：&quot;</span>))</span><br><span class="line">ret = binary_search(lst, num, <span class="number">0</span>, <span class="built_in">len</span>(lst)-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure>



<h4 id="切换列表"><a href="#切换列表" class="headerlink" title="切换列表"></a>切换列表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 让用户输入一个数n. 判断这个n是否出现在lst中</span></span><br><span class="line">lst = [<span class="number">4</span>, <span class="number">56</span>, <span class="number">178</span>, <span class="number">253</span>, <span class="number">625</span>, <span class="number">1475</span>, <span class="number">2580</span>, <span class="number">3574</span>, <span class="number">15963</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">binary_search</span>(<span class="params">lst, num</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(lst) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    mid = (<span class="built_in">len</span>(lst) - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; lst[mid]:</span><br><span class="line">        <span class="keyword">return</span> binary_search(lst[mid+<span class="number">1</span>:], num)</span><br><span class="line">    <span class="keyword">elif</span> num &lt; lst[mid]:</span><br><span class="line">        <span class="keyword">return</span> binary_search(lst[:mid], num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;这个数在lst中&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个数n：&quot;</span>))</span><br><span class="line"></span><br><span class="line">ret = binary_search(lst, num)</span><br><span class="line"><span class="built_in">print</span>(ret)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/2019/03/15/python%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="python简介"><a href="#python简介" class="headerlink" title="python简介"></a>python简介</h2><p> python是一门动态、解释型、强类型高级开发编程语言</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p> 把程序运行过程中产生的值存储起来，方便后面程序调用</p>
<h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><ul>
<li>由数字，字母，下划线组成</li>
<li>不能数字开头，更不能是纯数字</li>
<li>不能是python的关键字</li>
<li>不要太长</li>
<li>要有意义</li>
<li>区分大小写</li>
<li>不要用中文</li>
</ul>
<p>推荐：1）驼峰体：每个单词的首字母大写</p>
<p>​      2）下划线：单词用下划线连接</p>
<h2 id="基本数据类型-int-bool"><a href="#基本数据类型-int-bool" class="headerlink" title="基本数据类型(int, bool)"></a>基本数据类型(int, bool)</h2><h3 id="int"><a href="#int" class="headerlink" title="int"></a>int</h3><ul>
<li>操作：+，-，*，&#x2F;，%，&#x2F;&#x2F;</li>
<li>**xxx.bit_length()：**返回xxx的二进制长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(a.bit_length()) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<h3 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h3><ul>
<li>True</li>
<li>False</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>bool —&gt; int</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bs = <span class="literal">False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(bs)) <span class="comment"># &lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line">x = <span class="built_in">int</span>(bs)</span><br><span class="line"><span class="built_in">print</span>(x) <span class="comment"># 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(x)) <span class="comment"># &lt;class &#x27;int&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>int —&gt; bool</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(-<span class="number">1</span>)) <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bool</span>(<span class="number">0</span>))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<p>a) 把x转换成y类型：y(x)</p>
<p>b) 空的东西都是False， 非空的东西是True</p>
<p>c) False：0，’’，[]， {}，set()，tuple()，None(真空)</p>
<h2 id="用户交互"><a href="#用户交互" class="headerlink" title="用户交互"></a>用户交互</h2><ul>
<li>变量 &#x3D; input(“提示语”)</li>
<li>input默认得到str类型数据</li>
</ul>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><ul>
<li>%s：字符串占位符，任何数据类型都适用</li>
<li>%d：数字占位符，映变量类型必须为int，否则程序报错</li>
<li>在字符串如果使用了%s这样的占位符，那么所有的%都将变成占位符，此时需要使用%%来表示字符串的%</li>
<li>如果字符串没有使用%s，%d占位，则无需使用%%来表示字符串的%</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我叫%s, 今年%s岁&quot;</span> % (<span class="string">&quot;赛利亚&quot;</span>, <span class="number">56</span>))  <span class="comment"># 我叫赛利亚, 今年56岁</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我叫%s, 我已经拥有了全国0.01%%的财产了&quot;</span> % (<span class="string">&quot;赛利亚&quot;</span>)) <span class="comment"># 我叫赛利亚, 我已经拥有了全国0.01%的财产了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我叫赛利亚， 我已经学习了2%的python了&quot;</span>) <span class="comment"># 我叫赛利亚， 我已经学习了2%的python了</span></span><br></pre></td></tr></table></figure>



<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>and：并且，左右两端都为真，结果为真，否则为假</li>
<li>or：或者，左右两端有一个为真，结果为真，左右两端都为假，则结果为假</li>
<li>not：取反，非真即假，非假即真</li>
</ul>
<h3 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h3><ul>
<li>() —&gt; not —&gt; and —&gt; or</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(3 &gt; 2 and 4 &gt; 6 and 5 &lt; 7 and 7 &gt; 8) # False</span><br><span class="line">print(4 &gt; 6 or 7 &lt; 5 or 5 &gt; 8 or 7 &gt; 9 or 5 &gt; 3) # True</span><br></pre></td></tr></table></figure>



<h3 id="当左右两端是数字时"><a href="#当左右两端是数字时" class="headerlink" title="当左右两端是数字时"></a>当左右两端是数字时</h3><ul>
<li>x or y，若x为真，则值为x，否则为y</li>
<li>x and y，与or相反</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(3 and 0 or 5 and 4 or 6 and 8) # 4</span><br></pre></td></tr></table></figure>



<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>单行注释：#</li>
<li>多行注释：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;多行注释</span><br><span class="line">写多少行都行</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>



<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><h3 id="if结构："><a href="#if结构：" class="headerlink" title="if结构："></a>if结构：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件：</span><br><span class="line">    if-语句块</span><br></pre></td></tr></table></figure>



<h3 id="if-else结构："><a href="#if-else结构：" class="headerlink" title="if-else结构："></a>if-else结构：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件：</span><br><span class="line">    if-语句块</span><br><span class="line">else:</span><br><span class="line">    else-语句块</span><br></pre></td></tr></table></figure>



<h3 id="if-elif-else结构："><a href="#if-elif-else结构：" class="headerlink" title="if-elif-else结构："></a>if-elif-else结构：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if 条件：</span><br><span class="line">    if-语句块</span><br><span class="line">elif 条件：</span><br><span class="line">    elif-语句块</span><br><span class="line">...</span><br><span class="line">else:</span><br><span class="line">    else-语句块</span><br></pre></td></tr></table></figure>

<p>if语句里可以嵌套if语句，但不要超过3层，最多5层。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while 结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while 结构：</span><br><span class="line">    while语句块(循环体)</span><br></pre></td></tr></table></figure>

<p> 执行顺序：判断条件是否为真，如果为真则执行循环体，否则跳出循环。执行完循环体之后再次判断条件是否为真，直到为假为止。</p>
<p>break and continue</p>
<ul>
<li>break：结束本层循环</li>
<li>continue：结束本层本次循环，继续执行下一次循环</li>
</ul>
<p>while-else结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while 条件：</span><br><span class="line">    while语句块(循环体)</span><br><span class="line">else:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<ul>
<li>执行顺序：当条件成立时执行循环体，当条件不成立时执行else里的代码。</li>
<li>如果循环是通过break退出的，那么while后的else将不会执行，只有在while条件判断是假的时候才会执行这个else。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>vim编辑器</title>
    <url>/2025/02/25/vim%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h1><p>vim是一个全屏幕纯文本编辑器，是vi编辑器的增强版。</p>
<p>可以利用别名让输入vi命令的时候，实际上执行vim编辑器，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义别名</span></span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br></pre></td></tr></table></figure>

<p>这样定义的别名是临时生效，如果需要永久生效，需要放入环境变量配置文件(~&#x2F;.bashrc)。</p>
<h2 id="1-vim工作模式"><a href="#1-vim工作模式" class="headerlink" title="1. vim工作模式"></a>1. vim工作模式</h2><h3 id="1）命令模式"><a href="#1）命令模式" class="headerlink" title="1）命令模式"></a>1）命令模式</h3><p>主要使用快捷键的模式。</p>
<p>命令模式想要进入输入模式，可以使用以下方式：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>在光标所在字符后插入</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行尾插入</td>
</tr>
<tr>
<td>i</td>
<td>在光标所在字符前插入</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行行首插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标下插入新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标上插入新行</td>
</tr>
<tr>
<td>ZZ</td>
<td>保存退出</td>
</tr>
</tbody></table>
<h3 id="2）输入模式"><a href="#2）输入模式" class="headerlink" title="2）输入模式"></a>2）输入模式</h3><p>主要用于文本编辑，和记事本类似，输入数据就好。</p>
<h3 id="3）编辑模式-末行模式"><a href="#3）编辑模式-末行模式" class="headerlink" title="3）编辑模式(末行模式)"></a>3）编辑模式(末行模式)</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存不退出</td>
</tr>
<tr>
<td>:w 新文件名</td>
<td>把文件另存为新文件</td>
</tr>
<tr>
<td>:q</td>
<td>不保存退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存退出</td>
</tr>
<tr>
<td>:!</td>
<td>强制</td>
</tr>
<tr>
<td>:q!</td>
<td>强制不保存退出，用于修改文件之后，不保存数据退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存退出，当文件的所有者或者root用户，对文件没有写权限的时候，强制写入数据使用</td>
</tr>
</tbody></table>
<h2 id="2-命令模式操作"><a href="#2-命令模式操作" class="headerlink" title="2. 命令模式操作"></a>2. 命令模式操作</h2><h3 id="1）移动光标"><a href="#1）移动光标" class="headerlink" title="1）移动光标"></a>1）移动光标</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>上下左右移动光标</td>
<td>上、下、左、右方向键或者k、j、h、l</td>
</tr>
<tr>
<td>移动到文件头</td>
<td>gg</td>
</tr>
<tr>
<td>移动到文件尾</td>
<td>G或者shift+g</td>
</tr>
<tr>
<td>移动到行首</td>
<td>^</td>
</tr>
<tr>
<td>移动到行尾</td>
<td>$</td>
</tr>
<tr>
<td>移动到指定行</td>
<td>:n(这里n是数字，准备移动到第几行，就用哪个数字</td>
</tr>
</tbody></table>
<h3 id="2）删除或剪切"><a href="#2）删除或剪切" class="headerlink" title="2）删除或剪切"></a>2）删除或剪切</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>删除单个字母</td>
<td>x</td>
</tr>
<tr>
<td>删除n个字母</td>
<td>nx</td>
</tr>
<tr>
<td>删除单行</td>
<td>dd</td>
</tr>
<tr>
<td>删除多行</td>
<td>ndd</td>
</tr>
<tr>
<td>删除指定范围的行</td>
<td>:n1,n2d</td>
</tr>
<tr>
<td>粘贴到光标后</td>
<td>p</td>
</tr>
<tr>
<td>粘贴到光标前</td>
<td>P(大)</td>
</tr>
<tr>
<td>从光标所在行删除到文件尾</td>
<td>dG</td>
</tr>
</tbody></table>
<p>删除整行或多行，这是比较常用的删除方法，这里的dd快捷键既是删除，也是剪切。删除内容放入了剪切板，如果不粘贴就是剪切。</p>
<h3 id="3）复制"><a href="#3）复制" class="headerlink" title="3）复制"></a>3）复制</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>复制单行</td>
<td>yy</td>
</tr>
<tr>
<td>复制多行</td>
<td>nyy</td>
</tr>
</tbody></table>
<h3 id="4）撤销"><a href="#4）撤销" class="headerlink" title="4）撤销"></a>4）撤销</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>撤销</td>
<td>u</td>
</tr>
<tr>
<td>反撤销</td>
<td>ctrl+r</td>
</tr>
</tbody></table>
<p>u键能一直撤销到文件打开时的状态，类似Windows下ctrl+z键的作用。</p>
<p>ctrl+z能一直反撤销到最后一次操作状态，类似Windows下ctrl+y键的作用。</p>
<h3 id="5）vim配置文件"><a href="#5）vim配置文件" class="headerlink" title="5）vim配置文件"></a>5）vim配置文件</h3><p>这些末行模式参数设置，多数需要在vim中才能生效。</p>
<table>
<thead>
<tr>
<th>设置参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号</td>
</tr>
<tr>
<td>:syntax on</td>
<td>依据语法显示相关的颜色帮助</td>
</tr>
<tr>
<td>:syntax off</td>
<td>不显示语法相关的颜色帮助</td>
</tr>
<tr>
<td>:set hlsearch</td>
<td>设置将查找的字符串高亮显示，默认是set hlsearch高亮显示</td>
</tr>
<tr>
<td>:set nohlsearch</td>
<td>取消将查找的字符串高亮显示</td>
</tr>
<tr>
<td>:set ruler</td>
<td>设置显示右下角的状态栏</td>
</tr>
<tr>
<td>:set noruler</td>
<td>取消显示右下角的状态栏</td>
</tr>
<tr>
<td>:set showmode</td>
<td>设置在左下角显示如“–INSERT–”之类的状态栏，默认是set showmode显示</td>
</tr>
<tr>
<td>:set noshowmode</td>
<td>取消在左下角显示如”–INSERT–”之类的状态栏</td>
</tr>
<tr>
<td>:set list</td>
<td>设置显示隐藏字符(Tab键用”I”表示，回车符用“$”表示)</td>
</tr>
<tr>
<td>:set nolist</td>
<td>设置不显示隐藏字符，默认是nolist</td>
</tr>
<tr>
<td>:set all</td>
<td>查看所有设置参数</td>
</tr>
</tbody></table>
<p>大家会发现，这些设置参数都只是临时生效，一旦关闭文件再打开，又需要重新输入。如果想要永久生效，需要手工建立vim的配置文件”~&#x2F;.vimrc”，把你需要的参数写入配置文件就永久生效了。</p>
<p>Windows下回车符在Linux中是用“^M$”符号显示，而不是”$”符。这样会导致Windows下编辑的程序脚本，无法在Linux中执行。这时可以通过命令”dos2unix”，把Windows格式转为Linux格式，当然反过来”unix2dos”命令就是把Linux格式转为Windows格式。这两个命令默认没有安装，需要手工安装才能使用。</p>
<h3 id="6）查找"><a href="#6）查找" class="headerlink" title="6）查找"></a>6）查找</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;查找内容</td>
<td>从光标所在行向下查找</td>
</tr>
<tr>
<td>?查找内容</td>
<td>从光标所在行向上查找</td>
</tr>
<tr>
<td>n</td>
<td>下一个</td>
</tr>
<tr>
<td>N</td>
<td>上一个</td>
</tr>
</tbody></table>
<h3 id="7）替换"><a href="#7）替换" class="headerlink" title="7）替换"></a>7）替换</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>替换光标所在处的字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在处开始替换字符，按ESC结束</td>
</tr>
<tr>
<td>:1,10s&#x2F;old&#x2F;new&#x2F;g</td>
<td>替换1到10行的所有old为new</td>
</tr>
<tr>
<td>:%s&#x2F;old&#x2F;new&#x2F;g</td>
<td>替换整个文件的old为new</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在shell中“#”开头是注释，批量注释1到10行</span><br><span class="line">:1,10s/^/#/g</span><br><span class="line"></span><br><span class="line"># 取消注释</span><br><span class="line">:1,10s/^#//g</span><br><span class="line"></span><br><span class="line"># 批量添加“//”注释</span><br><span class="line">:1,10s/^/\/\//g</span><br><span class="line"></span><br><span class="line"># 取消注释</span><br><span class="line">:1,10s/^\/\///g</span><br></pre></td></tr></table></figure>



<h2 id="3-vim使用技巧"><a href="#3-vim使用技巧" class="headerlink" title="3. vim使用技巧"></a>3. vim使用技巧</h2><h3 id="1）在vim中导入其他文件内容或命令结果"><a href="#1）在vim中导入其他文件内容或命令结果" class="headerlink" title="1）在vim中导入其他文件内容或命令结果"></a>1）在vim中导入其他文件内容或命令结果</h3><p>a）导入其他文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把文件内容导入光标下一行</span><br><span class="line">:r 文件名            </span><br></pre></td></tr></table></figure>

<p>可以把其他文件的内容导入到光标下一行位置。</p>
<p>b）在vim中执行系统命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在vim中执行系统命令</span><br><span class="line">:!命令</span><br></pre></td></tr></table></figure>

<p>这里只是在vim中执行系统命令，但并不把系统命令的结果写入到文件中，主要用于在文件编辑中，查看系统信息如时间。</p>
<p>c）导入命令结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在vim中执行系统命令，并把命令结果导入光标下一行</span><br><span class="line">:r !命令</span><br></pre></td></tr></table></figure>



<h3 id="2）设定快捷键"><a href="#2）设定快捷键" class="headerlink" title="2）设定快捷键"></a>2）设定快捷键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自定义快捷键</span><br><span class="line">:map 快捷键 快捷键执行的命令</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按ctrl+p时，在行首加入注释</span><br><span class="line">:map ^P I#&lt;ESC&gt;</span><br><span class="line"></span><br><span class="line"># 按ctrl+b时，删除行首第一个字母</span><br><span class="line">:map ^B ^x</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：^P快捷键不能手工输入，需要执行ctrl+V+P来定义，或ctrl+v，然后ctrl+p。</p>
<h3 id="3）字符替换"><a href="#3）字符替换" class="headerlink" title="3）字符替换"></a>3）字符替换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 字符替换</span><br><span class="line">:ab 源字符 替换为字符</span><br></pre></td></tr></table></figure>

<p>在vim编辑中，有时候需要频繁输入某一长字符串(比如邮箱)，这时使用字符串替换，能增加输入效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当碰到“mymail”时，转变为邮箱</span><br><span class="line">:ab mymail ben@163.com</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>“源字符”不应设置的太短，否则有可能影响输入。</p>
<h3 id="4）多文件打开"><a href="#4）多文件打开" class="headerlink" title="4）多文件打开"></a>4）多文件打开</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim上下分屏同时打开两个文件</span><br><span class="line">vim -o 文件1 文件2</span><br><span class="line"></span><br><span class="line"># vim左右分屏同时打开两个文件</span><br><span class="line">vim -O 文件1 文件2</span><br></pre></td></tr></table></figure>

<p>这样可以同时打开两个文件，方便操作。可以通过先按”ctrl+w”，再按方向键的方式在两个文件之间切换。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>启动引导与修复</title>
    <url>/2025/03/04/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h2><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>Linux默认有7个运行级别</p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式，可以想象为windows的安全模式，主要用于系统修复</td>
</tr>
<tr>
<td>2</td>
<td>不完全的命令行模式，不含NFS服务</td>
</tr>
<tr>
<td>3</td>
<td>完全的命令行模式，就是标准字符界面</td>
</tr>
<tr>
<td>4</td>
<td>系统保留</td>
</tr>
<tr>
<td>5</td>
<td>图形模式</td>
</tr>
<tr>
<td>6</td>
<td>重启动</td>
</tr>
</tbody></table>
<p>在Linux系统中可以使用runlevel命令来查看系统的运行级别：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">N 5</span><br></pre></td></tr></table></figure>

<p>在这个命令的结果中，”N 5”中的N代表进入这个级别前，上一个级别是什么，5代表当前级别。”N”就是None的意思，也就是说系统是开机直接进入的5运行级别，没有上一个运行级别。那如果是从图形界面切换到字符界面的话，再查看运行级别，应该是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure>

<p>使用init命令可以手工改变当前的运行级别：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入图形界面，当然要已经安装了图形界面才可以</span></span><br><span class="line">[root@localhost ~]# init 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关机</span></span><br><span class="line">[root@localhost ~]# init 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">[root@localhost ~]# init 6</span><br></pre></td></tr></table></figure>

<p>不过要注意使用init命令关机和重启并不是太安全，容易造成数据丢失。所以推荐还是使用shutdown命令进行关机和重启。</p>
<h3 id="系统默认运行级别"><a href="#系统默认运行级别" class="headerlink" title="系统默认运行级别"></a>系统默认运行级别</h3><p>&#x2F;etc&#x2F;init&#x2F;rcS.conf配置文件调用&#x2F;etc&#x2F;inittab配置文件的目的就是为了确定系统的默认运行级别。也就是系统一开机后会进入那个运行级别。</p>
<p>注意这里的默认运行级别只能写成3或5，其的级别要不就是关机重启，要不就是保留或单用户，都不能作为系统默认运行级别。</p>
<h3 id="etc-rc-d-rc-local文件"><a href="#etc-rc-d-rc-local文件" class="headerlink" title="&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件"></a>&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件</h3><p>这个配置文件会在用户登录之前读取，这个文件中写入什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动就运行的工作，只需要写入&#x2F;etc&#x2F;rc.d&#x2F;rc.local这个配置文件即可。</p>
<h2 id="启动引导程序-Boot-Loader"><a href="#启动引导程序-Boot-Loader" class="headerlink" title="启动引导程序(Boot Loader)"></a>启动引导程序(Boot Loader)</h2><p>早期的Lilo引导程序已经不是很常见了，grub相比有很多优势，主要有：</p>
<ul>
<li>支持更多的文件系统；</li>
<li>grub的主程序可以直接在文件系统中查找内核文件；</li>
<li>在系统启动时，可以利用grub的交互界面编辑和修改启动选项；</li>
<li>可以动态的修改grub的配置文件，这样在修改配置文件之后不需要重新安装grub，而只需要重新启动就可以生效了。</li>
</ul>
<p>a）&#x2F;boot&#x2F;grub目录</p>
<p>grub的作用有以下几个：</p>
<ul>
<li>加载操作系统的内核。</li>
<li>拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。</li>
<li>还可以调用其他的启动引导程序，来实现多系统引导。</li>
</ul>
<p>grub的配置文件主要是放置在&#x2F;boot&#x2F;grub&#x2F;目录中的。其实这个目录中主要就是grub的配置文件和各种文件系统的stage1.5文件。不过grub的配置文件有两个&#x2F;boot&#x2F;grub&#x2F;grub.conf和&#x2F;boot&#x2F;grub&#x2F;menu.lst，这两个配置文件是软链接，所以修改哪一个都可以，个人习惯改grub.conf。</p>
<p>b）grub的配置文件</p>
<p>在grub中分区的表示方法</p>
<table>
<thead>
<tr>
<th>硬盘</th>
<th>分区</th>
<th>Linux中设备文件名</th>
<th>grub中设备文件名</th>
</tr>
</thead>
<tbody><tr>
<td>第一块SCSI硬盘</td>
<td>第一个主分区</td>
<td>&#x2F;dev&#x2F;sda1</td>
<td>hd(0,0)</td>
</tr>
<tr>
<td></td>
<td>第二个主分区</td>
<td>&#x2F;dev&#x2F;sda2</td>
<td>hd(0,1)</td>
</tr>
<tr>
<td></td>
<td>扩展分区</td>
<td>&#x2F;dev&#x2F;sda3</td>
<td>hd(0,2)</td>
</tr>
<tr>
<td></td>
<td>第一个逻辑分区</td>
<td>&#x2F;dev&#x2F;sda5</td>
<td>hd(0,4)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第一个主分区</td>
<td>&#x2F;dev&#x2F;sdb1</td>
<td>hd(1,0)</td>
</tr>
<tr>
<td></td>
<td>第二个主分区</td>
<td>&#x2F;dev&#x2F;sdb2</td>
<td>hd(1,1)</td>
</tr>
<tr>
<td></td>
<td>扩展分区</td>
<td>&#x2F;dev&#x2F;sdb3</td>
<td>hd(1,2)</td>
</tr>
<tr>
<td></td>
<td>第一个逻辑分区</td>
<td>&#x2F;dev&#x2F;sdb5</td>
<td>hd(1,4)</td>
</tr>
</tbody></table>
<p>grub的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">		root (hd0,0)</span><br><span class="line">		kernel				/vmlinuz-2.6.32-279.el6.i686			ro		root=UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS	KEYBOARDTYPE=pc	KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</span><br><span class="line">		initrd	/initramfs-2.6.32-279.el6.i686.img</span><br></pre></td></tr></table></figure>

<ul>
<li><p>default&#x3D;0</p>
<p>默认启动第一个系统。也就是如蛤在等待时间结束后，用户没有选择进入哪一个系统，那么系统会默认进入第一个系统。如果有多系统并存，那么每个系统都会有自己的titile字段，如果想要默认进入第二个系统，可以设为default&#x3D;1。</p>
</li>
<li><p>timeout&#x3D;5</p>
<p>等待时间，默认是5秒。也就是进入系统时，如果5秒内用户没有按下任意键，那么系统会进入default字段定义的系统。当然可以手工修改这个等待时间，如果timeout&#x3D;0则不会等待直接进入系统，timeout&#x3D;-1则是一直等待用户输入，而不会自动进入系统。</p>
</li>
<li><p>splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz</p>
<p>这里是指定grub启动时的背景图像文件的保存位置。hd(0,0)代表第一个硬盘的第一个分区。</p>
</li>
<li><p>hiddenmenu</p>
<p>隐藏菜单。启动时默认只能看到读秒，而不能看到菜单，如果想要看到菜单需要按任意键。如果注释了这句话，那么启动时就能直接看到菜单了。</p>
</li>
</ul>
<p>Centos系统的启动配置：</p>
<ul>
<li><p>title Centos (2.6.32-279.el6.i686)</p>
<p>title就是标题的意思，也就是说在title后面写入的是什么，那么系统启动时在grub的启动菜单中看到的就是什么。</p>
</li>
<li><p>root (hd0,0)</p>
<p>是指启动程序的保存分区。这个root并不是管理员。在我的系统中，&#x2F;boot分区是独立划分的，而且设备文件名为&#x2F;dev&#x2F;sda1，所以在grub中，就被描述为hd（0,0）。</p>
</li>
<li><p>kernel				&#x2F;vmlinuz-2.6.32-279.el6.i686			ro		root&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS	KEYBOARDTYPE&#x3D;pc	KEYTABLE&#x3D;us rd_NO_MD crashkernel&#x3D;auto LANG&#x3D;zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</p>
<ul>
<li><p>&#x2F;vmlinuz-2.6.32-279.el6.i686</p>
<p>指定了内核文件的位置，这里的&#x2F;是指&#x2F;boot分区。</p>
</li>
<li><p>ro</p>
<p>启动时以只读方式挂载根文件系统，这是为了不让启动过程影响磁盘内的文件系统。</p>
</li>
<li><p>root&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS</p>
<p>指定根文件系统所在位置。</p>
</li>
<li><p>rd_NO_LUKS</p>
<p>禁用LUKS，LUKS用于给磁盘加密。</p>
</li>
<li><p>rd_NO_MD</p>
<p>禁用软RAID</p>
</li>
<li><p>rd_NO_DM</p>
<p>禁用硬RAID</p>
</li>
<li><p>rd_NO_LVM</p>
<p>禁用LVM。以上禁用都只是在启动过程中禁用，是为加速系统启动的。</p>
</li>
<li><p>KEYBOARDTYPE&#x3D;pc    KEYTABLE&#x3D;us</p>
<p>键盘类型</p>
</li>
<li><p>crashkernel&#x3D;auto</p>
<p>自动为crashkernel预留内存</p>
</li>
<li><p>LANG&#x3D;zh_CN.UTF-8</p>
<p>语言环境</p>
</li>
<li><p>rhgb</p>
<p>（redhat graphics boot）用图片来代替启动过程中的文字信息。启动完成之后可以使用dmesg命令来查看这些文字信息。</p>
</li>
<li><p>quiet</p>
<p>隐藏启动信息，只显示重要信息。</p>
</li>
<li><p>initrd    &#x2F;initramfs-2.6.32-279.el6.i686.img</p>
<p>指定了initramfs内存文件系统镜像文件的所在位置。</p>
</li>
</ul>
</li>
</ul>
<p>grub加密</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grub-mkpasswd-pbkdf2</span><br><span class="line">输入密码： </span><br><span class="line">重新输入口令： </span><br><span class="line">您的密码的 PBKDF2 哈希为 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br></pre></td></tr></table></figure>

<p>这样就可以生成加密密码字串，这个字串是采用md5加密的，就是你的密码经md5编码之后的。</p>
<p>grub菜单整体加密</p>
<p>如果只是加密单个启动菜单，grub的编辑模式是不能锁定的，还是可以按“e”键进入编辑模式。而且进入编辑模式后，是可以删除password字段的，再按“b”（boot启动）键就可以不用密码直接进入系统。这时就需要给grub菜单整体加密了，整体加密后，如果想进入grub编辑界面必须输入正确的密码。加密方法其实只是把password字段换个位置而已。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout=5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但是这样加密，启动CentOS时，是不需要密码就能正常启动的。如果需要grub整体加密，又需要系统启动时输入正确的密码时，则需：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">		lock</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<p>在title字段加入lock。代表锁死，如果不输入正确的grub密码也不能启动。</p>
<h2 id="系统修复模式"><a href="#系统修复模式" class="headerlink" title="系统修复模式"></a>系统修复模式</h2><h3 id="单用户模式"><a href="#单用户模式" class="headerlink" title="单用户模式"></a>单用户模式</h3><p>Linux的单用户模式有些类似Windows的安全模式，只启动最少的程序用于系统修复。在单用户模式(运行级别为1)中，Linux引导进入根shell，网络被禁用，只有少数进程运行。单用户模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。</p>
<p>a）进入单用户模式</p>
<p>开机进入引导界面，按“e”进入。</p>
<p>b）单用户模式常见的错误修复</p>
<ul>
<li><p>遗忘root密码</p>
<p>进入单用户模式最大的特点就是不需要输入用户名和密码就能登录。既然已经登录了单用户模式，那么直接给root用户设定新密码即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# passwd root</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改系统默认运行级别</p>
<p>如果把系统的默认运行级别修改错误，比如改为了0或6，系统就不能正常启动了。这时也可以利用单用户模式进行修复，只要直接修改默认运行级别配置文件&#x2F;etc&#x2F;inittab，把系统默认运行级别修改回来即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/inittab</span><br><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure>

<p>绝大多数系统错误都可以通过单用户模式进行修复，理论上是只要能够进入单用户模式，那么系统错误就可以被单用户模式修复。当然意判断系统到底是哪里出现了问题，是需要不断地经验积累。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>文件系统管理</title>
    <url>/2025/02/25/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h1><h2 id="1-硬盘结构"><a href="#1-硬盘结构" class="headerlink" title="1. 硬盘结构"></a>1. 硬盘结构</h2><h3 id="1）硬盘的逻辑结构"><a href="#1）硬盘的逻辑结构" class="headerlink" title="1）硬盘的逻辑结构"></a>1）硬盘的逻辑结构</h3><p>每个扇区的大小是固定的，为512Byte。扇区也是磁盘的最小存储单位。</p>
<p>硬盘的大小是用”磁头数X柱面数X扇区数X每个扇区的大小”这样的公式来计算的。其中磁头数(Heads)表示硬盘总共有几个磁头，也可以理解成硬盘有几个盘面，然后乘以2；柱面数(Cylinders)表示硬盘每一面盘片有几条磁道；扇区数(Sectors)表示每条磁道上有几个扇区；每个扇区的大小一般是512Byte。</p>
<h3 id="2）硬盘接口"><a href="#2）硬盘接口" class="headerlink" title="2）硬盘接口"></a>2）硬盘接口</h3><ul>
<li><p>IDE硬盘接口(Integrated Drive Electronics，并口，即电子集成驱动器)</p>
<p>也称作”ATA硬盘”或”PATA硬盘”，是早期机械硬盘的主要接口，ATA133硬盘的理论速度可以达到133MB&#x2F;s(此速度为理论平均值)。</p>
</li>
<li><p>SATA接口(Serial ATA，串口)</p>
<p>是速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力。目前已经是SATA三代，理论传输速度达到600MB&#x2F;s(此速度为理论平均值)。</p>
</li>
<li><p>SCSI接口(Small Computer System Interface，小型计算机系统接口)广泛用在服务器上，具有应用范围广、多任务、带宽大、CPU占用率低及支持执插拔等优点，理论传输速度达到320MB&#x2F;s。</p>
</li>
</ul>
<h2 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2. 文件系统"></a>2. 文件系统</h2><h3 id="1）Linux文件系统的特性"><a href="#1）Linux文件系统的特性" class="headerlink" title="1）Linux文件系统的特性"></a>1）Linux文件系统的特性</h3><ul>
<li><p>super block（超级块）</p>
<p>记录整个文件系统的信息，包括：</p>
<ul>
<li>block与inode的总量</li>
<li>已经使用的inode和block的数量</li>
<li>未使用的inode和block的数量</li>
<li>block与inode的大小</li>
<li>文件系统的挂载时间</li>
<li>最近一次的写入时间</li>
<li>最近一次的磁盘检验时间等</li>
</ul>
</li>
<li><p>data block（数据块，也称作block）</p>
<p>用来实际保存数据的，block的大小(1KB|2KB|4KB)和数量在格式化后就已经决定，不能改变，除非重新格式化。每个block只能保存一个文件的数据，要是文件数据小于一个block块，那么这个block的剩余空间不能被其他文件使用；要是文件数据大于一个block块，则占用多个block块。Windows中磁盘碎片整理工具的原理就是把一个文件占用的多个block块尽量整理到一起，这样可以加快读写速度。</p>
</li>
<li><p>inode（i节点）</p>
<p>用来记录文件的权限(r、w、x)，文件的所有者和属组，文件的大小，文件的状态改变时间(ctime)，文件的最近一次读取时间(atime)，文件的最近一次修改时间(mtime)，文件的数据真正保存的block编号。每个文件需要占一个inode。</p>
</li>
</ul>
<h3 id="2）Linux常见文件系统"><a href="#2）Linux常见文件系统" class="headerlink" title="2）Linux常见文件系统"></a>2）Linux常见文件系统</h3><table>
<thead>
<tr>
<th>文件系统</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ext</td>
<td>Linux中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用。</td>
</tr>
<tr>
<td>ext2</td>
<td>是ext文件系统的升级版本，Red Hat Linux 7.2版本以前的系统默认都是ext2文件系统。于1993年发布，支持最大16TB的分区和最大2TB的文件</td>
</tr>
<tr>
<td>ext3</td>
<td>是ext2文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大16TB的分区和最大2TB的文件</td>
</tr>
<tr>
<td>ext4</td>
<td>是ext3文件系统的升级版。ext4在性能、伸缩性和可靠性方面进行了大量改进。ext4的变化可以说是翻天覆地的，比如向下兼容ext3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等。它是CentOS 6.x的默认文件系统</td>
</tr>
<tr>
<td>xfs</td>
<td>XFS最早针对IRIX操作系统开发，是一个高性能的日志型文件系统，能够在断电以及操作系统崩溃的情况下保证文件系统数据的一致性。它是一个64位的文件系统，后来进行开源并且移植到了Linux操作系统中，目前CentOS 7.x将XFS+LVM作为默认的文件系统，据官方所称，XFS对于大文件的读写性能较好。</td>
</tr>
<tr>
<td>swap</td>
<td>swap是Linux中用于交换分区的文件系统(类似于Windows中的虚拟内存)，当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的2倍，但不要超2GB。它是Linux的必需分区。</td>
</tr>
<tr>
<td>NFS</td>
<td>NFS是网络文件系统(Network File System)的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源</td>
</tr>
<tr>
<td>ISO9660</td>
<td>光盘的标准文件系统，Linux要想使用光盘，必须支持iso9660文件系统</td>
</tr>
<tr>
<td>fat</td>
<td>就是Windows下的fat16文件系统，在Linux中识别为fat</td>
</tr>
<tr>
<td>vfat</td>
<td>就是Windows下的fat32文件系统，在Linux中识别为vfat。支持最大32GB的分区和最大4GB的文件。</td>
</tr>
<tr>
<td>NTFS</td>
<td>就是Windows下的NTFS文件系统，不过Linux默认是不能识别NTFS文件系统的，如果需要识别，则需要重新编译内核才能支持。它比fat32文件系统更加安全，速度更快，支持最大2TB的分区和最大64GB的文件。</td>
</tr>
</tbody></table>
<h2 id="3-常用的硬盘管理命令"><a href="#3-常用的硬盘管理命令" class="headerlink" title="3. 常用的硬盘管理命令"></a>3. 常用的硬盘管理命令</h2><h3 id="1）df命令"><a href="#1）df命令" class="headerlink" title="1）df命令"></a>1）df命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -ahT</span><br><span class="line">选项：</span><br><span class="line">  -a:    显示特殊文件系统，这些文件系统几乎都是保存在内存中的。如/proc,因为挂载在内存中，所以占用量都是0</span><br><span class="line">  -h:    单位不是只用KB，而是换算成习惯单位</span><br><span class="line">  -T:    多出了文件系统类型一列</span><br></pre></td></tr></table></figure>



<h3 id="2）du命令"><a href="#2）du命令" class="headerlink" title="2）du命令"></a>2）du命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# du [选项] [目录或文件名]</span><br><span class="line">选项：</span><br><span class="line">  -a 显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量</span><br><span class="line">  -h 使用习惯单位显示磁盘占用量，如KB，MB或GB等</span><br><span class="line">  -s 统计总占用量，而不列出子目录和子文件的占用量</span><br></pre></td></tr></table></figure>

<p>du与df的区别：du是用于统计文件大小的，统计的文件大小是准确的；df是用于统计空间大小的，统计的剩余空间是准确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -Th</span><br><span class="line">文件系统        类型      大小  已用  可用 已用% 挂载点</span><br><span class="line">tmpfs           tmpfs     687M  2.5M  685M    1% /run</span><br><span class="line">/dev/nvme0n1p10 ext4      187G  144G   34G   82% /</span><br><span class="line">tmpfs           tmpfs     3.4G  5.4M  3.4G    1% /dev/shm</span><br><span class="line">tmpfs           tmpfs     5.0M   12K  5.0M    1% /run/lock</span><br><span class="line">efivarfs        efivarfs  148K  112K   32K   79% /sys/firmware/efi/efivars</span><br><span class="line">/dev/nvme0n1p1  vfat       96M   53M   44M   56% /boot/efi</span><br><span class="line">tmpfs           tmpfs     687M  172K  687M    1% /run/user/1000</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# du -sh /</span><br><span class="line">113G	/</span><br></pre></td></tr></table></figure>

<p>df和du统计的根目录大小有差异，是因为du统计的是根目录文件大小，df统计的不仅只有根目录文件大小，还有临时文件的大小。</p>
<h3 id="3）fsck文件系统修复命令"><a href="#3）fsck文件系统修复命令" class="headerlink" title="3）fsck文件系统修复命令"></a>3）fsck文件系统修复命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fsck -y 分区                  # 开机重启自动修复</span><br></pre></td></tr></table></figure>



<h3 id="4）显示磁盘状态"><a href="#4）显示磁盘状态" class="headerlink" title="4）显示磁盘状态"></a>4）显示磁盘状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs -h 分区</span><br></pre></td></tr></table></figure>



<h3 id="5）查看文件的详细时间"><a href="#5）查看文件的详细时间" class="headerlink" title="5）查看文件的详细时间"></a>5）查看文件的详细时间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# stat 文件名</span><br></pre></td></tr></table></figure>



<h3 id="6）判断文件类型"><a href="#6）判断文件类型" class="headerlink" title="6）判断文件类型"></a>6）判断文件类型</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# file 文件名</span><br></pre></td></tr></table></figure>



<h3 id="7）判断命令类型"><a href="#7）判断命令类型" class="headerlink" title="7）判断命令类型"></a>7）判断命令类型</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# type 命令名</span><br></pre></td></tr></table></figure>



<h2 id="4-fdisk命令手工分区"><a href="#4-fdisk命令手工分区" class="headerlink" title="4. fdisk命令手工分区"></a>4. fdisk命令手工分区</h2><h3 id="1）查看系统所有硬盘及分区"><a href="#1）查看系统所有硬盘及分区" class="headerlink" title="1）查看系统所有硬盘及分区"></a>1）查看系统所有硬盘及分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk -l</span><br></pre></td></tr></table></figure>



<h3 id="2）磁盘分区"><a href="#2）磁盘分区" class="headerlink" title="2）磁盘分区"></a>2）磁盘分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk 磁盘</span><br></pre></td></tr></table></figure>

<p>fdisk交互指令说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>设置可引导标记</td>
</tr>
<tr>
<td>b</td>
<td>编辑bsd磁盘标签</td>
</tr>
<tr>
<td>c</td>
<td>设置DOS操作系统兼容标记</td>
</tr>
<tr>
<td>d</td>
<td>删除一个分区</td>
</tr>
<tr>
<td>l</td>
<td>显示已知的文件系统类型。82为Linux swap分区，83为Linux分区</td>
</tr>
<tr>
<td>m</td>
<td>显示帮助菜单</td>
</tr>
<tr>
<td>n</td>
<td>新建分区</td>
</tr>
<tr>
<td>o</td>
<td>建立空白DOS分区表</td>
</tr>
<tr>
<td>p</td>
<td>显示分区列表</td>
</tr>
<tr>
<td>q</td>
<td>不保存退出</td>
</tr>
<tr>
<td>s</td>
<td>新建空白SUN磁盘标签</td>
</tr>
<tr>
<td>t</td>
<td>改变一个分区的系统ID</td>
</tr>
<tr>
<td>u</td>
<td>改变显示记录单位</td>
</tr>
<tr>
<td>v</td>
<td>验证分区表</td>
</tr>
<tr>
<td>w</td>
<td>保存退出</td>
</tr>
<tr>
<td>x</td>
<td>附加功能</td>
</tr>
</tbody></table>
<p>新建主分区：n—p—1—1分区号—分区大小+100M—w</p>
<p>新建扩展分区：n—e—2分区号—124起始柱面—1024柱面(所有剩余空间都分配给扩展分区)</p>
<p>新建逻辑分区：n—l—不用指定分区号—124起始柱面—+100M(指定大小)—w</p>
<h3 id="3）格式化"><a href="#3）格式化" class="headerlink" title="3）格式化"></a>3）格式化</h3><p>a）mkfs</p>
<p>mkfs命令非常简单易用，不过是不能调整分区的默认参数的（比如块大小是4096），这些默认参数除非特殊情况，否则不能调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t 文件系统类型 分区</span><br></pre></td></tr></table></figure>



<p>b）mke2fs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mke2fs [选项] 分区</span><br><span class="line">[选项]：</span><br><span class="line">  -t 文件系统：    指定格式化成哪个文件系统，如ext4, xfs</span><br><span class="line">  -b 字节:        指定block块的大小</span><br><span class="line">  -i 字切:        指定&quot;字节/inode&quot;的比例，也就是多少个字节分配一个inode</span><br><span class="line">  -j：            建立带有ext3日志功能的文件系统</span><br><span class="line">  -L 卷标名:      给文件系统设置卷标名，就不使用e2label命令设定了</span><br></pre></td></tr></table></figure>



<h3 id="4）建立挂载点"><a href="#4）建立挂载点" class="headerlink" title="4）建立挂载点"></a>4）建立挂载点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /disk1</span><br></pre></td></tr></table></figure>



<h3 id="5）挂载"><a href="#5）挂载" class="headerlink" title="5）挂载"></a>5）挂载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mount 分区 挂载点</span><br></pre></td></tr></table></figure>



<h3 id="6）查看"><a href="#6）查看" class="headerlink" title="6）查看"></a>6）查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有已经挂载的分区和光盘</span><br><span class="line">[root@localhost ~]# mount</span><br><span class="line"></span><br><span class="line"># 查看系统分区</span><br><span class="line">[root@localhost ~]# fdisk -l</span><br><span class="line"></span><br><span class="line"># 查看分区占用百分比</span><br><span class="line">[root@Loaclhost ~]# df -Th</span><br></pre></td></tr></table></figure>



<h3 id="7）自动挂载"><a href="#7）自动挂载" class="headerlink" title="7）自动挂载"></a>7）自动挂载</h3><p>修改分区自动挂载文件(&#x2F;etc&#x2F;fstab)。此文件直接参与系统启动，如果修改错误，系统启动报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1              /disk1               ext4            defaults            1                  2</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：设备文件名</li>
<li>第二列：挂载点</li>
<li>第三列：文件系统</li>
<li>第四列：挂载选项</li>
<li>第五列：是否可以被备份。0（不备份） 1（每天备份） 2（不定期备份）</li>
<li>第六列：是否检测磁盘。0（不检测） 1（启动时检测） 2（启动后检测）</li>
</ul>
<p>也可以使用UUID进行挂载，UUID（硬盘通用唯一识别码，可以理解为硬盘的ID）。</p>
<ul>
<li>这个字段在CentOS 5.5的系统当中是写入分区的卷标名或分区设备文件名的，现在变更成硬盘的UUID。这样做的好处是当硬盘增加了新的分区，或者分区的顺序改变，再或者内核升级后，仍然能够保证分区能够正确的加载，而不至于造成启动障碍。</li>
<li>dumpe2fs命令可以查看磁盘状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs /dev/sdb5</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /dev/disk/by-uuid/</span><br></pre></td></tr></table></figure>



<h3 id="8）重启测试"><a href="#8）重启测试" class="headerlink" title="8）重启测试"></a>8）重启测试</h3><p>或者使用”mount -a”重新挂载所有内容，用它进行测试。</p>
<h2 id="5-etc-fstab文件修复"><a href="#5-etc-fstab文件修复" class="headerlink" title="5. &#x2F;etc&#x2F;fstab文件修复"></a>5. &#x2F;etc&#x2F;fstab文件修复</h2><ul>
<li><p>服务器连接显示器输入root密码登录系统。</p>
</li>
<li><p>此时根目录为只读文件系统，需要重新挂载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,rw /</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;fstab文件内容至正确。</p>
</li>
<li><p>重启服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# reboot</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-parted命令分区"><a href="#6-parted命令分区" class="headerlink" title="6 parted命令分区"></a>6 parted命令分区</h2><p>Linux系统中有两种常见的分区表：</p>
<ul>
<li><p>MBR分区表（主引导记录分区表）</p>
<p>支持的最大分区是2TB，最多支持4个主分区，或3个主分区1个扩展分区。</p>
</li>
<li><p>GPT分区表（GUID分区表）</p>
<p>支持最大18EB分区，最多支持128个分区，其中1个系统保留分区，127个用户自定义分区。</p>
</li>
</ul>
<p>不过parted命令也有点小问题，就是命令自身分区的时候只能格式化成ext2文件系统，不支持ext3和ext4文件系统。不过这没有太多的影响，因为我们可以先分区再用mkfs进行格式化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# parted 硬盘</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>parted交互命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>check NUMBER</td>
<td>做一次简单的文件系统检测</td>
</tr>
<tr>
<td>cp [FROM-DEVICE] FROM-NUMBER TO NUMBER</td>
<td>复制文件系统到另一个分区</td>
</tr>
<tr>
<td>help [COMMAND]</td>
<td>显示所有的命令帮助</td>
</tr>
<tr>
<td>mklabel,mktable LABEL-TYPE</td>
<td>创建新的磁盘卷标(分区表)</td>
</tr>
<tr>
<td>mkfs NUMBER FS-TYPE</td>
<td>在分区上建立文件系统</td>
</tr>
<tr>
<td>mkpart PART-TYPE [FS-TYPE] START END</td>
<td>创建一个分区</td>
</tr>
<tr>
<td>mkpartfs PART-TYPE FS-TYPE START END</td>
<td>创建分区，并建立文件系统</td>
</tr>
<tr>
<td>move NUMBER START END</td>
<td>移动分区</td>
</tr>
<tr>
<td>name NUMBER NAME</td>
<td>给分区命名</td>
</tr>
<tr>
<td>print [devices|free|list,all|NUMBER]</td>
<td>显示分区表，活动设备，空闲空间，所有分区</td>
</tr>
<tr>
<td>quit</td>
<td>退出</td>
</tr>
<tr>
<td>rescue START END</td>
<td>修复丢失的分区</td>
</tr>
<tr>
<td>resize NUMBER START END</td>
<td>修改分区大小</td>
</tr>
<tr>
<td>rm NUMBER</td>
<td>删除分区</td>
</tr>
<tr>
<td>select DEVICE</td>
<td>选择需要编辑的设备</td>
</tr>
<tr>
<td>set NUMBER FLAG STATE</td>
<td>改变分区标记</td>
</tr>
<tr>
<td>toggle [NUMBER [FLAG]]</td>
<td>切换分区表的状态</td>
</tr>
<tr>
<td>unit UNIT</td>
<td>设置默认的单位</td>
</tr>
<tr>
<td>Version</td>
<td>显示版本</td>
</tr>
</tbody></table>
<h3 id="1）查看分区"><a href="#1）查看分区" class="headerlink" title="1）查看分区"></a>1）查看分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">(parted) print                                 # 输入print指令</span><br><span class="line">Model： VMware, VMware Virtual S（scsi）        # 硬盘参数</span><br><span class="line">Disk /dev/sdb：21.5GB                           # 硬盘大小</span><br><span class="line">Sector size (logical/physical)：512B/512B       # 扇区大小</span><br><span class="line">Partition Table：msdos                          # 分区表类型，就是MBR分区表</span><br><span class="line">Number      Start    End     Size    Type    File system    标志</span><br><span class="line">1           32.3kB   5379MB  5379MB   primary</span><br></pre></td></tr></table></figure>

<h3 id="2）修改成GPT分区表"><a href="#2）修改成GPT分区表" class="headerlink" title="2）修改成GPT分区表"></a>2）修改成GPT分区表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">（parted）mklabel gpt</span><br><span class="line">警告：正在使用/dev/sdb上的分区                            # 由于/dev/sdb分区已经挂载，所以有警告</span><br><span class="line"></span><br><span class="line">忽略/Ingore/放弃/Cancel? ignore                         # 输入ignore忽略报错</span><br><span class="line">警告：The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost, Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes                                       # 输入yes</span><br><span class="line">警告：WARNING：the kernel failed to re-read the partition table on /dev/sdb（设备或资源忙）. As a result,it may not reflect all of your changes until after reboot.                        # 下次重启后，才能生效</span><br><span class="line"></span><br><span class="line">（parted）print                                          # 查看分区表</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt                                     # 分区表已经变成GPT</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志          # 所有的分区都消失了</span><br></pre></td></tr></table></figure>

<p>修改了分区表，如果这块硬盘已经有分区了，那么原有分区和分区中的数据都会消失，而且需要重启系统才会生效。</p>
<p>转换分区表的目的是为了支持大于2TB的分区，如果分区并没有大于2TB，那么这步是可以不执行的。</p>
<p>**注意：**一定要把&#x2F;etc&#x2F;fstab文件中和原有分区的内容删除掉，才能重启，不然系统重启一定会报错。</p>
<h3 id="3）建立分区"><a href="#3）建立分区" class="headerlink" title="3）建立分区"></a>3）建立分区</h3><p>因为修改过分区表，所以&#x2F;dev&#x2F;sdb中的所有数据丢失了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">（parted）mkpart                                    # 输入创建分区命令</span><br><span class="line">分区名称?  []? disk1                                 # 分区名称</span><br><span class="line">文件系统类型？  [ext2]?                               # 文件系统类型，直接回车，使用默认ext2</span><br><span class="line">起始点? 1MB                                          # 分区从1MB开始</span><br><span class="line">结束点? 5GB                                          # 分区到5GB结束</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br><span class="line">1         1049kB   5000MB  4999MB                disk1</span><br></pre></td></tr></table></figure>



<h3 id="4）建立文件系统"><a href="#4）建立文件系统" class="headerlink" title="4）建立文件系统"></a>4）建立文件系统</h3><p>分区分完了，还需要格式化。不过如果使用parted交互命令格式化的话，只能格式化成ext2文件系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（parted）mkfs</span><br><span class="line">WARNING：you are attempting to use parted to operate on （mkfs） a file system. parted&#x27;s file system manipulation code is not as rebust as what you&#x27;ll find in dedicated, file-system-specific packages like e2fsprogs. We recommand you use parted only to manipulate partition tables, whenever possible. Support for performing most operations on most types of file systems will be removed in an upcoming release.</span><br><span class="line">警告：The existing file system will be destoryed and all data on the partition will be lost.</span><br><span class="line">Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes                                # 警告你格式化数据会丢失</span><br><span class="line">分区编号? 1</span><br><span class="line">文件系统类型?  [ext2]?                             # 指定文件系统类型</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br><span class="line">1         1049kB   5000MB  4999MB    ext2        disk1</span><br></pre></td></tr></table></figure>

<p>如果要格式化成ext4文件系统，需要使用Linux的mkfs命令。</p>
<h3 id="5）删除分区"><a href="#5）删除分区" class="headerlink" title="5）删除分区"></a>5）删除分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parted) rm                                     # 删除分区命令</span><br><span class="line">分区编号? 1                                      # 指定分区号</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br></pre></td></tr></table></figure>

<p>parted中的所有操作都是立即生效，没有保存生效的概念，这点和fdisk交互命令明显不同。</p>
<p>至于到底使用fdisk还是parted进行分区？推荐分区大小小于2GB，使用fdisk分区；分区大小大于2GB，使用parted分区。 </p>
<h2 id="7-swap分区"><a href="#7-swap分区" class="headerlink" title="7. swap分区"></a>7. swap分区</h2><h3 id="1）分区"><a href="#1）分区" class="headerlink" title="1）分区"></a>1）分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk /dev/sdb</span><br><span class="line">Command (m for help): t                               # 修改分区的系统id</span><br><span class="line">Selected partition 1                                  # 选择分区</span><br><span class="line">Hex code (type L to list codes)：82                    # 改为swap的id</span><br><span class="line">Changed system type of partition 1 to 82 (Linux swap / Solaris)</span><br></pre></td></tr></table></figure>



<h3 id="2）格式化"><a href="#2）格式化" class="headerlink" title="2）格式化"></a>2）格式化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkswap /dev/sdb1</span><br><span class="line">Setting up swapspace version 1, size = 522076 KiB</span><br><span class="line">no label, UUID=C3351dc3-f403-419a-9666-c24615e170fb</span><br></pre></td></tr></table></figure>



<h3 id="3）挂载"><a href="#3）挂载" class="headerlink" title="3）挂载"></a>3）挂载</h3><p>swap空间支持扩容。扩容也使用swapon命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# swapon /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>开机自动挂载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1      swap      swap      defaults      0      0</span><br></pre></td></tr></table></figure>

<p>也可以使用uuid。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>日志管理</title>
    <url>/2025/03/07/%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="日志简介"><a href="#日志简介" class="headerlink" title="日志简介"></a>日志简介</h2><h3 id="日志相关服务"><a href="#日志相关服务" class="headerlink" title="日志相关服务"></a>日志相关服务</h3><p>在CentOS 6.x中日志服务已经由rsyslogd取代了原先的syslogd服务。Redhat认为syslogd已经不能满足在工作中的需求，rsyslogd相比syslogd具有一些新的特点：</p>
<ul>
<li>基于TCP网络协议传输日志信息；</li>
<li>更安全的网络传输方式；</li>
<li>有日志消息的及时分析框架；</li>
<li>后台数据库；</li>
<li>配置文件中可以写简单的逻辑判断；</li>
<li>与syslog配置文件相兼容。</li>
</ul>
<h3 id="系统中常见的日志文件"><a href="#系统中常见的日志文件" class="headerlink" title="系统中常见的日志文件"></a>系统中常见的日志文件</h3><table>
<thead>
<tr>
<th>日志文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;var&#x2F;log&#x2F;cron</td>
<td>记录了系统定时任务相关的日志。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;cups&#x2F;</td>
<td>记录打印信息的日志。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;dmesg</td>
<td>记录了系统在开机时内核自检的信息。也可以使用dmesg命令直接查看内核自检信息。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;btmp</td>
<td>记录错误登录的日志。这个文件是二进制文件，不能直接vim查看，而要使用lastb命令查看。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;lastlog</td>
<td>记录系统中所有用户最后一次登录时间的日志。这个文件也是二进制文件，不能直接vim查看，而要使用lastlog命令查看。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;mailog</td>
<td>记录邮件信息。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;message</td>
<td>记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日志文件。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;secure</td>
<td>记录验证和授权方面的信息，只要涉及账户和密码的程序都会记录。比如说系统的登录，ssh的登录，su切换用户，sudo授权，甚至添加用户和修改用户密码都会记录在这个日志文件中。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;wtmp</td>
<td>永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、关机事件。同样这个文件也是一个二进制文件，不能直接vim，而需要使用last命令来查看。</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;run&#x2F;utmp</td>
<td>记录当前已经登录的用户的信息。这个文件会随着用户的登录和注销而不断变化，只记录当前登录用户的信息。同样这个文件不能直接vim，而要使用w,who,users等命令来查询。</td>
</tr>
</tbody></table>
<p>除了系统默认的日志之外，采用RPM方式安装的系统服务也会默认把日志记录在&#x2F;var&#x2F;log&#x2F;目录中(源码包安装的服务日志是在源码包指定目录中)。不过这些日志不是由rsyslogd服务来记录和管理的，而是各个服务器使用自己的日志管理文档来记录自身日志。</p>
<table>
<thead>
<tr>
<th>日志文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;var&#x2F;log&#x2F;httpd&#x2F;</td>
<td>RPM包安装的apache服务的默认日志目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;mail&#x2F;</td>
<td>RPM包安装的邮件服务的额外日志目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;samba&#x2F;</td>
<td>RPM包安装的samba服务的日志目录</td>
</tr>
<tr>
<td>&#x2F;var&#x2F;log&#x2F;sssd&#x2F;</td>
<td>守护进程安全服务目录</td>
</tr>
</tbody></table>
<h2 id="日志服务-rsyslogd"><a href="#日志服务-rsyslogd" class="headerlink" title="日志服务(rsyslogd)"></a>日志服务(rsyslogd)</h2><h3 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h3><p>只要是由日志服务rsyslogd记录的日志文件，他们的格式是一样的。基本日志格式包含以下四列：</p>
<ul>
<li>事件产生的时间</li>
<li>发生事件的服务器的主机名</li>
<li>产生事件的服务名或程序名</li>
<li>事件的具体信息</li>
</ul>
<h3 id="rsyslogd服务的配置文件"><a href="#rsyslogd服务的配置文件" class="headerlink" title="rsyslogd服务的配置文件"></a>rsyslogd服务的配置文件</h3><h4 id="etc-rsyslog-d-50-default-conf"><a href="#etc-rsyslog-d-50-default-conf" class="headerlink" title="&#x2F;etc&#x2F;rsyslog.d&#x2F;50-default.conf"></a>&#x2F;etc&#x2F;rsyslog.d&#x2F;50-default.conf</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auth,authpriv.*			/var/log/auth.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务名称[连接符号]日志等级    日志记录位置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">认证相关服务.所有日志等级     记录在/var/log/auth.log日志中</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>服务名称</p>
<p>我们首先需要确定rsyslogd服务可以识别哪些服务的日志，也可以理解为以下这些服务委托了rsyslogd服务来代为管理日志。这些服务如下表所示：</p>
<table>
<thead>
<tr>
<th>服务名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>auth（LOG_AUTH）</td>
<td>安全和认证相关消息(不推荐使用authpriv替代)</td>
</tr>
<tr>
<td>authpriv（LOG_AUTHPRIV）</td>
<td>安全和认证相关消息（私有的）</td>
</tr>
<tr>
<td>cron（LOG_CRON）</td>
<td>系统定时任务cront和at产生的日志</td>
</tr>
<tr>
<td>daemon（LOG_DAEMON）</td>
<td>和各个守护进程相关的日志</td>
</tr>
<tr>
<td>ftp（LOG_FTP）</td>
<td>ftp守护进程产生的日志</td>
</tr>
<tr>
<td>kern（LOG_KERN）</td>
<td>内核产生的日志（不是用户进程产生的）</td>
</tr>
<tr>
<td>local0-local7（LOG_LOCAL0-7）</td>
<td>为本地使用预留的服务</td>
</tr>
<tr>
<td>lpr（LOG_LPR）</td>
<td>打印产生的日志</td>
</tr>
<tr>
<td>Mail（LOG_MAIL）</td>
<td>邮件收发信息</td>
</tr>
<tr>
<td>news（LOG_NEWS）</td>
<td>与新闻服务器相关的日志</td>
</tr>
<tr>
<td>syslog（LOG_SYSLOG）</td>
<td>有syslogd服务产生的日志信息（虽然服务名称已经改为rsyslogd，但是很多配置都还是沿用了syslogd的，这里并没有修改服务名）。</td>
</tr>
<tr>
<td>user（LOG_USER）</td>
<td>用户等级类别的日志信息</td>
</tr>
<tr>
<td>uucp（LOG_UUCP）</td>
<td>uucp子系统的日志信息，uucp是早期linux系统进行数据传递的协议，后来也常用在新闻组服务中</td>
</tr>
</tbody></table>
</li>
<li><p>连接符号</p>
<p>日志服务连接日志等级的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">日志服务[连接符号]日志等级			日志记录位置</span><br></pre></td></tr></table></figure>

<p>在这里连接符号可以识别为：</p>
<ul>
<li>“.”代表只要比后面的等级高的（包含该等级）日志都记录下来。比如：”cron.info”代表cron服务产生的日志只要日志等级大于等于info级别，就记录。</li>
<li>“.&#x3D;”代表只记录所需等级的日志，其他等级的都不记录。比如：“*.&#x3D;emerg”代表任何日志服务产生的日志，只要等级是emerg等级就记录。这种用法极少见，了解就好。</li>
<li>“.!”代表不等于，也就是除了该等级的日志外，其他等级的日志都记录。</li>
</ul>
</li>
<li><p>日志等级</p>
<table>
<thead>
<tr>
<th>等级名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>debug（LOG_DEBUG）</td>
<td>一般的调试信息说明</td>
</tr>
<tr>
<td>info（LOG_INFO）</td>
<td>基本的通知信息</td>
</tr>
<tr>
<td>notice（LOG_NOTICE）</td>
<td>普通信息，但是有一定的重要性</td>
</tr>
<tr>
<td>warning（LOG_WARNING）</td>
<td>警告信息，但是还不会影响到服务或系统的运行</td>
</tr>
<tr>
<td>err（LOG_ERR）</td>
<td>错误信息，一般达到err等级的信息以及可以影响到服务或系统的运行了</td>
</tr>
<tr>
<td>crit（LOG_CRIT）</td>
<td>临界状况信息，比err等级还要严重</td>
</tr>
<tr>
<td>alert（LOG_ALERT）</td>
<td>警告状态信息，比crit还要严重。必须立即采取行动</td>
</tr>
<tr>
<td>emerg（LOG_EMERG）</td>
<td>疼痛等级信息，系统已经无法使用了</td>
</tr>
<tr>
<td>*</td>
<td>代表所有日志等级，比如：“authpriv.*”代表authpriv认证信息服务产生的日志，所有的日志等级都记录</td>
</tr>
</tbody></table>
<p>日志等这里还可以识别”none”，如果日志等级是none，就说明忽略这个日志服务，该服务的所有日志都不再记录。</p>
</li>
<li><p>日志记录位置</p>
<p>日志记录位置就是当前日志输出到哪个日志文件中保存，当然也可以把日志输出到印机打印，或者输出到远程日志服务器上（当然日志服务器要允许接收才行）。日志的记录位置也是固定的：</p>
<ul>
<li><p>日志文件的绝对路径</p>
<p>这是最常见的日志保存方法，如“&#x2F;var&#x2F;log&#x2F;secure”就是保存系统验证和授权信息日志的。</p>
</li>
<li><p>系统设备文件</p>
<p>如“&#x2F;dev&#x2F;lp0”代表第一台打印机，如果日志保存位置是打印机设备的话，当有日志时就会在打印机打印（不太符合可持续发展战略）。</p>
</li>
<li><p>转发给远程主机</p>
<p>因为可以选择使用TCP协议和UDP协议传输日志信息，所以有两种发送格式。如使用“@192.168.0.210:514”，就会把日志内容使用UDP协议发送到192.168.0.210的UDP 514端口上；如果使用”@@192.168.0.210:514”就会把日志内容使用TCP协议发送到192.168.0.210的TCP 514端口上，其中514是日志服务默认端口。当然只要192.168.0.210同意接收此日志，就可以把日志内容保存在日志服务器上。</p>
</li>
<li><p>用户名</p>
<p>如“root”，就会把日志发送给root用户，当然root要在线，否则就收不到日志信息了。发送日志给用户时，可以使用“*”代表发送给所有在线用户，如“mail.* *”就会把mail服务产生的所有级别的日志发送给所有在线用户。如果需要把日志发送给多个在线用户，用户名之间用“,”分隔。</p>
</li>
</ul>
</li>
</ul>
<p>忽略或丢弃日志。如果接受日志的对象是“~”，代表这个日志不会记录，而被直接丢弃。如“local3.* ~”代表忽略local3服务类型所有的日志都不记录。</p>
<h4 id="etc-rsyslog-conf配置文件内容"><a href="#etc-rsyslog-conf配置文件内容" class="headerlink" title="&#x2F;etc&#x2F;rsyslog.conf配置文件内容"></a>&#x2F;etc&#x2F;rsyslog.conf配置文件内容</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rsyslog.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/rsyslog.conf configuration file <span class="keyword">for</span> rsyslog</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># For more information install rsyslog-doc and see</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/usr/share/doc/rsyslog-doc/html/configuration/index.html</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Default logging rules can be found in /etc/rsyslog.d/50-default.conf</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载模块</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### MODULES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载imuxsock模块，为本地系统登录提供支持</span></span><br><span class="line">module(load=&quot;imuxsock&quot;) # provides support for local system logging</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载immark模块，提供标记信息的能力</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">module(load=<span class="string">&quot;immark&quot;</span>)  <span class="comment"># provides --MARK-- message capability</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载UDP模块，允许使用UDP的514端口接收采用UDP协议转发的日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides UDP syslog reception</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">module(load=<span class="string">&quot;imudp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imudp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载TCP模块，允许使用TCP的514端口接收采用TCP协议转发的日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides TCP syslog reception</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">module(load=<span class="string">&quot;imtcp&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">input(<span class="built_in">type</span>=<span class="string">&quot;imtcp&quot;</span> port=<span class="string">&quot;514&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">provides kernel logging support and <span class="built_in">enable</span> non-kernel klog messages</span></span><br><span class="line">module(load=&quot;imklog&quot; permitnonkernelfacility=&quot;on&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义全局设置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### GLOBAL DIRECTIVES ####</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">##########################</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Filter duplicated messages</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">RepeatedMsgReduction on</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Set the default permissions for all log files.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$FileOwner</span> syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileGroup adm</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">FileCreateMode 0640</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">DirCreateMode 0755</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">Umask 0022</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToUser syslog</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">PrivDropToGroup syslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Where to place spool and state files</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="variable">$WorkDirectory</span> /var/spool/rsyslog</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Include all config files in /etc/rsyslog.d/</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 包含/etc/rsyslog.d/目录中所有的&quot;.conf&quot;子配置文件。也就是说这个目录中的所有子配置文件也同时生效</span></span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">IncludeConfig /etc/rsyslog.d/*.conf</span></span><br></pre></td></tr></table></figure>

<h3 id="定义自己的日志"><a href="#定义自己的日志" class="headerlink" title="定义自己的日志"></a>定义自己的日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rsyslog.d/60-custom.conf</span><br><span class="line">*.crit				/var/log/alert.log</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把所有服务的<span class="string">&quot;临界点&quot;</span>以上的错误都保存在/var/log/alert.log日志中</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# systemctl restart syslog</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll /var/log/alert.log</span><br></pre></td></tr></table></figure>



<h2 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h2><h3 id="日志文件的命名规则"><a href="#日志文件的命名规则" class="headerlink" title="日志文件的命名规则"></a>日志文件的命名规则</h3><p>日志轮替最主要的作用就是把旧的日志文件移动并改名，同时建立新的空日志文件，当旧日志文件超出保存的范围之后，就会进行删除。那么旧的日志文件改名之后，如何命名呢？主要依靠&#x2F;etc&#x2F;logrotate.conf配置文件中“dateext”参数：</p>
<ul>
<li>如果配置文件中拥有”dateext”参数，那么日志会用日期来作为日志文件的后缀，例如“secure-20180605”。这样的话日志文件名不会重叠，所以也就不需要日志文件的改名，只需要保存指定的日志个数，删除多余的日志文件即可。</li>
<li>如果配置文件中没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时，当前的“secure”日志会自动改名为”secure.1”，然后新建”secure”日志，用来保存新的日志。当第二次进行日志轮替时，“secure.1”会自动改名为“secure.2”，当前的“secure”日志会自动改名为”secure.1”，然后也会新建”secure”日志，用来保存新的日志，以此类推。</li>
</ul>
<h3 id="logrotate配置文件"><a href="#logrotate配置文件" class="headerlink" title="logrotate配置文件"></a>logrotate配置文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/logrotate.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">see <span class="string">&quot;man logrotate&quot;</span> <span class="keyword">for</span> details</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">global options <span class="keyword">do</span> not affect preceding include directives</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">每周对日志文件进行一次轮替</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rotate <span class="built_in">log</span> files weekly</span></span><br><span class="line">weekly</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use the adm group by default, since this is the owning group</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">of /var/log/.</span></span><br><span class="line">su root adm</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存4个日志文件，也就是说如果进行了5次日志轮替，就会删除第一个备份日志</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">keep 4 weeks worth of backlogs</span></span><br><span class="line">rotate 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在日志轮替时，自动创建新的日志文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create new (empty) <span class="built_in">log</span> files after rotating old ones</span></span><br><span class="line">create</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用日期作为日志轮替文件的后缀</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">use <span class="built_in">date</span> as a suffix of the rotated file</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">dateext</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">日志文件是否压缩，如果取消注释，则日志会在转储的同时进行压缩</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment this <span class="keyword">if</span> you want your <span class="built_in">log</span> files compressed</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">compress</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">包含/etc/logrotate.d/目录中所有的子配置文件。也就是说会把这个目录中所有子配置文件读取进来，进行日志轮替。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">packages drop <span class="built_in">log</span> rotation information into this directory</span></span><br><span class="line">include /etc/logrotate.d</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">system-specific logs may also be configured here.</span> </span><br></pre></td></tr></table></figure>

<p>以上日志配置为默认配置，如果需要轮替的日志没有设定独立的参数，那么都会遵守以上参数。如果轮替日志配置了独立参数，那么独立参数优先级更高。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/logrotate.d/wtmp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">no packages own wtmp -- we<span class="string">&#x27;ll rotate it here</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">以下参数仅对此目录有效</span></span></span><br><span class="line">/var/log/wtmp &#123;</span><br><span class="line">    missingok</span><br><span class="line">    # 每月对日志文件进行一次轮替</span><br><span class="line">    monthly</span><br><span class="line">    # 建立的新日志文件,权限是0664,所有者是root，所属组是utmp组</span><br><span class="line">    create 0664 root utmp</span><br><span class="line">    # 日志文件最小轮替大小是1MB。也就是日志一定要超过1MB才会轮替，否则就算时间达到一个月，也不进行日志转储</span><br><span class="line">    minsize 1M</span><br><span class="line">    # 仅保留一个日志备份。也就是只有wtmp和wtmp.1日志保留而已</span><br><span class="line">    rotate 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>logrotate配置文件的主要参数，通过如下表说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>daily</td>
<td>日志的轮替周期是每天</td>
</tr>
<tr>
<td>weekly</td>
<td>日志的轮替周期是每周</td>
</tr>
<tr>
<td>monthly</td>
<td>日志的轮替周期是每月</td>
</tr>
<tr>
<td>rotate 数字</td>
<td>保留的日志文件的个数。0指没有备份</td>
</tr>
<tr>
<td>compress</td>
<td>日志轮替时，旧的日志进行压缩</td>
</tr>
<tr>
<td>create mode owner group</td>
<td>建立新日志，同时指定新日志的权限与所有者和所属组。如create 0600 root utmp</td>
</tr>
<tr>
<td>mail address</td>
<td>当日志轮替时，输出内容通过邮件发送到指定的邮件地址。如mail <a href="mailto:&#x61;&#97;&#97;&#x40;&#x31;&#x36;&#x33;&#x2e;&#x63;&#x6f;&#109;">aaa@163.com</a></td>
</tr>
<tr>
<td>missingok</td>
<td>如果日志不存在，则忽略该日志的警告信息</td>
</tr>
<tr>
<td>notifempty</td>
<td>如果日志为空文件，则不进行日志轮替</td>
</tr>
<tr>
<td>minsize 大小</td>
<td>日志轮替的最小值。也就是日志一定要达到这个最小值才会轮替，否则就算时间达到也不轮替</td>
</tr>
<tr>
<td>size 大小</td>
<td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替。如size 100k</td>
</tr>
<tr>
<td>dateext</td>
<td>使用日期作为日志轮替文件的后缀。如secure-20180605</td>
</tr>
<tr>
<td>sharedscripts</td>
<td>在此关键字之后的脚本只执行一次</td>
</tr>
<tr>
<td>prerotate&#x2F;endscript</td>
<td>在日志轮替之前执行脚本命令。endscript标示prerotate脚本结束。</td>
</tr>
<tr>
<td>postrotate&#x2F;endscript</td>
<td>在日志轮替之后执行脚本命令。endscript标示postrotate脚本结束。</td>
</tr>
</tbody></table>
<p>这些参数中较为不好理解的应该就是prerotate&#x2F;endscript和postrotate&#x2F;endscript参数了。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/var/log/httpd/error.log &#123;</span><br><span class="line">    rotate 5</span><br><span class="line">    mail www@my.org</span><br><span class="line">    size 100k</span><br><span class="line">    # 以下脚本只执行一次</span><br><span class="line">    sharedscripts</span><br><span class="line">    # 在日志轮替结束之后，执行以下脚本</span><br><span class="line">    postrotate</span><br><span class="line">    	# 重启apache服务</span><br><span class="line">        /usr/bin/killall -HUP httpd</span><br><span class="line">    endscript</span><br><span class="line">    # 脚本结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prerotate和postrotate主要用于在日志轮替的同时，执行指定的脚本，一般用于日志轮替之后重启服务。这里强调，如果你的日志是写入rsyslog服务的配置文件的，那么把新日志加入logrotate后，一定要重启rsyslog服务，否则你会发现虽然新日志建立了，但是数据还是写入了旧的日志当中。那是因为虽然logrotate知道日志轮替了，但是rsyslog服务并不知道。同理，如果你的日志不是被rsyslog管理，如源码包安装的Apache、Nginx等服务，则需要重启Apache或Nginx服务，否则日志也不能正常轮替。</p>
<h3 id="把自己的日志加入日志轮替"><a href="#把自己的日志加入日志轮替" class="headerlink" title="把自己的日志加入日志轮替"></a>把自己的日志加入日志轮替</h3><p>1）方法一</p>
<p>直接在&#x2F;etc&#x2F;logrotate.conf配置文件中写入该日志的轮替策略，从而把日志加入轮替。</p>
<p>2）方法二</p>
<p>在&#x2F;etc&#x2F;logrotate.d&#x2F;目录中新建立该日志的轮替文件，在该轮替文件中写入正确的轮替策略，因为该目录中的文件都会被“include”到主配置文件中，所以也可以把日志加入轮替。推荐使用此方法，因为系统中需要轮替的日志非常多，如果全部直接写入&#x2F;etc&#x2F;logrotate.conf配置文件，那么这个文件的可管理性就会非常差，不利于此文件的维护。</p>
<p>举个例子，如果需要把Nginx服务的日志加入日志轮替，则也需要重启Nginx服务。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/date/logs/nginx/access/access.log /date/logs/nginx/access/default.log &#123;</span><br><span class="line">	daily</span><br><span class="line">	rotate 15</span><br><span class="line">	sharedscripts</span><br><span class="line">	postrotate</span><br><span class="line">		# 重启rsyslog服务</span><br><span class="line">		/bin/kill -HUP $(/bin/cat /var/run/syslogd.pid) &amp;&gt;/dev/null</span><br><span class="line">		# 重启nginx服务</span><br><span class="line">		/bin/kill -HUP $(/bin/cat /usr/local/nginx/logs/nginx.pid) &amp;&gt;/dev/null</span><br><span class="line">	endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="logrotate命令"><a href="#logrotate命令" class="headerlink" title="logrotate命令"></a>logrotate命令</h3><p>日志轮替之所以可以在指定的时间备份日志，其实也要依赖系统定时任务。如果大家还记录&#x2F;etc&#x2F;cron&#x2F;daily&#x2F;目录，就会发现这个目录中是有logrotate文件，logrotate通过这个文件依赖定时任务执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# logrotate [选项] 配置文件名</span><br><span class="line">选项：</span><br><span class="line">	如果此命令没有选项，则会按照配置文件中的条件进行日志轮替</span><br><span class="line">	-v:		显示日志轮替过程。加了-v选项，会显示日志的轮替的过程</span><br><span class="line">	-f:		强制进行日志轮替。不管日志轮替的条件是否已经符合，强制配置文件中所有的日志进行轮替</span><br></pre></td></tr></table></figure>

<p>执行logrotate命令，并查看下执行过程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# logrotate -v /etc/logrotate.conf</span><br><span class="line">...</span><br><span class="line">rotating pattern: /var/log/wtmp  monthly (1 rotations)</span><br><span class="line">empty log files are rotated, only log files &gt;= 1048576 bytes are rotated, old logs are removed</span><br><span class="line">switching euid from 0 to 0 and egid from 0 to 4 (pid 39834)</span><br><span class="line">considering log /var/log/wtmp</span><br><span class="line">  Now: 2025-03-10 19:45</span><br><span class="line">  Last rotated at 2024-08-26 09:05</span><br><span class="line">  log does not need rotating (&#x27;minsize&#x27; directive is used and the log size is smaller than the minsize value)</span><br><span class="line">switching euid from 0 to 0 and egid from 4 to 0 (pid 39834)</span><br></pre></td></tr></table></figure>

<p>强制进行一次日志轮替，看看有什么效果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# logrotate -vf /etc/logrotate.conf</span><br><span class="line">...</span><br><span class="line">rotating pattern: /var/log/wtmp  forced from command line (1 rotations)</span><br><span class="line">empty log files are rotated, only log files &gt;= 1048576 bytes are rotated, old logs are removed</span><br><span class="line">switching euid from 0 to 0 and egid from 0 to 4 (pid 40773)</span><br><span class="line">considering log /var/log/wtmp</span><br><span class="line">  Now: 2025-03-10 19:48</span><br><span class="line">  Last rotated at 2024-08-26 09:05</span><br><span class="line">  log needs rotating                                 # 日志需要轮替</span><br><span class="line">rotating log /var/log/wtmp, log-&gt;rotateCount is 1</span><br><span class="line">dateext suffix &#x27;-20250310&#x27;                           # 提取日期参数</span><br><span class="line">glob pattern &#x27;-[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]&#x27;</span><br><span class="line">renaming /var/log/wtmp.1 to /var/log/wtmp.2 (rotatecount 1, logstart 1, i 1), </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">旧的日志被重命名</span></span><br><span class="line">renaming /var/log/wtmp to /var/log/wtmp.1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新日志文件</span></span><br><span class="line">creating new /var/log/wtmp mode = 0664 uid = 0 gid = 43</span><br><span class="line">removing old log /var/log/wtmp.2</span><br><span class="line">switching euid from 0 to 0 and egid from 4 to 0 (pid 40773)</span><br></pre></td></tr></table></figure>

<p>logrotate命令使用“-f”选项之后，就不管日志是否已经符合了日志轮替条件，而强制把所有的日志都进行了轮替。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>服务管理</title>
    <url>/2025/03/05/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="服务的简介与分类"><a href="#服务的简介与分类" class="headerlink" title="服务的简介与分类"></a>服务的简介与分类</h2><h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><p>Linux服务：</p>
<ul>
<li><p>RPM包默认安装的服务</p>
<ul>
<li><p>独立的服务</p>
<p>就是独立启动的意思，这类型的服务可以自行启动，而不用依赖其他的管理服务。不依赖其他管理服务，那么当客户端请求访问时，独立的服务响应请求更迅速。Linux中目前大多数服务都是独立的服务，比如apache服务，FTP服务，Samba服务等。</p>
</li>
<li><p>基于xinetd服务</p>
<p>这种服务就不能独立启动了，而是要依靠管理服务来调用这种服务。这个负责管理的服务就是xinetd服务，xinetd服务是系统的超级守护进程。xinetd服务的作用就是管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务云唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释放资源。这样做的好处是只需要持续启动xinetd服务，而其他基于xinetd的服务只有在需要时才启动，不会占用过多的服务器资源。但是这种服务由于在有客户端靖求时才会被唤醒，所以响应时间相对较慢。</p>
</li>
</ul>
</li>
<li><p>源码包安装的服务</p>
</li>
</ul>
<h3 id="查询已经安装的服务"><a href="#查询已经安装的服务" class="headerlink" title="查询已经安装的服务"></a>查询已经安装的服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --list [服务名]</span><br><span class="line">选项：</span><br><span class="line">  --list: 列出所有RPM默认安装服务的自启动状态</span><br></pre></td></tr></table></figure>



<h2 id="RPM包默认安装的服务管理"><a href="#RPM包默认安装的服务管理" class="headerlink" title="RPM包默认安装的服务管理"></a>RPM包默认安装的服务管理</h2><h3 id="独立服务管理"><a href="#独立服务管理" class="headerlink" title="独立服务管理"></a>独立服务管理</h3><h4 id="独立服务的启动管理"><a href="#独立服务的启动管理" class="headerlink" title="独立服务的启动管理"></a>独立服务的启动管理</h4><ul>
<li><p>使用&#x2F;etc&#x2F;init.d&#x2F;目录中的启动脚本启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# /etc/init.d/httpd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用service命令来启动独立的服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# service [独立服务名] start|stop|restart|...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="独立服务的自启动管理"><a href="#独立服务的自启动管理" class="headerlink" title="独立服务的自启动管理"></a>独立服务的自启动管理</h4><ul>
<li><p>使用chkconfig服务自启动管理命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig [--level 运行级别] [独立服务名] [on|off]</span><br><span class="line">选项：</span><br><span class="line">  --level:    设定在哪个运行级别中开机自启动(on)，或是关闭自启动(off)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --level 2345 httpd on</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件，设置服务自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/etc/rc.d/init.d/httpd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ntsysv命令管理自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ntsysv [--level 运行级别]</span><br><span class="line">选项：</span><br><span class="line">  --level 运行级别:  可以指定设定自启动的运行级别</span><br></pre></td></tr></table></figure>

<p>这个命令的操作是这样的：</p>
<ul>
<li>上下键：在不同服务之间移动</li>
<li>空格键：选定或取消服务的自启动，就是在服务之前是否打入“*”</li>
<li>tab键：在不同项目间切换</li>
<li>F1键：显示服务的说明</li>
</ul>
</li>
</ul>
<h3 id="基于xinetd服务的管理"><a href="#基于xinetd服务的管理" class="headerlink" title="基于xinetd服务的管理"></a>基于xinetd服务的管理</h3><h4 id="基于xinetd服务的启动"><a href="#基于xinetd服务的启动" class="headerlink" title="基于xinetd服务的启动"></a>基于xinetd服务的启动</h4><p>以telnet服务为例，telnet服务是用来进行系统远程管理的，端口是23。不过需要注意的是telnet的远程管理数据在网络中是明文传输，非常不安全。在生产服务器上不建议启动telnet服务。在生产服务器上，远程管理使用的是ssh协议，ssh是加密的，更加安全。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default: on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: The telnet server serves telnet sessions: it uses \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#       unencrypted username/password pairs for authentication.</span></span></span><br><span class="line">service telnet                                     # 服务的名称为telnet</span><br><span class="line">&#123;</span><br><span class="line">	flags				= REUSE                    # 标志为REUSE，设定TCP/IP socket可重用</span><br><span class="line">	socket_type         = stream                   # 使用TCP协议数据包</span><br><span class="line">	wait				= no					   # 允许多个连接同时连接</span><br><span class="line">	user				= root					   # 启动服务的用户为root</span><br><span class="line">	server				= /usr/sbin/in.telnetd     # 服务的启动程序</span><br><span class="line">	log_on_failure		+= USERID                  # 登录失败后，记录用户的ID</span><br><span class="line">	disable				= yes					   # 服务不启动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	disable				= no</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# service xinetd restart</span><br></pre></td></tr></table></figure>



<h4 id="基于xinetd服务的自启动"><a href="#基于xinetd服务的自启动" class="headerlink" title="基于xinetd服务的自启动"></a>基于xinetd服务的自启动</h4><ul>
<li><p>使用chkconfig命令管理自启动</p>
</li>
<li><p>使用ntsysv命令管理自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig 服务名 on|off</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码包安装的服务管理"><a href="#源码包安装的服务管理" class="headerlink" title="源码包安装的服务管理"></a>源码包安装的服务管理</h2><h3 id="源码包服务的启动管理"><a href="#源码包服务的启动管理" class="headerlink" title="源码包服务的启动管理"></a>源码包服务的启动管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/apache2/bin/apachectl start|stop|restart|...</span><br></pre></td></tr></table></figure>



<h3 id="源码包服务的自启动管理"><a href="#源码包服务的自启动管理" class="headerlink" title="源码包服务的自启动管理"></a>源码包服务的自启动管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/usr/local/apache2/bin/apachectl start</span><br></pre></td></tr></table></figure>



<h2 id="Linux中常见服务的作用"><a href="#Linux中常见服务的作用" class="headerlink" title="Linux中常见服务的作用"></a>Linux中常见服务的作用</h2><table>
<thead>
<tr>
<th>服务名称</th>
<th>功能简介</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>acpid</td>
<td>电源管理接口。如果是笔记本用户建立开启，可以监听内核层的相关电源事件</td>
<td>on</td>
</tr>
<tr>
<td>anacron</td>
<td>系统的定时任务程序。cron的一个子系统，如果定时任务错过了执行时间，可以通过anacron继续唤醒执行。</td>
<td>off</td>
</tr>
<tr>
<td>alsasound</td>
<td>Alsa声卡驱动。如果使用alsa声卡，开启</td>
<td>off</td>
</tr>
<tr>
<td>apmd</td>
<td>电源管理模块。如果支持acpid，就不需要apmd，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>atd</td>
<td>指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用crond来进行循环定时任务。</td>
<td>off</td>
</tr>
<tr>
<td>auditd</td>
<td>审核子系统。如果开启了此服务，SELinux的审核信息会写入&#x2F;var&#x2F;log&#x2F;audit&#x2F;audit.log文件，如果不开启，审核信息会记录在syslog中</td>
<td>on</td>
</tr>
<tr>
<td>autofs</td>
<td>让服务器可以自动挂载网络中的其他服务器的共享数据，一般用来自动挂载NFS服务。如果没有NFS服务建立关闭</td>
<td>off</td>
</tr>
<tr>
<td>avahi-daemon</td>
<td>Avahi是zeroconf协议的实现。它可以在没有DNS服务的局域网里发现基于zeroconf协议的设备和服务。除非有兼容设备或使用zeroconf协议，否则关闭</td>
<td>off</td>
</tr>
<tr>
<td>bluetooth</td>
<td>蓝牙设备支持。一般不会在服务器上启用蓝牙设备。</td>
<td>off</td>
</tr>
<tr>
<td>capi</td>
<td>仅对使用ISND设备的用户有用。</td>
<td>off</td>
</tr>
<tr>
<td>chargen-dgram</td>
<td>使用UDP协议的chargen server。主要功能是提供类似远程打字的功能。</td>
<td>off</td>
</tr>
<tr>
<td>chargen-stream</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>cpuspeed</td>
<td>可以用来调整CPU的频率。当闲置时可以自动降低CPU频率来节省电量</td>
<td>on</td>
</tr>
<tr>
<td>crond</td>
<td>系统的定时任务，一般的Linux服务器都需要定时任务帮助系统维护</td>
<td>on</td>
</tr>
<tr>
<td>cvs</td>
<td>一个版本控制系统</td>
<td>off</td>
</tr>
<tr>
<td>daytime-dgram</td>
<td>daytime使用TCP协议的Daytime守护进程，该协议为客户机实现从远程服务器获取日期和时间的功能。</td>
<td>off</td>
</tr>
<tr>
<td>daytime-stream</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>dovecot</td>
<td>邮件服务中POP3&#x2F;IMAP服务的守护进程。主要用来接收信件，如果启动了邮件服务则开启，否则关闭</td>
<td>off</td>
</tr>
<tr>
<td>echo-dgram</td>
<td>服务器回显客户服务的进程。</td>
<td>off</td>
</tr>
<tr>
<td>echo-stream</td>
<td>同上。</td>
<td>off</td>
</tr>
<tr>
<td>firstboot</td>
<td>系统安装完成之后，有个欢迎界面，需要对系统进程初始设定，就是这个进程的作用。既然不是第一次启动，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>gpm</td>
<td>在字符终端(tty1-tty6)中可以使用鼠标复制和粘贴。就是这个服务的功能。</td>
<td>on</td>
</tr>
<tr>
<td>haldaemon</td>
<td>检测盒支持USB设备。如果是服务器可以关闭，个人建议关闭</td>
<td>off</td>
</tr>
<tr>
<td>hidd</td>
<td>蓝牙鼠标、键盘等蓝牙设备检测。必须启动bluetooth服务。</td>
<td>off</td>
</tr>
<tr>
<td>hplip</td>
<td>HP打印机支持，如果没有HP打印机则关闭</td>
<td>off</td>
</tr>
<tr>
<td>httpd</td>
<td>apache服务的守护进程。如果需要启动apache，则开启</td>
<td>on</td>
</tr>
<tr>
<td>ip6tables</td>
<td>IPv6防火墙，目前IPv6协议并没有使用，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>iptables</td>
<td>防火墙功能，Linux中防火墙是内核支持功能，这是服务器的主要防护手段，必须开启</td>
<td>on</td>
</tr>
<tr>
<td>irda</td>
<td>IrDA提供红外线设备(笔记本、PDA’s，手机，计算器等等)间的通讯支持。</td>
<td>off</td>
</tr>
<tr>
<td>irqbalance</td>
<td>支持多核处理器，让CPU可以自动分配系统中断(IRQ)，提高系统性能。</td>
<td>on</td>
</tr>
<tr>
<td>isdn</td>
<td>使用ISDN设备连接网络。目前主流的联网方式是光纤接入和ADSL，ISDN已经非常少见</td>
<td>off</td>
</tr>
<tr>
<td>kudzu</td>
<td>该服务可以在开机时进行硬件检测，并会调用相关的设置软件。</td>
<td>off</td>
</tr>
<tr>
<td>lvm2-monitor</td>
<td>该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM方式，那么应该开启</td>
<td>on</td>
</tr>
<tr>
<td>mcstrans</td>
<td>SELinux的支持服务</td>
<td>on</td>
</tr>
<tr>
<td>mdmonitor</td>
<td>该服务用来监测Software RAID或LVM的信息。不是必须服务</td>
<td>off</td>
</tr>
<tr>
<td>mdmpd</td>
<td>该服务用来监测Multi-Path设备</td>
<td>off</td>
</tr>
<tr>
<td>messagebus</td>
<td>这是Linuxr IPC（Interprocess Communication, 进程间通讯）服务，用来在各个软件中交换信息</td>
<td>off</td>
</tr>
<tr>
<td>microcode_ctl</td>
<td>Intel系列的CPU可以通过这个服务支持额外的微指令集。</td>
<td>off</td>
</tr>
<tr>
<td>mysqld</td>
<td>mysql数据库服务器。如果需要就开启，</td>
<td>off</td>
</tr>
<tr>
<td>named</td>
<td>DNS服务的守护进程，用来进行域名解析。如果是DNS服务器则开启</td>
<td>off</td>
</tr>
<tr>
<td>netfs</td>
<td>该服务用于在系统启动时自动挂载网络中的共享文件空间，比如：NFS, Samba等。需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>network</td>
<td>提供网络设置功能。通过这个服务来管理网络</td>
<td>on</td>
</tr>
<tr>
<td>nfs</td>
<td>NFS（Network File System）服务，Linux与Linux之间的文件共享服务。需要就开启</td>
<td>off</td>
</tr>
<tr>
<td>nfslock</td>
<td>在Linux中如果使用了NFS服务，为了避免同一个文件被不同的用户编辑，所以有了这个锁服务。有NFS是开启</td>
<td>off</td>
</tr>
<tr>
<td>ntpd</td>
<td>该服务可以通过互联网自动更新系统时间，使系统时间永远都准确。需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>pcscd</td>
<td>智能卡检测服务</td>
<td>off</td>
</tr>
<tr>
<td>portmap</td>
<td>用在远程过程调用（RPC）的服务，如果没有任何RPC服务时，可以关闭，主要是NFS和NIS服务需要</td>
<td>off</td>
</tr>
<tr>
<td>psacct</td>
<td>该守护进程支持几个监控进程活动的工具。</td>
<td>off</td>
</tr>
<tr>
<td>rdisc</td>
<td>客户端ICMP路由协议</td>
<td>off</td>
</tr>
<tr>
<td>readahead_early</td>
<td>在系统开机的时候，先将某些进程加载如内存整理，可以加快一点启动速度。</td>
<td>off</td>
</tr>
<tr>
<td>readahead_later</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>restorecond</td>
<td>用于给SELinux监测和重新加载正确的文件上下文。如果开启SELinux则需要开启。</td>
<td>off</td>
</tr>
<tr>
<td>rpcgssd</td>
<td>与NFS有关的客户端功能</td>
<td>off</td>
</tr>
<tr>
<td>rpcidmapd</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>rsync</td>
<td>远程数据备份守护进程</td>
<td>off</td>
</tr>
<tr>
<td>sendmail</td>
<td>sendmail邮件服务的守护进程。如果有邮件服务就开启</td>
<td>off</td>
</tr>
<tr>
<td>setroubleshoot</td>
<td>该服务用于将SELinux相关信息记录在日志&#x2F;var&#x2F;log&#x2F;messages中</td>
<td>on</td>
</tr>
<tr>
<td>smartd</td>
<td>该服务用于自动检则硬盘状态</td>
<td>on</td>
</tr>
<tr>
<td>smb</td>
<td>网络服务samba守护进程。可以让Linux和Windows之间共享数据。如果需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>squid</td>
<td>代理服务的守护进程。</td>
<td>off</td>
</tr>
<tr>
<td>sshd</td>
<td>ssh加密远程登录管理的服务。</td>
<td>on</td>
</tr>
<tr>
<td>syslog</td>
<td>日志的守护进程。</td>
<td>on</td>
</tr>
<tr>
<td>vsftpd</td>
<td>vsftpd服务的守护进程。如果需要FTP服务则开启</td>
<td>off</td>
</tr>
<tr>
<td>xfs</td>
<td>这个是X Window的字体守护进程。为图形界面提供字体服务，如果不启动图形界面就不用开启</td>
<td>off</td>
</tr>
<tr>
<td>xinetd</td>
<td>超级守护进程。如果有依赖xinetd的服务就必须开启</td>
<td>off</td>
</tr>
<tr>
<td>ypbind</td>
<td>为NIS(网络信息系统)客户机激活ypbind服务进程。</td>
<td>off</td>
</tr>
<tr>
<td>yum-updatesd</td>
<td>yum的在线升级服务</td>
<td>off</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>权限管理</title>
    <url>/2025/02/25/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><h2 id="1-ACL权限"><a href="#1-ACL权限" class="headerlink" title="1. ACL权限"></a>1. ACL权限</h2><h3 id="1）ACL概述"><a href="#1）ACL概述" class="headerlink" title="1）ACL概述"></a>1）ACL概述</h3><p>ACL是用于解决用户对文件身份不足问题的。</p>
<h3 id="2）开启ACL"><a href="#2）开启ACL" class="headerlink" title="2）开启ACL"></a>2）开启ACL</h3><p>查询acl是否开启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dumpe2fs命令是查询指定分区详细文件系统信息的命令</span></span><br><span class="line">dumpe2fs -h &lt;根分区&gt;</span><br><span class="line">选项：</span><br><span class="line">  -h:    仅显示超级地中信息，而不显示磁盘块组的详细信息。</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> Default mount options:     user_xattr acl</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>如果没有开启，手工开启分区的ACL权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新挂载根分区，并挂载加入acl权限</span></span><br><span class="line">mount -o remount,acl /</span><br></pre></td></tr></table></figure>

<p>也可以通过修改&#x2F;etc&#x2F;fstab文件，永久开启ACL权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line">UUID=6f9a4f35-3b8f-425e-b8f3-4d46dbca87ad /               ext4       defaults.acl 0       1</span><br></pre></td></tr></table></figure>

<p>验证目录ACL权限存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -ahl /</span><br><span class="line">drwxrwx---+   2 sc   tg         4096  2月 14 20:19 www/</span><br><span class="line"># “+”代表有ACL权限</span><br></pre></td></tr></table></figure>



<h3 id="3）ACL基本命令"><a href="#3）ACL基本命令" class="headerlink" title="3）ACL基本命令"></a>3）ACL基本命令</h3><p>a）查询文件的ACL权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getfacl 文件名</span><br></pre></td></tr></table></figure>



<p>b）设定ACL权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setfacl [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -m    设定ACL权限</span><br><span class="line">  -b    删除ACL权限</span><br><span class="line">  -x    删除单个用户的ACL权限</span><br><span class="line">  -R    递归(只能赋予目录，且只对已经存在的文件生效)</span><br><span class="line"></span><br><span class="line">setfacl -m u:用户名:权限(1|2|4|5|7) 文件名</span><br><span class="line">setfacl -m g:组名:权限(1|2|4|5|7) 文件名</span><br><span class="line"></span><br><span class="line"># 赋予ACL默认权限。默认权限只能赋予目录，且只对以后新建的文件生效</span><br><span class="line">setfacl -m d:u:用户名|组名:权限(1|2|4|5|7) 目录</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 给test目录赋予aa用户读写执行的ACL权限</span><br><span class="line">setfacl -m u:aa:rwx /test</span><br><span class="line"></span><br><span class="line"># 赋予递归ACL权限</span><br><span class="line">setfacl -m u:cc:rx -R soft/</span><br><span class="line"></span><br><span class="line"># ACL默认权限</span><br><span class="line">setfacl -m d:u:aa:rwx -R soft/</span><br></pre></td></tr></table></figure>

<p>**注意：**ACL权限，一旦递归后，不可避免的出现权限溢出。因为x权限对目录来说相当于cd，而对文件是最大权限。所以ACL权限能不用则不用。</p>
<h3 id="4）最大有效权限-mask"><a href="#4）最大有效权限-mask" class="headerlink" title="4）最大有效权限(mask)"></a>4）最大有效权限(mask)</h3><p>即最大ACL权限。设定用户或组ACL权限后，该用户或组最终权限是最大ACL权限(mask权限)与该用户或组权限逻辑与的结果的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设定mask权限为r-x,使用“m:权限”格式</span><br><span class="line">setfacl -m m:rx project/</span><br><span class="line"></span><br><span class="line"># 查询project/目录权限</span><br><span class="line"># file: project/</span><br><span class="line"># owner: root</span><br><span class="line"># group: tgroup</span><br><span class="line">user::rwx              #effective:r-x</span><br><span class="line">group::rwx             #effective:r-x</span><br><span class="line">mask::r-x</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>



<h3 id="5）删除ACL权限"><a href="#5）删除ACL权限" class="headerlink" title="5）删除ACL权限"></a>5）删除ACL权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除指定用户和用户组的ACL权限</span><br><span class="line">setfacl -x u:st /project/</span><br><span class="line"></span><br><span class="line"># 删除文件的所有ACL权限</span><br><span class="line">setfacl -b /project/</span><br></pre></td></tr></table></figure>



<h2 id="2-sudo授权"><a href="#2-sudo授权" class="headerlink" title="2. sudo授权"></a>2. sudo授权</h2><p>给普通用户赋予部分管理员权限。</p>
<p>在&#x2F;sbin&#x2F;和&#x2F;usr&#x2F;sbin&#x2F;目录下的命令只有超级用户才能使用。</p>
<h3 id="1）root身份"><a href="#1）root身份" class="headerlink" title="1）root身份"></a>1）root身份</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 执行visudo命令，赋予普通用户权限命令，命令执行后和vi一样使用</span><br><span class="line">visudo</span><br><span class="line"></span><br><span class="line">root     ALL=(ALL)                         ALL</span><br><span class="line">#用户名   被管理主机的地址=(可使用的身份)       授权命令(绝对路径)</span><br><span class="line"># %wheel        ALL=(ALL)                              ALL</span><br><span class="line">#%组名           被管理主机的地址=(可使用的身份)            授权命令(绝对路径)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用户名&#x2F;组名：代表root给哪个用户或用户组赋予命令，注意组名前加“%”。</p>
</li>
<li><p>用户可以用指定的命令管理指定IP地址的服务器。如果写ALL，代表可以管理任务主机，如果写固定IP，代表用户可以管理指定的服务器。(这里的IP指定的是用户可以管理哪个IP地址的服务器，那么如果你是一台独立的服务器，这里写ALL和你服务器的IP地址，作用是一样的。而写入网段，只有对NIS服务这样用户和密码集中管理的服务器才有意义)。如果我们这里写本机的IP地址，不代表只允许本机的用户使用指定命令，而代表指定的用户可以从任何IP地址来管理当前服务器。</p>
</li>
<li><p>可使用身份：就是把来源用户切换成什么身份使用，(ALL)代表可以切换成任意身份。这个字段可以省略。</p>
</li>
<li><p>授权命令：代表root把什么命令授权给普通用户。默认是ALL，代表任何命令，这个当然不行，如果需要给哪个命令授权，写入命令名即可。不过需要注意一定要命令写成绝对路径。</p>
</li>
</ul>
<p>【示例1】：授权用户user1可以重启服务器。</p>
<p>则由root用户添加如下行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">user1         ALL=/sbin/shutdown -r now</span><br><span class="line"></span><br><span class="line"># 查看可用的授权</span><br><span class="line">[user1@localhost ~]$ sudo -l</span><br><span class="line"></span><br><span class="line"># 执行授权命令</span><br><span class="line">[user1@localhost ~]$ sudo /sbin/shutdown -r now</span><br></pre></td></tr></table></figure>



<p>【示例2】：授权一个用户管理web服务器。</p>
<p>首先要分析授权用户管理Apache至少要实现哪些基本授权：</p>
<ul>
<li>可以使用Apache管理脚本</li>
<li>可以修改Apache配置文件</li>
<li>可以更新网页内容</li>
</ul>
<p>假设Apache管理脚本程序为&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;httpd。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># visudo授权</span><br><span class="line">[root@loaclhost ~]# visudo</span><br><span class="line">user1      192.168.0.156=/etc/rc.d/init.d/httpd reload,/etc/rc.d/init.d/httpd configtest</span><br></pre></td></tr></table></figure>

<p>授权用户user1可以连接192.168.0.156上的Apache服务器，通过Apache管理脚本重新读取配置文件让更改的设置生效(reload)和可以检测Apache配置文件语法错误(configtest)。</p>
<p>为满足条件二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">user1      192.168.0.156=/usr/bin/vim /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure>

<p>授权用户user1可以用root身份使用vi编辑Apache配置文件。</p>
<p>为满足条件三，假设网页存放目录为&#x2F;var&#x2F;www&#x2F;html，则只需要授权user1对此目录具有写权限或者索性更改目录所有者为user1即可。如果需要，还可以设置user1可以通过FTP等文件共享服务更新网页。</p>
<p>【示例3】：授权aa用户可以添加其他普通用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">aa    ALL=/usr/sbin/useradd</span><br><span class="line">aa    ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd &quot;&quot;, !/usr/bin/passwd root    # 不能改root用户密码</span><br></pre></td></tr></table></figure>



<h2 id="3-文件特殊权限"><a href="#3-文件特殊权限" class="headerlink" title="3.文件特殊权限"></a>3.文件特殊权限</h2><h3 id="1）SetUID"><a href="#1）SetUID" class="headerlink" title="1）SetUID"></a>1）SetUID</h3><p>a）SetUID概念</p>
<p>SetUID的功能可以这样理解：</p>
<ul>
<li>只有可以执行的文件才能设定SUID权限</li>
<li>命令执行者要对该程序拥有x（执行）权限</li>
<li>命令执行者在执行该程序时获得该程序文件属主的身份(在执行程序的过程中灵魂附体为文件的属主)</li>
<li>SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /etc/passwd</span><br><span class="line">-rw-r--r-- 1 root root 3626  2月 15 11:38 /etc/passwd</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll /etc/shadow</span><br><span class="line">-rw-r----- 1 root shadow 2092  2月 15 11:37 /etc/shadow</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 root root 64152  5月 30  2024 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p>&#x2F;usr&#x2F;bin&#x2F;passwd命令拥有特殊权限SetUID，也就是在属主的权限位的执行权限上是s。可以这样来理解它：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。&#x2F;usr&#x2F;bin&#x2F;passwd命令具有SetUID权限，所有者为root（Linux中的命令默认所有者都是root），也就是说当普通用户使用passwd更改自己密码的时候，那一瞬间突然灵魂附体了，实际是用passwd命令所有者root的身份在执行passwd命令，root当然可以将密码写入&#x2F;etc&#x2F;shadow文件，所以普通用户也可以修改&#x2F;etc&#x2F;shadow文件，命令执行完成后该身份也随之消失。如果取消SetUID权限，则普通用户就不能修改自己的密码了。</p>
<p>b）设置SetUID权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置SetUID权限</span><br><span class="line">[root@localhost ~]# chmod u+s /usr/bin/vim      # 极其危险，意味着把服务器送给别人了，别人可以打开、修改任何文件了</span><br><span class="line"></span><br><span class="line"># 查看SetUID权限</span><br><span class="line">[root@localhost ~]# ll /usr/bin/vim</span><br><span class="line">-rwsr-xr-x 1 root root 1847752 4月 5 2012 /usr/bin/vim </span><br></pre></td></tr></table></figure>



<p>c）建议</p>
<ul>
<li>关键目录应严格控制写权限，比如“&#x2F;”、“&#x2F;usr”等；</li>
<li>用户的密码设置要严格遵守密码三原则；</li>
<li>对系统中默认应该具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限。</li>
</ul>
<p>d）检测SetUID的脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: ben (E-main: 326525276@qq.com)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索系统中所有拥有SUID和SGID的文件，并保存到临时目录中</span></span><br><span class="line">find / -perm -4000 -o -perm -2000 &gt; /tmp/setuid.check</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">做循环，每次循环取出临时文件中的文件名</span></span><br><span class="line">for i in $(cat /tmp/setuid.check)</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">比对这个文件名是否在模板文件中</span></span><br><span class="line">	grep $i /root/suid.list &gt; /dev/null</span><br><span class="line">	if [&quot;$?&quot; != &quot;0&quot;]</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果在，不报错</span></span><br><span class="line">	then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果文件不在模板文件中，则报错，并把报错存在日志中</span></span><br><span class="line">		echo &quot;$i isn&#x27;t in listfile!&quot; &gt;&gt; /root/suid_log_$(date +%F)</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件</span></span><br><span class="line">rm -rf /tmp/setuid.check</span><br></pre></td></tr></table></figure>



<h3 id="2）SetGID"><a href="#2）SetGID" class="headerlink" title="2）SetGID"></a>2）SetGID</h3><p>SGID既可以针对文件生效，也可以针对目录生效。这和SUID明显不同。</p>
<p>a）针对文件的作用</p>
<p>针对文件，SGID的含义如下：</p>
<ul>
<li>只有可执行的文件才能设置SGID权限</li>
<li>命令执行者要对该文件拥有x（执行）权限</li>
<li>命令执行者在执行文件的时候，组身份升级为该文件的属组</li>
<li>SetGID权限同样只在该文件执行过程中有效，也就是说组身份改变只在文件执行过程中有效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /var/lib/mlocate/mlocate.db</span><br><span class="line">-rw-r----- 1 root slocate 1838850 1月    20 04：29 /var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>

<p>属主权限是r、w，属组权限是r，其他人权限是0；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /usr/bin/locate</span><br><span class="line">-rwx--s--x. 1 root slocate 38464  8月 24 2010 /usr/bin/locate    # 所属组s代表SetGID权限</span><br></pre></td></tr></table></figure>

<p>当普通用户user1执行locate命令时，会发生如下事情：</p>
<ul>
<li>&#x2F;usr&#x2F;bin&#x2F;locate是可执行二进制程序，可以赋予SGID</li>
<li>执行用户user1对&#x2F;usr&#x2F;bin&#x2F;locate命令拥有执行权限</li>
<li>执行&#x2F;usr&#x2F;bin&#x2F;locate命令时，组身份会升级为slocate组，而slocate组对&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db数据库拥有r权限，所以普通用户可以使用locate</li>
</ul>
<p>命令查询mlocate.db数据库</p>
<ul>
<li>命令结束，user1用户的组身份返回为user1组</li>
</ul>
<p>b）针对目录的作用</p>
<p>如果SGID针对目录设置，含义如下：</p>
<ul>
<li>普通用户必须对此目录拥有r和x权限，才能进入此目录</li>
<li>普通用户在此目录中的有效组会变成此目录的属组</li>
<li>若普通用户对此目录拥有w权限时，新建的文件的默认属组就是这个目录的属组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入临时目录</span><br><span class="line">[root@localhost ~]# cd /tmp</span><br><span class="line"># 建立测试目录</span><br><span class="line">[root@localhost tmp]# mkdir dtest</span><br><span class="line"># 给测试目录赋予SGID</span><br><span class="line">[root@localhost tmp]# chmod g+s dtest</span><br><span class="line"># 查询SGID是否生效</span><br><span class="line">[root@localhost tmp]# ll -d dtest/</span><br><span class="line">drwxr-sr-x 2 root root 4096 1月 20 06：04 dtest/</span><br><span class="line"># 给测试目录权限，让普通用户可以写</span><br><span class="line">[root@localhost tmp]# chmod 777 dtest/</span><br><span class="line"># 切换成普通用户user1</span><br><span class="line">[root@localhost tmp]# su - user1</span><br><span class="line"># 普通用户进入测试目录</span><br><span class="line">[user1@localhost ~]$ cd /tmp/dtest/</span><br><span class="line"># 普通用户建立abc文件</span><br><span class="line">[user1@localhost ~]$ touch abc</span><br><span class="line"># abc文件的默认属组是root, 说明SGID生效</span><br><span class="line">[user1@localhost ~]$ ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-rw-r-- 1 user1 root 0 1月 20 06：07 abc</span><br></pre></td></tr></table></figure>



<h3 id="3）Sticky-BIT"><a href="#3）Sticky-BIT" class="headerlink" title="3）Sticky BIT"></a>3）Sticky BIT</h3><p>Sticky BIT粘着位，也简称为SBIT，SBIT目前仅针对目录有效。</p>
<p>SBIT作用如下：</p>
<ul>
<li>粘着位目录只对目录有效</li>
<li>普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限</li>
<li>如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件，一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。</li>
</ul>
<h3 id="4）设定文件特殊权限"><a href="#4）设定文件特殊权限" class="headerlink" title="4）设定文件特殊权限"></a>4）设定文件特殊权限</h3><p>特殊权限：</p>
<ul>
<li>4代表SUID</li>
<li>2代表SGID</li>
<li>1代表SBIT</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 赋予SUID权限</span><br><span class="line">[root@localhost ~]# chmod 4755 ftest              # 或者chmod u+s ftest</span><br><span class="line"></span><br><span class="line"># 赋予SGID权限</span><br><span class="line">[root@localhost ~]# chmod 2755 ftest              # 或者chmod g+s ftest</span><br><span class="line"></span><br><span class="line"># 赋予SBIT权限</span><br><span class="line">[root@localhost ~]# mkdir dtest</span><br><span class="line">[root@localhost ~]# chmod 1755 dtest/             # 或者chmod o+t ftest</span><br></pre></td></tr></table></figure>



<h2 id="4-文件系统属性chattr权限"><a href="#4-文件系统属性chattr权限" class="headerlink" title="4. 文件系统属性chattr权限"></a>4. 文件系统属性chattr权限</h2><p>a）命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]chattr [+-=] [选项] 文件或目录名</span><br><span class="line">选项：</span><br><span class="line">  +：    增加权限</span><br><span class="line">  -：    删除权限</span><br><span class="line">  =：    等于某权限</span><br><span class="line">  i：    如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和          删除文件</span><br><span class="line">  a：    如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许          删除</span><br><span class="line">  e：    Linux中绝大多数的文件都默认拥有e属性。表示该文件是使用ext文件系统进行存储的，而且不能使用“chattr -e”命令取消e属性</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 赋予文件i属性</span><br><span class="line">chattr +i abc</span><br><span class="line"></span><br><span class="line"># 取消文件i属性</span><br><span class="line">chattr -i abc</span><br><span class="line"></span><br><span class="line"># 赋予目录i属性</span><br><span class="line">chattr +i bcd/</span><br><span class="line"></span><br><span class="line"># 取消目录i属性</span><br><span class="line">chattr -i bcd/</span><br></pre></td></tr></table></figure>



<p>b) 查看文件系统属性(lsattr)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lsattr 选项 文件名</span><br><span class="line">选项：</span><br><span class="line">  -a:    显示所有文件和目录</span><br><span class="line">  -d:    若目标是目录，仅列出目录本身的属性，而不是子文件</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>用户管理</title>
    <url>/2025/02/25/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="1-用户相关文件"><a href="#1-用户相关文件" class="headerlink" title="1. 用户相关文件"></a>1. 用户相关文件</h2><h3 id="1）用户信息文件"><a href="#1）用户信息文件" class="headerlink" title="1）用户信息文件"></a>1）用户信息文件</h3><p>&#x2F;etc&#x2F;passwd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一列：用户名</p>
</li>
<li><p>第二列：密码位</p>
<p>x为密码标志位，代表用户有密码，用户密码放置在&#x2F;etc&#x2F;shadow文件中。</p>
</li>
<li><p>第三列：用户ID</p>
<ul>
<li>0：超级用户UID，如果用户UID为0，代表这个账号是管理员账号。那Linux中如何把普通用户升级为管理员呢？就是把其他用户的UID修改为0就可以了。不过不建议建立多个管理员账号。</li>
<li>1-499：系统用户(伪用户)UID，这些UID账号是系统保留给系统用户的UID，也就是说UID是1-499范围内的用户是不能登录系统的，而是用来运行系统或服务的，其中1-99是系统保留的账号，系统自动创建。100-499是预留给用户创建系统账号的。</li>
<li>500-65535：普通用户UID。建立的普通用户UID从500开始，最大到65535。这些用户足够使用了，但是如果不够也不用害怕，2.6.x内核以后的Linux系统用户UID已经可以支持2的32次方了。</li>
</ul>
</li>
<li><p>第四列：组ID（GID）</p>
<p>添加用户时，如果不指定用户所属的初始组，那么会建立和用户名相同的组。</p>
</li>
<li><p>第五列：用户说明</p>
</li>
<li><p>第六列：用户家目录（~）</p>
</li>
<li><p>第七列：登录shell（标准是&#x2F;bin&#x2F;bash）</p>
</li>
</ul>
<h3 id="2）影子文件"><a href="#2）影子文件" class="headerlink" title="2）影子文件"></a>2）影子文件</h3><p>&#x2F;etc&#x2F;shadow</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$6$jvGI3Z2PqL/TT4lT$q1lVTdba3dRsmWsEJVHzTqAHOSlb3qvM/hL7wKTQCo5148xfMiT0mnq1zQ7n7wCZu/QEdtP/57BVko4X6U4in0:18929:0:99999:7:::</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一列：用户名</p>
</li>
<li><p>第二列：加密密码</p>
<p>我们也可以在密码前人为的加入“!”或“*”改变加密值让密码暂时失效，使这个用户无法登录，达到暂时禁止用户登录的效果。</p>
<p>所有伪用户的密码都是”!!”或“*”，代表没有密码是不能登录的。当然新创建的用户如果不设定密码，它的密码项也是”!!”，代表这个用户没有密码，不能登录。</p>
</li>
<li><p>第三列：密码最近更改时间（day），1970年1月1日作为标准时间</p>
<p>时间戳转日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date -d &quot;1970-01-01 18929 days&quot;</span><br><span class="line">2021年 10月 29日 星期五 00:00:00 CST</span><br></pre></td></tr></table></figure>

<p>日期转时间戳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $(($(date --date=&quot;2021/10/29&quot; +%s)/86400+1))</span><br><span class="line">18929</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四列：两次密码的修改间隔时间（和第3个字段相比）</p>
</li>
<li><p>第五列：密码有效期(和第3个字段相比)</p>
</li>
<li><p>第六列：密码修改到期前警告天数(和第5个字段相比)</p>
</li>
<li><p>第七列：密码过期后的宽限天数(和第5个字段相比)</p>
</li>
<li><p>第八列：密码失效时间</p>
<p>这里同样要写时间戳，也就是用1970年1月1日进行时间换算，如果超过了失效时间，就算密码没有过期，用户也就失效无法使用了。</p>
</li>
<li><p>第九列：保留</p>
</li>
</ul>
<h3 id="3）组信息文件"><a href="#3）组信息文件" class="headerlink" title="3）组信息文件"></a>3）组信息文件</h3><p>&#x2F;etc&#x2F;group</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:x:0:</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：组名</li>
<li>第二列：组密码位</li>
<li>第三列：GID</li>
<li>第四列：此组中支持的其他用户，附加组是此组的用户<ul>
<li>初始组：每个用户初始组只能有一个，一般都是和用户名相同的组作为初始组。</li>
<li>附加组：每个用户可以属于多个附加组。要把用户加入组，都是加入附加组。</li>
</ul>
</li>
</ul>
<h3 id="4）组密码文件-不建议使用"><a href="#4）组密码文件-不建议使用" class="headerlink" title="4）组密码文件(不建议使用)"></a>4）组密码文件(不建议使用)</h3><p>&#x2F;etc&#x2F;gshadow</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:*::</span><br></pre></td></tr></table></figure>

<p>如果给用户组设定了组管理员，并给该用户组设定了组密码，组密码就保存在这个文件当中。组管理员就可以利用这个密码管理这个用户组了。</p>
<h3 id="5）用户家目录"><a href="#5）用户家目录" class="headerlink" title="5）用户家目录"></a>5）用户家目录</h3><h3 id="6）用户邮箱目录"><a href="#6）用户邮箱目录" class="headerlink" title="6）用户邮箱目录"></a>6）用户邮箱目录</h3><p>这个邮箱在&#x2F;var&#x2F;spool&#x2F;mail目录当中，例如lamp用户的邮箱就是&#x2F;var&#x2F;spool&#x2F;mail&#x2F;lamp文件</p>
<h3 id="7）用户模板目录"><a href="#7）用户模板目录" class="headerlink" title="7）用户模板目录"></a>7）用户模板目录</h3><p>&#x2F;etc&#x2F;skel&#x2F;</p>
<p>用户家目录初始化时的模板目录。</p>
<h2 id="2-用户管理命令"><a href="#2-用户管理命令" class="headerlink" title="2.用户管理命令"></a>2.用户管理命令</h2><h3 id="1）添加用户"><a href="#1）添加用户" class="headerlink" title="1）添加用户"></a>1）添加用户</h3><p>a）手工删除用户</p>
<p>手工删除用户试验：手工删除，如果可以正常建立用户，证明用户删除干净。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建用户，就是写入这6个文件</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/group</span><br><span class="line">/etc/gshadow</span><br><span class="line">/home/user1</span><br><span class="line">/var/spool/mail/user1</span><br></pre></td></tr></table></figure>



<p>b）useradd命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br><span class="line">选项：</span><br><span class="line">  -u：UID   指定UID</span><br><span class="line">  -g：组名   指定初始组，不要手工指定</span><br><span class="line">  -G：组名   指定附加组，把用户加入组，使用附加组</span><br><span class="line">  -c：说明   添加说明</span><br><span class="line">  -d：目录   手工指定家目录，目录不需要事先建立</span><br><span class="line">  -s：shell  /bin/bash</span><br><span class="line">  -m：创建家目录</span><br></pre></td></tr></table></figure>



<p>c）useradd默认值</p>
<p>useradd添加用户时参考的默认值文件主要有两个：</p>
<ul>
<li><p>&#x2F;etc&#x2F;default&#x2F;useradd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># useradd defaults file</span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=yes</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GROUP&#x3D;100</p>
<p>这个选项是建立用户的默认组，也就是说添加每个用户时，用户的初始组就是GID为100的这个用户组。</p>
</li>
<li><p>HOME&#x3D;&#x2F;home</p>
<p>这个选项是用户的家目录的默认位置，所以所有的新建用户的家目录默认都在&#x2F;home&#x2F;下。</p>
</li>
<li><p>INACTIVE&#x3D;-1</p>
<p>这个选项就是密码过期后的宽限天数，也就是&#x2F;etc&#x2F;shadow文件的第七个字段。如果是天数，比如10代表密码过期后10天后失效；如果是0，代表密码过期后立即失效；如果是-1，则代表密码永远不会失效。这是默认值是-1，所以所有新建立的用户密码都不会失效。</p>
</li>
<li><p>EXPIRE&#x3D;</p>
<p>这个选项是密码失效时间，也就是&#x2F;etc&#x2F;shadow文件的第八个字段，也就是说用户到达这个日期后就会直接失效。当然这里也是使用时间戳来表示日期的。默认是空，所以所有新建用户没有失效时间。永久有效。</p>
</li>
<li><p>SHELL&#x3D;&#x2F;bin&#x2F;bash</p>
<p>这个选项是用户的默认shell。&#x2F;bin&#x2F;bash是Linux的标志shell，所以所有新建立的用户默认都具备shell赋予的权限。</p>
</li>
<li><p>SKEL&#x3D;&#x2F;etc&#x2F;skel</p>
<p>这个选项就是定义用户的模板目录的位置，&#x2F;etc&#x2F;skel&#x2F;目录中的文件都会复制到新建用户的家目录当中。</p>
</li>
<li><p>CREATE_MAIL_SPOOL&#x3D;yes</p>
<p>这个选项定义是否给新建用户建立邮箱，默认是创建，也就是说所有的新建用户系统都会新建一个邮箱，放在&#x2F;var&#x2F;spool&#x2F;mail&#x2F;下，和用户名相同。</p>
</li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;login.defs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIL_DIR        /var/spool/mail</span><br><span class="line"></span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DYAS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line"></span><br><span class="line">UID_MIN         500</span><br><span class="line">UID_MAX         60000</span><br><span class="line"></span><br><span class="line">GID_MIN         500</span><br><span class="line">GID_MAX         60000</span><br><span class="line"></span><br><span class="line">CREATE_HOME     yes</span><br><span class="line"></span><br><span class="line">UMASK           077</span><br><span class="line"></span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line"></span><br><span class="line">ENCRYPT_METHOD  SHA512</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MAIL_DIR          &#x2F;var&#x2F;spool&#x2F;mail</p>
<p>这行指定了新建用户的默认邮箱位置。比如lamp用户的邮箱就是&#x2F;var&#x2F;spool&#x2F;mail&#x2F;lamp。</p>
</li>
<li><p>PASS_MAX_DAYS    99999</p>
<p>这行指定的是密码的有效期，也就是&#x2F;etc&#x2F;shadow文件的第五个字段。代表多少天之后必须修改密码，默认值是99999</p>
</li>
<li><p>PASS_MIN_DAYS    0</p>
<p>这行指定是两次密码的修改间隔时间，也就是&#x2F;etc&#x2F;shadow文件的第四个字段。代表第一次修改密码之后，几天后才能再次修改密码，默认值是0</p>
</li>
<li><p>PASS_MIN_LEN    5</p>
<p>这行代表密码的最小长度，默认不小于5位，但是我们现在用户登录时验证已经被PAM模块取代，所以这个选项并不生效。</p>
</li>
<li><p>PASS_WARN_AGE    7</p>
<p>这行代表密码修改到期前的警告天数。也就是&#x2F;etc&#x2F;shadow文件的第六个字段。代表密码到底有效期前多少天开始进行警告提醒，默认值是7天。</p>
</li>
<li><p>UID_MIN|UID_MAX</p>
<p>这两行指定了UID的最小值和最大值之间的范围。</p>
</li>
<li><p>GID_MIN|GID_MAX</p>
<p>这两行指定了GID的最小值和最大值之间的范围。</p>
</li>
<li><p>CREATE_HOME    yes</p>
<p>这行指定建立用户时是否自动建立用户的家目录，默认是建立。</p>
</li>
<li><p>UMASK    077</p>
<p>这行指定的是建立的用户家目录的默认权限，因为umask值是077，所以新建的用户家目录的权限是700。</p>
</li>
<li><p>USERGROUPS_ENAB    yes</p>
<p>这行指定的是使用命令userdel删除用户时，是否删除用户的初始组，默认是删除。</p>
</li>
<li><p>ENCRYPT_METHOD    SHA512</p>
<p>这行指定Linux用户的密码使用SHA512散列模式加密，这是新的密码加密模式，原先的Linux只能用DES或MD5方式加密。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2）设定密码"><a href="#2）设定密码" class="headerlink" title="2）设定密码"></a>2）设定密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd [选项] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -l:         暂时锁定用户。仅root用户可用（lock）</span><br><span class="line">  -u:         解锁用户。仅root用户可用（unlock）</span><br><span class="line">  --stdin:    可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改当前用户的密码</span><br><span class="line">passwd</span><br><span class="line"></span><br><span class="line"># 使用字符串作为密码</span><br><span class="line">echo &quot;123&quot; | passwd --stdin lamp</span><br><span class="line"></span><br><span class="line"># 把密码修改日期归零(shadow第3个字段，0代表1970年1月1日)。这样用户一登录就要修改密码。</span><br><span class="line">chage -d 0 lamp</span><br></pre></td></tr></table></figure>



<h3 id="3）用户信息修改"><a href="#3）用户信息修改" class="headerlink" title="3）用户信息修改"></a>3）用户信息修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usermod [选项] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -u UID:        修改用户的UID</span><br><span class="line">  -d 家目录：     修改用户的家目录。家目录必须写绝对路径</span><br><span class="line">  -c 用户说明:    修改用户的说明信息，就是/etc/passwd文件的第五个字段</span><br><span class="line">  -g 组名：       修改用户的初始组，就是/etc/passwd文件的第四个字段</span><br><span class="line">  -G 组名：       修改用户的附加组，其实就是把用户加入其他用户组</span><br><span class="line">  -s shell:      修改用户的登录Shell。默认是/bin/bash</span><br><span class="line">  -e 日期：       修改用户的失效日期，格式为&quot;YYYY-MM-DD&quot;。也就是/etc/shadow文件的第八个字段</span><br><span class="line">  -L:            临时锁定用户(Lock)</span><br><span class="line">  -U:            解锁用户(Unlock)</span><br></pre></td></tr></table></figure>

<p>usermod也可以修改用户名，但不建议这么做，这样及其容易把管理员自己稿晕。建议删除旧用户，再建立新用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改用户名</span><br><span class="line">usermod -l 新名 旧名</span><br></pre></td></tr></table></figure>



<h3 id="4）删除用户"><a href="#4）删除用户" class="headerlink" title="4）删除用户"></a>4）删除用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userdel [-r] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -r:    在删除用户的同时删除用户的家目录</span><br></pre></td></tr></table></figure>



<h3 id="5）切换用户身份"><a href="#5）切换用户身份" class="headerlink" title="5）切换用户身份"></a>5）切换用户身份</h3><p>su命令可以切换成不同的用户身份。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su [选项] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -:          选项只使用“-”代表连带用户的环境变量一起切换</span><br><span class="line">  -c 命令:    仅执行一次命令，而不切换用户身份</span><br></pre></td></tr></table></figure>

<p>“-”不能省略，它代表切换用户身份时，用户的环境变量也要切换成新用户的环境变量。</p>
<h2 id="3-组管理命令"><a href="#3-组管理命令" class="headerlink" title="3. 组管理命令"></a>3. 组管理命令</h2><h3 id="1）添加用户组"><a href="#1）添加用户组" class="headerlink" title="1）添加用户组"></a>1）添加用户组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd [选项] 组名</span><br><span class="line">选项：</span><br><span class="line">  -g GID:    指定组ID</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加group1组</span><br><span class="line">groupadd group1</span><br></pre></td></tr></table></figure>



<h3 id="2）删除用户组"><a href="#2）删除用户组" class="headerlink" title="2）删除用户组"></a>2）删除用户组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure>

<p>不过要注意，要删除的组不能是其他用户的初始组，也就是说这个组中没有初始用户才可以删除。如果组中有附加用户，则删除组时不受影响。</p>
<h3 id="3）把用户添加进组或从组中删除"><a href="#3）把用户添加进组或从组中删除" class="headerlink" title="3）把用户添加进组或从组中删除"></a>3）把用户添加进组或从组中删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpasswd [选项] 组名</span><br><span class="line">选项：</span><br><span class="line">  -a 用户名：    把用户加入组</span><br><span class="line">  -d 用户名：    把用户从组中删除</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加test组</span><br><span class="line">groupadd test</span><br><span class="line"></span><br><span class="line"># 把test1用户加入test组</span><br><span class="line">gpasswd -a test1 test</span><br><span class="line"></span><br><span class="line"># 把用户test1从test组中删除</span><br><span class="line">gpasswd -d test1 test</span><br></pre></td></tr></table></figure>



<h3 id="4）改变有效组"><a href="#4）改变有效组" class="headerlink" title="4）改变有效组"></a>4）改变有效组</h3><p>每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？当然是初始用户组的组身份。因为初始组是用户一旦登录就直接获得的组身份。也就是说，用户在创建文件后，文件的属组就是用户的初始组，因为用户的有效组默认是初始组。使用newgrp可以切换用户的有效组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newgrp 组名</span><br></pre></td></tr></table></figure>



<h3 id="5-组权限实验"><a href="#5-组权限实验" class="headerlink" title="5. 组权限实验"></a>5. 组权限实验</h3><p>根目录下创建个www目录，属主为teacher, 学生st1，st2可以往这个目录提交作业。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建www目录</span><br><span class="line">mkdir /www</span><br><span class="line"></span><br><span class="line"># 创建teacher用户</span><br><span class="line">useradd -m teacher</span><br><span class="line"></span><br><span class="line"># 设置teacher用户密码</span><br><span class="line">passwd teacher</span><br><span class="line"></span><br><span class="line"># 创建st1,st2用户并设置密码</span><br><span class="line">useradd -m st1</span><br><span class="line">useradd -m st2</span><br><span class="line"></span><br><span class="line"># 创建tg组</span><br><span class="line">groupadd tg</span><br><span class="line"></span><br><span class="line"># 将st1, st2加入tg组</span><br><span class="line">gpasswd -a st1 tg</span><br><span class="line">gpasswd -a st2 tg</span><br><span class="line"></span><br><span class="line"># 设置www目录属主和属组</span><br><span class="line">chown teacher:tg /www/</span><br><span class="line"></span><br><span class="line"># 设置www目录权限</span><br><span class="line">chmod 770 /www/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>系统管理</title>
    <url>/2025/03/05/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h3><p>1）什么是进程</p>
<p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</p>
<p>2）什么是程序</p>
<p>程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。</p>
<p>程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。</p>
<p>进程是正在执行当中的程序。程序被执行时，执行人的权限和属性、以及程序的代码都会被加载如内存，操作系统给这个进程分配一个ID号，称为PID（进程ID）。</p>
<p>3）进程管理的作用</p>
<ul>
<li><p>判断服务器健康状态</p>
<p>运维工程师最主要的工作就是保证服务器安全稳定的运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服务器的CPU占用率、内存占用率过高，就需要人为介入解决问题了。</p>
</li>
<li><p>查看系统中所有的进程</p>
<p>我们需要查看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务，是否有非法服务运行。</p>
</li>
<li><p>杀死进程</p>
<p>这是进程管理中最不常用的手段，当需要停止服务时，会通过正确关闭命令来停止服务（如apache服务可以通过service httpd sotp来关闭）。只有当正确终止进程的手段失效的情况下，才会考虑使用kill命令杀死进程（你不是杀手，不要什么进程都用kill来终止，否则非常容易导致服务器崩溃）。</p>
</li>
</ul>
<h3 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h3><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令是用来静态显示系统中进程的命令。不过这个命令有些特殊，它的部分命令的选项不能加入“-”，比如“ps aux”，这是因为ps命令的部分选项需要遵守BSD操作系统的格式，所以ps命令的常用选项的组合是固定的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统中所有进程，使用BSD操作系统格式</span></span><br><span class="line">[root@localhost ~]# pa aux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统中所有进程，使用Linux标准命令格式</span></span><br><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">选项：</span><br><span class="line">  a:		显示一个终端的所有进程，除了会话引线</span><br><span class="line">  u:		显示进程的归属用户及内存的使用情况</span><br><span class="line">  x:		显示没有控制终端的进程</span><br><span class="line">  -l:		长格式显示。显示更加详细的信息</span><br><span class="line">  -e:		显示所有进程，和-A作用一致</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ps aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.2  24104 15260 ?        Ss   3月04   0:10 /sbin/init splash</span><br><span class="line">root           2  0.0  0.0      0     0 ?        S    3月04   0:00 [kthreadd]</span><br></pre></td></tr></table></figure>

<ul>
<li>USER：该进程是由哪个用户产生的</li>
<li>PID：进程的ID号</li>
<li>%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源</li>
<li>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源</li>
<li>VSZ：该进程占用虚拟内存的大小，单位KB</li>
<li>RSS：该进程占用实际物理内存的大小，单位KB</li>
<li>TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端(可以通过alt+F1-F7键切换不同的终端)，tty1-tty6是本地的字符界面终端，tty7是图形终端。pts&#x2F;0-255代表虚拟终端，一般是远程连接终端，第一个远程连接占用的是pts&#x2F;0终端，第二个远程连接占用pts&#x2F;1，依次增长。</li>
<li>STAT：进程状态。常见状态有：<ul>
<li>D：不可被唤醒的睡眠状态，通常用于I&#x2F;O情况</li>
<li>R：该进程正在运行</li>
<li>S：该进程在睡眠状态，可被唤醒</li>
<li>T：停止状态，可能是在后台暂停或进程在除错状态</li>
<li>W：内存交互状态（从2.6内核开始无效）</li>
<li>X：死掉的进程（应该不会出现）</li>
<li>Z：僵尸进程。进程已经终止，但是部分程序还在内存当中。</li>
<li>&lt;：高优先级（以下状态在BSD格式当中出现）</li>
<li>N：低优先级</li>
<li>L：被锁入内存</li>
<li>s：包含子进程</li>
<li>l：多线程</li>
<li>+：位于后台</li>
</ul>
</li>
<li>START：该进程的启动时间</li>
<li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li>
<li>COMMAND：产生此进程的命令名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0       1       0  0  80   0 -  6026 -      ?        00:00:10 systemd</span><br><span class="line">1 S     0       2       0  0  80   0 -     0 -      ?        00:00:00 kthreadd</span><br></pre></td></tr></table></figure>

<ul>
<li>F：进程标志，说明进程的权限，常见标志有：<ul>
<li>1：进程可以复制，但是不能执行</li>
<li>4：进程使用超级用户权限</li>
</ul>
</li>
<li>S：进程状态。具体的状态和“ps aux”命令中STAT状态一致</li>
<li>UID：进程是哪个UID用户调用运行的</li>
<li>PID：进程的ID号</li>
<li>PPID：代进程的ID号</li>
<li>C：该进程的CPU使用率，单位是百分比</li>
<li>PRI：进程的优先级，数值越小该进程优先级越高，越快被CPU执行</li>
<li>NI：进程的优先级，也是数值越小越早被执行</li>
<li>ADDR：该进程在内存的哪个位置</li>
<li>SZ：该进程占用多大内存</li>
<li>WCHAN：该进程是否运行。“-”代表正在运行</li>
<li>TTY：该进程由哪个终端产生</li>
<li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li>
<li>CMD：产生此进程的命令名</li>
</ul>
<h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# top [选项]</span><br><span class="line">选项：</span><br><span class="line">  -d 秒数：    指定top命令每隔几秒更新。默认是3秒。</span><br><span class="line">  -b:  		  使用批处理模式输出。一般和&quot;-n&quot;选项合用，用于把top命令重定向到文件中 </span><br><span class="line">  -n 次数:	 指定top命令执行的次数。一般和&quot;-b&quot;选项合用</span><br><span class="line">  -p:		   指定PID。只查看某个PID的进程</span><br><span class="line">  -s:          使top在安全模式运行，避免在交互模式中出现错误</span><br><span class="line">  -u 用户名:    只监听某个用户的进程</span><br><span class="line">在top命令的交互模式当中可以执行的命令：</span><br><span class="line">  ？或h:	   显示交互模式的帮助</span><br><span class="line">  P:		以CPU使用率排序，默认就是此项</span><br><span class="line">  M:		以内存的使用率排序</span><br><span class="line">  N:		以PID排序</span><br><span class="line">  T:		按照CPU的累积运算时间排序，也就是用于TIME+项排序</span><br><span class="line">  k:		按照PID号，给予某个进程一个信号，一般用于终止某个进程，信号9是强制终止的信号</span><br><span class="line">  r:		按照PID号，给某个进程重设优先级（Nice）值</span><br><span class="line">  q:		退出top</span><br></pre></td></tr></table></figure>

<p>top执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 20:40:42 up 1 day, 11:10,  1 user,  load average: 0.62, 0.43, 0.45</span><br><span class="line">任务: 394 total,   1 running, 385 sleeping,   8 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.9 us,  3.9 sy,  0.0 ni, 94.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st </span><br><span class="line">MiB Mem :   6865.1 total,    245.4 free,   4582.3 used,   2676.1 buff/cache     </span><br><span class="line">MiB Swap:   2048.0 total,    789.7 free,   1258.3 used.   2282.8 avail Mem </span><br><span class="line"> 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND                                                     </span><br><span class="line"> 231207 ben       20   0   17672   5632   3456 R  23.1   0.1   0:00.06 top                                                       </span><br><span class="line">      1 root      20   0   24104  14620   9348 S   0.0   0.2   0:11.09 systemd                                                   </span><br><span class="line">      2 root      20   0       0      0      0 S   0.0   0.0   0:00.06 kthreadd                                                   </span><br><span class="line">      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_workqueue_release        </span><br></pre></td></tr></table></figure>

<p>top命令的输出内容是动态的，默认每3秒刷新一次。命令的输出主要分为两大部分；第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出判断服务器的健康状态；第二部分从第六行开始，显示的是系统中进程的信息。</p>
<ul>
<li><p>第一部分内容</p>
<ul>
<li><p>第一行信息为任务队列信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>20:40:42</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 1 day, 11:10</td>
<td>系统的运行时间，本机已经运行1天11小时10分钟</td>
</tr>
<tr>
<td>1 user</td>
<td>当前登录了1个用户</td>
</tr>
<tr>
<td>load average: 0.62, 0.43, 0.45</td>
<td>系统在之前1分钟，5分钟，15分钟的平均负载。如果CPU是单核，则这个数超过1，就是高负载。如果CPU是四核，则这个数超过4，就是高负载。（这个平均负载完全是个人经验来进行判断的，一般认为不应该超过服务器CPU的核数。）</td>
</tr>
</tbody></table>
</li>
<li><p>第二行为进程信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>任务: 394 total</td>
<td>系统中的进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>385 sleeping</td>
<td>睡眠的进程</td>
</tr>
<tr>
<td>8 stopped</td>
<td>正在停止的进程</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程。如果不是0，需要手工检查僵尸进程</td>
</tr>
</tbody></table>
</li>
<li><p>第三行为CPU信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%Cpu(s):  1.9 us</td>
<td>用户模式占用的CPU百分比</td>
</tr>
<tr>
<td>3.9 sy</td>
<td>系统模式占用的CPU百分比</td>
</tr>
<tr>
<td>0.0 ni</td>
<td>改变过优先级的用户进程占用的CPU百分比</td>
</tr>
<tr>
<td>94.2 id</td>
<td>空闲CPU的CPU百分比</td>
</tr>
<tr>
<td>0.0 wa</td>
<td>等待输入&#x2F;输出的进程的占用CPU百分比</td>
</tr>
<tr>
<td>0.0 hi</td>
<td>硬中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td>0.0 si</td>
<td>软中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td>0.0 st</td>
<td>st（Steal time）虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比</td>
</tr>
</tbody></table>
</li>
<li><p>第四行为物理内存信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Mem :   6865.1 total</td>
<td>物理内存的总量</td>
</tr>
<tr>
<td>245.4 free</td>
<td>空闲的物理内存数量</td>
</tr>
<tr>
<td>4582.3 used</td>
<td>已经使用的物理内存数量</td>
</tr>
<tr>
<td>2676.1 buff&#x2F;cache</td>
<td>作为缓冲&#x2F;缓存的内存数量</td>
</tr>
</tbody></table>
</li>
<li><p>第五行为交换分区（swap）信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Swap:   2048.0 total</td>
<td>交换分区（虚拟分区）的总大小</td>
</tr>
<tr>
<td>789.7 free</td>
<td>空闲交换分区的大小</td>
</tr>
<tr>
<td>1258.3 used</td>
<td>已经使用的交互分区的大小</td>
</tr>
<tr>
<td>2282.8 avail Mem</td>
<td>可利用的交互分区的大小</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>第二部分内容</p>
<p>主要是系统进程信息。这部分和ps命令的输出比较类似，只是如果在终端中执行top命令不能看到所有的进程，而只能看到占比靠前的进程。</p>
<ul>
<li>PID: 进程ID</li>
<li>USER: 该进程所属的用户</li>
<li>PR: 优先级，数值越小优先级越高</li>
<li>NI: 优先级，数值越小优先级越高</li>
<li>VIRT: 该进程使用的虚拟内存的大小，单位KB</li>
<li>RES: 该进程使用的物理内存的大小，单位KB</li>
<li>SHR: 共享内存大小，单位KB</li>
<li>%CPU: 该进程占用CPU的百分比</li>
<li>%MEM: 该进程占用内存的百分比</li>
<li>TIME+: 该进程总共占用的CPU时间</li>
<li>COMMAND: 进程的命令名</li>
</ul>
</li>
</ul>
<p>top命令查看某一个进程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只查看PID为15273的apache进程</span></span><br><span class="line">[root@localhost ~]# top -p 15273</span><br></pre></td></tr></table></figure>

<p>在top命令的交互界面中按“q”键会退出top命令。也可以按“?”或“h”得到top命令交互界面的帮助信息。也可以按“k”键终止某个进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 21:30:33 up 1 day, 12:00,  1 user,  load average: 2.53, 1.43, 1.12</span><br><span class="line">任务: 391 total,   1 running, 382 sleeping,   8 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  5.5 us,  3.1 sy,  0.0 ni, 91.2 <span class="built_in">id</span>,  0.2 wa,  0.0 hi,  0.1 si,  0.0 st</span> </span><br><span class="line">MiB Mem :   6865.1 total,    196.3 free,   4604.8 used,   2714.5 buff/cache     </span><br><span class="line">MiB Swap:   2048.0 total,    742.7 free,   1305.3 used.   2260.2 avail Mem </span><br><span class="line">PID to signal/kill [default pid = 166294]                               # 按&quot;k&quot;键，会提示输入要杀死进程的PID</span><br></pre></td></tr></table></figure>

<p>如果在操作终端执行top命令，并不能看到系统中所有的进程，默认看到的只是CPU占比靠前的进程。如果我们想要看到所有的进程可以把top命令的结果重定向到文件当中即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让top命令只执行一次，然后把结果保存到top.log文件中。这样就能看到所有的进程了</span></span><br><span class="line">[root@localhost ~]# top -b -n 1 &gt; /root/top.log</span><br></pre></td></tr></table></figure>



<h4 id="pstree命令"><a href="#pstree命令" class="headerlink" title="pstree命令"></a>pstree命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pstree [选项]</span><br><span class="line">选项：</span><br><span class="line">  -p:		显示进程的PID</span><br><span class="line">  -u:		显示进程的所属用户</span><br></pre></td></tr></table></figure>



<h3 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h3><p>系统中可以识别的信号较多，可以使用命令“kill -l”或“man 7 signal”来查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# kill -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>主要信号：</p>
<table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭，然后重新读取配置文件之后重启。</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键。</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术的错误。</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。一般用于强制终止进程。</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间. alarm函数使用该信号。</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill命令的默认信号。有时如果进程已经发生问题，这个信号是无法正常终止进程的，我们才会尝试SIGKILL信号，也就是信号9。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行，本信号不能被阻断。</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号不能被阻断。</td>
</tr>
</tbody></table>
<h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# kill [信号] PID</span><br></pre></td></tr></table></figure>

<p>使用“-1”信号，让进程重启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# kill -1 2246</span><br></pre></td></tr></table></figure>

<p>使用“-19”信号，让进程暂停：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用vim命令编辑一个文件，不要退出</span></span><br><span class="line">[root@localhost ~]# vim /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">换不同的终端，查看下这个进程的状态</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vim&quot; | grep -v &quot;grep&quot;</span><br><span class="line">ben       271840  0.2  0.1  31228 13568 pts/0    Sl+  16:00   0:00 vim /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用-19信号，让PID是271840的进程暂停。相当于在vim界面按<span class="string">&quot;ctrl+z&quot;</span>快捷键</span></span><br><span class="line">[root@localhost ~]# kill -19 271840</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">271840进程的状态变成为T(暂停)状态。271840进程会卡在后台，如果想要恢复可以使用<span class="string">&quot;kill -9 271840&quot;</span>强制终止进程。</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vim&quot; | grep -v &quot;grep&quot;</span><br><span class="line">ben       271840  0.0  0.1  31228 13568 pts/0    Tl   16:00   0:00 vim /tmp/test.txt</span><br></pre></td></tr></table></figure>



<h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# killall [选项][信号] 进程名</span><br><span class="line">选项：</span><br><span class="line">  -i:	交互式，询问是否要杀死某个进程</span><br><span class="line">  -l:	忽略进程名的大小写</span><br></pre></td></tr></table></figure>

<p>交互式杀死docker进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ps aux | grep &quot;docker-proxy&quot;</span><br><span class="line">root        5331  0.0  0.0 1746028 2160 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 127.0.0.1 -host-port 9090 -container-ip 172.23.0.2 -container-port 9090</span><br><span class="line">root        5345  0.0  0.0 1746028 2076 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 7891 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5352  0.0  0.0 1819504 2008 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 7891 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5366  0.0  0.0 1745772 2152 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5373  0.0  0.0 1746028 2088 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5388  0.0  0.0 1894260 4148 ?        Sl   3月04   0:02 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5395  0.0  0.0 1745772 2104 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5409  0.0  0.0 1671784 2204 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 7890 -container-ip 172.23.0.2 -container-port 7890</span><br><span class="line">root        5416  0.0  0.0 1671784 2168 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 7890 -container-ip 172.23.0.2 -container-port 7890</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式杀死docker进程</span></span><br><span class="line">[root@localhost ~]# killall -i docker-proxy</span><br><span class="line">杀死 docker-proxy(5331) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5345) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5352) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5366) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5373) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5388) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5395) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5409) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5416) ? (y/N) n</span><br></pre></td></tr></table></figure>



<h4 id="pkill命令"><a href="#pkill命令" class="headerlink" title="pkill命令"></a>pkill命令</h4><p>pkill命令和killall命令非常类似，也是按照进程名来杀死进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pkill [选项] [信号] 进程名</span><br><span class="line">选项：</span><br><span class="line">  -t 终端号:	按照终端号踢出用户</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制杀死从pts/1虚拟终端登录的进程</span></span><br><span class="line">[root@localhost ~]# pkill -9 -t pts/1</span><br></pre></td></tr></table></figure>



<h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><h3 id="工作管理简介"><a href="#工作管理简介" class="headerlink" title="工作管理简介"></a>工作管理简介</h3><p>后台管理有个事项需要注意：</p>
<ul>
<li>前台是指当前可以操控和执行命令的这个操作环境，后台是指工作可以自行运行，但是不能直接用ctrl+c来终止它，只能使用fg&#x2F;bg来调用工作；</li>
<li>当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作。如tty1登录终端是不能管理tty2终端中的工作的；</li>
<li>放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作。如果把1s命令放入后台执行，它很快就会执行完成，我们很难操作它。</li>
<li>放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行。比如vim命令放入后台只能暂停，而不能执行，因为vim需要前台输入信息。top命令也不能放入后台执行，而只能放入后台暂停，因为top命令需要和前台有交互。</li>
</ul>
<h3 id="如何把命令放入后台"><a href="#如何把命令放入后台" class="headerlink" title="如何把命令放入后台"></a>如何把命令放入后台</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令 &amp;"></a>命令 &amp;</h4><p>第一种方法把命令放入后台的方法是在命令后面加入“空格&amp;”，这种方法放入后台的命令，在后台是执行状态。但是注意，放入后台执行的命令不能与前台有交互，否则这个命令是不能在后台执行的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find命令放入后台执行，每个后台命令会分配一个工作号，命令既然可以执行，就会有进程产生，所以也会有进程号。</span></span><br><span class="line">[root@localhost ~]# find / -name install.log &amp;</span><br><span class="line">[2] 284313</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[工作号] 进程号</span></span><br></pre></td></tr></table></figure>

<p>虽然find命令在执行，但是当前操作还是可以进行其他命令操作的。如果在终端出现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">证明后台这个任务已经完成了，当然命令如果有执行结果的话，也会显示到操作终端上。[2]是这个命令的工作号，+号代表这个任务是最近一个被放入后台的工作。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### ctrl+z</span></span></span><br><span class="line"></span><br><span class="line">第二种方法是在命令执行过程中按ctrl+z快捷键，命令在后台是暂停状态。</span><br><span class="line"></span><br><span class="line">使用这种方法放入后台的命令，就算是不和前台有交互，能在后台执行的命令，也是暂停状态，ctrl+z快捷键就是暂停的快捷键。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在top命令执行的过程中，按下ctrl+z快捷键</span></span><br><span class="line">[root@localhost ~]# top</span><br><span class="line">[1]+  已停止               top</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提示命令被放入后台，工作号是1，状态是暂停。而且虽然top命令没有结束，也能取得控制台权限</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩一下/etc/目录</span></span><br><span class="line">[root@localhost ~]# tar -zcf etc.tar.gz /etc</span><br><span class="line">tar: 从成员名中删除开头的&quot;/&quot;</span><br><span class="line">tar: 从硬连接目标中删除开头的&quot;/&quot;</span><br><span class="line">^Z                              # 执行过程中，按下ctrl+z快捷键</span><br><span class="line">[2]+   Stopped    tar -zcf etc.tar.gz /etc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令被放入后台，工作号是2，状态是暂停</span></span><br></pre></td></tr></table></figure>



<h3 id="后台命令管理"><a href="#后台命令管理" class="headerlink" title="后台命令管理"></a>后台命令管理</h3><h4 id="查看后台的工作"><a href="#查看后台的工作" class="headerlink" title="查看后台的工作"></a>查看后台的工作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# jobs [-l]</span><br><span class="line">选项：</span><br><span class="line">  -l:	显示工作的PID</span><br></pre></td></tr></table></figure>

<h4 id="将后台暂停的工作恢复到前台执行"><a href="#将后台暂停的工作恢复到前台执行" class="headerlink" title="将后台暂停的工作恢复到前台执行"></a>将后台暂停的工作恢复到前台执行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fg %工作号</span><br><span class="line">参数：</span><br><span class="line">  %工作号:		%号可以省略，但是注意工作号和PID的区别</span><br></pre></td></tr></table></figure>

<h4 id="把后台暂停的工作恢复到后台执行"><a href="#把后台暂停的工作恢复到后台执行" class="headerlink" title="把后台暂停的工作恢复到后台执行"></a>把后台暂停的工作恢复到后台执行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# bg %工作号</span><br></pre></td></tr></table></figure>

<h4 id="后台命令脱离登录终端运行"><a href="#后台命令脱离登录终端运行" class="headerlink" title="后台命令脱离登录终端运行"></a>后台命令脱离登录终端运行</h4><p>我们已经知道把命令放入后台，只能在当前登录终端执行。那如果我是远程管理的服务器，在远程终端中执行了后台命令，这时我退出终端，这个后台命令还能继续执行吗？当然是不行的， 这个后台命令会被终止。如果确实需要在远程终端中执行某些后台命令，可以这么做：</p>
<ul>
<li>把需要后台执行的命令加入&#x2F;etc&#x2F;rc.local文件，让系统在启动时执行这个后台程序。这种方法的问题是，服务器是不能随便重启的，万一有临时后台任务，就不能执行。</li>
<li>使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的。</li>
<li>使用nohup命令。</li>
</ul>
<p>nohup命令的作用就是让后台工作在离开操作终端时，也能够正确的在后台执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nohup [命令] &amp; </span><br></pre></td></tr></table></figure>

<p>用find命令打印&#x2F;下所有文件，放入后台执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nohup find / -print &gt; /root/file.log &amp;</span><br><span class="line">[3] 2349</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有提示信息</span></span><br><span class="line">[root@localhost ~]# nohup：忽略输入并把输出追加到&quot;nohup.out&quot;</span><br></pre></td></tr></table></figure>



<h2 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>监控系统资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vmstat [刷新延时 刷新次数]</span><br></pre></td></tr></table></figure>

<p>使用vmstat检测，每1秒刷新一次，共刷新3次：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vmstat 1 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- -------cpu-------</span><br><span class="line"> r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st gu</span><br><span class="line"> 1  0 1975536 315116 888372 2032876    1   13    58    88  912    6  4  2 94  0  0  0</span><br><span class="line"> 0  0 1975536 296724 888372 2032912    8    0     8     0 2845 3503  4  2 94  0  0  0</span><br><span class="line"> 3  0 1975536 294804 888372 2032916    0    0     0     0 2592 3581  1  2 97  0  0  0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>procs：进程信息字段</p>
<ul>
<li>r：等待运行的进程数，数量越大，系统越繁忙。</li>
<li>b：不可被唤醒的进程数量，数量越大，系统越繁忙。</li>
</ul>
</li>
<li><p>memory：内存信息字段</p>
<ul>
<li>swpd：虚拟内存的使用情况，单位KB</li>
<li>free：空闲的内存容量，单位KB</li>
<li>buff：缓冲的内存容量，单位KB</li>
<li>cache：缓存的内存容量，单位KB</li>
</ul>
</li>
<li><p>swap：交换分区的信息字段</p>
<ul>
<li>si：从磁盘中交换到内存中数据的数量，单位KB</li>
<li>so：从内存中交换到磁盘中数据的数量，单位KB。此两个数越大，证明数据需要经常在磁盘和内存之间交换，系统性能越差。</li>
</ul>
</li>
<li><p>io：磁盘读写信息字段</p>
<ul>
<li>bi：从块设备读入数据的总量，单位是块</li>
<li>bo：写到块设备的数据的总量，单位是块。此两个数越大，代表系统的I&#x2F;O越繁忙。</li>
</ul>
</li>
<li><p>system：系统信息字段</p>
<ul>
<li>in：每秒被中断的进程次数</li>
<li>cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙。</li>
</ul>
</li>
<li><p>cpu：cpu信息字段</p>
<ul>
<li>us：非内核进程消耗cpu运算时间的百分比</li>
<li>sy：内核进程消耗cpu运算时间的百分比</li>
<li>id：空闲cpu的百分比</li>
<li>wa：等待I&#x2F;0所消耗的cpu百分比</li>
<li>st：被虚拟机所盗用的cpu百分比</li>
</ul>
</li>
</ul>
<h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>显示开机时内核检测信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看CPU信息</span></span><br><span class="line">[root@localhost ~]# dmesg | grep CPU</span><br></pre></td></tr></table></figure>



<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>查看内存使用状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# free [-b|-k|-m|-g]</span><br><span class="line">选项：</span><br><span class="line">  -b:	以字节为单位显示</span><br><span class="line">  -k:	以KB为单位显示，默认是以KB为单位显示</span><br><span class="line">  -m:	以MB为单位显示</span><br><span class="line">  -g:	以GB为单位显示</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">内存：         6.7Gi       4.2Gi       283Mi       277Mi       2.8Gi       2.5Gi</span><br><span class="line">交换：         2.0Gi       1.9Gi       122Mi</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行</p>
<ul>
<li>total：总内存数。</li>
<li>used：已经使用的内存数。</li>
<li>free：空闲的内存数。</li>
<li>shared：多个进程共享的内存总数。</li>
<li>buff&#x2F;cache：缓冲&#x2F;缓存内存数。</li>
</ul>
</li>
<li><p>第二行</p>
<ul>
<li>total：swap的总数</li>
<li>used：已经使用的swap数</li>
<li>free：空闲的swap数。</li>
</ul>
</li>
</ul>
<h3 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h3><p>CPU的主要信息保存在&#x2F;proc&#x2F;cpuinfo这个文件中，只要查看这个文件，就可以知道cpu的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/cpuinfo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑CPU编号</span></span><br><span class="line">processor	: 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU制造厂商</span></span><br><span class="line">vendor_id	: AuthenticAMD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">产品的系列代号</span></span><br><span class="line">cpu family	: 23</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU系列代号</span></span><br><span class="line">model		: 24</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU系列的名字，编号，主频</span></span><br><span class="line">model name	: AMD Ryzen 7 3700U with Radeon Vega Mobile Gfx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新版本</span></span><br><span class="line">stepping	: 1</span><br><span class="line">microcode	: 0x8108109</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实际主频</span></span><br><span class="line">cpu MHz		: 1372.114</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二级缓存</span></span><br><span class="line">cache size	: 512 KB</span><br></pre></td></tr></table></figure>



<h3 id="查看本机登录用户信息"><a href="#查看本机登录用户信息" class="headerlink" title="查看本机登录用户信息"></a>查看本机登录用户信息</h3><p>如果我们想要知道Linux服务器上目前已经登录的用户信息，可以使用w或who命令来进行查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 17:54:27 up 2 days,  8:24,  1 user,  load average: 0.82, 0.89, 1.04</span><br><span class="line">USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU  WHAT</span><br><span class="line">ben               -                二09    2:27m  0.00s  0.04s lightdm --session-child 13 20</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行：和top命令的第一行非常类似，主要显示了系统当前时间，开机多久(up)，有多少用户登录(users)，1分钟、5分钟、15分种前的平均负载(load average)。</li>
<li>第二行：项目的说明<ul>
<li>USER：登录的用户名</li>
<li>TTY：登录终端</li>
<li>FROM：从哪个IP地址登录</li>
<li>LOGIN@：登录时间</li>
<li>IDLE：用户闲置时间</li>
<li>JCPU：指的是和该终端连接的所有进程占用的CPU运算时间。这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间</li>
<li>PCPU：是指当前进程所占用的CPU运算时间</li>
<li>WHAT：当前正在运行的命令</li>
</ul>
</li>
<li>第三行：代表一个用户</li>
</ul>
<p>who命令比w命令稍微简单一点，也可以用来查看系统中已经登录的用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# who</span><br><span class="line">ben      tty7         2025-03-04 09:29 (:0)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名  登录终端      登录时间(登录来源IP地址)</span></span><br></pre></td></tr></table></figure>



<h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>uptime命令的作用就是显示系统的启动时间和平均负载，也就是top命令的第一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uptime</span><br><span class="line"> 18:05:21 up 2 days,  8:35,  1 user,  load average: 1.61, 1.24, 1.10</span><br></pre></td></tr></table></figure>



<h3 id="查看系统与内核相关信息"><a href="#查看系统与内核相关信息" class="headerlink" title="查看系统与内核相关信息"></a>查看系统与内核相关信息</h3><p>使用uname命令查看内核的相关信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uname [选项]</span><br><span class="line">选项：</span><br><span class="line">  -a:	查看系统所有相关信息</span><br><span class="line">  -r:   查看内核版本</span><br><span class="line">  -s:   查看内核名称</span><br></pre></td></tr></table></figure>

<p>如果我们想要判断当前系统的位数，可以通过file命令来判断系统文件(主要系统命令)的位数来推断系统的位数。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# file /bin/ls</span><br><span class="line">/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3eca7e3905b37d48cf0a88b576faa7b95cc3097b, for GNU/Linux 3.2.0, stripped</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">很明显，当前系统是64位的</span></span><br></pre></td></tr></table></figure>

<p>如果想要查询当前Linux系统的发行版本，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lsb_release -a </span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 24.04.1 LTS</span><br><span class="line">Release:	24.04</span><br><span class="line">Codename:	noble</span><br></pre></td></tr></table></figure>



<h2 id="系统定时任务"><a href="#系统定时任务" class="headerlink" title="系统定时任务"></a>系统定时任务</h2><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>循环执行定时任务。</p>
<p>1）crond服务管理与访问控制</p>
<p>crontab命令是需要crond服务支持的，crond服务同样是独立的服务，所以启动和自启动方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启动crond服务</span></span><br><span class="line">[root@localhost ~]# service crond restart</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设定crond服务为开机自启动</span></span><br><span class="line">[root@localhost ~]# systemctl enable crond</span><br></pre></td></tr></table></figure>

<p>crond服务默认是自启动的，如果服务器上有循环执行的系统定时任务，就不要关闭crond服务了。</p>
<p>2）用户的crontab设置</p>
<p>每个用户都可以实现自己的crontab定时任务，只要是使用这个用户身份执行“crontab -e”命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# crontab [选项]</span><br><span class="line">选项：</span><br><span class="line">  -e:		编辑crontab定时任务</span><br><span class="line">  -l:		查询crontab任务</span><br><span class="line">  -r:		删除当前用户所有的crontab任务，如果有多个任务，只想删除一个，可以使用&quot;crontab -e&quot;</span><br><span class="line">  -u 用户名: 修改或删除其他用户的crontab任务。只有root可用	</span><br></pre></td></tr></table></figure>

<p>进入crontab编辑界面，会打开vim编辑你的工作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">* * * * * 执行的任务</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>项目</th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个“*”</td>
<td>一小时当中的第几分钟</td>
<td>0-59</td>
</tr>
<tr>
<td>第二个“*”</td>
<td>一天当中的第几个小时</td>
<td>0-23</td>
</tr>
<tr>
<td>第三个“*”</td>
<td>一个月当中的第几天</td>
<td>1-31</td>
</tr>
<tr>
<td>第四个“*”</td>
<td>一年当中的第几月</td>
<td>1-12</td>
</tr>
<tr>
<td>第五个“*”</td>
<td>一周当中的星期几</td>
<td>0-7(0和7都代表星期日)</td>
</tr>
</tbody></table>
<p>特殊符号：</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表任何时间，比如第一个“*”就代表一小时中每分钟都执行一次。</td>
</tr>
<tr>
<td>，</td>
<td>代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令。</td>
</tr>
<tr>
<td>~</td>
<td>代表连续的时间范围。比如“0 5 * * 1-6 命令”，代表在周一到周六的凌晨5点0分执行命令。</td>
</tr>
<tr>
<td>*&#x2F;n</td>
<td>代表每隔多久执行一次。比如“*&#x2F;10 * * * * 命令”，代表每隔10分钟就执行一次命令。</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让系统每隔5分钟，就向/tmp/test文件中写入一行<span class="string">&quot;ll&quot;</span></span></span><br><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">*/5 * * * * /bin/echo &quot;ll&quot; &gt;&gt; /tmp/test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统在每周二的凌晨5点05分重启一次</span></span><br><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">5 5 * * 2 /sbin/shutdown -r now</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在每月的1号，10号，15号的凌晨3点30分都定时执行日志备份脚本autobak.sh</span></span><br><span class="line">[root@localhost ~]# crontab -e</span><br><span class="line">30 3 1,10,15 * * /root/sh/autobak.sh</span><br></pre></td></tr></table></figure>



<p>3）crontab的注意事项</p>
<p>在书写crontab定时任务时，需要注意几个注意事项：</p>
<ul>
<li>六个选项都不能为空，必须填写。如果不确定使用“*”代表任意时间。</li>
<li>crontab定时任务，最小有效时间是分钟，最大时间范围是月。</li>
<li>在定义时间时，日期和星期最好不要在一条定时任务中出现，因为它们都是以天为单位，非常容易让管理员混乱。</li>
<li>在定时任务中，不管是直接写命令，还是在脚本中写命令，最好都是用绝对路径。有时相对路径的命令会报错。</li>
</ul>
<p>4）系统的crontab设置</p>
<p>“crontab -e”是每个用户执行的命令，也就是说不同的用户身份可以执行自己的定时任务。可以是有些定时任务需要系统执行，这时就需要编辑&#x2F;etc&#x2F;crontab这个配置文件了。当然，并不是说写入&#x2F;etc&#x2F;crontab配置文件中的定时任务执行时，不需要用户身份，而是”crontab -e”命令定义定时任务时，默认用户身份是当前登录用户。而修改&#x2F;etc&#x2F;crontab配置文件时，定时任务的执行者身份是可以手工指定的。这样定时任务的执行会更加灵活，修改起来也更加方便。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/crontab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unlike any other crontab you don<span class="string">&#x27;t have to run the `crontab&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> to install the new version when you edit this file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and files <span class="keyword">in</span> /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that none of the other crontabs <span class="keyword">do</span>.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标识使用哪种shell</span></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can also override PATH, but by default, newer versions inherit it from the environment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example of job definition:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*  *  *  *  * user-name <span class="built_in">command</span> to be executed</span></span><br><span class="line">17 *	* * *	root	cd / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6	* * *	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.daily; &#125;</span><br><span class="line">47 6	* * 7	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.weekly; &#125;</span><br><span class="line">52 6	1 * *	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.monthly; &#125;</span><br><span class="line"><span class="meta prompt_">#</span></span><br></pre></td></tr></table></figure>

<p>修改&#x2F;etc&#x2F;crontab这个配置文件，加入自己的定时任务，不过需要注意指定脚本的执行者身份：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/crontab</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/crontab: system-wide crontab</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Unlike any other crontab you don<span class="string">&#x27;t have to run the `crontab&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">command</span> to install the new version when you edit this file</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and files <span class="keyword">in</span> /etc/cron.d. These files also have username fields,</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">that none of the other crontabs <span class="keyword">do</span>.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">标识使用哪种shell</span></span><br><span class="line">SHELL=/bin/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can also override PATH, but by default, newer versions inherit it from the environment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Example of job definition:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">.---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">|  |  |  |  |</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*  *  *  *  * user-name <span class="built_in">command</span> to be executed</span></span><br><span class="line">17 *	* * *	root	cd / &amp;&amp; run-parts --report /etc/cron.hourly</span><br><span class="line">25 6	* * *	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.daily; &#125;</span><br><span class="line">47 6	* * 7	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.weekly; &#125;</span><br><span class="line">52 6	1 * *	root	test -x /usr/sbin/anacron || &#123; cd / &amp;&amp; run-parts --report /etc/cron.monthly; &#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用run-parts脚本调用并执行/root/cron/目录中所有的可执行文件</span></span><br><span class="line">* * * * *       root    run-parts /root/cron/</span><br></pre></td></tr></table></figure>

<p>只要保存&#x2F;etc&#x2F;crontab文件，这个定时任务就可以执行了，当然要确定crond服务是运行的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>软件包安装</title>
    <url>/2025/02/25/%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a>软件包安装</h1><h2 id="1-软件包分类"><a href="#1-软件包分类" class="headerlink" title="1. 软件包分类"></a>1. 软件包分类</h2><ul>
<li>源码包</li>
<li>二进制包</li>
</ul>
<h2 id="2-源码包"><a href="#2-源码包" class="headerlink" title="2. 源码包"></a>2. 源码包</h2><h3 id="1）源码包优点"><a href="#1）源码包优点" class="headerlink" title="1）源码包优点"></a>1）源码包优点</h3><ul>
<li>开源，如果有足够的能力，可以修改源码包。</li>
<li>可以自由选择所需的功能</li>
<li>软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高</li>
<li>卸载方便</li>
</ul>
<h3 id="2）源码包缺点"><a href="#2）源码包缺点" class="headerlink" title="2）源码包缺点"></a>2）源码包缺点</h3><ul>
<li>安装过程步骤较多，尤其安装较大的软件集合时(如LAMP环境搭建)，容易出现拼写错误</li>
<li>编译过程时间较长，安装比二进制安装时间长</li>
<li>因为是编译安装，安装过程中一旦报错新手很难解决</li>
</ul>
<h2 id="3-二进制包"><a href="#3-二进制包" class="headerlink" title="3. 二进制包"></a>3. 二进制包</h2><p>Linux系列：Debian和RedHat。</p>
<h3 id="1）二进制包分类"><a href="#1）二进制包分类" class="headerlink" title="1）二进制包分类"></a>1）二进制包分类</h3><p>a）DPKG包</p>
<p>是由Debian Linux所开发出来的包管理机制，通过DPKG包，Debian Linux就可以进行软件包管理。主要应用在Debian和Ubuntu中。</p>
<p>b）RPM包</p>
<p>是由Red Hat公司所开发的包管理系统。功能强大，安装、升级、查询和卸载都非常简单和方便。目前很多Linux都在使用这种包管理方式，包括Fedora、CentOS、SuSE等。</p>
<h3 id="2）RPM包特点"><a href="#2）RPM包特点" class="headerlink" title="2）RPM包特点"></a>2）RPM包特点</h3><p>RPM包优点：</p>
<ul>
<li>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
<p>RPM包缺点：</p>
<ul>
<li>经过编译，不再可以看到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>依赖性。有时我们会发现需要安装软件包a时需要先安装b和c，而安装b时需要安装d和e。这时需要先安装d和e，再安装b和c，最后才能安装a包。</li>
</ul>
<h3 id="3）RPM包依赖"><a href="#3）RPM包依赖" class="headerlink" title="3）RPM包依赖"></a>3）RPM包依赖</h3><p>a）树形依赖</p>
<p>a——&gt;b——&gt;c</p>
<p>b）环形依赖</p>
<p>a——&gt;b——&gt;c——&gt;a</p>
<p>c）模块依赖</p>
<p>什么是模块依赖？例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-connector-odbc-5.2.5-7.el7.x86_64.rpm</span><br><span class="line">错误：依赖检测失败：</span><br><span class="line">    libodbc.so.2()(64bit) 被 mysql-connector-odbc-5.2.5-7.el7.x86_64 需要</span><br><span class="line">    libodbcinst.so.2()(64bit) 被 mysql-connector-odbc-5.2.5-7.el7.x86_64 需要</span><br></pre></td></tr></table></figure>

<p>发现报错，需要安装”libodbc.so.2”函数库文件，这时会发现在光盘中根本找不到这个文件，那是因为函数库没有单独成包，是包含在某一个软件包中的，而如果知道在哪个软件包中，需要查询网站<a href="http://www.rpmfind.net./">www.rpmfind.net。</a></p>
<h3 id="4）RPM包安装方法"><a href="#4）RPM包安装方法" class="headerlink" title="4）RPM包安装方法"></a>4）RPM包安装方法</h3><ul>
<li>手工安装</li>
<li>yum在线安装</li>
</ul>
<h2 id="4-软件包选择建议"><a href="#4-软件包选择建议" class="headerlink" title="4. 软件包选择建议"></a>4. 软件包选择建议</h2><ul>
<li>源码包：如果软件包是给大量客户端提供访问，建议使用源码包安装，源码包效率更高(LAMP)。</li>
<li>RPM包：如果软件包是给Linux底层使用，或只给少量客户访问，建议使用RPM包安装，因为RPM包简单。</li>
</ul>
<h2 id="5-RPM手工安装"><a href="#5-RPM手工安装" class="headerlink" title="5. RPM手工安装"></a>5. RPM手工安装</h2><p>rpm数据库路径：&#x2F;var&#x2F;lib&#x2F;rpm&#x2F;</p>
<h3 id="1）RPM包命名规则"><a href="#1）RPM包命名规则" class="headerlink" title="1）RPM包命名规则"></a>1）RPM包命名规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">httpd-2.2.15-15.el6.centos.1.i686.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li>httpd：软件包名</li>
<li>2.2.15：软件版本</li>
<li>15：软件发布的次数</li>
<li>el6：软件发行商。el6是RedHat公司发布，适合RHEL6.x(Red Hat Enterprise Linux)和CentOS6.x下使用</li>
<li>i686：适合的硬件平台。RPM包可以在不同的硬件平台安装，选择适合不同CPU的软件版本，可以最大化的发挥CPU性能，所以出现了所谓的i386（386以上计算机都可以安装）、i586（586以上的计算机都可以安装）、i686（奔腾II以上计算机都可以安装，目前所有的CPU都是奔腾II以上，所以这个软件版本居多）、x86_64（64位CPU可以安装）和noarch（没有硬件限制）等文件名了。</li>
<li>rpm：rpm包的扩展名，我们说过Linux下文件不是靠扩展名区分文件类型，也就是Linux中扩展名没有任何意义。可是这里怎么又出现了扩展名呢？如果RPM包不用“rpm”作为扩展名，系统可以正确识别没有问题，可是管理员很难识别这是个什么样的软件。</li>
</ul>
<h3 id="2）RPM包手工命令安装"><a href="#2）RPM包手工命令安装" class="headerlink" title="2）RPM包手工命令安装"></a>2）RPM包手工命令安装</h3><p>a）默认安装位置</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;bin&#x2F;</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib&#x2F;</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;man&#x2F;</td>
<td>帮助文件保存位置</td>
</tr>
</tbody></table>
<p>b）安装命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh 包全名</span><br><span class="line">选项：</span><br><span class="line">  -i    install安装(install)</span><br><span class="line">  -v    显示更详细的信息(verbose)</span><br><span class="line">  -h    打印#显示安装进度(hash)</span><br></pre></td></tr></table></figure>

<p>其他选项：</p>
<ul>
<li>–nodeps：不检测依赖性安装。安装软件时会检测依赖性，确定所需的底层软件是否安装。如果没有安装则会报错。如果我不管依赖性，想强行安装，可以使用这个选项。这样不检测依赖性安装的软件是不能使用的，所以不建议这样做。</li>
<li>–replacefiles：替换文件安装。如果安装软件包，可是包中部分文件已经存在，那么正常安装时，会报错”某个文件已经存在”从而导致软件无法安装，使用这个选项可以忽视这个报错，而覆盖安装。</li>
<li>–replacepkgs：替换软件包安装。如果软件包已经安装，此选项可以把软件包重复安装一遍。</li>
<li>–force：强制安装。不管是否已经安装，都重新安装。就是–replacefiles和–replacepkgs的综合。</li>
<li>–test：测试安装。不会实际安装，只是检测一下依赖性。</li>
<li>–prefix：指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。如果指定了安装路径，软件没有安装到系统默认路径中的话，系统会找不到这些安装的软件，需要进行手工配置才能被系统识别。所以rpm包我们一般都采用默认路径安装：1）默认安装位置是系统的习惯位置。2）RPM包管理系统是有卸载命令的(数据库记录安装位置)</li>
</ul>
<p>c）服务启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># service启动</span><br><span class="line">service 服务名 start|stop|restart|status</span><br><span class="line">参数：</span><br><span class="line">  start:    启动服务</span><br><span class="line">  stop:     停止服务</span><br><span class="line">  restart:  重启服务</span><br><span class="line">  status:   查看服务状态</span><br><span class="line">  </span><br><span class="line">  # 标准启动</span><br><span class="line">  /etc/init.d/服务名 start|stop|restart|status</span><br></pre></td></tr></table></figure>



<h3 id="3）RPM包升级"><a href="#3）RPM包升级" class="headerlink" title="3）RPM包升级"></a>3）RPM包升级</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -Uvh 包全名</span><br><span class="line">选项：</span><br><span class="line">  -U      升级安装，如果没有安装过，系统直接安装。如果安装过的版本较旧，则升级到新版本(upgrade)</span><br><span class="line"> </span><br><span class="line">rpm -Fvh 包全名</span><br><span class="line">选项：</span><br><span class="line">  -F      升级安装，如果没有安装过，则不会安装，必须安装有较旧版本，才能升级(freshen)</span><br></pre></td></tr></table></figure>



<h3 id="4）RPM包卸载"><a href="#4）RPM包卸载" class="headerlink" title="4）RPM包卸载"></a>4）RPM包卸载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -e 包名</span><br><span class="line">选项：</span><br><span class="line">  --nodeps      不检查依赖性</span><br><span class="line">  -e            卸载</span><br></pre></td></tr></table></figure>



<h3 id="5）RPM包查询"><a href="#5）RPM包查询" class="headerlink" title="5）RPM包查询"></a>5）RPM包查询</h3><p>a）查询软件包是否安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -q 包名</span><br><span class="line">选项：</span><br><span class="line">  -q：查询(query)</span><br></pre></td></tr></table></figure>



<p>b）查询系统中的所有安装软件包</p>
<p>可以查询Linux系统中所有已经安装的软件包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa</span><br><span class="line">选项：</span><br><span class="line">  -a：所有(all)</span><br></pre></td></tr></table></figure>

<p>可以用管道符来查看所需内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep 包名</span><br></pre></td></tr></table></figure>



<p>c）查询软件包的详细信息</p>
<p>可以查询已经安装的某个软件包的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qi 包名</span><br><span class="line">选项：</span><br><span class="line">  -i：查询软件信息(information)</span><br></pre></td></tr></table></figure>

<p>也可以查询还没有安装的软件包的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qip 包全名</span><br><span class="line">选项：</span><br><span class="line">  -p：查询没有安装的软件包(package)</span><br></pre></td></tr></table></figure>



<p>d）查询软件包中的文件列表</p>
<p>可以查询已经安装的软件包中的文件列表和安装的完整目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ql 包名</span><br><span class="line">选项：</span><br><span class="line">  -l：列出软件包中所有的文件列表和软件所安装的目录(list)</span><br></pre></td></tr></table></figure>

<p>查询未安装的软件包中的文件列表和打算安装的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qlp 包全名</span><br><span class="line">选项：</span><br><span class="line">  -p：查询没有安装的软件包信息(package)</span><br></pre></td></tr></table></figure>



<p>e）查询系统文件属于哪个RPM包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qf 系统文件名</span><br><span class="line">选项：</span><br><span class="line">  -f：查询系统文件属于哪个软件包(file)</span><br></pre></td></tr></table></figure>



<p>f）查询软件包所依赖的软件包</p>
<p>查询系统中和已经安装的软件包有依赖关系的软件包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qR 包名</span><br><span class="line">选项：</span><br><span class="line">  -R：查询软件包的依赖性(requires)</span><br></pre></td></tr></table></figure>

<p>查询未安装的软件包的依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qRp 包全名</span><br></pre></td></tr></table></figure>



<h3 id="6）验证"><a href="#6）验证" class="headerlink" title="6）验证"></a>6）验证</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验本机已经安装的所有软件包</span></span><br><span class="line">rpm -Va</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验指定RPM包中的文件(verify)</span></span><br><span class="line">rpm -V 已安装的名包</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验某个系统文件是否被修改</span></span><br><span class="line">rpm -Vf 系统文件名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -V httpd</span><br><span class="line">S.5....T.    c             /etc/httpd/conf/httpd.conf</span><br><span class="line">验证内容    文件类型          文件名</span><br></pre></td></tr></table></figure>

<p>验证内容详情：</p>
<ul>
<li>S：文件大小是否改变</li>
<li>M：文件的类型或文件的权限(rwx)是否被改变</li>
<li>5：文件MD5校验和是否改变(可以看成文件内容是否改变)</li>
<li>D：设备的主从代码是否改变</li>
<li>L：文件路径是否改变</li>
<li>U：文件的属主(所有者)是否改变</li>
<li>G：文件的属组是否改变</li>
<li>T：文件的修改时间是否改变</li>
</ul>
<p>文件类型：</p>
<ul>
<li>c：配置文件(config file)</li>
<li>d：普通文档(documention)</li>
<li>g：“鬼”文件(ghost file)，很少见，就是该文件不应该被这个RPM包包含 </li>
<li>l：授权文件(license file)</li>
<li>r：描述文件(readme)</li>
</ul>
<h3 id="7）数字证书"><a href="#7）数字证书" class="headerlink" title="7）数字证书"></a>7）数字证书</h3><p>前面的校验方法只能对已经安装的RPM包中的文件进行校验，但是如果RPM包本身就被动过手脚，那么校验就不能解决问题了，我们就必须使用数字证书验证了。</p>
<p>数字证书特点：</p>
<ul>
<li>首先必须找到原厂的公钥文件，然后进行安装</li>
<li>再安装RPM包时会提取RPM包中的证书信息，然后和本机安装的原厂证书进行验证</li>
<li>如果验证通过，则允许安装；如果验证不通过，则不允许安装并警告</li>
</ul>
<p> a）数字证书导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm --import 数字证书文件</span><br><span class="line">选项：</span><br><span class="line">  --import：导入数字证书</span><br></pre></td></tr></table></figure>



<p>b）查询系统中安装好的数字证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep gpg-pubkey</span><br></pre></td></tr></table></figure>



<h3 id="8）RPM包中文件的提取"><a href="#8）RPM包中文件的提取" class="headerlink" title="8）RPM包中文件的提取"></a>8）RPM包中文件的提取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm2cpio 包全名 | cpio -idv . 文件的绝对路径</span><br></pre></td></tr></table></figure>

<p>rpm2cpio：将rpm包转换为cpio格式的命令。</p>
<p>cpio：是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件。</p>
<h2 id="6-RPM包在线安装-yum"><a href="#6-RPM包在线安装-yum" class="headerlink" title="6. RPM包在线安装(yum)"></a>6. RPM包在线安装(yum)</h2><h3 id="1）yum源文件解析"><a href="#1）yum源文件解析" class="headerlink" title="1）yum源文件解析"></a>1）yum源文件解析</h3><p>yum源配置文件保存在&#x2F;etc&#x2F;yum.repos.d&#x2F;目录中，文件的扩展名一定是”*.repo”。也就是说，yum源配置文件只要扩展名是”*.repo”就会生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /etc/yum.repos.d/</span><br><span class="line">CentOS-Base.repo    CentOS-Debuginfo.repo    CentOS-fasttrack.repo    CentOS-Media.repo    CentOS-Vault.repo</span><br></pre></td></tr></table></figure>

<p>这个目录中有5个yum源配置文件，默认情况下CentOS-Base.repo文件生效。</p>
<p>CentOS-Base.repo中有5个yum源容器，以base容器解释其内容详情：</p>
<ul>
<li>[base]：容器名称，一定要放在[]中。</li>
<li>name：容器说明，可以自己随便写。</li>
<li>mirrorlist：镜像站点，这个可以注释掉。</li>
<li>baseurl：yum源服务器的地址。默认是CentOS官方的yum源服务器，是可以使用的。如果觉得慢，可以改成国内yum源地址。</li>
<li>enabled：此容器是否生效，如果不写或写成enabled&#x3D;1则表示此容器生效，写成enabled&#x3D;0则表示此容器不生效。</li>
<li>gpgcheck：如果为1则表示RPM的数字证书生效，如果为0则表示RPM的数字证书不生效。</li>
<li>gpgkey：数字证书的公钥文件保存位置，不用修改。</li>
</ul>
<h3 id="2）搭建本地光盘yum源"><a href="#2）搭建本地光盘yum源" class="headerlink" title="2）搭建本地光盘yum源"></a>2）搭建本地光盘yum源</h3><p>a）放入CentOS安装光盘，并挂载光盘到指定位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建cdrom目录，作为光盘的挂载点</span></span><br><span class="line">mkdir /mnt/cdrom</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载光盘到/mnt/cdrom</span></span><br><span class="line">mount /dev/cdrom /mnt/cdrom/</span><br></pre></td></tr></table></figure>

<p>b）修改其他几个yum源配置文件的扩展名，让它们失效，因为只有扩展名是”*.repo”的文件才能作为yum源配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repo.d</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure>

<p>c）修改光盘yum源配置文件CentOS-Media.repo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim CentOS-Media.repo</span><br><span class="line">[c6-media]</span><br><span class="line">name=CentOS-$releasever - Media</span><br><span class="line">baseurl=file:///mnt/cdrom/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1   # 让配置生效</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>

<p>d）查看是否生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询yum源所有可安装的软件包列表</span></span><br><span class="line">yum list</span><br></pre></td></tr></table></figure>



<h3 id="3）yum命令"><a href="#3）yum命令" class="headerlink" title="3）yum命令"></a>3）yum命令</h3><p>a）查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询yum所有安装包</span></span><br><span class="line">yum list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询yum源服务器中是否包含某个软件包</span></span><br><span class="line">yum list 包名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索yum源服务器上所有和关键字相关的软件包</span></span><br><span class="line">yum search 关键字</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询指定软件包的信息</span></span><br><span class="line">yum info samba</span><br></pre></td></tr></table></figure>

<p>yum search搜索可以用于确定某个软件在哪个相关包当中。</p>
<p>b）安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install 包名</span><br><span class="line">选项：</span><br><span class="line">  install：    安装</span><br><span class="line">  -y：         自动回答yes。如果不加-y，那么每个安装的软件都需要手工回答yes</span><br></pre></td></tr></table></figure>



<p>c）升级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y update 包名</span><br><span class="line">选项：</span><br><span class="line">  update:    升级</span><br><span class="line">  -y：       自动回答yes</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">升级本机所有软件包（包括内核，不常用）</span></span><br><span class="line">yum -y update</span><br></pre></td></tr></table></figure>



<p>d）卸载</p>
<p>除非你确定卸载的软件的依赖包不会对系统产生影响，否则不要执行yum的卸载，因为很有可能在卸载软件包的同时卸载的依赖包也是重要的系统文件，这就可能导致系统崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove 包名</span><br></pre></td></tr></table></figure>



<h3 id="4）yum组管理命令"><a href="#4）yum组管理命令" class="headerlink" title="4）yum组管理命令"></a>4）yum组管理命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有可用的软件组列表</span></span><br><span class="line">yum grouplist</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出软件组中包含的软件</span></span><br><span class="line">yum groupinfo 软件组名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装指定软件组</span></span><br><span class="line">yum groupinstall 软件组名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载指定软件组</span></span><br><span class="line">yum groupremove 软件组名</span><br></pre></td></tr></table></figure>



<h2 id="7-源码包安装"><a href="#7-源码包安装" class="headerlink" title="7.源码包安装"></a>7.源码包安装</h2><h3 id="1）注意事项"><a href="#1）注意事项" class="headerlink" title="1）注意事项"></a>1）注意事项</h3><p>a）源码包是从哪里来的？</p>
<p>源码包是通过官方网站下载的，如果需要使用，是需要单独下载的。</p>
<p>b）是否可以在系统中既安装rpm包的Apache，又安装源码包的Apache？</p>
<p>可以，因为两种安装方法安装的Apache，安装位置是不一样的：</p>
<ul>
<li>源码包必须指定安装位置(源码包没有安装数据库，没有删除命令)</li>
<li>RPM包不建议指定安装位置，建议安装在默认位置(RPM包安装的服务有标准卸载命令，不怕文件到处安装)</li>
</ul>
<h3 id="2）安装过程"><a href="#2）安装过程" class="headerlink" title="2）安装过程"></a>2）安装过程</h3><p>a）下载软件包</p>
<p>b）解压缩</p>
<p>c）进入解压目录</p>
<p>d）.&#x2F;configure（编译前准备）</p>
<p>这一步主要有三个作用：</p>
<ul>
<li>在安装之前需要检测系统环境是否符合安装要求。</li>
<li>定义需要的功能选项。”.&#x2F;configure”支持的功能选项较多，可以执行“.&#x2F;configure –help”命令查询其支持的功能，一般都会通过”.&#x2F;configure –prefix&#x3D;安装路径”来指定安装路径。</li>
<li>把系统环境的检测结果和定义好的功能选项写入Makefile文件，后续的编译和安装需要依赖这个文件的内容。</li>
</ul>
<p>需要注意的是，configure不是系统命令，而是源码包软件自带的一个脚本程序，所以必须采用“.&#x2F;configure”方式执行。</p>
<p>e）make（编译）</p>
<p>make会调用gcc编译器，并读取Makefile文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被Linux识别的可执行文件，这些可执行文件保存在当前目录下。编译过程较为耗时，需要有足够的耐心。</p>
<p>f）make clean（清空编译内容，非必需步骤）</p>
<p>如果在”.&#x2F;configure”或“make”编译中报错，那么我们在重新执行命令前一定要记得执行make clean命令，它会清空Makefile文件或编译产生的“.o”文件。</p>
<p>g）make install（编译安装）</p>
<p>这才是真正的安装过程，一般会写清楚程序的安装位置。如果忘记指定安装目录，则可以把这个命令的执行过程保存下来，以备将来删除使用。</p>
<h3 id="3）删除"><a href="#3）删除" class="headerlink" title="3）删除"></a>3）删除</h3><p>源码包没有删除命令，如果需要删除，直接删除安装目录即可。</p>
<h3 id="4）打入补丁"><a href="#4）打入补丁" class="headerlink" title="4）打入补丁"></a>4）打入补丁</h3><p>a）补丁的生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 比较old和new文件的不同</span><br><span class="line">diff 选项 old new</span><br><span class="line">选项：</span><br><span class="line">  -a    将任何文档当做文本文档处理</span><br><span class="line">  -b    忽略空格造成的不同</span><br><span class="line">  -B    忽略空白行造成的不同</span><br><span class="line">  -I    忽略大小写造成的不同</span><br><span class="line">  -N    当比较两个目录时，如果某个文件只在一个目录中，则另一个目录中视作空文件。</span><br><span class="line">  -r    当比较目录时，递归比较子目录</span><br><span class="line">  -u    使用统一的输出格式</span><br></pre></td></tr></table></figure>

<p>比较两个文件的不同，并生成补丁文件”txt.patch”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 比较两个文件的不同，同时生成txt.patch补丁文件</span><br><span class="line">diff -Naur /root/test/old.txt /root/test/new.txt &gt; txt.patch</span><br></pre></td></tr></table></figure>



<p>b）打入补丁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按照补丁文件进行更新</span><br><span class="line">patch -pn &lt; 补丁文件</span><br><span class="line">选项：</span><br><span class="line">  -pn    n为数字。代表按照补丁文件中的路径，指定更新文件的位置。</span><br></pre></td></tr></table></figure>

<p>“-pn”不好理解，补丁文件是要打入旧文件的，但是你当前所在的目录和补丁文件中的记录是不一定匹配的，所以就需要”-pn”来同步两个目录。</p>
<p>比如我当前在“&#x2F;root&#x2F;test”目录下，补丁文件中记录的文件目录是为“&#x2F;root&#x2F;test&#x2F;old.txt”。这时如果写入“p1”，那么补丁文件就会打入”&#x2F;root&#x2F;test&#x2F;root&#x2F;test&#x2F;old.txt”。如果写入的是“p2”，那么补丁文件就会打入”&#x2F;root&#x2F;test&#x2F;test&#x2F;old.txt”。如果写入的是“p3”，那么补丁文件就会打入”&#x2F;root&#x2F;test&#x2F;old.txt”。即n表示删除补丁文件中记录的文件目录的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch -p3 &lt; txt.patch</span><br></pre></td></tr></table></figure>



<h2 id="8-脚本安装程序"><a href="#8-脚本安装程序" class="headerlink" title="8. 脚本安装程序"></a>8. 脚本安装程序</h2><p>以Webmin安装为例。</p>
<p>a）下载webmin软件，地址：<a href="http://sourceforge.net/projects/webadmin/files/webmin/">http://sourceforge.net/projects/webadmin/files/webmin/</a></p>
<p>b）解压软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf webmin-1.610.tar.gz</span><br></pre></td></tr></table></figure>

<p>c）进入解压目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd webmin-1.610</span><br></pre></td></tr></table></figure>

<p>d）执行安装程序setup.sh，并指定功能选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>高级文件系统管理</title>
    <url>/2025/02/25/%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="高级文件系统管理"><a href="#高级文件系统管理" class="headerlink" title="高级文件系统管理"></a>高级文件系统管理</h1><h2 id="1-磁盘配额"><a href="#1-磁盘配额" class="headerlink" title="1. 磁盘配额"></a>1. 磁盘配额</h2><h3 id="1）磁盘配额条件"><a href="#1）磁盘配额条件" class="headerlink" title="1）磁盘配额条件"></a>1）磁盘配额条件</h3><ul>
<li><p>内核必须支持磁盘配额</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep CONFIG_QUOTA /boot/config-2.6.32-279.el6.i686</span><br><span class="line">CONFIG_QUOTA=y</span><br><span class="line">CONFIG_QUOTA_NETLINK_INTERFACE=y</span><br><span class="line"># CONFIG_QUOTA_DEBUG is not set</span><br><span class="line">CONFIG_QUOTA_TREE=m</span><br><span class="line">CONFIG_QUOTACTL=y</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统中必须安装了quota工具，Linux默认是安装了quota工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa | grep quota</span><br><span class="line">quota-3.17-16.el6.i686</span><br></pre></td></tr></table></figure>

<p>要支持磁盘配额的分区必须开启磁盘配额功能，这个功能需要手工开启，不再是默认就开启的。</p>
</li>
</ul>
<h3 id="2）概念"><a href="#2）概念" class="headerlink" title="2）概念"></a>2）概念</h3><ul>
<li>用户配额和组配额</li>
<li>磁盘容量限制和文件个数限制</li>
<li>软限制和硬限制</li>
<li>宽限时间</li>
</ul>
<p>如果用户的空间占用数处于软限制和硬限制之间，都会在用户登录时警告用户磁盘将满，这个时间就是宽限时间，默认是7天。如果达到了宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级为硬限制。</p>
<h3 id="3）磁盘配额规划"><a href="#3）磁盘配额规划" class="headerlink" title="3）磁盘配额规划"></a>3）磁盘配额规划</h3><p>磁盘配额实验：</p>
<ul>
<li>磁盘配额是限制普通用户在分区上使用磁盘空间和文件个数的，所以我们需要指定一个分区，那么我们手工建立一个5GB的&#x2F;dev&#x2F;sdb1分区，把它挂载到&#x2F;disk目录当中。</li>
<li>还有我们需要建立被限制的用户和用户组。那么我们假设需要限制user1、user2和user3用户，这三个用户属于test组。</li>
<li>其中test组磁盘容量硬限制为500MB，软限制450MB，文件个数不做限制。user1用户为了便于测试，磁盘容量硬限制为50MB，软限制为40MB，文件个数硬限制为10个，软限制为8个。user2和user3用户磁盘容量硬限制为250MB，软限制为200MB，文件个数不做限制。</li>
<li>user1、user2和user3用户加起来的磁盘容量限制为550MB，超过了test组的磁盘容量500MB。这样的话，某个用户可能达不到自己的用户限制，而达到组限制时就不能再写入数据了。也就是说，如果用户限制和组限制同时存在，那么哪个限制更小，哪个限制优先生效。</li>
<li>系统宽限时间改为8天。</li>
</ul>
<p>磁盘配额步骤：</p>
<ul>
<li><p>分配5GB的&#x2F;dev&#x2F;sdb1分区，并将它挂载到&#x2F;disk目录当中。</p>
</li>
<li><p>建立需要做限制的用户和用户组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# groupadd test</span><br><span class="line">[root@localhost ~]# useradd -G test user1</span><br><span class="line">[root@localhost ~]# useradd -G test user2</span><br><span class="line">[root@localhost ~]# useradd -G test user3</span><br><span class="line">[root@localhost ~]# passwd user1</span><br><span class="line">[root@localhost ~]# passwd user2</span><br><span class="line">[root@localhost ~]# passwd user3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在分区上开启磁盘配额功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,usruota,grpquota /disk    # 重新挂载/disk分区，并加入用户和用户组的磁盘配额功能</span><br></pre></td></tr></table></figure>

<p>要想永久生效，则需要修改&#x2F;etc&#x2F;fstab文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1    /disk    ext4    defaults,usrquota,grpquota    0    0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /disk    # 修改配置文件如果想要生效，必须重启系统，否则也需要把分区重新挂载一遍</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立磁盘配额的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：扫描/etc/mtab文件中所有启用磁盘配额功能的分区。如果加入此参数，命令后面就不需要加入分区名了</span><br><span class="line">  -c：不管原有的配置文件，重新扫描并建立新的配置文件</span><br><span class="line">  -u：建立用户配额的配置文件，也就是生成aquota.user文件</span><br><span class="line">  -g：建立组配额的配置文件，会生成aquota.group文件</span><br><span class="line">  -v：显示扫描过程</span><br><span class="line">  -m：强制以读写的方式扫描文件系统，和-M类似。一般扫描根分区时使用。</span><br><span class="line">  -f：强制扫描文件系统，并写入新的配置文件。一般扫描新添加的硬盘分区时使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck -avug</span><br></pre></td></tr></table></figure>

<p>需要关闭SELinux，否则会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /disk/</span><br><span class="line">总计 24</span><br><span class="line">-rw-------   1 root root  6144  4月 31 19:30 aquota.group</span><br><span class="line">-rw-------   1 root root  6144  4月 18 19:30 aquota.user</span><br><span class="line"># /disk目录中两个配额配置文件已经建立</span><br></pre></td></tr></table></figure>

<p>如果需要给根分区开启配额功能，需要：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2    /    ext4    defaults,usrquota,grpquota    1    1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /</span><br><span class="line">[root@localhost ~]# quotacheck -avugm</span><br></pre></td></tr></table></figure>

<p>如果我们自动扫描&#x2F;分区建立配额文件时，因为&#x2F;分区已经挂载成读写系统，而quotacheck需要把分区先挂载成只读分区，然后建立配置文件，最后再挂载回来，所以不能直接在&#x2F;分区建立配置文件，这时就需要使用-m强制以读写方式扫描文件系统了。</p>
<ul>
<li><p>设置用户和组的配额限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# edquota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：  设定用户配额</span><br><span class="line">  -g 组名：    设定组配额</span><br><span class="line">  -t：        设定宽限时间</span><br><span class="line">  -p：        复制配额限制。如果已经设定好某个用户的配额限制，其他用户的配额限制如果和这个用户相同，那么可以直接复制配额限制，而不用都手工指定</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# edquota -u user1</span><br><span class="line"># edquota命令进入之后，就是标准的vi操作方法</span><br><span class="line">Disk quotas for user user1（uid 500）：</span><br><span class="line"># 磁盘配额是设定用户user1（UID是500）</span><br><span class="line">Filesystem    blocks        soft     hard     inodes        soft      hard</span><br><span class="line">/dev/sdb1       0           40000    50000      0            8         10</span><br><span class="line"># 分区名        已占用容量    软限制    硬限制     已占用文件数   软限制     硬限制</span><br></pre></td></tr></table></figure>
</li>
<li><p>配额复制</p>
<p>user3用户的配额值和user2用户完全一样，就可以使用user2用户作为模板进行复制，这样我们如果需要建立大量的配额值一致的用户时，就会非常方便，不用一个个手工建立了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# edquota -p user2 -u user3</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改宽限时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# edquota -t</span><br><span class="line">Grace period before enforcing soft limits for users:</span><br><span class="line">Time units may be: days, hours, minutes, or seconds</span><br><span class="line">Filesystem    Block grace period    Inode grace period</span><br><span class="line">/dev/sdb1       8days                8days</span><br><span class="line"># 分区名        容量的宽限时间          个数的宽限时间</span><br></pre></td></tr></table></figure>


</li>
<li><p>启动和关闭配额</p>
<p>启动配额：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quotaon [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件启动所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：启动用户配额</span><br><span class="line">  -g：启动组配额</span><br><span class="line">  -v：显示启动过程的信息</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quotaon -vug /disk/        # 启动/disk分区的配额</span><br><span class="line">/dev/sdb1 [/disk]：group quotas turned on</span><br><span class="line">/dev/sdb1 [/disk]：user quotas turned on</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# quotaon -avug        # 这条命令也可以</span><br></pre></td></tr></table></figure>

<p>关闭配额：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quotaoff [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件关闭所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：关闭用户配额</span><br><span class="line">  -g：关闭组配额</span><br><span class="line">  </span><br><span class="line"> [root@localhost ~]# quotaoff -a        # 依据/etc/mtab文件关闭配额分区</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4）磁盘配额查询"><a href="#4）磁盘配额查询" class="headerlink" title="4）磁盘配额查询"></a>4）磁盘配额查询</h3><ul>
<li><p>quota查询用户或用户组配额</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：   查询用户配额</span><br><span class="line">  -g 组名：     查询组配额</span><br><span class="line">  -v：          显示详细信息</span><br><span class="line">  -s：          以习惯单位显示容量大小，如M,G</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quota -uvs user1</span><br></pre></td></tr></table></figure>
</li>
<li><p>repquota查询文件系统配额</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# repquota [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：    依据/etc/mtab文件查询配额，如果不加-a选项，就一定要加分区名</span><br><span class="line">  -u：    查询用户配额</span><br><span class="line">  -g:     查询组配额</span><br><span class="line">  -v：    显示详细信息</span><br><span class="line">  -s：    以习惯单位显示容量大小</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# repquota -augvs</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5）测试"><a href="#5）测试" class="headerlink" title="5）测试"></a>5）测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user1@localhost disk]$ dd if=/dev/zero of=/disk/testfile bs=1M count=60    # 建立testfile文件，指定大小60MB</span><br></pre></td></tr></table></figure>



<h3 id="6）非交互设定用户磁盘配额"><a href="#6）非交互设定用户磁盘配额" class="headerlink" title="6）非交互设定用户磁盘配额"></a>6）非交互设定用户磁盘配额</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">[root@localhost ~]# setquota -u user4 10000 20000 5 8 /disk</span><br></pre></td></tr></table></figure>



<h2 id="2-LVM逻辑卷管理"><a href="#2-LVM逻辑卷管理" class="headerlink" title="2. LVM逻辑卷管理"></a>2. LVM逻辑卷管理</h2><h3 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h3><p>LVM是Logical Volume Manager的简称，中文就是逻辑卷管理。</p>
<ul>
<li>物理卷(PV, Physical Volume)：就是真正的物理硬盘或分区。</li>
<li>卷组(VG, Volume Group)：将多个物理卷合起来就组成了卷组，组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘上的不同分区，可以把卷组想象为一个逻辑硬盘。</li>
<li>逻辑卷(LV, Logical Volume)：卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区称作逻辑卷，逻辑卷可以格式化和写入数据。可以把逻辑卷想象成为分区。</li>
<li>物理扩展(PE, Physical Extend)：PE是用来保存数据的最小单元，数据实际上都是写入PE当中，PE的大小是可以配置的，默认是4MB。</li>
</ul>
<h3 id="2）建立LVM的步骤"><a href="#2）建立LVM的步骤" class="headerlink" title="2）建立LVM的步骤"></a>2）建立LVM的步骤</h3><ul>
<li>首先需要把物理硬盘分成分区，当然也可以是整块物理硬盘。</li>
<li>然后把物理分区建立成为物理卷(PV)，也可以直接把整块硬盘都建立为物理卷。</li>
<li>接下来把物理卷整合成为卷组(VG)。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。</li>
<li>最后就是把卷组再划分成为逻辑卷(LV)，当然逻辑卷也是可以直接调整大小的。逻辑卷可以想象成为分区，所以也需要格式化和挂载。</li>
</ul>
<h3 id="3）物理卷管理"><a href="#3）物理卷管理" class="headerlink" title="3）物理卷管理"></a>3）物理卷管理</h3><p>a）硬盘分区</p>
<p>创建方式就是使用fdisk交互命令，不过需要注意的是分区的系统ID不再是Linux默认的分区ID号(83)了，而要改为LVM的ID号8e。</p>
<p>b）建立物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate [设备文件名]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"># 把整块硬盘都建立成物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb</span><br><span class="line"></span><br><span class="line"># 把分区建立成为物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb5</span><br></pre></td></tr></table></figure>



<p>c）查看物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvscan</span><br><span class="line">[root@localhost ~]# pvdisplay        # 更详细的物理卷信息</span><br></pre></td></tr></table></figure>



<p>d）删除物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvremove /dev/sdb5</span><br></pre></td></tr></table></figure>



<h3 id="4）卷组管理"><a href="#4）卷组管理" class="headerlink" title="4）卷组管理"></a>4）卷组管理</h3><p>a）建立卷组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate [选项] 卷组名 物理卷名</span><br><span class="line">[选项]：</span><br><span class="line">  -s PE大小    指定PE的大小，单位可以是MB,GB,TB等。如是不写默认PE大小为4MB</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6</span><br></pre></td></tr></table></figure>



<p>b）查看卷组</p>
<p>查看卷组的命令有两个：</p>
<ul>
<li><p>vgscan</p>
<p>vgscan主要是查看系统中是否有卷组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgscan</span><br></pre></td></tr></table></figure>
</li>
<li><p>vgdisplay</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgdisplay</span><br></pre></td></tr></table></figure></li>
</ul>
<p>c）增加卷组容量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgextend scvg /dev/sdb7</span><br></pre></td></tr></table></figure>



<p>d）减小卷组容量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在卷组中删除/dev/sdb7物理卷</span><br><span class="line">[root@localhost ~]# vgreduce scvg /dev/sdb7</span><br><span class="line"># 删除所有的未使用物理卷</span><br><span class="line">[root@localhost ~]# vgreduce -a</span><br></pre></td></tr></table></figure>



<p>e）删除卷组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgremove scvg</span><br></pre></td></tr></table></figure>

<p>卷组删除之后，才能删除物理卷，要注意的是scvg卷组还没有添加任何的逻辑卷，如果拥有了逻辑卷，得先删除逻辑卷再删除卷组。</p>
<h3 id="5）逻辑卷管理"><a href="#5）逻辑卷管理" class="headerlink" title="5）逻辑卷管理"></a>5）逻辑卷管理</h3><p>a）建立逻辑卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate [选项] [-n 逻辑卷名] 卷组名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：指定逻辑卷大小，单位MB，GB，TB等</span><br><span class="line">  -l 个数：按照PE个数指定逻辑卷大小，这个参数需要换算容量，太麻烦</span><br><span class="line">  -n 逻辑卷名：指定逻辑卷名</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate -L 1.5G -n userlv scvg    # 在scvg卷组中建立1.5GB的userlv逻辑卷</span><br></pre></td></tr></table></figure>

<p>建立完成逻辑卷之后，还要格式化和挂载之后逻辑卷才能正常使用。不过需要注意的是逻辑卷的设备文件名是&#x2F;dev&#x2F;卷组名&#x2F;逻辑卷名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t ext4 /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# mkdir /disklvm</span><br><span class="line">[root@localhost ~]# mount /dev/scvg/userlv /disklvm/</span><br><span class="line">[root@localhost ~]# mount      # 查看挂载</span><br></pre></td></tr></table></figure>

<p>如果需要开机自动挂载，也要修改&#x2F;etc&#x2F;fstab文件。</p>
<p>b）查看逻辑卷</p>
<p>查看命令有两个：</p>
<ul>
<li><p>lvscan</p>
<p>lvscan只能看到系统中是否拥有逻辑卷。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvscan</span><br></pre></td></tr></table></figure>
</li>
<li><p>lvdisplay</p>
<p>lvdisplay可以看到逻辑卷的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvdisplay</span><br></pre></td></tr></table></figure></li>
</ul>
<p>c）调整逻辑卷大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvresize [选项] 逻辑卷设备文件名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：安装容量调整大小，单位KB,GB,TB等。使用+代表增加空间，-号代表减少空间。如果直接写容量，代表设定逻辑卷大小为指定大小。</span><br><span class="line">  -l 个数：按照PE个数调整逻辑卷大小</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvresize -L 2.5.G /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# lvdisplay               # 逻辑卷的大小已经改变了</span><br><span class="line">[root@localhost ~]# df -h /disklvm/         # 大小没有变化</span><br></pre></td></tr></table></figure>

<p>lvresize只能改变逻辑卷的大小，如果需要让分区使用这个新逻辑卷，还要使用resize2fs命令来调整分区的大小。不过这里体现了LVM的优势，不需要卸载分区，直接就能调整分区的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs [选项] [设备文件名] [调整的大小]</span><br><span class="line">选项：</span><br><span class="line">  -f：    强制调整</span><br><span class="line">  设备文件名：指定调整哪个分区的大小</span><br><span class="line">  调整的大小：指定把分区调整到多大，要加M,G等单位。如果不加大小，会使用整个分区</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# df -h /disklvm/       # 已经调整过来了</span><br></pre></td></tr></table></figure>



<h3 id="4）删除逻辑卷"><a href="#4）删除逻辑卷" class="headerlink" title="4）删除逻辑卷"></a>4）删除逻辑卷</h3><p>删除逻辑卷前要先卸载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvremove 逻辑卷设备文件名</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
