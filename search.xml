<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux常用命令</title>
    <url>/2025/02/25/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="1-命令提示符"><a href="#1-命令提示符" class="headerlink" title="1. 命令提示符"></a>1. 命令提示符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$</span><br></pre></td></tr></table></figure>

<ul>
<li>[]：这是提示符的分隔符号，没有特殊含义</li>
<li>ben：显示的是当前的登录用户。</li>
<li>@：分隔符号，没有特殊含义。</li>
<li>ben-NBLK-WAX9X：当前系统的简写主机名。</li>
<li>~：代表用户当前所在的目录。</li>
<li>$：命令提示符，超级用户是#，普通用户是$。</li>
</ul>
<h2 id="2-文件操作命令"><a href="#2-文件操作命令" class="headerlink" title="2. 文件操作命令"></a>2. 文件操作命令</h2><h3 id="1）touch"><a href="#1）touch" class="headerlink" title="1）touch"></a>1）touch</h3><p>创建空文件或者修改文件时间。</p>
<h3 id="2）stat"><a href="#2）stat" class="headerlink" title="2）stat"></a>2）stat</h3><p>查看文件详细信息，而且可以看到文件的四个时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stat abc</span><br><span class="line">文件：abc</span><br><span class="line">  大小：0         	块：0          IO 块大小：4096   普通空文件</span><br><span class="line">设备：259,10	Inode: 2953378     硬链接：1</span><br><span class="line">权限：(0664/-rw-rw-r--)  Uid: ( 1000/     ben)   Gid: ( 1000/     ben)</span><br><span class="line">访问时间：2024-11-19 16:04:02.421884754 +0800      # 最后一次访问时间</span><br><span class="line">修改时间：2024-11-19 16:04:02.421884754 +0800      # 数据修改时间</span><br><span class="line">变更时间：2024-11-19 16:04:02.421884754 +0800      # 状态修改时间</span><br><span class="line">创建时间：2024-11-19 16:03:01.150885757 +0800</span><br></pre></td></tr></table></figure>



<h3 id="3）cat"><a href="#3）cat" class="headerlink" title="3）cat"></a>3）cat</h3><p>【功能描述】：查看文件内容。</p>
<p>选项：</p>
<ul>
<li>-A：相当于-vET选项的整合，用于列出所有隐藏符号</li>
<li>-E：列出每行结尾的回车符$</li>
<li>-n：显示行号</li>
<li>-T：把Tab键用^T显示出来</li>
<li>-v：列出特殊字符</li>
</ul>
<h3 id="4）more"><a href="#4）more" class="headerlink" title="4）more"></a>4）more</h3><p>【功能描述】：分屏显示文件内容。</p>
<p>more命令比较简单，一般不用什么选项，命令会打开一个交互界面，可以识别一些交互命令。常用交互命令如下：</p>
<ul>
<li>空格键：向下翻页</li>
<li>b：向上翻页</li>
<li>回车键：向下滚动一行</li>
<li>&#x2F;字符串：指定搜索的字符串</li>
<li>q：退出</li>
</ul>
<h3 id="5）less"><a href="#5）less" class="headerlink" title="5）less"></a>5）less</h3><p>【功能描述】：分行显示文件内容。</p>
<h3 id="6）head"><a href="#6）head" class="headerlink" title="6）head"></a>6）head</h3><p>【功能描述】：显示文件开头的命令。</p>
<h3 id="7）tail"><a href="#7）tail" class="headerlink" title="7）tail"></a>7）tail</h3><p>【功能描述】：显示文件结尾的命令。</p>
<p>选项：</p>
<ul>
<li>-n 行数：从文件结尾开始，显示指定行数。</li>
<li>-f：监听文件的新增内容，ctrl+c退出。</li>
</ul>
<h3 id="8）ln"><a href="#8）ln" class="headerlink" title="8）ln"></a>8）ln</h3><p>【功能描述】：在文件之间建立链接</p>
<h4 id="1）硬链接"><a href="#1）硬链接" class="headerlink" title="1）硬链接"></a>1）硬链接</h4><p>特征：</p>
<ul>
<li>源文件和硬链接文件拥有相同的Inode和Block</li>
<li>修改任意一个文件，另一个都改变</li>
<li>删除任意一个文件，另一个都能使用</li>
<li>硬链接标记不清，很难确认硬链接文件位置，不建议使用</li>
<li>硬链接不能链接目录</li>
<li>硬链接不能跨分区</li>
</ul>
<h4 id="2）软链接"><a href="#2）软链接" class="headerlink" title="2）软链接"></a>2）软链接</h4><p>特征：</p>
<ul>
<li>软链接和源文件拥有不同的Inode和Block</li>
<li>两个文件修改任意一个，另一个都改变</li>
<li>删除软链接，源文件不受影响；删除源文件，软链接不能使用</li>
<li>软链接没有实际数据，只保存源文件的Inode，不论源文件多大，软链接大小不变</li>
<li>软链接的权限是最大权限lrwxrwxrwx.，但是由于没有实际数据，最终访问时需要参考源文件权限</li>
<li>软链接可以链接目录</li>
<li>软链接可以跨分区</li>
<li>软链接特征明显，建议使用软链接</li>
</ul>
<h2 id="3-目录和文件都能操作的命令"><a href="#3-目录和文件都能操作的命令" class="headerlink" title="3. 目录和文件都能操作的命令"></a>3. 目录和文件都能操作的命令</h2><h3 id="1）rm"><a href="#1）rm" class="headerlink" title="1）rm"></a>1）rm</h3><p>【功能描述】：删除文件或目录</p>
<p>选项：</p>
<ul>
<li>-f：强制删除</li>
<li>-i：交互删除，在删除之前会询问用户(默认)</li>
<li>-r：递归删除，可以删除目录</li>
</ul>
<h3 id="2）cp"><a href="#2）cp" class="headerlink" title="2）cp"></a>2）cp</h3><p>【功能描述】：复制文件和目录</p>
<p>选项：</p>
<ul>
<li>-a：相当于-dpr选项的集合。</li>
<li>-d：如果源文件为软链接(硬链接无效)，则复制出的目标文件也为软链接。</li>
<li>-i：询问，如果目标文件已经存在，则会询问是否覆盖。</li>
<li>-p：复制后目标文件保留源文件的属性(包括所有者、所属组、权限和时间)</li>
<li>-r：递归复制，用于复制目录</li>
</ul>
<h3 id="3）mv"><a href="#3）mv" class="headerlink" title="3）mv"></a>3）mv</h3><p>【功能描述】：移动文件或者改名</p>
<p>选项：</p>
<ul>
<li>-f：强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖</li>
<li>-i：交互移动，如果目标文件已经存在，则询问用户是否覆盖(默认)</li>
<li>-v：显示详细信息</li>
</ul>
<h2 id="4-权限"><a href="#4-权限" class="headerlink" title="4. 权限"></a>4. 权限</h2><h3 id="1）权限位含义"><a href="#1）权限位含义" class="headerlink" title="1）权限位含义"></a>1）权限位含义</h3><ul>
<li>第一位代表<strong>文件类型</strong>。Linux不像Windows使用扩展名表示文件类型，而是使用权限位的第1位表示文件类型。虽然Linux文件的种类不像Windows中那么多，但是分类也不少，详细情况可以使用“info ls”命令查看。<ul>
<li>“-”：普通文件。</li>
<li>“b”：块设备文件。</li>
<li>“c”：字符设备文件。</li>
<li>“d”：目录文件。</li>
<li>“l”：软链接文件。</li>
<li>“p”：管道符文件。</li>
<li>“s”：套接字文件。</li>
</ul>
</li>
<li>第2-4位代表<strong>文件所有者</strong>(u)的权限<ul>
<li>r：读权限</li>
<li>w：写权限</li>
<li>x：执行权限</li>
</ul>
</li>
<li>第5-7位代表<strong>文件所属组</strong>(g)的权限</li>
<li>第8-10位代表<strong>其他人</strong>(o)的权限</li>
</ul>
<h3 id="2）基本权限的作用"><a href="#2）基本权限的作用" class="headerlink" title="2）基本权限的作用"></a>2）基本权限的作用</h3><h4 id="a-权限含义的解释"><a href="#a-权限含义的解释" class="headerlink" title="a.权限含义的解释"></a>a.权限含义的解释</h4><p>首先，读、写、执行权限对文件和目录的作用是不同的。</p>
<p>权限对文件的作用</p>
<ul>
<li>读(r)：对文件有读(r)权限，代表可以读取文件中的数据。如果把权限对应到命令上，那么一旦对文件有读(r)权限，就可以对文件执行cat、more、less、head、tail等文件查看命令。</li>
<li>写(w)：对文件有写(w)权限，代表可以修改文件中的数据。如果把权限对应到命令上，那么一旦对文件有写(w)权限，就可以对文件执行vim、echo等修改文件数据的命令。注意：对文件有写权限，是不能删除文件本身的，只能修改文件中的数据。如果要想删除文件，则需要对文件的上级目录有写权限。</li>
<li>执行(x)：对文件有执行(x)权限，代表文件拥有了执行权限。可以运行。在Linux中，只要文件有执行(x)权限，这个文件就是执行文件了。只是这个文件到底能不能正确执行，不仅需要执行(x)权限，还要看文件中的代码是不是正确的语言代码。对文件来说，执行(x)权限是最高权限。</li>
</ul>
<p>权限对目录的作用</p>
<ul>
<li>读(r)：对目录有读(r)权限，代表可以查看目录下的内容，也就是可以查看目录下有哪些子文件和子目录。如果把权限对应到命令上，那么一旦对目录拥有了读(r)权限，就可以在下执行ls命令，查看目录下的内容了。</li>
<li>写(w)：对目录有写(w)权限，代表可以修改目录下的数据，也就是可以在目录中新建、删除、复制、剪切子文件或目录。如果把权限对应到命令上，那么一旦对目录拥有了写(w)权限，就可以在目录下执行touch、rm、cp、mv命令。对目录来说，写(w)权限是最高权限。</li>
<li>执行(x)：目录是不能运行的，那么对目录拥有了执行(x)权限，代表可以进入目录。如果把权限对应到命令上，那么一旦对目录拥有了执行(x)权限，就可以对目录执行cd命令，进入目录。</li>
</ul>
<h4 id="b-目录的可用权限"><a href="#b-目录的可用权限" class="headerlink" title="b.目录的可用权限"></a>b.目录的可用权限</h4><p>目录的可用权限其实只有以下几个：</p>
<ul>
<li>0：任何权限都不赋予。</li>
<li>5：基本的目录浏览和进入权限。</li>
<li>7：完全权限。</li>
</ul>
<h3 id="3）chmod"><a href="#3）chmod" class="headerlink" title="3）chmod"></a>3）chmod</h3><p>【功能描述】：修改文件的权限模式。</p>
<p>选项：</p>
<ul>
<li>-R：递归设置权限，也就是给子目录中的所有文件设定权限。</li>
</ul>
<p>【注意】</p>
<ul>
<li>普通用户可以修改所有者是自己的文件的权限</li>
</ul>
<h3 id="4）chown"><a href="#4）chown" class="headerlink" title="4）chown"></a>4）chown</h3><p>【功能描述】：修改文件和目录的所有者和所有组。</p>
<p>选项：</p>
<ul>
<li>-R：递归设置权限，也就是给子目录中的所有文件设置权限。</li>
</ul>
<p>【注意】</p>
<ul>
<li>普通用户不能修改文件的所有者(哪怕文件属于这个普通用户)，只有超级用户才能修改所有者。</li>
</ul>
<h3 id="5）chgrp"><a href="#5）chgrp" class="headerlink" title="5）chgrp"></a>5）chgrp</h3><p>【功能描述】：修改文件和目录的所属组。</p>
<h3 id="6）umask"><a href="#6）umask" class="headerlink" title="6）umask"></a>6）umask</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询系统umask权限</span><br><span class="line">umask</span><br><span class="line">0002       # 用八进制数值表示umask权限</span><br><span class="line"></span><br><span class="line">umask -S</span><br><span class="line">u=rwx,g=rwx,o=rx      # 用字母表示文件和目录的初始权限</span><br></pre></td></tr></table></figure>



<p>umask权限的计算方法</p>
<p>新建文件和目录的默认最大权限：</p>
<ul>
<li>对文件来讲，新建文件的默认最大权限是666，没有执行(x)权限。这是因为执行权限对文件来讲比较危险，不能在新建文件的时候默认赋予，而必须通过用户手工赋予。</li>
<li>对目录来讲，新建目录的默认最大权限是777，这是因为对目录而言，执行(x)权限仅仅代表进入目录，所以即使建立新文件时直接默认赋予，也没有什么危险。</li>
</ul>
<p>按照官方的标准算法，umask默认权限需要使用二进制进行逻辑与和逻辑非联合运算才可以得到正确的新建文件和目录的默认权限。这种方法既不好计算，也不好理解，不太推荐。</p>
<p>按照权限字母来讲解umask权限的计算方法：</p>
<ul>
<li><p>文件的默认权限最大只能是666，而umask的值是002</p>
<p>“-rw-rw-rw-” - “——-w-” &#x3D; “-rw-rw-r–”</p>
</li>
<li><p>目录的默认权限最大可以是777，而umask的值是002</p>
<p>“drwxrwxrwx” - “d——-w-“ &#x3D; “drwxrwxr-x”</p>
</li>
</ul>
<h2 id="5-帮助命令"><a href="#5-帮助命令" class="headerlink" title="5. 帮助命令"></a>5. 帮助命令</h2><h3 id="1）man"><a href="#1）man" class="headerlink" title="1）man"></a>1）man</h3><p>【功能描述】：显示联机帮助手册</p>
<p>man命令快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>上箭头</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>下箭头</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>PgUp</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>PgDn</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>g</td>
<td>移动到第一页</td>
</tr>
<tr>
<td>G</td>
<td>移动到最后一页</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
<tr>
<td>&#x2F;字符串</td>
<td>从当前页向下搜索字符串</td>
</tr>
<tr>
<td>?字符串</td>
<td>从当前页向上搜索字符串</td>
</tr>
<tr>
<td>n</td>
<td>当搜索字符串时，可以使用n键找到下一个字符串</td>
</tr>
<tr>
<td>N</td>
<td>当搜索字符串时，使用N键反向查询字符串。也就是说，如果使用“&#x2F;字符串”方式搜索，则N键表示向上搜索字符串；如果使用“?字符串”方式搜索，则N键表示向下搜索字符串。</td>
</tr>
</tbody></table>
<p>man命令的帮助级别</p>
<table>
<thead>
<tr>
<th>级别</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>普通用户可以执行的系统命令和可执行文件的帮助</td>
</tr>
<tr>
<td>2</td>
<td>内核可以调用的函数和工具的帮助</td>
</tr>
<tr>
<td>3</td>
<td>C语言函数的帮助</td>
</tr>
<tr>
<td>4</td>
<td>设备和特殊文件的帮助</td>
</tr>
<tr>
<td>5</td>
<td>配置文件的帮助</td>
</tr>
<tr>
<td>6</td>
<td>游戏的帮助(个人版的Linux中是有游戏的)</td>
</tr>
<tr>
<td>7</td>
<td>杂项的帮助</td>
</tr>
<tr>
<td>8</td>
<td>超级用户可以执行的系统命令的帮助</td>
</tr>
<tr>
<td>9</td>
<td>内核的帮助</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看命令拥有哪个级别的帮助</span></span><br><span class="line">man -f 命令 或 whatis 命令</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看和命令相关的所有帮助</span></span><br><span class="line">man -k 命令 或 apropos 命令</span><br></pre></td></tr></table></figure>



<h3 id="2）info"><a href="#2）info" class="headerlink" title="2）info"></a>2）info</h3><p>【功能描述】：一套完整资料的帮助信息</p>
<p>info命令快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>上箭头</td>
<td>向上移动一行</td>
</tr>
<tr>
<td>下箭头</td>
<td>向下移动一行</td>
</tr>
<tr>
<td>PgUp</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>PgDn</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Tab</td>
<td>在有“*”符号的节点间进行切换</td>
</tr>
<tr>
<td>回车</td>
<td>进入有“*”符号的子页面，查看详细帮助信息</td>
</tr>
<tr>
<td>u</td>
<td>进入上一层信息(回车是进入下一层信息)</td>
</tr>
<tr>
<td>n</td>
<td>进入下一小节信息</td>
</tr>
<tr>
<td>p</td>
<td>进入上一小节信息</td>
</tr>
<tr>
<td>？</td>
<td>查看帮助信息</td>
</tr>
<tr>
<td>q</td>
<td>退出info信息</td>
</tr>
</tbody></table>
<h3 id="3）help-基本不用"><a href="#3）help-基本不用" class="headerlink" title="3）help(基本不用)"></a>3）help(基本不用)</h3><p>【功能描述】：显示Shell内置命令的帮助。</p>
<p>区分Shell内置命令与外部命令：type 命令。</p>
<h3 id="4）–help"><a href="#4）–help" class="headerlink" title="4）–help"></a>4）–help</h3><p>【功能描述】：man命令的信息简要版。</p>
<h2 id="6-搜索命令"><a href="#6-搜索命令" class="headerlink" title="6. 搜索命令"></a>6. 搜索命令</h2><h3 id="1）whereis"><a href="#1）whereis" class="headerlink" title="1）whereis"></a>1）whereis</h3><p>搜索系统命令的命令。</p>
<p>【功能描述】：查找二进制命令、源文件和帮助文档的命令。</p>
<h3 id="2）which"><a href="#2）which" class="headerlink" title="2）which"></a>2）which</h3><p>搜索系统命令的命令。</p>
<p>和whereis命令的区别在于：</p>
<ul>
<li>whereis命令可以在查找到二进制命令的同时，查找到帮助文档的位置；</li>
<li>which命令在查找到二进制命令的同时，如果这个命令有别名，则还可以找到别名命令。</li>
</ul>
<h3 id="3）locate"><a href="#3）locate" class="headerlink" title="3）locate"></a>3）locate</h3><p>【功能描述】：按照文件名搜索文件。</p>
<p>优点：按照数据库搜索，搜索速度快，消耗资源小。数据库位置&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db（更新数据库：updatedb）。</p>
<p>缺点：只能按照文件名来搜索文件，而不能执行更复杂的搜索，比如按照权限、大小、修改时间等搜索文件。</p>
<h3 id="4）find"><a href="#4）find" class="headerlink" title="4）find"></a>4）find</h3><ul>
<li><p>按照文件名搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -name: 按照文件名搜索</span><br><span class="line">  -iname: 按照文件名搜索，不区分文件名大小写</span><br><span class="line">  -inum: 按照inode号搜索</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照文件大小搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -size [+|-]大小: 按照指定大小搜索文件。&quot;+&quot;指搜索比指定大小还大的文件，&quot;-&quot;指搜索比指定大小还小的文件。 </span><br><span class="line"></span><br><span class="line">单位：</span><br><span class="line">- b：默认单位，如果单位为b或者不写单位，则按照512 Byte搜索</span><br><span class="line">- c：按照字节搜索</span><br><span class="line">- w：按照双字节搜索</span><br><span class="line">- k：按KB搜索</span><br><span class="line">- M：按MB搜索</span><br><span class="line">- G：按GB搜索</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照修改时间搜索</p>
<p>Linux中的文件有访问时间(atime)、数据修改时间(mtime)、状态修改时间(ctime)等时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">先项：</span><br><span class="line">  -atime [+|-]时间(天)：按照访问时间搜索</span><br><span class="line">  -mtime [+|-]时间(天)：按照数据修改时间搜索</span><br><span class="line">  -ctime [+|-]时间(天)：按照状态修改时间搜索</span><br><span class="line">  </span><br><span class="line">以mtime数据修改时间为例，说明时间含义：</span><br><span class="line">- -5：代表5天内修改的文件</span><br><span class="line">- 5：代表前5~6天那一天修改的文件</span><br><span class="line">- +5：代表6天前修改的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照权限搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -perm 权限模式：查找文件权限刚好等于&quot;权限模式&quot;的文件</span><br><span class="line">  -perm -权限模式：查找文件权限全部包含&quot;权限模式&quot;的文件</span><br><span class="line">  -perm +权限模式：查找文件权限包含&quot;权限模式&quot;的任意一个权限的文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照所有者和所属组搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -uid 用户ID：按照用户ID查找所有者是指定ID的文件</span><br><span class="line">  -gid 组ID：按照用户组ID查找所属组是指定ID的文件</span><br><span class="line">  -user 用户名：按照用户名查找所有者是指定用户的文件</span><br><span class="line">  -group 组名：按照组名查打所属组是指定用户组的文件</span><br><span class="line">  -nouser：查找没有所有者的文件</span><br></pre></td></tr></table></figure>

<p>按照所有者和所属组搜索时，“-nouser”选项比较常用，主要用于查找垃圾文件。</p>
<p>只有一种情况例外，那就是外来文件。比如光盘和U盘中的文件如果是由Windows复制的，在Linux中查看就是没有所有者的文件，再比如手工源码包安装的文件，也有可能没有所有者。</p>
</li>
<li><p>按照文件类型搜索</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -type d：查找目录</span><br><span class="line">  -type f：查找普通文件</span><br><span class="line">  -type l：查找软链接文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容</span><br><span class="line">选项：</span><br><span class="line">  -a：逻辑与(and)</span><br><span class="line">  -o：逻辑或(or)</span><br><span class="line">  -not(!)：逻辑非(not)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-a：逻辑与(and)</p>
<p>find命令也支持逻辑运算符先项，其中-a代表逻辑与运算，也就是-a的两个条件都成立，find搜索的结果才成立</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录下搜索大小2KB，并且文件类型是普通文件的文件</span></span><br><span class="line">find . -size +2k -a -type f</span><br></pre></td></tr></table></figure>
</li>
<li><p>-o：逻辑或(or)</p>
<p>-o选项代表逻辑或运算，也就是-o的两个条件只要其中一个成立，find命令就可以找到结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录下搜索文件名要么是cangls的文件，要么是bols的文件</span></span><br><span class="line">find . -name cangls -o -name bols</span><br></pre></td></tr></table></figure>
</li>
<li><p>-not(!)：逻辑非(not)</p>
<p>-not是逻辑非，也就是取反的意思</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在当前目录下搜索文件名不是cangls文件</span></span><br><span class="line">find . -not -name cangls</span><br><span class="line">find . ! -name cangls</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>其他选项</p>
<ul>
<li><p>-exec选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容 -exec 命令2 &#123;&#125; \；</span><br></pre></td></tr></table></figure>

<p>这个选项的作用其实是把find命令的结果交由“-exec”调用的命令2来处理。”{}”就代表find命令的查找结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find /var/log -mtime +10 -exec ls -ahl &#123;&#125; \;</span><br></pre></td></tr></table></figure>
</li>
<li><p>-ok选项</p>
<p>“-ok”选项和”-exec”选项的作用基本一致，区别在于：“-exec”的命令2会直接处理，而不询问：”-ok”的命令2在处理前会先询问用户是否这样处理，在得到确认命令后，才会执行。</p>
</li>
</ul>
</li>
</ul>
<h2 id="7-补充命令"><a href="#7-补充命令" class="headerlink" title="7. 补充命令"></a>7. 补充命令</h2><h3 id="1）grep"><a href="#1）grep" class="headerlink" title="1）grep"></a>1）grep</h3><p>grep的作用是在文件中提取和匹配符合条件的字符串行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep [选项] &quot;搜索内容&quot; 文件名</span><br><span class="line">选项：</span><br><span class="line">  -i：忽略大小写</span><br><span class="line">  -n：输出行号</span><br><span class="line">  -v：反向查找</span><br><span class="line">  --color=auto：搜索出的关键字用颜色显示</span><br></pre></td></tr></table></figure>



<p>find和grep区别：</p>
<ul>
<li>find命令用于在系统中搜索符合条件的文件名，如果需要模糊查询，则使用通配符进行匹配。搜索文件名是完全匹配的。</li>
<li>grep命令用于在文件中搜索符合条件的字符串，如果需要模糊查询，则使用正则表达式进行匹配。搜索时字符串是包含匹配的。</li>
</ul>
<p>通匹符和正则表达式的区别：</p>
<ul>
<li><p>通配符：用于匹配文件名，完全匹配。</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配一个任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或任意多个任意字符，也就是可以匹配任何内容</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中任意一个字符。例如，[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符，-代表一个范围，例如，[a-z]代表匹配一个小写字母</td>
</tr>
<tr>
<td>[^]</td>
<td>逻辑非，表示匹配不是中括号内的一个字符，例如，[^0-9]代表匹配一个不是数字的字符</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式：用于匹配字符串，包含匹配。</p>
<table>
<thead>
<tr>
<th>正则符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配前一个字符重复0次，或1次。只能用egrep才生效</td>
</tr>
<tr>
<td>*</td>
<td>匹配前一个字符重复0次，或任意多次</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中任意一个字符，例如，[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符，-代表一个范围，例如，[a-z]代表匹配一个小写字母</td>
</tr>
<tr>
<td>[^]</td>
<td>逻辑非，表示匹配不是中括号内的一个字符，例如，[^0-9]代表匹配一个不是数字的字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配行首</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="2）管道符"><a href="#2）管道符" class="headerlink" title="2）管道符"></a>2）管道符</h3><p>命令格式：命令1 | 命令2</p>
<p>命令1的正确输出作为命令2的操作对象。</p>
<h3 id="3）命令的别名"><a href="#3）命令的别名" class="headerlink" title="3）命令的别名"></a>3）命令的别名</h3><p>命令的别名，就是命令的小名，主要是用于照顾管理员使用习惯的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询命令别名</span></span><br><span class="line">alias</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设定命令别名. <span class="built_in">alias</span> 别名=‘原命令’</span></span><br><span class="line">alias ser=&#x27;service network restart&#x27;</span><br></pre></td></tr></table></figure>

<p>用命令定义的别名，是临时生效的，要想永久生效，需要写入环境变量配置文件~&#x2F;.bashrc。</p>
<p>命令的执行顺序：</p>
<ul>
<li>第一顺位执行用绝对路径或相对路径执行的命令。</li>
<li>第二顺位执行别名。</li>
<li>第三顺位执行bash的内部命令。</li>
<li>第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令。</li>
</ul>
<h3 id="4）常用快捷键"><a href="#4）常用快捷键" class="headerlink" title="4）常用快捷键"></a>4）常用快捷键</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Tab键</td>
<td>命令或文件补全</td>
</tr>
<tr>
<td>ctrl+A</td>
<td>把光标移动到命令行开头。如果我们输入的命令过长，想要把光标移动到命令行开头时使用。</td>
</tr>
<tr>
<td>ctrl+E</td>
<td>把光标移动到命令行结尾。</td>
</tr>
<tr>
<td>ctrl+C</td>
<td>强制终止当前的命令。</td>
</tr>
<tr>
<td>ctrl+L</td>
<td>清屏，相当于clear命令</td>
</tr>
<tr>
<td>ctrl+U</td>
<td>删除或剪切光标之前的命令。我输入了一行很长的命令，不用使用退格键一个一个字符的删除，使用这个快捷键会更加方便。</td>
</tr>
<tr>
<td>ctrl+Y</td>
<td>粘贴ctrl+U剪切的内容。</td>
</tr>
<tr>
<td>ctrl+D</td>
<td>退出当前终端</td>
</tr>
<tr>
<td>ctrl+Z</td>
<td>暂停，并放入后台。</td>
</tr>
<tr>
<td>ctrl+S</td>
<td>暂停屏幕输出</td>
</tr>
<tr>
<td>ctrl+Q</td>
<td>恢复屏幕输出</td>
</tr>
</tbody></table>
<h2 id="8-压缩和解压缩"><a href="#8-压缩和解压缩" class="headerlink" title="8. 压缩和解压缩"></a>8. 压缩和解压缩</h2><p>在Linux中可以识别的常见压缩格式有十几种，比如“.zip”，“.gz”，“.bz2”，“.tar”，“.tar.gz”，“.tar.bz2”等。</p>
<h3 id="1）“-zip”格式"><a href="#1）“-zip”格式" class="headerlink" title="1）“.zip”格式"></a>1）“.zip”格式</h3><p>“.zip”是Windows中最常见的压缩格式。Linux也可以正确识别”.zip”格式，这可以方便地和Windows系统通用压缩文件。</p>
<p>a）压缩命令(zip)</p>
<p>【功能描述】：压缩文件或目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">zip [选项] 压缩包名 源文件或源目录</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -r: 压缩目录</span><br></pre></td></tr></table></figure>



<p>b）解压缩(unzip)</p>
<p>【功能描述】：列表、测试和提取压缩文件中的文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">unzip [选项] 压缩包名</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -d：指定解压缩位置</span><br></pre></td></tr></table></figure>



<h3 id="2）“-gz”格式-不会打包"><a href="#2）“-gz”格式-不会打包" class="headerlink" title="2）“.gz”格式(不会打包)"></a>2）“.gz”格式(不会打包)</h3><p>“.gz”格式是Linux中最常用的压缩格式，使用gzip命令进行压缩。</p>
<p>a）压缩命令(gzip)</p>
<p>【功能描述】：压缩文件或目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">gzip [选项] 源文件</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -c：将压缩数据输出到标准输出中，可以用于保留源文件</span><br><span class="line">  -d：解压缩</span><br><span class="line">  -r：压缩目录（将目录下的文件进行压缩）</span><br></pre></td></tr></table></figure>



<p>b）解压缩(gunzip)</p>
<p>如果要解压缩”.gz”格式，那么使用”gzip -d 压缩包”和”gunzip 压缩包”命令都可以。</p>
<p>【功能描述】：解压缩文件或目录。</p>
<h3 id="3）“-bz2”格式-不能压缩目录"><a href="#3）“-bz2”格式-不能压缩目录" class="headerlink" title="3）“.bz2”格式(不能压缩目录)"></a>3）“.bz2”格式(不能压缩目录)</h3><p>“.bz2”格式是Linux的另一种压缩格式，从理论上来讲，“.bz2”格式的算法更先进、压缩比更好；而”.gz”格式相对来讲压缩的时间更快。</p>
<p>a）压缩命令(bzip2)</p>
<p>【功能描述】：bz2格式的压缩命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bzip2命令格式</span></span><br><span class="line">bzip2 [选项] 源文件</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -d：解压缩</span><br><span class="line">  -k：压缩时，保留源文件</span><br><span class="line">  -v：显示压缩的详细信息</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩成.bz2格式</span></span><br><span class="line">bzip2 anaconda-ks.cfg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保留源文件压缩</span></span><br><span class="line">bzip2 -k install.log.syslog</span><br></pre></td></tr></table></figure>



<p>b）解压缩（bunzip2）</p>
<p>“.bz2”格式可以使用”bzip2 -d 压缩包”命令来进行解压缩，也可以使用”bunzip2 压缩包”命令来进行解压缩。</p>
<p>【功能描述】：.bz2格式的解压缩命令。</p>
<h3 id="4）“-tar”格式-打包不压缩"><a href="#4）“-tar”格式-打包不压缩" class="headerlink" title="4）“.tar”格式(打包不压缩)"></a>4）“.tar”格式(打包不压缩)</h3><p>“.tar”格式的打包和解打包都使用tar命令，区别只是选项不同。</p>
<p>a）打包(tar)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar命令格式</span></span><br><span class="line">tar [选项] [-f 压缩包名] 源文件或目录</span><br><span class="line">选项：</span><br><span class="line">  -c：打包</span><br><span class="line">  -f：指定压缩包的文件名。压缩包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名</span><br><span class="line">  -v：显示打包文件过程</span><br><span class="line"> </span><br><span class="line">tar -cvf anaconda-ks.cfg.tar anaconda-ks.cfg</span><br></pre></td></tr></table></figure>



<p>b）解打包(tar)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">tar [选项] 压缩包</span><br><span class="line">选项：</span><br><span class="line">  -x：解打包</span><br><span class="line">  -f：指定压缩包的文件名</span><br><span class="line">  -v：显示解打包文件过程</span><br><span class="line">  -t：测试，就是不解打包，只是查看包中有哪些文件</span><br></pre></td></tr></table></figure>



<h3 id="5）“-tar-gz”和”-tar-bz2”格式"><a href="#5）“-tar-gz”和”-tar-bz2”格式" class="headerlink" title="5）“.tar.gz”和”.tar.bz2”格式"></a>5）“.tar.gz”和”.tar.bz2”格式</h3><p>使用tar命令直接打包压缩。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令格式</span></span><br><span class="line">tar [选项] 压缩包 源文件或目录</span><br><span class="line">选项：</span><br><span class="line">  -z：压缩和解压缩“.tar.gz”格式</span><br><span class="line">  -j：压缩和解压缩“.tar.bz2”格式</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将/tmp目录打包压缩</span></span><br><span class="line">tar -zcvf tmp.tar.gz /tmp/</span><br><span class="line">tar -jcvf tmp.tar.bz2 /tmp/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压缩与解打包</span></span><br><span class="line">tar -zxvf tmp.tar.gz</span><br><span class="line">tar -jxvf tmp.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只查看，不解压</span></span><br><span class="line">tar -ztvf tmptar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压到指定位置</span></span><br><span class="line">tar -zxvf tmp.tar.gz -C /tmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只解压压缩包中的特定文件，到指定位置</span></span><br><span class="line">tar -zxvf tmp.tar.gz -C /tmp test/cde</span><br></pre></td></tr></table></figure>



<h2 id="9-关机和重启"><a href="#9-关机和重启" class="headerlink" title="9. 关机和重启"></a>9. 关机和重启</h2><h3 id="1）sync数据同步"><a href="#1）sync数据同步" class="headerlink" title="1）sync数据同步"></a>1）sync数据同步</h3><p>【功能描述】：刷新文件系统缓冲区</p>
<h3 id="2）shutdown-推荐"><a href="#2）shutdown-推荐" class="headerlink" title="2）shutdown(推荐)"></a>2）shutdown(推荐)</h3><p>【功能描述】：关机和重启</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本命令格式</span><br><span class="line">shutdown [选项] 时间 [警告信息]</span><br><span class="line">选项：</span><br><span class="line">   -c：取消已经执行的shutdown命令</span><br><span class="line">   -h：关机</span><br><span class="line">   -r：重启</span><br></pre></td></tr></table></figure>



<h3 id="3）reboot"><a href="#3）reboot" class="headerlink" title="3）reboot"></a>3）reboot</h3><p>在现在的系统中，reboot命令也是安全的，而且不需要加入过多的选项。</p>
<h3 id="4）halt和poweroff"><a href="#4）halt和poweroff" class="headerlink" title="4）halt和poweroff"></a>4）halt和poweroff</h3><p>这两个都是关机命令，直接执行即可。这两个命令不会完整关闭和保存系统的服务，不建议使用。</p>
<h3 id="5）init"><a href="#5）init" class="headerlink" title="5）init"></a>5）init</h3><p>init是修改Linux运行级别的命令，也可以用于关机和重启，这个命令并不安全，不建议使用。</p>
<h2 id="10-网络命令"><a href="#10-网络命令" class="headerlink" title="10. 网络命令"></a>10. 网络命令</h2><h3 id="1）配置IP地址"><a href="#1）配置IP地址" class="headerlink" title="1）配置IP地址"></a>1）配置IP地址</h3><p>a. 配置IP地址</p>
<p>IP地址是计算机在互联网中唯一的地址编码。每台计算机如果需要接入网络和其他计算机进行数据通信，就必须配置唯一的公网IP地址。</p>
<p>配置IP地址方法：</p>
<ul>
<li>setup工具</li>
<li>手工修改配置文件：vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</li>
</ul>
<p>b. 重启网络服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启网络服务</span></span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure>



<p>c. 虚拟机需要桥接到有线网卡，并重启网络服务。</p>
<p>d. 复制镜像有可能需要重置UUID（唯一识别符）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除MAC地址行</span></span><br><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除MAC地址和UUID绑定文件</span></span><br><span class="line">rm -rf /etc/udev/rules.d/70-persistent-net.rules</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启Linux</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h3 id="2）ifconfig"><a href="#2）ifconfig" class="headerlink" title="2）ifconfig"></a>2）ifconfig</h3><p>【功能描述】：配置网络接口</p>
<p>ifconfig命令最主要的作用就是查看IP地址的信息，直接输入ifconfig命令即可。</p>
<h3 id="3）ping"><a href="#3）ping" class="headerlink" title="3）ping"></a>3）ping</h3><p>【功能描述】：向网络主机发送ICMP请求。</p>
<p>ping是常用的网络命令，主要通过ICMP协议进行网络探测，测试网络中主机的通信情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本命令格式</span><br><span class="line">ping [选项] IP</span><br><span class="line">选项：</span><br><span class="line">  -b：后面加入广播地址，用于对整个网段进行探测</span><br><span class="line">  -c 次数：用于指定ping的次数</span><br><span class="line">  -s 字节：指定探测包的大小</span><br><span class="line"></span><br><span class="line"># 探测192.168.103.0/24网段中有多少可以通信的主机</span><br><span class="line">ping -b -c 3 192.168.103.255</span><br></pre></td></tr></table></figure>



<h3 id="4）netstat"><a href="#4）netstat" class="headerlink" title="4）netstat"></a>4）netstat</h3><p>【功能描述】：输出网络连接、路由表、接口统计、伪装连接和组播成员。</p>
<p>netstat是网络状态查看命令，既可以查看到本机开启的端口，也可以查看有哪些客户端连接。</p>
<p>在CentOS 7.x中netstat命令默认没有安装，如果需要使用，需要安装net-snmp和net-tools软件包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 基本命令格式</span><br><span class="line">netstat [选项]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">  -a：列出所有网络状态，包括Socket程序</span><br><span class="line">  -c 秒数：指定每隔几秒刷新一次网络状态</span><br><span class="line">  -n：使用IP地址和端口号显示，不使用域名与服务名</span><br><span class="line">  -p：显示PID和程序名</span><br><span class="line">  -t：显示使用TCP协议端口的连接状况</span><br><span class="line">  -u：显示使用UDP协议端口的连接状况</span><br><span class="line">  -l：仅显示监听状态的连接</span><br><span class="line">  -r：显示路由表</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 查看本机开启的端口</span><br><span class="line">netstat -tuln</span><br></pre></td></tr></table></figure>

<p>命令输出结果：</p>
<ul>
<li>Proto：网络连接的协议，一般就是TCP协议或者UDP协议。</li>
<li>Recv-Q：表示接收到的数据，已经在本地的缓冲中，但是还没有被进程取走。</li>
<li>Send-Q：表示从本机发送，对方还没有收到的数据，依然在本地的缓冲中，一般是不具备ACK标志的数据包。</li>
<li>Local Address：本机的IP地址和端口号。</li>
<li>Foreign Address：远程主机的IP地址和端口号。</li>
<li>State：状态。常见的状态主要有以下几种。<ul>
<li>LISTEN：监听状态，只有TCP协议需要监听，而UDP协议不需要监听。</li>
<li>ESTABLISHED：已经建立连接的状态。如果使用“-l”选项，则看不到已经建立连接的状态。</li>
<li>SYN_SENT：SYN发起包，就是主动发起连接的数据包。</li>
<li>SYN_RECV：接收到主动连接的数据包。</li>
<li>FIN_WAIT1：正在中断的连接。</li>
<li>FIN_WAIT2：已经中断的连接，但是正在等待对方主机进行确认。</li>
<li>FIN_WAIT：连接已经中断，但是套接字依然在网络中等待结束。</li>
<li>CLOSED：套接字没有被使用。</li>
</ul>
</li>
</ul>
<p>在这些状态中，我们最用的就是LISTEN和ESTABLISHED状态，一种代表正在监听，另一种代表已经建立连接。</p>
<h3 id="5）write"><a href="#5）write" class="headerlink" title="5）write"></a>5）write</h3><p>【功能描述】：向其他用户发送信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看有多少人正在登录</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$ w</span><br><span class="line"> 14:50:14 up 4 min,  1 user,  load average: 2.31, 1.29, 0.56</span><br><span class="line">USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU  WHAT</span><br><span class="line">ben               -                14:46     ?     0.00s  0.04s lightdm --session-child 13 20</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">向在pts/1（远程终端）登录的user1用户发送信息，使用<span class="string">&quot;Ctrl+D&quot;</span>快捷键保存发送的数据</span></span><br><span class="line">write user1 pts/1</span><br></pre></td></tr></table></figure>



<h3 id="6）wall"><a href="#6）wall" class="headerlink" title="6）wall"></a>6）wall</h3><p>write命令用于给指定用户发送信息，而wall命令用于给所有登录用户发送信息，包括自己。执行时，在wall命令后加入需要发送的信息即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wall &quot;hello&quot;</span><br></pre></td></tr></table></figure>



<h3 id="7）mail"><a href="#7）mail" class="headerlink" title="7）mail"></a>7）mail</h3><p>mail是Linux的邮件客户端命令，可以利用这个命令给其他用户发送邮件。</p>
<p>【功能描述】：发送和接收电子邮件。</p>
<p>a. 发送邮件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送邮件, Ctrl+D发送</span></span><br><span class="line">mail user1</span><br></pre></td></tr></table></figure>

<p>接收到的邮件都保存在“&#x2F;var&#x2F;spool&#x2F;mail&#x2F;用户名”中，每个用户都有一个以自己的用户名命令的邮箱。</p>
<p>b. 发送文件内容</p>
<p>如果想把某个文件的内容发送给指定用户，则可以执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把/root/anaconda-ks.cfg文件内容发送给root用户</span></span><br><span class="line">mail -s &quot;test mail&quot; root &lt; /root/anaconda-ks.cfg</span><br><span class="line">选项：</span><br><span class="line">  -s：指定邮件标题</span><br></pre></td></tr></table></figure>

<p>在写脚本时，有时需要脚本自动发送一些信息给指定用户，把要发送的信息预先写到文件中，是一个非常不错的选择。</p>
<p>c. 查看已经接收的邮件</p>
<p>我们可以直接在命令行中执行mail命令，进入mail的交互命令中，可以在这里查看已经接收到的邮件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mail</span></span><br><span class="line">&quot;/var/mail/test&quot;: 2 messages 2 new</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">N   1 ben                日 12月 22 15:  13/425   hello</span></span><br><span class="line"> N   2 ben                日 12月 22 15:  15/434   hello</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">未阅读 编号 发件人            时间                  标题</span></span><br></pre></td></tr></table></figure>

<p>可以看到已经接收到的邮件列表，“N”代表未读邮件，如果是已经阅读过的邮件，则前面是不会有这个“N”的；之后的数字是邮件的编号，我们主要通过这个编号来进行邮件的操作。如果我们想要查看第一封邮件，则只需要输入邮件的编号“1”就可以了。</p>
<p>交互命令是可以简化输入的。</p>
<ul>
<li>headers: 列出邮件标题列表，直接输入“h”命令即可。</li>
<li>delete：删除指定邮件。比如想要删除第二封邮件，可以输入“d 2”。</li>
<li>save：保存邮件。可以把指定邮件保存成文件。如”s 2 &#x2F;tmp&#x2F;test.mail”。</li>
<li>quit：退出，并把已经操作过的邮件进行保存。比如移除已删除邮件、保存已阅读邮件等。</li>
<li>exit：退出，但是不保存任何操作。</li>
</ul>
<h3 id="8）nmap"><a href="#8）nmap" class="headerlink" title="8）nmap"></a>8）nmap</h3><p>端口扫描命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nmap -sT 域名或IP</span><br><span class="line">选项：</span><br><span class="line">  -s        扫描</span><br><span class="line">  -T        扫描所有开启的TCP端口</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nmap -sT 127.0.0.1</span><br><span class="line">Starting Nmap 7.94SVN ( https://nmap.org ) at 2025-03-01 15:55 CST</span><br><span class="line">Nmap scan report for localhost (127.0.0.1)</span><br><span class="line">Host is up (0.00027s latency).</span><br><span class="line">Not shown: 995 closed tcp ports (conn-refused)</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">25/tcp   open  smtp</span><br><span class="line">631/tcp  open  ipp</span><br><span class="line">1090/tcp open  ff-fms</span><br><span class="line">4000/tcp open  remoteanything</span><br><span class="line">9090/tcp open  zeus-admin</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.09 seconds</span><br></pre></td></tr></table></figure>



<h2 id="11-痕迹命令"><a href="#11-痕迹命令" class="headerlink" title="11. 痕迹命令"></a>11. 痕迹命令</h2><p>系统中有一些重要的痕迹日志文件，如&#x2F;var&#x2F;log&#x2F;wtmp、&#x2F;var&#x2F;run&#x2F;utmp、&#x2F;var&#x2F;log&#x2F;btmp、&#x2F;var&#x2F;log&#x2F;lastlog等日志文件，如果你用vim打开这些文件，你会发现这些文件是二进制乱码。这是由于这些日志中保存的是系统的重要登录痕迹，包括某个用户何时登录了系统，何时退出了系统，错误登录等重要的系统信息。这些信息要是可以通过vim打开，就能编辑，这样痕迹信息就不准确，所以这些重要的痕迹日志，只能通过对应的命令来进行查看。</p>
<h3 id="1）w"><a href="#1）w" class="headerlink" title="1）w"></a>1）w</h3><p>w命令是显示系统中正在登录的用户信息的命令，这个命令查看的痕迹日志是&#x2F;var&#x2F;run&#x2F;utmp。</p>
<p>【功能描述】：显示登录用户，和他正在做什么。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# w</span><br><span class="line"> 15:44:22 up  1:59,  1 user,  load average: 0.00, 0.00, 0.00</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    192.168.0.75     15:44    3.00s  0.01s  0.00s w</span><br></pre></td></tr></table></figure>

<p>第一行信息：</p>
<ul>
<li>系统当前时间</li>
<li>系统运行时间</li>
<li>当前登录用户数</li>
<li>系统在之前1分钟、5分钟、15分钟的平均负载。如果CPU是单核的，则这个数值超过1就是高负载，如果CPU是四核的，则这个数值超过4就是高负载。</li>
</ul>
<p>第二行信息：</p>
<ul>
<li>USER: 当前登录的用户</li>
<li>TTY: 登录的终端<ul>
<li>tty1-6：本地字符终端(alt+F1-6切换)</li>
<li>tty7：本地图形终端(ctrl+alt+F7切换，必须安装启动图形界面)</li>
<li>pts&#x2F;0-255：远程终端</li>
</ul>
</li>
<li>FROM：登录的IP地址，如果是本地终端，则是空</li>
<li>LOGIN@：登录时间</li>
<li>IDLE：用户闲置时间</li>
<li>JCPU：所有进程占用的CPU时间</li>
<li>PCPU：当前进程占用的CPU时间</li>
<li>WHAT：用户正在进行的操作</li>
</ul>
<h3 id="2）who"><a href="#2）who" class="headerlink" title="2）who"></a>2）who</h3><p>who命令和w命令类似，用于查看正在登录的用户，但是显示的内容更加简单，也是查看&#x2F;var&#x2F;run&#x2F;utmp。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# who</span><br><span class="line">root     pts/0        2024-12-22 15:44 (192.168.0.75)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名   登录终端      登录时间(来源IP)</span></span><br></pre></td></tr></table></figure>



<h3 id="3）last"><a href="#3）last" class="headerlink" title="3）last"></a>3）last</h3><p>last命令是查看系统所有登录过的用户的信息的，包括正在登录的用户和之前登录的用户。这个命令查看的是&#x2F;var&#x2F;log&#x2F;wtmp痕迹日志文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# last</span><br><span class="line">root     pts/0        192.168.0.75     Sun Dec 22 15:44   still logged in</span><br><span class="line">reboot   system boot  5.15.0-117-gener Sun Dec 22 13:45   still running</span><br><span class="line">reboot   system boot  5.15.0-117-gener Sun Dec 22 13:15   still running</span><br><span class="line">reboot   system boot  5.15.0-117-gener Fri Dec 20 15:52   still running</span><br><span class="line">reboot   system boot  5.15.0-117-gener Fri Dec 20 15:44   still running</span><br><span class="line">reboot   system boot  5.15.0-117-gener Thu Dec 19 19:53   still running</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统重启信息记录</span></span><br><span class="line">root     pts/0        192.168.0.75     Thu Dec 19 17:00 - 18:02  (01:02)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用户名   终端号        来源IP地址        登录时间            退出时间</span></span><br></pre></td></tr></table></figure>



<h3 id="4）lastlog"><a href="#4）lastlog" class="headerlink" title="4）lastlog"></a>4）lastlog</h3><p>lastlog命令是查看系统中所有用户最后一次的登录时间的命令，他查看的日志是&#x2F;var&#x2F;log&#x2F;lastlog文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# lastlog</span><br><span class="line">Username         Port     From             Latest</span><br><span class="line">root             pts/0    192.168.0.75     Sun Dec 22 15:44:19 +0800 2024</span><br><span class="line">daemon                                     **Never logged in**     # 系统伪用户</span><br><span class="line">bin                                        **Never logged in**</span><br><span class="line">sys                                        **Never logged in**</span><br><span class="line">sync                                       **Never logged in**</span><br><span class="line">games                                      **Never logged in**</span><br><span class="line">man                                        **Never logged in**</span><br><span class="line">lp                                         **Never logged in**</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名         终端       来源IP           登录时间</span></span><br></pre></td></tr></table></figure>



<h3 id="5）lastb"><a href="#5）lastb" class="headerlink" title="5）lastb"></a>5）lastb</h3><p>lastb命令是查看错误登录的信息的，查看的是&#x2F;var&#x2F;log&#x2F;btmp痕迹日志。。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@90ubuntu:~# lastb</span><br><span class="line">root         tty1                        Mon Nov 12 23:50 - 23:58 （00:00）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">错误登录用户  终端                        尝试登录的时间</span></span><br></pre></td></tr></table></figure>





<h2 id="12-挂载命令"><a href="#12-挂载命令" class="headerlink" title="12. 挂载命令"></a>12. 挂载命令</h2><h3 id="1）mount"><a href="#1）mount" class="headerlink" title="1）mount"></a>1）mount</h3><p>linux所有存储设备都必须挂载使用，包括硬盘。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询系统中已经挂载的设备，-l会显示卷标名称</span><br><span class="line">mount -l</span><br><span class="line"></span><br><span class="line"># 依据配置文件/etc/fstab的内容，自动挂载</span><br><span class="line">mount -a</span><br><span class="line"></span><br><span class="line">mount [-t 文件系统] [-L 卷标名] [-o 特殊选项] 设备文件名 挂载点</span><br><span class="line">选项：</span><br><span class="line">  -t 文件系统：加入文件系统类型来指定挂载的类型，可以ext3、ext4、iso9660等文件系统</span><br><span class="line">  -L 卷标名：挂载指定卷标的分区，而不是安装设备文件名挂载</span><br><span class="line">  -o 特殊选项：可以指定挂载的额外选项，比如读写权限、同步异步等，如果不指定则默认值生效。参数如下表。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>atime&#x2F;noatime</td>
<td>更新访问时间&#x2F;不更新访问时间，访问时区文件时，是否更新文件的访问时间，默认为更新</td>
</tr>
<tr>
<td>async&#x2F;sync</td>
<td>异步&#x2F;同步，默认为异步</td>
</tr>
<tr>
<td>auto&#x2F;noauto</td>
<td>自动&#x2F;手动，mount -a命令执行时，是否会自动安装&#x2F;etc&#x2F;fstab文件内容挂载，默认为自动</td>
</tr>
<tr>
<td>defaults</td>
<td>定义默认值，相当于rw,suid,dev,exec,auto,nouser,async这七个选项</td>
</tr>
<tr>
<td>exec &#x2F;noexec</td>
<td>执行&#x2F;不执行，设定是否允许在文件系统中执行可执行文件，默认是exec允许</td>
</tr>
<tr>
<td>remount</td>
<td>重新挂载已经挂载的文件系统，一般用于指定修改特殊权限</td>
</tr>
<tr>
<td>rw&#x2F;ro</td>
<td>读写&#x2F;只读，文件系统挂载时，是否具有读写权限，默认是w</td>
</tr>
<tr>
<td>suid&#x2F;nosuid</td>
<td>具有&#x2F;不具有SUID权限，设定文件系统是否具有SUID和SGID的权限，默认是具有</td>
</tr>
<tr>
<td>user&#x2F;nouser</td>
<td>允许&#x2F;不允许普通用户挂载，设定文件系统是否允许普通用户挂载，默认是不允许，只有root挂载分区</td>
</tr>
<tr>
<td>usrquota</td>
<td>写入代表文件系统支持用户磁盘配额，默认不支持</td>
</tr>
<tr>
<td>grpquota</td>
<td>写入代表文件系统支持组磁盘配额，默认不支持</td>
</tr>
</tbody></table>
<h3 id="2）挂载光盘"><a href="#2）挂载光盘" class="headerlink" title="2）挂载光盘"></a>2）挂载光盘</h3><p>光盘挂载的前提依然是指定光盘的设备文件名，不同版本的Linux，设备文件名并不相同。</p>
<ul>
<li>CentOS 5.x以前的系统，光盘设备文件名是&#x2F;dev&#x2F;hdc。</li>
<li>CentOS 6.x以后的系统，光盘设备文件名是&#x2F;dev&#x2F;sr0。</li>
</ul>
<p>不论哪个系统都有软链接&#x2F;dev&#x2F;cdrom，都可以作为光盘的设备文件名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载光盘</span></span><br><span class="line">mount -t iso9660 /dev/cdrom /mnt/cdrom/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载</span></span><br><span class="line">umount /mnt/cdrom 或 umount /dev/sr0</span><br></pre></td></tr></table></figure>

<p>【注意】：卸载的时候需要退出光盘目录，才能正常卸载。</p>
<h3 id="3）挂载U盘"><a href="#3）挂载U盘" class="headerlink" title="3）挂载U盘"></a>3）挂载U盘</h3><p>U盘会和硬盘共用设备文件名，所以U盘的设备文件名不是固定的，需要手工查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询硬盘</span></span><br><span class="line">fdisk -l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载</span></span><br><span class="line">mount -t vfat /dev/sdb1 /mnt/usb/</span><br></pre></td></tr></table></figure>

<p>如果U盘中有中文，会发现中文是乱码，Linux要想正常显示中文，需要两个条件：</p>
<ul>
<li>安装了中文编码和中文字体。</li>
<li>操作终端需要支持中文显示(纯字符终端，是不支持中文编码的)。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载U盘，指定中文编码格式为UTF-8</span></span><br><span class="line">mount -t vfat -o iocharset=utf8 /dev/sdb1 /mnt/usb/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载</span></span><br><span class="line">umount /mnt/usb/</span><br></pre></td></tr></table></figure>



<h3 id="4）挂载NTFS分区"><a href="#4）挂载NTFS分区" class="headerlink" title="4）挂载NTFS分区"></a>4）挂载NTFS分区</h3><p>Linux的驱动加载顺序：</p>
<ul>
<li>驱动直接放入系统内核之中，这种驱动主要是系统启动加载必须的驱动，数量较少。</li>
<li>驱动以模块的形式放入硬盘。大多数驱动都以这种方式保存，保存位置在&#x2F;lib&#x2F;modules&#x2F;3.10.0-862.el7.x86_64&#x2F;kernel&#x2F;中。</li>
<li>驱动可以被Linux识别，但是系统认为这种驱动一般不常用，默认不加载。如果需要加载这种驱动，需要重新编译内核，而NTFS文件系统的驱动就属于这种情况。</li>
<li>硬件不能被Linux内核识别，需要手工安装驱动。当然前提是厂商提供了该硬件针对Linux的驱动，否则需要自己开发驱动了。</li>
</ul>
<p>使用NTFS-3G安装NTFS文件系统模块</p>
<p>下载NTFS-3G插件：<a href="https://github.com/tuxera/ntfs-3g">https://github.com/tuxera/ntfs-3g</a></p>
<p>安装完成后，就可以挂载和使用Windows的NTFS分区了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t ntfs-3g /dev/sdb1 /mnt/win</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Shell基础</title>
    <url>/2025/02/25/Shell%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="Shell概述"><a href="#Shell概述" class="headerlink" title="Shell概述"></a>Shell概述</h2><h3 id="Shell分类"><a href="#Shell分类" class="headerlink" title="Shell分类"></a>Shell分类</h3><table>
<thead>
<tr>
<th>Shell类别</th>
<th>易学性</th>
<th>可移植性</th>
<th>编辑性</th>
<th>快捷性</th>
</tr>
</thead>
<tbody><tr>
<td>Bourne Shell（sh）</td>
<td>容易</td>
<td>好</td>
<td>较差</td>
<td>较差</td>
</tr>
<tr>
<td>Korn Shell（ksh）</td>
<td>较难</td>
<td>较好</td>
<td>好</td>
<td>较好</td>
</tr>
<tr>
<td>Bourne Again（Bash）</td>
<td>难</td>
<td>较好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>POSIX Shell（psh）</td>
<td>较难</td>
<td>好</td>
<td>好</td>
<td>较好</td>
</tr>
<tr>
<td>C Shell（csh）</td>
<td>较难</td>
<td>差</td>
<td>较好</td>
<td>较好</td>
</tr>
<tr>
<td>TC Shell（tcsh）</td>
<td>难</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
</tbody></table>
<p>Shell的两种主语法类型有Bourne和C，这两种语法彼此不兼容。Bourne家族主要包括sh、ksh、Bash、psh、zsh；C家族主要包括：csh、tcsh（Bash和zsh在不同程度上支持csh的语法）。</p>
<p>可以通过&#x2F;etc&#x2F;shells文件来查询Linux支持的Shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/shells</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/etc/shells: valid login shells</span></span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/bash</span><br><span class="line">/bin/rbash</span><br><span class="line">/usr/bin/rbash</span><br><span class="line">/usr/bin/dash</span><br><span class="line">/usr/bin/sh</span><br></pre></td></tr></table></figure>



<h3 id="Shell脚本的执行方式"><a href="#Shell脚本的执行方式" class="headerlink" title="Shell脚本的执行方式"></a>Shell脚本的执行方式</h3><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo [选项] [输出内容]</span><br><span class="line">选项：</span><br><span class="line">  -e：    支持反斜线控制的字符转换（如下表）</span><br><span class="line">  -n：    取消输出后行末的换行符号(就是内容输出后不换行)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo &quot;Mr. Ben is the most honest man!&quot;</span><br><span class="line">Mr. Ben is the most honest man!</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo -n &quot;Mr. Ben is the most honest man!&quot;</span><br><span class="line">Mr. Ben is the most honest man![root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>在echo命令中如果使用了”-e”选项，则可以支持控制字符。</p>
<table>
<thead>
<tr>
<th>控制字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\\</td>
<td>输出\本身</td>
</tr>
<tr>
<td>\a</td>
<td>输出警告音</td>
</tr>
<tr>
<td>\b</td>
<td>退格键，也就是向左删除键</td>
</tr>
<tr>
<td>\c</td>
<td>取消输出行末的换行符。和“-n”选项一致</td>
</tr>
<tr>
<td>\e</td>
<td>ESCAPE键</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车键</td>
</tr>
<tr>
<td>\t</td>
<td>制表符，也就是Tab键</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>\0nnn</td>
<td>按照八进制ASCII码表输出字符。其中0为数字零，nnn是三位八进制数</td>
</tr>
<tr>
<td>\xhh</td>
<td>按照十六进制ASCII码表输出字符。其中hh是两位十六进制数</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo -e &quot;\\ \a&quot;</span><br><span class="line">\</span><br><span class="line"># 这个输出会输出\，同时会在系统音响中输出一声提示音</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo -e &quot;ab\bc&quot;</span><br><span class="line">ac</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# echo -e &quot;a\tb\tc\nd\te\tf&quot;</span><br><span class="line">a    b    c</span><br><span class="line">d    e    f</span><br><span class="line"></span><br><span class="line"># 八进制输出</span><br><span class="line">[root@localhost ~]# echo -e &quot;\0141\t\0142\t\0143\n\0144\t\0145\t\0146&quot;</span><br><span class="line">a    b    c</span><br><span class="line">d    e    f</span><br><span class="line"></span><br><span class="line"># 十六进制</span><br><span class="line">[root@localhost ~]# echo -e &quot;\x61\t\x62\t\x63\n\x64\t\x65\t\x66&quot;</span><br><span class="line">a    b    c</span><br><span class="line">d    e    f</span><br><span class="line"></span><br><span class="line"># 按颜色输出</span><br><span class="line">[root@localhost ~]# echo -e &quot;\e[1;31m    abcd \e[0m&quot;</span><br><span class="line">    abcd</span><br></pre></td></tr></table></figure>

<p>按颜色输出这个命令，“\e[1”是标准格式，代表颜色输出开始，”\e[0m”代表颜色输出结束，31m定义字体颜色是红色。echo能够识别的颜色：</p>
<ul>
<li>30m：黑色</li>
<li>31m：红色</li>
<li>32m：绿色</li>
<li>33m：黄色</li>
<li>34m：蓝色</li>
<li>35m：洋红</li>
<li>36m：青色</li>
<li>37m：白色</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo -e &quot;\e[1;42m abcd \e[0m&quot;</span><br></pre></td></tr></table></figure>

<p>这条命令会给abcd加一个绿色的背景。echo可以使用的背景颜色如下：</p>
<ul>
<li>40m：黑色</li>
<li>41m：红色</li>
<li>42m：绿色</li>
<li>43m：黄色</li>
<li>44m：蓝色</li>
<li>45m：洋红</li>
<li>46m：青色</li>
<li>47m：白色</li>
</ul>
<h4 id="Shell脚本的执行"><a href="#Shell脚本的执行" class="headerlink" title="Shell脚本的执行"></a>Shell脚本的执行</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The first program</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 326525276@qq.com）</span></span><br><span class="line"></span><br><span class="line">echo -e &quot;Mr. Ben is the most honest man! &quot;</span><br></pre></td></tr></table></figure>

<p>在Linux中脚本的执行主要有两种方法：</p>
<ul>
<li><p>赋予执行权限，直接运行（推荐）</p>
<p>这种方法是最常用的Shell脚本运行方法，也最为直接简单。运行时可以使用绝对路径，也可以使用相对路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赋予执行权限</span></span><br><span class="line">[root@localhost sh]# chmod +x hello.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绝对路径执行</span></span><br><span class="line">[root@localhost sh]# /root/sh/hello.sh</span><br><span class="line">Mr. Ben is the most honest man!</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">相对路径执行</span></span><br><span class="line">[root@localhost sh]# ./hello.sh</span><br><span class="line">Mr. Ben is the most honest man!</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过Bash调用执行脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost sh]# bash hello.sh</span><br><span class="line">Mr. Ben is the most honest man!</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Bash的基本功能"><a href="#Bash的基本功能" class="headerlink" title="Bash的基本功能"></a>Bash的基本功能</h2><h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# history [选项] [历史命令保存文件]</span><br><span class="line">选项：</span><br><span class="line">  -c：    清空历史命令</span><br><span class="line">  -w：    把缓存中的历史命令写入历史命令保存文件。如果不手工指定历史命令保存文件，则放入默认历史命令保存文件~/.bash_history中</span><br></pre></td></tr></table></figure>

<p>history命令查看的历史命令和<del>&#x2F;.bash_history文件中保存的历史命令是不同的。那是因为当前登录操作的命令并没有直接写入</del>&#x2F;.bash_history文件，而是保存在缓存当中的。需要等当前用户注销之后，缓存中的命令才会写入<del>&#x2F;.bash_history文件。如果需要把内存中的命令直接写入</del>&#x2F;.bash_history文件，而不等用户注销时再写入，就需要使用”-w”选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把缓存中的历史命令直接写入~/.bash_history</span><br><span class="line">[root@localhost ~]# history -w</span><br><span class="line"></span><br><span class="line"># 清空历史命令</span><br><span class="line">[root@localhost ~]# history -c</span><br></pre></td></tr></table></figure>

<h3 id="历史命令的调用"><a href="#历史命令的调用" class="headerlink" title="历史命令的调用"></a>历史命令的调用</h3><p>如果想要使用原先的历史命令有这样几种方法：</p>
<ul>
<li>使用上、下箭头调用以前的历史命令</li>
<li>使用“!n”重复执行第n条历史命令</li>
<li>使用”!!”重复执行上一条命令</li>
<li>使用”!字串”重复执行最后一条以该字串开头的命令</li>
<li>使用”!$”重复上一条命令的最后一个参数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调用最后一条以<span class="built_in">cat</span>开头的命令</span></span><br><span class="line">[root@localhost ~]# !cat</span><br></pre></td></tr></table></figure>

<h3 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h3><p>bash的标准输入输出</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>设备文件名</th>
<th>文件描述符</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>键盘</td>
<td>&#x2F;dev&#x2F;stdin</td>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>显示器</td>
<td>&#x2F;dev&#x2F;stdout</td>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>显示器</td>
<td>&#x2F;dev&#x2F;stderr</td>
<td>2</td>
<td>标准错误输出</td>
</tr>
</tbody></table>
<p>输出重定向</p>
<ul>
<li><p>标准输出重定向：</p>
<ul>
<li>命令 &gt; 文件：以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中。</li>
<li>命令 &gt;&gt; 文件：以追加的方式，把命令的正确输出输出到指定的文件或设备当中。</li>
</ul>
</li>
<li><p>标准错误输出重定向：</p>
<ul>
<li>错误命令 2&gt;文件：以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中。</li>
<li>错误命令 2&gt;&gt;文件：以追加的方式，把命令的错误输出输出到指定的文件或设备当中。</li>
</ul>
</li>
<li><p>正确输出和错误输出同时保存：</p>
<ul>
<li>命令 &gt; 文件 2&gt;&amp;1：以覆盖的方式，把正确输出和错误输出都保存在同一个文件当中。</li>
<li>命令 &gt;&gt; 文件 2&gt;&amp;1：以追加的方式，把正确输出和错误输出都保存在同一个文件当中。</li>
<li>命令 &amp;&gt;文件：以覆盖的方式，把正确输出和错误输出都保存在同一个文件当中。</li>
<li>命令 &amp;&gt;&gt;文件：以追加的方式，把正确输出和错误输出都保存在同一个文件当中。</li>
<li>命令&gt;&gt;文件1 2&gt;&gt;文件2：把正确的输出追加到文件1中，把错误的输出追加到文件2中。</li>
</ul>
</li>
</ul>
<p>输入重定向</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# wc [选项] [文件名]</span><br><span class="line">选项：</span><br><span class="line">  -c    统计字节数</span><br><span class="line">  -w    统计单词数</span><br><span class="line">  -l    统计行数</span><br></pre></td></tr></table></figure>



<h3 id="多命令执行顺序"><a href="#多命令执行顺序" class="headerlink" title="多命令执行顺序"></a>多命令执行顺序</h3><table>
<thead>
<tr>
<th>多命令执行符</th>
<th>格式</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>；</td>
<td>命令1 ; 命令2</td>
<td>多个命令顺序执行，命令之间没有任何逻辑联系</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>命令1 &amp;&amp; 命令2</td>
<td>1）当命令1正确执行($?&#x3D;0)，则命令2才会执行。2）当命令1执行不正确，则命令2不会执行。</td>
</tr>
<tr>
<td>||</td>
<td>命令1 || 命令2</td>
<td>1）当命令1执行不正确，则命令2才会执行。2）当命令1正确执行，则命令2不会执行。</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls &amp;&amp; echo yes || echo no</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h3 id="管道符"><a href="#管道符" class="headerlink" title="管道符"></a>管道符</h3><p>a）行提取命令grep</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep [选项] &quot;搜索内容&quot; 文件名</span><br><span class="line">选项：</span><br><span class="line">  -A 数字：      列出符合条件的行，并列出后续的n行</span><br><span class="line">  -B 数字：      列出符合条件的行，并列出前面的n行</span><br><span class="line">  -c：          统计找到的符合条件的字符串的次数</span><br><span class="line">  -i：          忽略大小写</span><br><span class="line">  -n：          输出行号</span><br><span class="line">  -v：          反向查找</span><br><span class="line">  --color=auto  搜索出的关键字用颜色显示</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找用户信息文件/etc/passwd中，有多少可以登录的用户</span></span><br><span class="line">[root@localhost ~]# grep &quot;/bin/bash&quot; /etc/passwd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找包含有“root”的行，并列出后续的3行</span></span><br><span class="line">[root@localhost ~]# grep -A 3 &quot;root&quot; /etc/passwd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找可以登录的用户，并显示行号</span></span><br><span class="line">[root@localhost ~]# grep -n &quot;/bin/bash&quot; /etc/passwd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找不含有“/bin/bash”的行，其实就是列出所有的伪用户</span></span><br><span class="line">[root@localhost ~]# grep -v &quot;/bin/bash&quot; /etc/passwd</span><br></pre></td></tr></table></figure>



<p>b）find和grep的区别</p>
<p>find命令是在系统当中搜索符合条件的文件名，如果需要模糊查询，使用通配符进行匹配，搜索时文件名是完全匹配。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# touch abc</span><br><span class="line">[root@localhost ~]# touch abcd</span><br><span class="line">[root@localhost ~]# find . -name &quot;abc&quot;</span><br><span class="line">./abc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索文件名是abc的文件，只会找到abc文件，而不会找到文件abcd。虽然abcd文件名中包含abc，但是find是完全匹配，只能和要搜索的数据完全一样，才能找到</span></span><br></pre></td></tr></table></figure>

<p>**注意：**find命令是可以通过-regex选项识别正则表达式规则的，也就是说find命令可以按照正则表达式规则匹配，而正则表达式是模糊匹配。</p>
<p>grep命令是在文件当中搜索符合条件的字符串，如果需要模糊查询，使用正则表达式进行匹配，搜索时字符串是包含匹配。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo abc &gt; test</span><br><span class="line">[root@localhost ~]# echo abcd &gt;&gt; test</span><br><span class="line">[root@localhost ~]# grep &quot;abc&quot; test</span><br><span class="line">abc</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure>



<p>c）管道符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll -a /etc/ | more</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询下本地所有网络连接，提取包含ESTABLISHED(已建立连接)的行，就可以知道服务器上有多个已经成功连接的网络连接</span></span><br><span class="line">[root@localhost ~]# netstat -an | grep &quot;ESTABLISHED&quot;</span><br><span class="line">[root@localhost ~]# netstat -an | grep &quot;ESTABLISHED&quot; | wc -l</span><br></pre></td></tr></table></figure>



<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th>通配符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>？</td>
<td>匹配一个任意字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0个或任意多个字符，也就是可以匹配任何内容</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号任意一个字符。例如[abc]代表一定匹配一个字符，a或b或c</td>
</tr>
<tr>
<td>[-]</td>
<td>匹配中括号中任意一个字符，-代表一个范围。例如[a-z]代表匹配一个小写字母</td>
</tr>
<tr>
<td>[^]</td>
<td>逻辑非，表示匹配不是中括号内的一个字符。例如[^0-9]代表匹配一个不是数字的字符</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# touch abc</span><br><span class="line">[root@localhost ~]# touch abcd</span><br><span class="line">[root@localhost ~]# touch 012</span><br><span class="line">[root@localhost ~]# touch 0abc</span><br><span class="line">[root@localhost ~]# ls *</span><br><span class="line">012 0abc abc abcd</span><br><span class="line">[root@localhost ~]# ls ?abc</span><br><span class="line">0abc</span><br><span class="line">[root@localhost ~]# ls [0-9]*</span><br><span class="line">012 0abc</span><br><span class="line">[root@localhost ~]# ls [^0-9]*</span><br><span class="line">abc abcd</span><br></pre></td></tr></table></figure>



<h3 id="Bash中其他特殊符号"><a href="#Bash中其他特殊符号" class="headerlink" title="Bash中其他特殊符号"></a>Bash中其他特殊符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>‘’</td>
<td>单引号。在单引号中所有的特殊符号，如“$”和“~”都没有特殊含义</td>
</tr>
<tr>
<td>“”</td>
<td>双引号。在双引号中特殊符号都没有特殊含义，但是“$”、“~”和“\”是例外，拥有”调用变量的值”、“引用命令”和“转义符”的特殊含义。</td>
</tr>
<tr>
<td>&#96;&#96;</td>
<td>反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号不易读。</td>
</tr>
<tr>
<td>$()</td>
<td>和反引号作用一样，用来引用系统命令。</td>
</tr>
<tr>
<td>()</td>
<td>用于一串命令执行时，()中的命令会在子Shell中运行</td>
</tr>
<tr>
<td>{}</td>
<td>用于一串命令执行时，{}中的命令会在当前Shell中执行。也可以用于变量变形与替换</td>
</tr>
<tr>
<td>[]</td>
<td>用于变量的测试</td>
</tr>
<tr>
<td>#</td>
<td>在Shell脚本中，#开头的行代表注释</td>
</tr>
<tr>
<td>$</td>
<td>用于调用变量的值，</td>
</tr>
<tr>
<td>\</td>
<td>转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符。</td>
</tr>
</tbody></table>
<p>a）单引号和双引号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量的值</span></span><br><span class="line">[root@localhost ~]# name=ben</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果输出时使用单引号，则<span class="variable">$name</span>原封不动输出</span></span><br><span class="line">[root@localhost ~]# echo &#x27;$name&#x27;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果输出时使用双引号，则会输出变量name的值</span></span><br><span class="line">[root@localhost ~]# echo &quot;$name&quot;</span><br><span class="line">ben</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反引号括起来的命令会正常执行</span></span><br><span class="line">[root@localhost ~]# echo `date`</span><br><span class="line">2025年 02月 25日 星期二 17:16:57 CST</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果反引号命令被单引号括起来，则这个命令不会执行</span></span><br><span class="line">[root@localhost ~]# echo &#x27;`date`&#x27;</span><br><span class="line">`date`</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果反引号被双引号括起来，则这个命令会执行</span></span><br><span class="line">[root@localhost ~]# echo &quot;`date`&quot;</span><br><span class="line">2025年 02月 25日 星期二 17:19:24 CST</span><br></pre></td></tr></table></figure>

<p>b）反引号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果命令不用反引号包含，命令不会执行，而是直接输出</span></span><br><span class="line">[root@localhost ~]# echo ls</span><br><span class="line">ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只有用反引号包括命令，这个命令才会执行</span></span><br><span class="line">[root@localhost go]# echo `ls`</span><br><span class="line">bin pkg src</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">$()作用和反引号一样</span></span><br><span class="line">[root@localhost ~]# echo $(date)</span><br><span class="line">2025年 02月 25日 星期二 17:28:03 CST</span><br></pre></td></tr></table></figure>

<p>c）小括号、中括号和大括号</p>
<p>父Shell和子Shell。在Bashk中，是可以调用新的Shell的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# bash</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>通过pstree命令查看下进程数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pstree</span><br><span class="line">systemd————ModemManager————3*[&#123;ModemManager&#125;]</span><br><span class="line">         |——systemd————(sd-pam)</span><br><span class="line">                     |——gnome-terminal————bash————bash————pstree</span><br></pre></td></tr></table></figure>

<p>如果是用于一串命令的执行，那么小括号和大括号的主要区别在于：</p>
<ul>
<li><p>()执行一串命令时，需要重新开一个子shell进行执行</p>
</li>
<li><p>{}执行一串命令时，是在当前shell执行</p>
</li>
<li><p>()最后一个子命令可以不用分号</p>
</li>
<li><p>{}最后一个子命令要用分号</p>
</li>
<li><p>{}的第一个命令和左括号之间必须要有一个空格</p>
</li>
<li><p>()里的各命令不必和括号有空格</p>
</li>
<li><p>()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令</p>
</li>
<li><p>()和{}都是把一串的命令放在括号里面，并且命令之间用:号隔开</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">父shell中定义变量name</span></span><br><span class="line">[root@localhost ~]# name=ben</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">子shell中给name赋值</span></span><br><span class="line">[root@localhost ~]# (name=liming;echo $name)</span><br><span class="line">liming</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">父shell中name值还是ben</span></span><br><span class="line">[root@localhost ~]# echo $name</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&#123;&#125;是在当前shell执行，会修改name的值</span></span><br><span class="line">[root@localhost ~]# &#123; name=liming;echo $name;&#125;</span><br><span class="line">liming</span><br><span class="line">[root@localhost ~]# echo $name</span><br><span class="line">liming</span><br></pre></td></tr></table></figure>



<h2 id="Bash的变量和运算符"><a href="#Bash的变量和运算符" class="headerlink" title="Bash的变量和运算符"></a>Bash的变量和运算符</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>在定义变量时，有一些规则需要遵守：</p>
<ul>
<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。</li>
<li>在Bash中，变量的默认类型是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。</li>
<li>变量用等号连接值，等号左右两侧不能有空格。</li>
<li>变量的值如果有空格，需要使用单引号或双引号包括。其中双引号括起来的内容“$”、“\”和反引号都拥有特殊含义，而单引号括起来的内容都是普通字符。</li>
<li>在变量的值中，可以使用“\”转义符。</li>
<li>如果需要增加变量的值，那么可以进行变量值的叠加。不过变量需要用双引号包含“$变量名”或用${变量名}包含变量名。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# test=123</span><br><span class="line">[root@localhost ~]# test=&quot;$test&quot;456</span><br><span class="line">[root@localhost ~]# echo $test</span><br><span class="line">123456</span><br><span class="line">[root@localhost ~]# test=$&#123;test&#125;789</span><br><span class="line">[root@localhost ~]# echo $test</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure>

<p>变量值的叠加可以使用两种格式：“$变量名”或${变量名}。</p>
<ul>
<li>如果是把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# test=$(date)</span><br><span class="line">[root@localhost ~]# echo $test</span><br><span class="line">2025年 02月 25日 星期二 18:22:43 CST</span><br></pre></td></tr></table></figure>

<ul>
<li>环境变量名建议大写，便于区分。</li>
</ul>
<h4 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h4><ul>
<li><p>用户自定义变量</p>
<p>这种变量是最常见的变量，由用户自由定义变量名和变量的值。</p>
</li>
<li><p>环境变量</p>
<p>这种变量中主要保存的是和系统操作环境相关的数据，比如当前登录用户，用户的家目录，命令的提示符等。环境变量的变量名可以自由定义，但是一般对系统起作用的环境变量的变量名是系统预先设定好的。</p>
</li>
<li><p>位置参数变量</p>
<p>这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的。</p>
</li>
<li><p>预定义变量</p>
<p>是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</p>
</li>
</ul>
<h4 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h4><p>定义变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义变量name</span></span><br><span class="line">[root@localhost ~]# name=&quot;Ben&quot;</span><br></pre></td></tr></table></figure>



<p>调用变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出变量name的值</span></span><br><span class="line">[root@localhost ~]# ehco $name</span><br><span class="line">Ben</span><br></pre></td></tr></table></figure>



<p>查看变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# set [选项]</span><br><span class="line">选项：</span><br><span class="line">  -u：    如果设定此选项，调用未声明变量时会报错(默认无任何提示)</span><br><span class="line">  -x：    如果设定此选项，在命令执行之前，会把命令先输出一次</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有变量</span></span><br><span class="line">[root@localhost ~]# set</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# set -u</span><br><span class="line">[root@localhost ~]# echo $file</span><br><span class="line">bash: file: 未绑定的变量</span><br><span class="line">[root@localhost ~]# set -x</span><br><span class="line">[root@localhost ~]# ls</span><br><span class="line">+ ls --color=auto</span><br><span class="line">_config.landscape.yml  _config.yml  db.json  deploy.sh  node_modules  package.json</span><br></pre></td></tr></table></figure>



<p>删除变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# unset name</span><br></pre></td></tr></table></figure>



<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>设置环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# export age=&quot;18&quot;</span><br></pre></td></tr></table></figure>



<p>查看环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# env | grep age</span><br></pre></td></tr></table></figure>

<p>set命令可以查看所有变量，而env命令只能查看环境变量。</p>
<p>删除环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# unset age</span><br></pre></td></tr></table></figure>



<p>系统默认环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# env</span><br><span class="line">SHELL=/bin/bash                                                # 当前的shell</span><br><span class="line">SESSION_MANAGER=local/ben-NBLK-WAX9X:@/tmp/.ICE-unix/4024,unix/ben-NBLK-WAX9X:/tmp/.ICE-unix/4024</span><br><span class="line">QT_ACCESSIBILITY=1</span><br><span class="line">COLORTERM=truecolor</span><br><span class="line">XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg</span><br><span class="line">XDG_SESSION_PATH=/org/freedesktop/DisplayManager/Session0</span><br><span class="line">XDG_MENU_PREFIX=gnome-</span><br><span class="line">GNOME_DESKTOP_SESSION_ID=this-is-deprecated</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">LANGUAGE=zh_CN:zh:en_US:en</span><br><span class="line">LC_ADDRESS=zh_CN.UTF-8</span><br><span class="line">GNOME_SHELL_SESSION_MODE=ubuntu</span><br><span class="line">LC_NAME=zh_CN.UTF-8</span><br><span class="line">SSH_AUTH_SOCK=/run/user/1000/keyring/ssh</span><br><span class="line">MEMORY_PRESSURE_WRITE=c29tZSAyMDAwMDAgMjAwMDAwMAA=</span><br><span class="line">HOMEBREW_PREFIX=/home/linuxbrew/.linuxbrew</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">DESKTOP_SESSION=ubuntu</span><br><span class="line">LC_MONETARY=zh_CN.UTF-8</span><br><span class="line">GTK_MODULES=gail:atk-bridge</span><br><span class="line">PWD=/home/ben/work/个人/githubPage</span><br><span class="line">LOGNAME=ben</span><br><span class="line">XDG_SESSION_DESKTOP=ubuntu</span><br><span class="line">XDG_SESSION_TYPE=x11</span><br><span class="line">MANPATH=/home/linuxbrew/.linuxbrew/share/man:</span><br><span class="line">GPG_AGENT_INFO=/run/user/1000/gnupg/S.gpg-agent:0:1</span><br><span class="line">SYSTEMD_EXEC_PID=4060</span><br><span class="line">XAUTHORITY=/home/ben/.Xauthority</span><br><span class="line">XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/ben</span><br><span class="line">GDM_LANG=zh_CN</span><br><span class="line">HOME=/home/ben                                                    # 当前登录用户的家目录</span><br><span class="line">IM_CONFIG_PHASE=1</span><br><span class="line">LC_PAPER=zh_CN.UTF-8</span><br><span class="line">LANG=zh_CN.UTF-8                                                  # 语系</span><br><span class="line">LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.crdownload=00;90:*.dpkg-dist=00;90:*.dpkg-new=00;90:*.dpkg-old=00;90:*.dpkg-tmp=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:*.swp=00;90:*.tmp=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:          # 定义颜色显示</span><br><span class="line">XDG_CURRENT_DESKTOP=ubuntu:GNOME</span><br><span class="line">MEMORY_PRESSURE_WATCH=/sys/fs/cgroup/user.slice/user-1000.slice/user@1000.service/session.slice/org.gnome.Shell@x11.service/memory.pressure</span><br><span class="line">VTE_VERSION=7600</span><br><span class="line">XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0</span><br><span class="line">GNOME_TERMINAL_SCREEN=/org/gnome/Terminal/screen/e46b9f29_027f_412a_aa8b_f9404dd3bc96</span><br><span class="line">QTWEBENGINE_DICTIONARIES_PATH=/usr/share/hunspell-bdic/</span><br><span class="line">CLUTTER_IM_MODULE=fcitx</span><br><span class="line">INFOPATH=/home/linuxbrew/.linuxbrew/share/info:</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line">LESSCLOSE=/usr/bin/lesspipe %s %s</span><br><span class="line">XDG_SESSION_CLASS=user</span><br><span class="line">TERM=xterm-256color                                                     # 终端环境</span><br><span class="line">LC_IDENTIFICATION=zh_CN.UTF-8</span><br><span class="line">LESSOPEN=| /usr/bin/lesspipe %s</span><br><span class="line">USER=ben                                                                # 当前登录的用户</span><br><span class="line">HOMEBREW_CELLAR=/home/linuxbrew/.linuxbrew/Cellar</span><br><span class="line">GNOME_TERMINAL_SERVICE=:1.10145</span><br><span class="line">DISPLAY=:0</span><br><span class="line">SHLVL=1</span><br><span class="line">GSM_SKIP_SSH_AGENT_WORKAROUND=true</span><br><span class="line">LC_TELEPHONE=zh_CN.UTF-8</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">HOMEBREW_REPOSITORY=/home/linuxbrew/.linuxbrew/Homebrew</span><br><span class="line">LC_MEASUREMENT=zh_CN.UTF-8</span><br><span class="line">XDG_RUNTIME_DIR=/run/user/1000</span><br><span class="line">DEBUGINFOD_URLS=https://debuginfod.ubuntu.com </span><br><span class="line">LC_TIME=zh_CN.UTF-8</span><br><span class="line">GTK3_MODULES=xapp-gtk3-module</span><br><span class="line">XDG_DATA_DIRS=/usr/share/ubuntu:/usr/share/gnome:/usr/local/share:/usr/share:/var/lib/snapd/desktop</span><br><span class="line">PATH=/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/ben/.local/bin:/home/ben/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin    # 系统查找命令的路径</span><br><span class="line">GDMSESSION=ubuntu</span><br><span class="line">DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus</span><br><span class="line">LC_NUMERIC=zh_CN.UTF-8</span><br><span class="line">_=/usr/bin/env</span><br><span class="line">OLDPWD=/home/ben/work/个人/githubPage/themes/next</span><br></pre></td></tr></table></figure>



<h4 id="Bash操作接口相关的变量"><a href="#Bash操作接口相关的变量" class="headerlink" title="Bash操作接口相关的变量"></a>Bash操作接口相关的变量</h4><p>Bash操作接口相关的变量对我们的Bash操作终端起到了重要的作用。这些变量只能用set命令查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# set</span><br><span class="line">BASH=/usr/bin/bash                       # Bash的位置</span><br><span class="line">BASH_VERSINFO=([0]=&quot;5&quot; [1]=&quot;2&quot; [2]=&quot;21&quot; [3]=&quot;1&quot; [4]=&quot;release&quot; [5]=&quot;x86_64-pc-linux-gnu&quot;)    # Bash的版本</span><br><span class="line">BASH_VERSION=&#x27;5.2.21(1)-release&#x27;         # bash的版本</span><br><span class="line">HISTFILE=/home/ben/.bash_history         # 历史命令保存文件</span><br><span class="line">HISTFILESIZE=2000                        # 在文件当中记录的历史命令最大条数</span><br><span class="line">HISTSIZE=1000                            # 在缓存中记录的历史命令最大条数</span><br><span class="line">LANG=zh_CN.UTF-8                         # 语系环境</span><br><span class="line">MACHTYPE=x86_64-pc-linux-gnu             # 软件类型是i386兼容类型</span><br><span class="line">MAILCHECK=60                             # 每60s去扫描新邮件</span><br><span class="line">PPID=557258                              # 父shell的PID</span><br><span class="line">PS1=&#x27;\[\e]0;\u@\h: \w\a\]$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ &#x27;                                              # 命令提示符</span><br><span class="line">PS2=&#x27;&gt; &#x27;                                 # 如果命令一行没有输入完成，第二行命令的提示符</span><br><span class="line">UID=1000                                 # 当前用户的UID</span><br></pre></td></tr></table></figure>



<h4 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h4><p>系统查找命令的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询PATH环境变量的值</span></span><br><span class="line">[root@localhost ~]# echo $PATH</span><br><span class="line">/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/ben/.local/bin:/home/ben/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin</span><br></pre></td></tr></table></figure>

<p>PATH变量的值是用“：”分割的路径，这些路径就是系统查找命令的路径。也就是说当我们输入了一个程序名，如果没有写入路径，系统就会到PATH变量定义的路径中去寻找是否可以执行的程序，如果找到则执行，否则会报“命令没有发现”的错误。</p>
<p>我们把自己的脚本拷贝到PATH变量定义的路径中，自己写的脚本也可以不输入路径而直接运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝hello.sh到/bin目录</span></span><br><span class="line">[root@localhost ~]# cp /root/sh/hello.sh /bin/</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行hello.sh</span></span><br><span class="line">[root@localhost ~]# hello.sh</span><br><span class="line">Mr. Ben is the most honest man.</span><br></pre></td></tr></table></figure>

<p>我们也可以修改PATH变量的值，而不把程序脚本复制到&#x2F;bin&#x2F;目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在变量PATH的后面，加入/root/sh目录</span></span><br><span class="line">[root@localhost ~]# PATH=&quot;$PATH&quot;:/root/sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询PATH的值</span></span><br><span class="line">[root@localhost ~]# echo $PATH</span><br><span class="line">/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:/home/ben/.local/bin:/home/ben/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/usr/local/go/bin:/root/sh</span><br></pre></td></tr></table></figure>

<p>这样定义的PATH变量只是临时生效，一旦重启或注销就会消失，如果想要永久生效，需要写入环境变量配置文件。</p>
<h4 id="PS1变量"><a href="#PS1变量" class="headerlink" title="PS1变量"></a>PS1变量</h4><p>命令提示符设置。</p>
<p>PS1是用来定义命令行的提示符的，可以安装我们自己的需求来定义自己喜欢的提示符。PS1可以支持以下这些选项：</p>
<ul>
<li>\d：显示日期，格式为”星期 月 日”</li>
<li>\H：显示完整的主机名，如默认主机名”localhost.localdomain”</li>
<li>\h：显示简写主机名。如默认主机名”localhost”</li>
<li>\t：显示24小时制时间，格式为”HH:MM:SS”</li>
<li>\T：显示12小时制时间，格式为”HH:MM:SS”</li>
<li>\A：显示24小时制时间，格式为“HH:MM”</li>
<li>@：显示12小时制时间，格式为”HH:MM am&#x2F;pm”</li>
<li>\u：显示当前用户名</li>
<li>\v：显示Bash的版本信息</li>
<li>\w：显示当前所在目录的完整名称</li>
<li>\W：显示当前所在目录的最后一个目录</li>
<li>\#：执行的第几个命令</li>
<li>\$：提示符。如果是root用户会显示提示符为“#”， 如果是普通用户会显示提示符为“$”</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo $PS1</span><br><span class="line">\[\e]0;\u@\h: \w\a\]$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$</span><br></pre></td></tr></table></figure>

<p>在PS1变量中，如果是可以解释的符号，如”\u”、“\h”等，则显示这个符号的作用，如果是不能解释的符号，如”@”或“空格”，则原符号输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改提示符</span><br><span class="line">[root@localhost ~]# PS1=&#x27;\[\u@\t \w\]\$&#x27;</span><br></pre></td></tr></table></figure>

<p>PS1变量的值要用单引号包含，否则设置不生效。PS1变量可以自由定制，不过说实话一个提示符已经使用习惯了，还是用默认的吧。</p>
<h4 id="LANG语系变量"><a href="#LANG语系变量" class="headerlink" title="LANG语系变量"></a>LANG语系变量</h4><p>LANG变量定义了Linux系统的主语系环境。这个变量的默认值是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# echo $LANG</span><br><span class="line">zh_CN.UTF-8</span><br></pre></td></tr></table></figure>

<p>这是因为Linux安装时，选择的是中文安装，所以默认的主语系变量是“zh_CN.UTF-8”。</p>
<p>那么Linux到底支持多少语系呢？可以使用以下命令查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# locale -a | more</span><br><span class="line">C</span><br><span class="line">C.utf8</span><br><span class="line">en_AG</span><br><span class="line">en_AG.utf8</span><br><span class="line">en_AU.utf8</span><br><span class="line">en_BW.utf8</span><br><span class="line">en_CA.utf8</span><br><span class="line">en_DK.utf8</span><br><span class="line">en_GB.utf8</span><br><span class="line">en_HK.utf8</span><br><span class="line">en_IE.utf8</span><br><span class="line">en_IL</span><br><span class="line">en_IL.utf8</span><br><span class="line">en_IN</span><br><span class="line">en_IN.utf8</span><br><span class="line">en_NG</span><br><span class="line">en_NG.utf8</span><br><span class="line">en_NZ.utf8</span><br><span class="line">en_PH.utf8</span><br><span class="line">en_SG.utf8</span><br><span class="line">en_US.utf8</span><br><span class="line">en_ZA.utf8</span><br><span class="line">en_ZM</span><br><span class="line">en_ZM.utf8</span><br><span class="line">en_ZW.utf8</span><br><span class="line">POSIX</span><br><span class="line">zh_CN.utf8</span><br><span class="line">zh_SG.utf8</span><br></pre></td></tr></table></figure>

<p>当前系统是什么语系呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# locale</span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line">LANGUAGE=zh_CN:zh:en_US:en</span><br><span class="line">LC_CTYPE=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_NUMERIC=zh_CN.UTF-8</span><br><span class="line">LC_TIME=zh_CN.UTF-8</span><br><span class="line">LC_COLLATE=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_MONETARY=zh_CN.UTF-8</span><br><span class="line">LC_MESSAGES=&quot;zh_CN.UTF-8&quot;</span><br><span class="line">LC_PAPER=zh_CN.UTF-8</span><br><span class="line">LC_NAME=zh_CN.UTF-8</span><br><span class="line">LC_ADDRESS=zh_CN.UTF-8</span><br><span class="line">LC_TELEPHONE=zh_CN.UTF-8</span><br><span class="line">LC_MEASUREMENT=zh_CN.UTF-8</span><br><span class="line">LC_IDENTIFICATION=zh_CN.UTF-8</span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<p>系统默认语系查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/sysconfig/i18n</span><br><span class="line">LANG=&quot;zh_CN.UTF-8&quot;</span><br></pre></td></tr></table></figure>

<p>默认语系是下次重启之后系统所使用的语系，而当前系统语系是当前系统使用的语系。如果系统重启，会从默认语系配置文件&#x2F;etc&#x2F;sysconfig&#x2F;i18n中读出语系，然后赋予变量LANG让这个语系生效。</p>
<p>关于Linux支持中文的问题。是不是只要定义了语系为中文语系，如zh_CN.UTF-8就可以正确显示中文呢？这个要分情况，如果我们在图形界面中，或者是使用远程连接工具(如secureCRT)，只要正确设置了语系，那么是可以正确显示中文的。当然远程工具也要配置正确的语系环境。如果是纯字符界面(本地终端tty1-tty6)是不能显示中文的，因为Linux的纯字符界面是不能显示中文这么复杂的编码的。如果非要在纯字符界面显示中文，那么只能安装中文插件，如zhcon等。</p>
<h4 id="位置参数变量"><a href="#位置参数变量" class="headerlink" title="位置参数变量"></a>位置参数变量</h4><table>
<thead>
<tr>
<th>位置参数变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$n</td>
<td>n为数字，$0代表命令本身，$1-9代表第一到第九个参数，十以上的参数需要用大括号包含，如${10}</td>
</tr>
<tr>
<td>$*</td>
<td>这个变量代表命令行中所有的参数，$*把所有的参数看成一个整本</td>
</tr>
<tr>
<td>$@</td>
<td>这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待</td>
</tr>
<tr>
<td>$#</td>
<td>这个变量代表命令行中所有参数的个数</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author：Ben（E-mail：17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给num1变量赋值是第一个参数</span></span><br><span class="line">num1=$1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给num2变量赋值是第二个参数</span></span><br><span class="line">num2=$2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">求和</span></span><br><span class="line">sum=$(( $num1 + $num2 ))</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author：Ben（E-mail：17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印所有位置参数个数</span></span><br><span class="line">echo &quot;A total of $# parameters&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印所有位置参数值</span></span><br><span class="line">for i in &quot;$*&quot;</span><br><span class="line">    do</span><br><span class="line">        echo &quot;The parameters is: $i&quot;</span><br><span class="line">    done</span><br><span class="line">x=1</span><br><span class="line">for y in &quot;$@&quot;</span><br><span class="line">    do</span><br><span class="line">        echo &quot;The parameter$x is: $y&quot;</span><br><span class="line">        x=$(( $x + 1 ))</span><br><span class="line">    done</span><br></pre></td></tr></table></figure>



<h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><table>
<thead>
<tr>
<th>预定义变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$?</td>
<td>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0(具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确了。</td>
</tr>
<tr>
<td>$$</td>
<td>当前进程的进程号(PID)</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的进程号(PID)</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~/test$ls</span><br><span class="line">12  nginx-test  nginx-test.zip</span><br><span class="line">ben@ben-NBLK-WAX9X:~/test$echo $?</span><br><span class="line">0</span><br><span class="line">ben@ben-NBLK-WAX9X:~/test$ls install.log</span><br><span class="line">ls: 无法访问 &#x27;install.log&#x27;: 没有那个文件或目录</span><br><span class="line">ben@ben-NBLK-WAX9X:~/test$echo $?</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出当前进程的PID，这个PID就是这个脚本执行时，生成的进程的PID</span></span><br><span class="line">echo &quot;The current process is $$&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在/root目录下查找hello.sh文件，&amp;是把命令放入后台执行</span></span><br><span class="line">find /root -name hello.sh &amp;</span><br><span class="line">echo &quot;The last on Daemon process is $!&quot;</span><br></pre></td></tr></table></figure>



<h4 id="接收键盘输入"><a href="#接收键盘输入" class="headerlink" title="接收键盘输入"></a>接收键盘输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# read [选项] [变量名]</span><br><span class="line">选项：</span><br><span class="line">  -p &quot;提示信息&quot;:    在等待read输入时，输出提示信息</span><br><span class="line">  -t 秒数:          read命令会一直等待用户输入，使用此选项可以指定等待时间</span><br><span class="line">  -n 字符数:        read命令只接受指定的字符数，就会执行</span><br><span class="line">  -s:              隐藏输入的数据，适用于机密信息的输入</span><br><span class="line">变量名：变量名可以自定义，如果不指定变量名，会把输入保存入默认变量REPLY。如果只提供了一个变量名，则整个输入行赋予该变量。如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -t 30 -p &quot;Please input your name: &quot; name</span><br><span class="line">echo &quot;Name is $name&quot;</span><br><span class="line"></span><br><span class="line">read -s -t 30 -p &quot;Please enter your age: &quot; age</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调整输出格式</span></span><br><span class="line">echo -e &quot;\n&quot;</span><br><span class="line">echo &quot;Age is $age&quot;</span><br><span class="line"></span><br><span class="line">read -n 1 -t 30 -p &quot;Please select your gender[M/F]: &quot; gender</span><br><span class="line">echo -e &quot;\n&quot;</span><br><span class="line">echo &quot;Sex is $gender&quot;</span><br></pre></td></tr></table></figure>



<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h4><p>如果需要进行数值运算，可以采用以下三种方法中的任意一种：</p>
<ul>
<li><p>使用declare声明变量类型</p>
<p>既然所有变量的默认类型是字符串型，那么只要把变量声明为整数型就可以了。使用declare命令就可以实现声明变量的类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# declare [+/-][选项] 变量名</span><br><span class="line">选项：</span><br><span class="line">  -：      给变量设定类型属性</span><br><span class="line">  +：      取消变量的类型属性</span><br><span class="line">  -a：     将变量声明为数组型</span><br><span class="line">  -i：     将变量声明为整数型(integer)</span><br><span class="line">  -r：     将变量声明为只读变量。注意，一旦设置为只读变量，既不能修改变量的值，也不能删除变量，甚至不能通过+r取消只读属性</span><br><span class="line">  -x：     将变量声明为环境变量</span><br><span class="line">  -p：     显示指定变量的被声明的类型</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=11</span><br><span class="line">ben@ben-NBLK-WAX9X:~$bb=22</span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -i cc=$aa+$bb</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $cc</span><br><span class="line">33</span><br></pre></td></tr></table></figure>



<p>【数组变量类型】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$name[0]=&quot;zhang san&quot;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$name[1]=&quot;li si&quot;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$name[2]=&quot;tong gang&quot;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $&#123;name&#125;</span><br><span class="line">zhang san</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $&#123;name[1]&#125;</span><br><span class="line">li si</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $&#123;name[*]&#125;</span><br><span class="line">zhang san li si tong gang</span><br></pre></td></tr></table></figure>

<p>数组的下标是从0开始的，在调用数组值时，需要使用${数组[下标]}的方式来读取。不过上面并没有把name变量声明为数组型，其实只要在定义变量时采用了“变量名[下标]”的格式，这个变量就会被系统认为是数组型了，不用强制声明。</p>
<p>环境变量</p>
<p>其实也可以使用declare命令把变量声明为环境变量，和export命令的作用是一样的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# declare -x test=123</span><br></pre></td></tr></table></figure>



<p>【只读属性】</p>
<p>一旦给变量设定了只读属性，那么这个变量既不能修改变量的值，也不能删除变量，甚至不能使用“+r”选项取消只读属性。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$declare -r test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量值不能修改</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$test=456</span><br><span class="line">bash: test: 只读变量</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量只读属性不能取消</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare +r test</span><br><span class="line">bash: declare: test: 只读变量</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量不能删除</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$unset test</span><br><span class="line">bash: unset: test: 无法取消设定：只读variable</span><br></pre></td></tr></table></figure>

<p>不过这个变量只是命令行声明的，所以只要重新登录或重启，这个变量就会消失。</p>
<p>【查询变量属性和取消变量属性】</p>
<p>变量属性的查询使用“-p”选项，变量属性的取消使用“+”选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询cc变量类型</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -p cc</span><br><span class="line">declare -i cc=&quot;33&quot;    # int</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询name变量类型</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -p name</span><br><span class="line">declare -a name=([0]=&quot;zhang san&quot; [1]=&quot;li si&quot; [2]=&quot;tong gang&quot;)    # 数组</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询<span class="built_in">test</span>变量类型</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -p test</span><br><span class="line">declare -rx test         # 只读+环境变量</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">取消<span class="built_in">test</span>变量环境变量属性</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare +x test</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询<span class="built_in">test</span>变量类型</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$declare -p test</span><br><span class="line">declare -r test             # 只读</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用expr或let数值运算工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=11</span><br><span class="line">ben@ben-NBLK-WAX9X:~$bb=22</span><br><span class="line">ben@ben-NBLK-WAX9X:~$dd=$(expr $aa + $bb)</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $dd</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<p>使用expr命令进行运算时，要注意“+”号左右两侧必须有空格，否则运算不执行。</p>
<p>至于let命令，和expr命令基本类似，都是Linux中的运算命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=11</span><br><span class="line">ben@ben-NBLK-WAX9X:~$bb=22</span><br><span class="line">ben@ben-NBLK-WAX9X:~$let ee=$aa+$bb</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $ee</span><br><span class="line">33</span><br><span class="line">ben@ben-NBLK-WAX9X:~$n=20</span><br><span class="line">ben@ben-NBLK-WAX9X:~$let n+=1</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $n</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>let命令对格式要求比expr命令宽松，所以推荐使用let命令进行数值运算。</p>
</li>
<li><p>使用“$((运算式))”或“$[运算式]”方式运算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=11</span><br><span class="line">ben@ben-NBLK-WAX9X:~$bb=22</span><br><span class="line">ben@ben-NBLK-WAX9X:~$ff=$(( $aa+$bb ))</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $ff</span><br><span class="line">33</span><br><span class="line">ben@ben-NBLK-WAX9X:~$gg=$[ $aa+$bb ]</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $gg</span><br><span class="line">33</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这三种数值运算方式，可以按照自己的习惯来进行使用，不过推荐使用“$((运算式))”的方式。</p>
<h4 id="常用运算符"><a href="#常用运算符" class="headerlink" title="常用运算符"></a>常用运算符</h4><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>13</td>
<td>-，+</td>
<td>单目负、单目正</td>
</tr>
<tr>
<td>12</td>
<td>!，~</td>
<td>逻辑非、按位取反或补码</td>
</tr>
<tr>
<td>11</td>
<td>*，&#x2F;，%</td>
<td>乘、除、取模</td>
</tr>
<tr>
<td>10</td>
<td>+，-</td>
<td>加，减</td>
</tr>
<tr>
<td>9</td>
<td>&lt;&lt;，&gt;&gt;</td>
<td>按位左移，按位右移</td>
</tr>
<tr>
<td>8</td>
<td>&lt;&#x3D;，&gt;&#x3D;，&lt;，&gt;</td>
<td>小于等于、大于等于、小于、大于</td>
</tr>
<tr>
<td>7</td>
<td>&#x3D;&#x3D;，!&#x3D;</td>
<td>等于、不等于</td>
</tr>
<tr>
<td>6</td>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>5</td>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>4</td>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>3</td>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>2</td>
<td>||</td>
<td>逻辑或</td>
</tr>
<tr>
<td>1</td>
<td>&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;、&#x3D;，%&#x3D;，&amp;&#x3D;，^&#x3D;，|&#x3D;，&lt;&lt;&#x3D;，&gt;&gt;&#x3D;</td>
<td>赋值、运算且赋值</td>
</tr>
</tbody></table>
<p>运算符优先级表明在每个表达式或子表达式中哪一个运算对象首先被求值，数值越大优先级越高，具有较高优先级级别的运算符先于较低级别的运算符进行求值运算。</p>
<p>加减乘除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$aa=$(( (11+3)*3/2 ))</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $aa</span><br><span class="line">21</span><br></pre></td></tr></table></figure>

<p>取模运算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$bb=$(( 14%3 ))</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $bb</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>逻辑与</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$cc=$(( 1 &amp; 0 ))</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $cc</span><br><span class="line">0</span><br></pre></td></tr></table></figure>



<h3 id="变量的测试与内容置换"><a href="#变量的测试与内容置换" class="headerlink" title="变量的测试与内容置换"></a>变量的测试与内容置换</h3><table>
<thead>
<tr>
<th>变量置换方式</th>
<th>变量y没有设置</th>
<th>变量y为空值</th>
<th>变量y设置值</th>
</tr>
</thead>
<tbody><tr>
<td>x&#x3D;${y-新值}</td>
<td>x&#x3D;新值</td>
<td>x为空</td>
<td>x&#x3D;$y</td>
</tr>
<tr>
<td>x&#x3D;${y:-新值}</td>
<td>x&#x3D;新值</td>
<td>x&#x3D;新值</td>
<td>x&#x3D;$y</td>
</tr>
<tr>
<td>x&#x3D;${y+新值}</td>
<td>x为空</td>
<td>x&#x3D;新值</td>
<td>x&#x3D;新值</td>
</tr>
<tr>
<td>x&#x3D;${y:+新值}</td>
<td>x为空</td>
<td>x为空</td>
<td>x&#x3D;新值</td>
</tr>
<tr>
<td>x&#x3D;${y&#x3D;新值}</td>
<td>x&#x3D;新值，y&#x3D;新值</td>
<td>x为空，y值不变</td>
<td>x&#x3D;$y，y值不变</td>
</tr>
<tr>
<td>x&#x3D;${y:&#x3D;新值}</td>
<td>x&#x3D;新值，y&#x3D;新值</td>
<td>x&#x3D;新值，y&#x3D;新值</td>
<td>x&#x3D;$y，y值不变</td>
</tr>
<tr>
<td>x&#x3D;${y?新值}</td>
<td>新值输出到标准错误输出(屏幕)</td>
<td>x为空</td>
<td>x&#x3D;$y</td>
</tr>
<tr>
<td>x&#x3D;${y:?新值}</td>
<td>新值输出到标准错误输出</td>
<td>新值输出到标准错误输出</td>
<td>x&#x3D;$y</td>
</tr>
</tbody></table>
<p>如果大括号内没有”:”，则变量y为空，还是没有设置，处理方法是不同的；如果大括号内有“:”，则变量y不论是为空，还是没有设置，处理方法是一样的。</p>
<p>如果大括号内是“-”或“+”，则在改变变量x值的时候，变量y是不改变的；如果大括号内是“&#x3D;”，则在改变变量x的同时，变量y的值也会改变。</p>
<p>如果大括号内是“?”，则当变量y不存在或为空时，会把“新值”当成报错输出到屏幕上。</p>
<p>变量y没有设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量y没有设置</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$unset y</span><br><span class="line">ben@ben-NBLK-WAX9X:~$x=$&#123;y-new&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量x等于新值</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $x</span><br><span class="line">new</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量y不存在</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $y</span><br><span class="line"></span><br><span class="line">ben@ben-NBLK-WAX9X:~$</span><br></pre></td></tr></table></figure>

<p>变量y为空</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量y为空</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$y=&quot;&quot;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$x=$&#123;y-new&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">则变量x为空</span></span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $x</span><br><span class="line"></span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $y</span><br><span class="line"></span><br><span class="line">ben@ben-NBLK-WAX9X:~$</span><br></pre></td></tr></table></figure>

<p>变量y有值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ben@ben-NBLK-WAX9X:~$y=old</span><br><span class="line">ben@ben-NBLK-WAX9X:~$x=$&#123;y-new&#125;</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $x</span><br><span class="line">old</span><br><span class="line">ben@ben-NBLK-WAX9X:~$echo $y</span><br><span class="line">old</span><br><span class="line">ben@ben-NBLK-WAX9X:~$</span><br></pre></td></tr></table></figure>

<h2 id="环境变量配置文件"><a href="#环境变量配置文件" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h2><h3 id="source命令"><a href="#source命令" class="headerlink" title="source命令"></a>source命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# source 配置文件</span><br><span class="line">或</span><br><span class="line">[root@localhost ~]# . 配置文件</span><br></pre></td></tr></table></figure>



<h3 id="环境变量配置文件-1"><a href="#环境变量配置文件-1" class="headerlink" title="环境变量配置文件"></a>环境变量配置文件</h3><h4 id="登录时生效的环境变量配置文件"><a href="#登录时生效的环境变量配置文件" class="headerlink" title="登录时生效的环境变量配置文件"></a>登录时生效的环境变量配置文件</h4><p>在Linux系统登录时主要生效的环境变量配置文件有以下五个：</p>
<ul>
<li>&#x2F;etc&#x2F;profile</li>
<li>&#x2F;etc&#x2F;profile.d&#x2F;*.sh</li>
<li>~&#x2F;.bash_profile</li>
<li>~&#x2F;.bashrc</li>
<li>&#x2F;etc&#x2F;bashrc</li>
</ul>
<p>环境变量配置文件调用过程</p>
<ul>
<li><p>在用户登录过程先调用&#x2F;etc&#x2F;profile文件</p>
<p>在这个环境变量配置文件中会定义这些默认环境变量：</p>
<ul>
<li>USER变量：根据登录的用户，给这个变量赋值(就是让USER变量的值是当前用户)。</li>
<li>LOGNAME变量：根据USER变量的值，给这个变量赋值。</li>
<li>MAIL变量：根据登录的用户，定义用户的邮箱为&#x2F;var&#x2F;spool&#x2F;mail&#x2F;用户名。</li>
<li>PATH变量：根据登录用户的UID是否为0，判断PATH变量是否包含&#x2F;sbin、&#x2F;usr&#x2F;sbin和、&#x2F;usr&#x2F;local&#x2F;sbin这三个系统命令目录。</li>
<li>HOSTNAME变量：更改主机名，给这个变量赋值。</li>
<li>HISTSIZE变量：定义历史命令的保存条数。</li>
<li>umask：定义umask默认权限。注意&#x2F;etc&#x2F;profile文件中的umask权限是在“有用户登录过程(也就是输入了用户名和密码)”时才会生效。</li>
<li>调用&#x2F;etc&#x2F;profile.d&#x2F;*.sh文件，也就是调用&#x2F;etc&#x2F;profile.d&#x2F;目录下所有以.sh结尾的文件。</li>
</ul>
</li>
<li><p>由&#x2F;etc&#x2F;profile文件调用&#x2F;etc&#x2F;profile.d&#x2F;*.sh文件</p>
<p>这个目录中所有以.sh结尾的文件都会被&#x2F;etc&#x2F;profile文件调用，这里最常用的就是lang.sh文件，而这个文件又会调用&#x2F;etc&#x2F;sysconfig&#x2F;i18n文件。</p>
</li>
<li><p>由&#x2F;etc&#x2F;profile文件调用~&#x2F;.bash_profile文件</p>
<p>~&#x2F;.bash_profile文件主要实现两个功能：</p>
<ul>
<li>调用了~&#x2F;.bashrc文件。</li>
<li>在PATH变量后面加入了“:$HOME&#x2F;bin”这个目录。也就是说，如果我们在自己的家目录中建立bin目录，然后把自己的脚本放入“~&#x2F;bin”目录，就可以直接执行脚本，而不用通过目录执行了。</li>
</ul>
</li>
<li><p>由<del>&#x2F;.bash_profile文件调用</del>&#x2F;.bashrc文件</p>
<p>在~&#x2F;.bashrc文件中主要实现了：</p>
<ul>
<li>定义默认别名。</li>
<li>调用&#x2F;etc&#x2F;bashrc</li>
</ul>
</li>
<li><p>由~&#x2F;.bashrc调用了&#x2F;etc&#x2F;bashrc文件</p>
<p>在&#x2F;etc&#x2F;bashrc文件中主要定义了这些内容：</p>
<ul>
<li>PS1变量：也就是用户的提示符，如果想要永久修改提示符，就要在这个文件中修改。</li>
<li>umask：定义umask默认权限。这个文件中定的umask是针对”没登录过程(也就是不需要输入用户名和密码时，比如从一个终端切换到另一个终端，或进入子shell)”时生效的。如果是“有用户登录过程”，则是&#x2F;etc&#x2F;profile文件中的umask生效。</li>
<li>PATH变量：会给PATH变量追加值，当然也是在“没有登录过程”时才生效。</li>
<li>调用&#x2F;etc&#x2F;profile.d&#x2F;*.sh文件，这也是在”没有用户登录过程”时才调用。在“有用户登录过程”时，&#x2F;etc&#x2F;profile.d&#x2F;*.sh文件已经被&#x2F;etc&#x2F;profile文件调用过了。</li>
</ul>
</li>
</ul>
<p>这样五个环境变量配置文件会被依次调用，如果是我们自己定义的环境变量，如果你的修改是打算对所有用户生效的，那么可以放入&#x2F;etc&#x2F;profile环境变量配置文件；如果你的修改只是给自己使用的，那么可以放入<del>&#x2F;.bash_profile或</del>&#x2F;.bashrc这两个配置文件中的任一个。</p>
<p>如果我们误删除了这些环境变量，比如删除了&#x2F;etc&#x2F;bashrc文件，或删除了<del>&#x2F;.bashrc文件，那么这些文件中配置就会失效(</del>&#x2F;.bashrc_profile文件会调用&#x2F;etc&#x2F;profile文件)。那提示符就会变成：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-bash-4.1#</span><br></pre></td></tr></table></figure>



<h4 id="注销时生效的环境变量配置文件"><a href="#注销时生效的环境变量配置文件" class="headerlink" title="注销时生效的环境变量配置文件"></a>注销时生效的环境变量配置文件</h4><p>在用户退出登录时，只会调用一个环境变量配置文件，就是~&#x2F;.bash_logout。这个文件默认没有写入任何内容，可是如果我们希望在退出登录时执行一些操作，比如清除历史命令，备份某些数据，就可以把命令写入这个文件。</p>
<h4 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h4><p>还有一些环境变量配置文件，最常见的就是~&#x2F;bash_history文件，也就是历史命令保存文件。</p>
<h3 id="Shell登录信息"><a href="#Shell登录信息" class="headerlink" title="Shell登录信息"></a>Shell登录信息</h3><h4 id="etc-issue"><a href="#etc-issue" class="headerlink" title="&#x2F;etc&#x2F;issue"></a>&#x2F;etc&#x2F;issue</h4><p>我们在登录tty1-6这六个本地终端时，会有几行的欢迎界面。这些欢迎信息是保存在&#x2F;etc&#x2F;issue文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/issue</span><br><span class="line">CentOS release 7.9 (Final)</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure>

<p>可以支持的转义符可以通过man agetty命令查询。下表中列出常见的转义符作用：</p>
<table>
<thead>
<tr>
<th>转义符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>显示当前系统日期</td>
</tr>
<tr>
<td>\s</td>
<td>显示操作系统名称</td>
</tr>
<tr>
<td>\l</td>
<td>显示登录的终端号，这个比较常用。</td>
</tr>
<tr>
<td>\m</td>
<td>显示硬件体系结构，如i386、i686等</td>
</tr>
<tr>
<td>\n</td>
<td>显示主机名</td>
</tr>
<tr>
<td>\o</td>
<td>显示域名</td>
</tr>
<tr>
<td>\r</td>
<td>显示内核版本</td>
</tr>
<tr>
<td>\t</td>
<td>显示当前系统时间</td>
</tr>
<tr>
<td>\u</td>
<td>显示当前登录用户的序列号</td>
</tr>
</tbody></table>
<h4 id="etc-issue-net"><a href="#etc-issue-net" class="headerlink" title="&#x2F;etc&#x2F;issue.net"></a>&#x2F;etc&#x2F;issue.net</h4><p>&#x2F;etc&#x2F;issue是在本地终端登录时显示欢迎信息的。如果是远程登录(如ssh远程登录，或telnet远程登录)需要显示欢迎信息，则需要配置&#x2F;etc&#x2F;issue.net这个文件了。使用这个文件时需要注意两个点：</p>
<ul>
<li>在&#x2F;etc&#x2F;issue文件中支持的转义符，在&#x2F;etc&#x2F;issue.net文件中不能使用。</li>
<li>ssh远程登录是否显示&#x2F;etc&#x2F;issue.net的欢迎信息，是由ssh的配置文件决定的。</li>
</ul>
<p>如果需要ssh远程登录可以查看&#x2F;etc&#x2F;issue.net的欢迎信息，那么首先需要修改ssh的配置文件&#x2F;etc&#x2F;ssh&#x2F;sshd_config：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/ssh/sshd_config</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">no default banner path</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Banner none</span></span><br><span class="line">Banner /etc/issue.net</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这样在ssh远程登录时，也可以显示欢迎信息，只是不再可以识别“\d”和“\l”等信息了。</p>
<h4 id="etc-motd"><a href="#etc-motd" class="headerlink" title="&#x2F;etc&#x2F;motd"></a>&#x2F;etc&#x2F;motd</h4><p>&#x2F;etc&#x2F;motd文件也是显示欢迎信息的，这个文件和&#x2F;etc&#x2F;issue及&#x2F;etc&#x2F;issue.net文件的区别是：&#x2F;etc&#x2F;issue及&#x2F;etc&#x2F;issue.net是在用户登录之前显示欢迎信息，而&#x2F;etc&#x2F;motd是在用户输入用户名和密码，正确登录之后显示欢迎信息。在&#x2F;etc&#x2F;motd文件中的欢迎信息，不论是本地登录，还是远程登录都可以显示。</p>
<h3 id="定义Bash快捷键"><a href="#定义Bash快捷键" class="headerlink" title="定义Bash快捷键"></a>定义Bash快捷键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# stty 关键字 快捷键</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义ctrl+p快捷键为强制终止，<span class="string">&quot;^&quot;</span>字符只要手工输入即可</span></span><br><span class="line">[root@localhost ~]# stty intr ^p</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询所有快捷键</span></span><br><span class="line">[root@localhost ~]# stty -a</span><br><span class="line">intr = ^P; quit = ^\; erase = ^?; kill = ^U; eof = ^D; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;; swtch = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; discard = ^O;</span><br><span class="line">min = 1; time = 0;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>Shell编程</title>
    <url>/2025/02/27/Shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>正则表达式用来在文件中匹配符合条件的字符串，通配符用来匹配符合条件的文件名。其实这种区别只在Shell当中适用，因为用来文件当中搜索字符串的命令如grep、awk、sed等命令可以支持正则表达式，而在系统当中搜索文件的命令如ls、find、cp这些命令不支持正则表达式，所以只能使用Shell自己的通配符来进行匹配了。</p>
<h4 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>前一个字符匹配0次或任意多次</td>
</tr>
<tr>
<td>.</td>
<td>匹配除了换行符外任意一个字符</td>
</tr>
<tr>
<td>^</td>
<td>匹配行首。例如^hello会匹配以hello开头的行</td>
</tr>
<tr>
<td>$</td>
<td>匹配行尾。例如hello$会匹配以hello结尾的行</td>
</tr>
<tr>
<td>[]</td>
<td>匹配中括号中指定的任意一个字符，只匹配一个字符。例如[aoeiu]匹配任意一个元音字母</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配除中括号的字符以外的任意一个字符。例如[^0-9]匹配任意一位非数字字符</td>
</tr>
<tr>
<td>\</td>
<td>转义符。用于取消特殊符号的转义</td>
</tr>
<tr>
<td>\{n\}</td>
<td>表示其前面的字符恰好出现n次。例如[0-9]\{4\}匹配4位数字</td>
</tr>
<tr>
<td>\{n, \}</td>
<td>表示其前面的字符出现不小于n次。例如[0-9]\{2, \}表示两位及以上的数字</td>
</tr>
<tr>
<td>\{n,m\}</td>
<td>表示其前面的字符至少出现n次，最多出现m次。例如[a-z]\{6,8\}匹配6到8位的小写字母。</td>
</tr>
</tbody></table>
<p>练习文件建立：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“a*”前一个字符匹配0次，或任意多次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">5555nice!</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“aa*”代表这行字符串最少要有一个a</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;aa*&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he was the most honest man.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“.”匹配除了换行符外任意一个字符，只能匹配一个字符，这个字符可以是任意字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s..d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# grep &quot;s.*d&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“^”代表匹配行首，比如“^M”会匹配以大写“M”开头的行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^M&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure>

<p>“$”代表匹配行尾，比如“n$”会匹配以小写“n”结尾的行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;n$&quot; test_rule.txt</span><br><span class="line">M. Zhang San is the most honest man</span><br></pre></td></tr></table></figure>

<p>“^$”则会匹配空白行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^$&quot; test_rule.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“[]”会匹配中括号中指定任意一个字符，注意只能匹配一个字符。比如[ao]会匹配a或o</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;s[ao]id&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“[^]”匹配除中括号的字符以外的任意一个字符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[^a-z]&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">123despise him.</span><br><span class="line">But since Mr. Zhang San came,</span><br><span class="line">5555nice!</span><br><span class="line">M. Zhang San is the most honest man</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“\“转义符</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;\.$&quot; test_rule.txt</span><br><span class="line">he was the most honest man.</span><br><span class="line">123despise him.</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">Later, Mr. Li Ming soid his hot body.</span><br></pre></td></tr></table></figure>

<p>“\{n\}”表示其前面的字符恰好出现n次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;a\&#123;3\&#125;&quot; test_rule.txt</span><br><span class="line">he never saaaid thos words.</span><br><span class="line">because, actuaaaally,</span><br></pre></td></tr></table></figure>

<p>“\{n,\}”会匹配前面的字符出现最少n次。比如“^[0-9]\{3, \}[a-z]”这个正则就能匹配最少用连续三个数字开头的字符串</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;^[0-9]\&#123;3,\&#125;[a-z]&quot; test_rule.txt</span><br><span class="line">123despise him.</span><br><span class="line">5555nice!</span><br></pre></td></tr></table></figure>

<p>“\{n,m\}”匹配其前面的字符至少出现n次，最多出现m次</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep &quot;sa\&#123;1,3\&#125;i&quot; test_rule.txt</span><br><span class="line">Mr. Li Ming said:</span><br><span class="line">he never saaaid thos words.</span><br></pre></td></tr></table></figure>



<h4 id="扩展正则表达式"><a href="#扩展正则表达式" class="headerlink" title="扩展正则表达式"></a>扩展正则表达式</h4><p>在正则表达式中应该还可以支持一些元字符，比如“+”、“?”、“|”、“()”。其实Linux是支持这些元字符的，只是grep命令默认不支持而已。如果想要支持这些元字符，必须使用egrep命令或grep -E选项，所以我们又把这些元字符称作扩展元字符。</p>
<p>如果查询grep的帮助，对egrep的说明就是和grep -E选项一样的命令，所以我们可以把这两个命令当做别名来对待。</p>
<table>
<thead>
<tr>
<th>扩展元字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>前一个字符匹配1次或任意多次。如“go+gle”会匹配“gogle”、“google”或“gooogle”等。</td>
</tr>
<tr>
<td>?</td>
<td>前一个字符匹配0次或1次。如”colou?r”可以匹配“colour”或“color”。</td>
</tr>
<tr>
<td>|</td>
<td>匹配两个或多个分支的选择。如”was|his”会匹配既包含“was”的行，也匹配包含”his”的行。</td>
</tr>
<tr>
<td>()</td>
<td>匹配其整体为一个字符，即模式单元。可以理解为由多个单字符组成的大字符。如“(dog)+”会匹配“dog”、“dogdog”、“dogdogdog”等。因为被()包含的字符会当成一个整体。</td>
</tr>
</tbody></table>
<h3 id="字符截取和替换命令"><a href="#字符截取和替换命令" class="headerlink" title="字符截取和替换命令"></a>字符截取和替换命令</h3><h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f 列号：         提取第几列</span><br><span class="line">  -d 分隔号：       按照指定分隔符分割列</span><br><span class="line">  -c 字符范围：      不依赖分隔符来区分列，而是通过字符范围(行首为0)来进行字段提取。“n-”表示从第n个字符到行尾；&quot;n-m&quot;表示从第n个字符到第m个字符；&quot;-                     m&quot;表示从第1个字符到第m个字符。</span><br></pre></td></tr></table></figure>

<p>cut命令的默认分隔符是制表符，也就是“tab”键。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    Gender  Mark</span><br><span class="line">1       Liming  M       86</span><br><span class="line">2       Sc      M       90</span><br><span class="line">3       Tg      M       83</span><br></pre></td></tr></table></figure>

<p>提取第二列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2 test.txt</span><br><span class="line">Name</span><br><span class="line">Liming</span><br><span class="line">Sc</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure>

<p>提取多列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut -f 2,3 test.txt</span><br><span class="line">Name	Gender</span><br><span class="line">Liming	M</span><br><span class="line">Sc	M</span><br><span class="line">Tg	M</span><br></pre></td></tr></table></figure>

<p>按照字符进行提取：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut -c 8- test.txt        # &quot;8-&quot;代表提取所有行的第8个字符到结尾</span><br><span class="line">	Gender	Mark</span><br><span class="line">g	M	86</span><br><span class="line">90</span><br><span class="line">83</span><br></pre></td></tr></table></figure>

<p>以“:”作为分隔符提取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cut -d &quot;:&quot; -f 1,3 /etc/passwd</span><br><span class="line">root:0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><p>a）printf格式化输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;输出类型输出格式&#x27; 输出内容</span><br><span class="line">输出类型：</span><br><span class="line">  %ns:        输出字符串。n是数字指代输出几个字符</span><br><span class="line">  %ni:        输出整数。n是数字指代输出几个数字</span><br><span class="line">  %m.nf:      输出浮点数。m和n是数字，指代输出的整数位和小数位数。如%8.2f代表共输出8位数，其中2位是小数，6位是整数。</span><br><span class="line">输出格式：</span><br><span class="line">  \a：         输出警告声音</span><br><span class="line">  \b：         输出退格键，也就是Backspace键</span><br><span class="line">  \f：         清除屏幕</span><br><span class="line">  \n:          换行</span><br><span class="line">  \r:          回车，也就是Enter键</span><br><span class="line">  \t:          水平输出退格键，也就是Tab键</span><br><span class="line">  \v:          垂直输出退格键，也就是Tab键</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>使用printf输出test.txt文件的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s&#x27; $(cat test.txt)</span><br><span class="line">IDNamePHPLinuxMySQLAverage1Liming82958687.662Sc74968785.663Tg99839391.66[root@localhost ~]#</span><br></pre></td></tr></table></figure>

<p>如果不指定输出格式，则会把所有输出内容连在一起输出。其实文本的输出本身就是这样的，cat等文本输出命令之所以可以按照格式漂亮的输出，那是因为cat命令已经设定了输出格式。为了用printf输出合理的格式，可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意在<span class="built_in">printf</span>命令的单引号中，只能识别格式输出符号，而手工输入的空格是无效的</span></span><br><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %s\t %s\t %s\t %s\t \n&#x27; $(cat test.txt)</span><br><span class="line">ID	 Name	 PHP	 Linux	 MySQL	 Average	 </span><br><span class="line">1	 Liming	 82	 95	 86	 87.66	 </span><br><span class="line">2	 Sc	 74	 96	 87	 85.66	 </span><br><span class="line">3	 Tg	 99	 83	 93	 91.66</span><br></pre></td></tr></table></figure>

<p>如果不想把成绩当成字符串输出，而是按照整形和浮点型输出，则要这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# printf &#x27;%s\t %s\t %i\t %i\t %i\t %8.2f\t \n&#x27; $(cat test.txt | grep -v Name)</span><br><span class="line">1	 Liming	 82	 95	 86	    87.66	 </span><br><span class="line">2	 Sc	 74	 96	 87	    85.66	 </span><br><span class="line">3	 Tg	 99	 83	 93	    91.66</span><br></pre></td></tr></table></figure>



<p>b）awk基本使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;条件1&#123;动作1&#125; 条件2&#123;动作2&#125;...&#x27; 文件名</span><br><span class="line">条件(Pattern)：</span><br><span class="line">    一般使用关系表达式作为条件。这些关系表达式非常多。如：</span><br><span class="line">    x &gt; 10    判断变量x是否大于10</span><br><span class="line">    x == y    判断变是x是否等于变量y</span><br><span class="line">    A`B       判断字符串A中是否包含能匹配B表达式的子字符串</span><br><span class="line">    A!`B      判断字符串A中是否不包含能匹配B表达式的子字符串</span><br><span class="line">动作(Action)：</span><br><span class="line">    格式化输出</span><br><span class="line">    流程控制语句</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出第二列和第六列</span></span><br><span class="line">[root@localhost ~]# awk &#x27;&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>



<p>c）awk的条件</p>
<table>
<thead>
<tr>
<th>条件的类型</th>
<th>条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>awk保留字</td>
<td>BEGIN</td>
<td>在awk程序一开始时，尚未读取任何数据之前执行。BEGIN后的动作只在程序开始时执行一次。</td>
</tr>
<tr>
<td></td>
<td>END</td>
<td>在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td></td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td></td>
<td>&gt;&#x3D;</td>
<td>大于等于</td>
</tr>
<tr>
<td></td>
<td>&lt;&#x3D;</td>
<td>小于等于</td>
</tr>
<tr>
<td></td>
<td>&#x3D;&#x3D;</td>
<td>等于。用于判断两个值是否相等，如果是给变量赋值，请使用“&#x3D;”号</td>
</tr>
<tr>
<td></td>
<td>!&#x3D;</td>
<td>不等于</td>
</tr>
<tr>
<td></td>
<td>A~B</td>
<td>判断字符串A中是否包含能匹配B表达式的子字符串</td>
</tr>
<tr>
<td></td>
<td>A!~B</td>
<td>判断字符串B中是否不包含能匹配B表达式的子字符串</td>
</tr>
<tr>
<td>正则表达式</td>
<td>&#x2F;正则&#x2F;</td>
<td>如果在“&#x2F;&#x2F;”中可以写入字符，也可以支持正则表达式</td>
</tr>
</tbody></table>
<ul>
<li><p>BEGIN</p>
<p>BEGIN是awk的保留字，是一种特殊的条件类型。BEGIN的执行时机是“在awk程序一开始时，尚未读取任何数据之前执行”。一旦BEGIN后的动作执行一次，当awk开始从文件中读入数据，BEGIN的条件就不再成立，所以BEGIN定义的动作只能被执行一次。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">awk命令只要检测不到完整的单引号不会执行，所以这个命令的换行不用加入<span class="string">&quot;\&quot;</span></span></span><br><span class="line">[root@localhost ~]# awk &#x27;BEGIN&#123;printf &quot;This is a transcript \n&quot;&#125; </span><br><span class="line">&#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">This is a transcript </span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>
</li>
<li><p>END</p>
<p>END也是awk保留字，不过刚好和BEGIN相反。END是在awk程序处理完所有数据，即将结束时执行。END后的动作只在程序结束时执行一次。例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;END&#123;printf &quot;The END \n&quot;&#125; &#123;printf $2 &quot;\t&quot; $6 &quot;\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br><span class="line">The END</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算符</p>
<p>查看平均成绩大于等于87分的学员是谁：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$6 &gt;= 87&#123;printf $2 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">Liming</span><br><span class="line">Tg</span><br></pre></td></tr></table></figure>

<p>加入条件之后，只有条件成立动作才会执行，如果条件不满足，则运作不运行。通过这个实验，大家可以发现，虽然awk是列提取命令，但是也要按行来读入的。这个命令的执行过程是这样的：</p>
<p>1）如果有BEGIN条件，则先执行BEGIN定义的动作</p>
<p>2）如果没有BEGIN条件，则读入第一行，把第一行的数据依次赋予$0、$1、$2等变量。其中$0代表此行的整体数据，$1代表第一字段，$2代表第二字段。</p>
<p>3）依据条件类型判断动作是否执行。如果条件符合，则执行动作，否则读入下一行数据。如果没有条件，则每行都执行动作。</p>
<p>4）读入下一行数据，重复执行以上步骤。</p>
<p>查看Sc用户的平均成绩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat test.txt | grep -v Name | awk &#x27;$2 ~ &quot;Sc&quot;&#123;printf $6 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">85.66</span><br></pre></td></tr></table></figure>
</li>
<li><p>正则表达式</p>
<p>如果想让awk识别字符串，必须使用“&#x2F;&#x2F;”包含，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印LiMing的成绩</span></span><br><span class="line">[root@localhost ~]# awk &#x27;/Liming/ &#123;print&#125;&#x27; test.txt </span><br><span class="line">1	Liming	82	95	86	87.66</span><br></pre></td></tr></table></figure>

<p>当使用df命令查看分区使用情况时，如果只想看真正的系统分区的使用状况，而不想查看光盘和临时分区的使用状况，则可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -h | awk &#x27;/sda[0-9]/ &#123;printf $1 &quot;\t&quot; $5 &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>4）awk内置变量</p>
<table>
<thead>
<tr>
<th>awk内置变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>$0</td>
<td>代表目前awk所读入的整行数据。我们已知awk是一行一行读入数据的，$0就代表当前读入行的整行数据。</td>
</tr>
<tr>
<td>$n</td>
<td>代表目前读入行的第n个字段。</td>
</tr>
<tr>
<td>NF</td>
<td>当前行拥有的字段(列)总数。</td>
</tr>
<tr>
<td>NR</td>
<td>当前awk所处理的行，是总数据的第几行。</td>
</tr>
<tr>
<td>FS</td>
<td>用户定义分隔符。awk的默认分隔符是任何空格，如果想要使用其他分隔符(如”：”)，就需要FS变量定义。</td>
</tr>
<tr>
<td>ARGC</td>
<td>命令行参数个数。</td>
</tr>
<tr>
<td>ARGV</td>
<td>命令行参数数组。</td>
</tr>
<tr>
<td>FNR</td>
<td>当前文件中的当前记录数(对输入文件起始为1)。</td>
</tr>
<tr>
<td>OFMT</td>
<td>数值的输出格式(默认为%.6g)。</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段的分隔符(默认为空格)。</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符(默认为换行符)。</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符(默认为换行符)。</td>
</tr>
</tbody></table>
<p>查询可以登录的用户的用户名和UID：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root	0</span><br><span class="line">ben	1000</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat /etc/passwd | grep &quot;/bin/bash&quot; | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号:&quot; NR &quot;\t 字段数: &quot; NF &quot;\n&quot;&#125;&#x27;</span><br><span class="line">root	0	 行号:1	 字段数: 7</span><br><span class="line">ben	1000	 行号:2	 字段数: 7</span><br></pre></td></tr></table></figure>

<p>查看sshd这个伪用户的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $1==&quot;sshd&quot; &#123;printf $1 &quot;\t&quot; $3 &quot;\t 行号：&quot; NR &quot;\t 字段数：&quot; NF &quot;\n&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure>



<p>5）awk流程控制</p>
<p>统计PHP成绩的总分：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR==2&#123;php1=$3&#125; NR==3&#123;php2=$3&#125; NR==4&#123;php3=$3;total=php1+php2+php3;print &quot;total php is &quot; total&#125;&#x27; test.txt</span><br><span class="line">total php is 255</span><br></pre></td></tr></table></figure>

<ul>
<li>“NR&#x3D;&#x3D;2{php1&#x3D;$3}”：条件是NR&#x3D;&#x3D;2，动作是php1&#x3D;$3，指如果输入数据是第二行(第一行是标题行)，就把第二行的第三字段的值赋予变量“php1”。</li>
<li>“NR&#x3D;&#x3D;3{php2&#x3D;$3}”：如果输入数据是第三行，就把第三行的第三字段的值赋予变量“php2”。</li>
<li>‘NR&#x3D;&#x3D;4{php3&#x3D;$3;total&#x3D;php1+php2+php3;print “total php is “ total}’：如果输入数据是第四行，就把第四行的第三字段的值赋予变量“php3”；然后定义变量total的值为‘php1+php2+php3’；然后输出”total php is “关键字，后面加变量total的值。</li>
</ul>
<p>在awk编程中，因为命令语句非常长，在输入格式时需要注意以下内容：</p>
<ul>
<li>多个条件{动作}可以用空格分割，也可以用回车分割。</li>
<li>在一个动作中，如果需要执行多个命令，需要用“;”分割，或用回车分割。</li>
<li>在awk中，变量的赋值与调用都不需要加入“$”符。</li>
<li>条件中判断两个值是否相同，请使用”&#x3D;&#x3D;”，以便和变量赋值进行区分。</li>
</ul>
<p>如果Linux成绩大于90，就是一个好学生：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;&#123;if (NR&gt;=2)&#123;if ($3&gt;90) printf $2 &quot; is a good student!\n&quot;&#125;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure>

<p>其实awk中if判断语句，完全可以直接利用awk自带的条件来取代：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;NR&gt;=2&#123;test=$3&#125; test&gt;90&#123;printf $2 &quot; is a good student!\n&quot;&#125;&#x27; test.txt</span><br><span class="line">Tg is a good student!</span><br></pre></td></tr></table></figure>



<p>6）awk函数</p>
<p>awk编程也允许在编程时使用函数，awk函数定义方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名 (参数列表) &#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一简单的函数，使用函数来打印test.txt的学员姓名和平均成绩：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk &#x27;function test(a,b) &#123;printf a &quot;\t&quot; b &quot;\n&quot;&#125; &#123;test($2,$6)&#125;&#x27; test.txt</span><br><span class="line">Name	Average</span><br><span class="line">Liming	87.66</span><br><span class="line">Sc	85.66</span><br><span class="line">Tg	91.66</span><br></pre></td></tr></table></figure>



<p>7）awk中调用脚本</p>
<p>对于小的单行程序来说，将脚本作为命令行自变量传递给awk是非常简单的，而对于多行程序就比较难处理。当程序是多行的时候，使用外部脚本是很适合的。首先在外部文件中写好脚本，然后可以使用awk的-f选项，使其读入脚本并且执行。</p>
<p>例如，我们可以先编写一个awk脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim pass.awk</span><br><span class="line">BEGIN	&#123;FS=&quot;:&quot;&#125;</span><br><span class="line">&#123;print $1 &quot;\t&quot; $3&#125;</span><br></pre></td></tr></table></figure>

<p>然后可以使用”-f”选项来调用这个脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# awk -f pass.awk /etc/passwd</span><br><span class="line">root	0</span><br><span class="line">daemon	1</span><br><span class="line">bin	2</span><br><span class="line">sys	3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><p>sed主要是用来将数据进行选取、替换、删除和新增的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed [选项] &#x27;[动作]&#x27; 文件名</span><br><span class="line">选项：</span><br><span class="line">  -n:              一般sed命令会把所有数据都输出到屏幕，如果加入此选择，则只会把经过sed命令处理的行输出到屏幕。</span><br><span class="line">  -e:              允许对输入数据应用多条sed命令编辑。</span><br><span class="line">  -f 脚本文件名:    从sed脚本中读入sed操作。和awk命令的-f非常类似。</span><br><span class="line">  -r:              在sed中支持扩展正则表达式。</span><br><span class="line">  -i:              用sed的修改结果直接修改读取数据的文件，而不是由屏幕输出</span><br><span class="line">动作：</span><br><span class="line">  a \n:             追加，在当前行后添加一行或多行。添加多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  c \n:             行替换，用c后面的字符串替换原数据行，替换多行时，除最后一行外，每行末尾需用&quot;\&quot;代表数据未完结。</span><br><span class="line">  i \n:             插入，在当前行前插入一行或多行。插入多行时，除最后一行外，每行末尾需要用&quot;\&quot;代表数据未完结。</span><br><span class="line">  d:               删除，删除指定的行。</span><br><span class="line">  p:               打印，输出指定的行。</span><br><span class="line">  s:               字串替换，用一个字符串替换另外一个字符串。格式为&quot;行范围 s/旧字串/新字串/g&quot;（和vim中的替换格式类似）</span><br></pre></td></tr></table></figure>

<p>对sed命令要注意，sed所做的修改并不会直接改变文件的内容(如果是用管道符接收的命令的输出，这种情况连文件都没有)，而是把修改结果只显示到屏幕上，除非使用“-i”选项才会直接修改文件。</p>
<ul>
<li><p>行数据操作</p>
<p>【查看】</p>
<p>查看test.txt的第二行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2p&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>“p”命令确实输出了第二行数据，但是sed命令还会把所有数据都输出一次。如果想指定输出某行数据，需要”-n”选项的帮助：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed -n &#x27;2p&#x27; test.txt</span><br><span class="line">1       Liming  82      95      86      87.66</span><br></pre></td></tr></table></figure>



<p>【删除】</p>
<p>删除第二行到第四行的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2,4d&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件本身并没有修改</span></span><br><span class="line">[root@localhost ~]# cat test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>



<p>【追加】</p>
<p>“a“会在指定行后面追加入数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2a hello&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">hello</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>



<p>【插入】</p>
<p>“i”会在指定行前面插入数据:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# sed -n &#x27;2i hello\nworld&#x27; test.txt</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>



<p>【替换】</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;2c No such person&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No such person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# cat test.txt | sed &#x27;2c No sucn person&#x27;</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">No sucn person</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>sed命令默认情况下是不会修改文件内容的，如果确定需要让sed命令直接处理文件的内容，可以使用”-i”选项。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed -i &#x27;2c No such person&#x27; test.txt</span><br></pre></td></tr></table></figure>


</li>
<li><p>字符串替换</p>
<p>“c”动作是进行整行替换的，如果仅仅想替换行中的部分数据，就要使用“s”动作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;s/旧字串/新字串/g&#x27; 文件名</span><br></pre></td></tr></table></figure>

<p>在第三行中，把74替换成99：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;3s/74/99/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      99      96      87      85.66</span><br><span class="line">3       Tg      99      83      93      91.66</span><br></pre></td></tr></table></figure>

<p>把第四行注释掉：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed &#x27;4s/^/#/g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1       Liming  82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3       Tg      99      83      93      91.66</span></span><br></pre></td></tr></table></figure>

<p>“-e”选项可以同时执行多个sed动作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sed -e &#x27;s/Liming//g;s/Tg//g&#x27; test.txt</span><br><span class="line">ID      Name    PHP     Linux   MySQL   Average </span><br><span class="line">1         82      95      86      87.66</span><br><span class="line">2       Sc      74      96      87      85.66</span><br><span class="line">3             99      83      93      91.66</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sort [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -f:        忽略大小写</span><br><span class="line">  -b:        忽略每行前面的空白部分</span><br><span class="line">  -n:        以数值型进行排序，默认使用字符串型排序</span><br><span class="line">  -r:        反向排序</span><br><span class="line">  -u:        删除重复行。就是uniq命令</span><br><span class="line">  -t:        指定分隔符，默认分隔符是制表符</span><br><span class="line">  -k n[,m]:  按照指定的字段范围排序。从第n字段开始，m字段结束(默认到行尾)</span><br></pre></td></tr></table></figure>

<p>sort命令默认是用每行开头第一个字符来进行排序的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sort /etc/passwd</span><br><span class="line">_apt:x:105:65534::/nonexistent:/usr/sbin/nologin</span><br><span class="line">avahi-autoipd:x:109:116:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologin</span><br><span class="line">avahi:x:115:121:Avahi mDNS daemon,,,:/var/run/avahi-daemon:/usr/sbin/nologin</span><br><span class="line">backup:x:34:34:backup:/var/backups:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>反向排序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sort -r /etc/passwd</span><br><span class="line">www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin</span><br><span class="line">whoopsie:x:120:125::/nonexistent:/bin/false</span><br><span class="line">uuidd:x:107:114::/run/uuidd:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果想要指定排序的字段，需要先使用“-t”选项指定分隔符，并使用“-k”选项指定字段号。例如按照UID字段排序&#x2F;etc&#x2F;passwd文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# sort -n -t &quot;:&quot; -k 3,3 /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>当然“-k”选项可以直接使用“-k 3”，代表从第三字段到行尾排序（第一个字符先排序，如果一致，第二个字符再排序，直到行尾）。</p>
<h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h4><p>uniq命令是用来取消重复行的命令，其实和”sort -u”选项是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uniq [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -i:        忽略大小写</span><br></pre></td></tr></table></figure>



<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>统计命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# wc [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -l:        只统计行数</span><br><span class="line">  -w:        只统计单词数</span><br><span class="line">  -m:        只统计字符数</span><br></pre></td></tr></table></figure>



<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="按照文件类型进行判断"><a href="#按照文件类型进行判断" class="headerlink" title="按照文件类型进行判断"></a>按照文件类型进行判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-b 文件</td>
<td>判断该文件是否存在，并且是否为块设备文件（是块设备文件为真）</td>
</tr>
<tr>
<td>-c 文件</td>
<td>判断该文件是否存在，并且是否为字符设备文件（是字符设备文件为真）</td>
</tr>
<tr>
<td>-d 文件</td>
<td>判断该文件是否存在，并且是否为目录文件（是目录为真）</td>
</tr>
<tr>
<td>-e 文件</td>
<td>判断该文件是否存在（存在为真）</td>
</tr>
<tr>
<td>-f 文件</td>
<td>判断该文件是否存在，并且是否为普通文件（是普通文件为真）</td>
</tr>
<tr>
<td>-L 文件</td>
<td>判断该文件是否存在，并且是否为符号链接文件（是符号链接文件为真）</td>
</tr>
<tr>
<td>-p 文件</td>
<td>判断该文件是否存在，并且是否为管道文件（是管道文件为真）</td>
</tr>
<tr>
<td>-s 文件</td>
<td>判断该文件是否存在，并且是否为非空（非空为真）</td>
</tr>
<tr>
<td>-S 文件</td>
<td>判断该文件是否存在，并且是否为套接字文件（是套接字文件为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# [ -e /root/sh/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">0        # 判断结果为0，/root/sh/目录是存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -e /root/test/ ]</span><br><span class="line">[root@localhost ~]# echo $?</span><br><span class="line">1        # 判断结果为0，/root/test/目录是不存在的</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# [ -d /root/sh ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一个判断命令如果正确执行，则打印<span class="string">&quot;yes&quot;</span>，否则打印<span class="string">&quot;no&quot;</span></span></span><br></pre></td></tr></table></figure>



<h4 id="按照文件权限进行判断"><a href="#按照文件权限进行判断" class="headerlink" title="按照文件权限进行判断"></a>按照文件权限进行判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-r 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有读权限（有读权限为真）</td>
</tr>
<tr>
<td>-w 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有写权限（有写权限为真）</td>
</tr>
<tr>
<td>-x 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有执行权限（有执行权限为真）</td>
</tr>
<tr>
<td>-u 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SUID权限（有SUID权限为真）</td>
</tr>
<tr>
<td>-g 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SGID权限（有SGID权限为真）</td>
</tr>
<tr>
<td>-k 文件</td>
<td>判断该文件是否存在，并且是否该文件拥有SBIT权限（有SBIT权限为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll test.txt</span><br><span class="line">-rw-rw-r-- 1 ben ben 187  2月 28 02:09 test.txt</span><br><span class="line">[root@localhost ~]# [ -w test.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="两个文件之间进行比较"><a href="#两个文件之间进行比较" class="headerlink" title="两个文件之间进行比较"></a>两个文件之间进行比较</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>文件1 -nt 文件2</td>
<td>判断文件1的修改时间是否比文件2的新（如果新则为真）</td>
</tr>
<tr>
<td>文件1 -ot 文件2</td>
<td>判断文件1的修改时间是否比文件2的旧（如果旧则为真）</td>
</tr>
<tr>
<td>文件1 -ef 文件2</td>
<td>判断文件1是否和文件2的Inode号一致，可以理解为两个文件是否为同一个文件。这个判断用于判断硬链接是很好的方法</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建个硬链接</span></span><br><span class="line">[root@localhost ~]# ln /tmp/test.txt /tmp/stu.txt</span><br><span class="line">[root@localhost ~]# [ /tmp/test.txt -ef /tmp/stu.txt ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br></pre></td></tr></table></figure>



<h4 id="两个整数之间比较"><a href="#两个整数之间比较" class="headerlink" title="两个整数之间比较"></a>两个整数之间比较</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>整数1 -eq 整数2</td>
<td>判断整数1是否和整数2相等（相等为真）</td>
</tr>
<tr>
<td>整数1 -ne 整数2</td>
<td>判断整数1是否和整数2不相等（不相等为真）</td>
</tr>
<tr>
<td>整数1 -gt 整数2</td>
<td>判断整数1是否大于整数2（大于为真）</td>
</tr>
<tr>
<td>整数1 -lt 整数2</td>
<td>判断整数1是否小于整数2（小于为真）</td>
</tr>
<tr>
<td>整数1 -ge 整数2</td>
<td>判断整数1是否大于等于整数2（大于等于为真）</td>
</tr>
<tr>
<td>整数1 -le 整数2</td>
<td>判断整数1是否小于等于整数2（小于等于为真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# [ 23 -ge 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">yes</span><br><span class="line">[root@localhost ~]# [ 23 -le 22 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="字符串的判断"><a href="#字符串的判断" class="headerlink" title="字符串的判断"></a>字符串的判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>-z 字符串</td>
<td>判断字符串是否为空（为空返回真）</td>
</tr>
<tr>
<td>-n 字符串</td>
<td>判断字符串是否为非空（非空返回真）</td>
</tr>
<tr>
<td>字符串1 &#x3D;&#x3D; 字符串2</td>
<td>判断字符串1是否和字符串2相等（相等返回真）</td>
</tr>
<tr>
<td>字符串1 !&#x3D; 字符串2</td>
<td>判断字符串1 是否和字符串2不相等（不相等返回真）</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给name赋值</span></span><br><span class="line">[root@localhost ~]# name=ben</span><br><span class="line">[root@localhost ~]# [ -z &quot;$name&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# bb=22</span><br><span class="line">[root@localhost ~]# [ &quot;$aa&quot; == &quot;$bb&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>



<h4 id="多重条件判断"><a href="#多重条件判断" class="headerlink" title="多重条件判断"></a>多重条件判断</h4><table>
<thead>
<tr>
<th>测试选项</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>判断1 -a 判断2</td>
<td>逻辑与，判断1和判断2都成立，最终的结果为真</td>
</tr>
<tr>
<td>判断1 -o 判断2</td>
<td>逻辑或，判断1和判断2有一个成立，最终的结果就为真</td>
</tr>
<tr>
<td>! 判断</td>
<td>逻辑非，使原始的判断式取反</td>
</tr>
</tbody></table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# aa=11</span><br><span class="line">[root@localhost ~]# [ -n &quot;$aa&quot; -a &quot;$aa&quot; -gt 23 ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br><span class="line">[root@localhost ~]# [ ! -n &quot;$aa&quot; ] &amp;&amp; echo &quot;yes&quot; || echo &quot;no&quot;</span><br><span class="line">no</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>“!”和“-n”之间必须加入空格，否则会报错的。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if条件判断"><a href="#if条件判断" class="headerlink" title="if条件判断"></a>if条件判断</h4><p>a）单分支if条件语句</p>
<p>单分支条件语句最为简单，就是只有一个判断条件，如果符合条件则执行某个程序，否则什么事情都不做。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ];then</span><br><span class="line">	程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>单分支条件语句需要注意几个点：</p>
<ul>
<li><p>if语句使用fi结尾，和一般语言使用大括号结尾不同。</p>
</li>
<li><p>[ 条件判断式 ]就是使用test命令判断，所以中括号和条件判断式之间必须有空格。</p>
</li>
<li><p>then后面跟符合条件之后执行的程序，可以放在[]之后，用“;”分割。也可以换行写入，就不需要“;”了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]</span><br><span class="line">	then</span><br><span class="line">		程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">rate=$(df -h | grep &quot;/dev/sda3&quot; | awk &#x27;&#123;print $5&#125;&#x27; | cut -d &quot;%&quot; -f1)</span><br><span class="line">if [ $rate -ge 80 ];then</span><br><span class="line">	echo &quot;Warning! /dev/sda3 is full!!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>b）双分支if条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式 ]；then</span><br><span class="line">	条件成立时，执行的程序</span><br><span class="line">else</span><br><span class="line">	条件不成立时，执行的另一个程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">同步系统时间</span></span><br><span class="line">ntpdate asia.pool.ntp.org &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把当前系统时间按照<span class="string">&quot;年月日&quot;</span>格式赋予变量<span class="built_in">date</span></span></span><br><span class="line">date=$(date +%y%m%d)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计mysql数据库的大小，并把大小赋予size变量</span></span><br><span class="line">size=$(du -sh /var/lib/mysql)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断备份目录是否存在，是否为目录</span></span><br><span class="line">if [ -d  /tmp/dbak ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">	echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">	echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入备份目录</span></span><br><span class="line">	cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">	tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除临时文件</span></span><br><span class="line">	rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">如果判断为假，则建立备份目录</span></span><br><span class="line">	mkdir /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把当前日期写入临时文件</span></span><br><span class="line">	echo &quot;Date: $date!&quot; &gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">把数据库大小写入临时文件</span></span><br><span class="line">	echo &quot;Date size: $size&quot; &gt;&gt; /tmp/dbbak/dbinfo.txt</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">进入备份目录</span></span><br><span class="line">	cd /tmp/dbbak</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">打包压缩数据库与临时文件，把所有输出丢入垃圾箱</span></span><br><span class="line">	tar -zcf mysql-lib-$date.tar.gz /var/lib/mysql dbinfo.txt &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">删除临时文件</span></span><br><span class="line">	rm -rf /tmp/dbbak/dbinfo.txt</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>在工作中，服务器上的服务经常会宕机。如果我们对服务器监控不好，就会造成服务器中服务宕机了，而管理员却不知道的情况，这时我们可以写一个脚本来监听本机的服务，如果服务停止或宕机了，可以自动重启这些服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用nmap命令扫描服务器，并截取apache服务的状态，赋予变量port</span></span><br><span class="line">port=$(nmap -sT 192.168.4.210 | grep tcp | grep http | awk &#x27;&#123;print $2&#125;&#x27;)</span><br><span class="line">if [ &quot;$port&quot; == &quot;open&quot; ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">则证明apache正常启动，在正常日志中写入一句话即可</span></span><br><span class="line">	echo &quot;$(date) httpd is ok!&quot; &gt;&gt; /tmp/autostart-acc.log</span><br><span class="line">else</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">否则证明apache没有启动，自动启动apache</span></span><br><span class="line">	/etc/rc.d/init.d/httpd start &amp;&gt;/dev/null</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">并在错误日志中记录自动启动apache的时间</span></span><br><span class="line">	echo &quot;$(date) restart httpd!!&quot; &gt;&gt; /tmp/autostart-err.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<p>c）多分支if条件语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if [ 条件判断式1 ];then</span><br><span class="line">	当条件判断式1成立时，执行程序1</span><br><span class="line">elif [ 条件判断式2 ];then</span><br><span class="line">	当条件判断式2成立时，执行程序2</span><br><span class="line">else</span><br><span class="line">	当所有条件都不成立时，最后执行此程序</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>判断用户输入的是什么文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">！/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（Email:17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接收键盘的输入，并赋予变量file</span></span><br><span class="line">read -p &quot;Please input a filename: &quot; file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file变量是否为空</span></span><br><span class="line">if [ -z &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;Error,please input a filename&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出程序，并返回1</span></span><br><span class="line">	exit 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否存在</span></span><br><span class="line">elif [ ! -e &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;Your input is not a file!&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">退出程序，并返回2</span></span><br><span class="line">	exit 2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为普通文件</span></span><br><span class="line">elif [ -f &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;$file is a regulare file!&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断file的值是否为目录文件</span></span><br><span class="line">elif [ -d &quot;$file&quot; ];then</span><br><span class="line">	echo &quot;$file is a directory!&quot;</span><br><span class="line">else</span><br><span class="line">	echo &quot;$file is an other file!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="多分支case条件语句"><a href="#多分支case条件语句" class="headerlink" title="多分支case条件语句"></a>多分支case条件语句</h4><p>case语句和if…elif…else语句一样都是多分支条件语句，不过和if多分支条件语句不同的是，case语句只能判断一种条件关系，而if语句可以判断多种条件关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case $变量名 in</span><br><span class="line">	&quot;值1&quot;)</span><br><span class="line">		如果变量的值等于值1，则执行程序1</span><br><span class="line">		;;</span><br><span class="line">	&quot;值2&quot;)</span><br><span class="line">		如果变量的值等于值2，则执行程序2</span><br><span class="line">		;;</span><br><span class="line">	...</span><br><span class="line">	*)</span><br><span class="line">		如果变量的值都不是以上的值，则执行此程序</span><br><span class="line">		;;</span><br><span class="line">esac	</span><br></pre></td></tr></table></figure>

<p>这个语句需要注意以下内容：</p>
<ul>
<li><p>case语句，会取出变量中的值，然后与语句体中的值逐一比较。如果数值符合，则执行对应的程序，如果数值不符，则依次比较下一个值。如果所有的值都不符合，则执行“*)”（“*”代表所有其他值）中的程序。</p>
</li>
<li><p>case语句以“case”开头，以“esac”结尾。</p>
</li>
<li><p>每个分支程序之后要通过“;;”双分号结尾，代表该程序段结束。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please choose yes/no: &quot; -t 30 cho</span><br><span class="line">case $cho in </span><br><span class="line">	&quot;yes&quot;)</span><br><span class="line">		echo &quot;Your choose is yes!&quot;</span><br><span class="line">		;;</span><br><span class="line">	&quot;no&quot;)</span><br><span class="line">		echo &quot;Your choose is no!&quot;</span><br><span class="line">		;;</span><br><span class="line">	*)</span><br><span class="line">		echo &quot;Your choose is error!&quot;</span><br><span class="line">		;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>



<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环是固定循环，也就是在循环时已经知道需要进行几次循环，有时也把for循环称为计数循环。</p>
<p>语法一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for 变量 in 值1 值2 值3...</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>这种语法中for循环的次数，取决于in后面值的个数（空格分隔），有几个值就循环几次，并且每次循环都把值赋予变量。</p>
<p>打印时间：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for time in morning noon afternoon evening</span><br><span class="line">	do</span><br><span class="line">		echo &quot;This time is $time&quot;</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>批量解压缩脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入压缩目录</span></span><br><span class="line">cd /lamp</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把所有tar.gz结尾的文件的文件覆盖到ls.log临时文件中</span></span><br><span class="line">ls *.tar.gz &gt; ls.log</span><br><span class="line">for i in $(cat ls.log)</span><br><span class="line">	do</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">解压缩</span></span><br><span class="line">		tar -zxf $i &amp;&gt;/dev/null</span><br><span class="line">	done</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件ls.log</span></span><br><span class="line">rm -rf /lamp/ls.log</span><br></pre></td></tr></table></figure>



<p>语法二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (( 初始值;循环控制条件;变量变化 ))</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>这种语法需要注意：</p>
<ul>
<li>初始值：在循环开始时，需要给某个变量赋予初始值，如i&#x3D;1;</li>
<li>循环控制条件：用于指定变量循环的次数，如i&lt;&#x3D;100，则只要i的值小于等于100，循环就会继续;</li>
<li>变量变化：每次循环之后，变量该如何变化，如i&#x3D;i+1。代表每次循环之后，变量i的值都加1。</li>
</ul>
<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line">for (( i=1;i&lt;=100;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum of 1+2+...+100 is : $s&quot;</span><br></pre></td></tr></table></figure>

<p>批量添加指定数量的用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入用户名，把输入保存入变量name</span></span><br><span class="line">read -p &quot;Please input user name: &quot; -t 30 name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入添加用户的数量，把输入保存入变量num</span></span><br><span class="line">read -p &quot;Please input the number of users: &quot; -t num</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让用户输入初始密码，把输入保存入变量pass</span></span><br><span class="line">read -p &quot;Please input the password of users: &quot; -t pass</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断三个变量不为空</span></span><br><span class="line">if [ ! -z &quot;$name&quot; -a ! -z &quot;$num&quot; -a ! -z &quot;#pass&quot; ];then</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">判断变量num的值是否为数字</span></span><br><span class="line">	y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line">	if [ -z &quot;$y&quot; ];then</span><br><span class="line">		for (( i=1;i&lt;=$num;i=i+1 ))</span><br><span class="line">			do</span><br><span class="line">				# 添加用户</span><br><span class="line">				/usr/sbin/useradd $name$i &amp;&gt;/dev/null</span><br><span class="line">				# 修改用户密码</span><br><span class="line">				echo $pass | /usr/bin/passwd --stdin $name$i &amp;&gt;/dev/null</span><br><span class="line">			done</span><br><span class="line">	fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>批量删除用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">user=$(cat /etc/passwd | grep &quot;/bin/bash&quot; | grep -v &quot;root&quot; | cut -d &quot;:&quot; -f 1)</span><br><span class="line">for i in $user</span><br><span class="line">	do</span><br><span class="line">		userdel -r $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while [ 条件判断式 ]</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>对while循环来讲，只要条件判断式成立，循环就会一直继续，直到条件判断式不成立，循环才会停止。</p>
<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">while [ $i -le 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+ 1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure>



<h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><p>until循环和while循环相反，until循环时只要条件判断式不成立则进行循环，并执行循环程序。一旦循环条件成立，则终止循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">until [ 条件判断式 ]</span><br><span class="line">	do</span><br><span class="line">		程序</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

<p>从1加到100：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">i=1</span><br><span class="line">s=0</span><br><span class="line">until [ $i -gt 100 ]</span><br><span class="line">	do</span><br><span class="line">		s=$(( $s+$i ))</span><br><span class="line">		i=$(( $i+1 ))</span><br><span class="line">	done</span><br><span class="line">echo &quot;The sum is: $s&quot;</span><br></pre></td></tr></table></figure>



<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function 函数名（）&#123;</span><br><span class="line">	程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">function sum () &#123;</span><br><span class="line">	s=0</span><br><span class="line">	for (( i=0;i&lt;=$1;i=i+1 ))</span><br><span class="line">		do</span><br><span class="line">			s=$(( $i+$s ))</span><br><span class="line">		done</span><br><span class="line">	echo &quot;The sum of 1+2+3+...+$l is: $s&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line">y=$(echo $num | sed &#x27;s/[0-9]//g&#x27;)</span><br><span class="line"></span><br><span class="line">if [ -z $y ];then</span><br><span class="line">	sum $num</span><br><span class="line">else</span><br><span class="line">	echo &quot;Error!! Please input a number!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>



<h4 id="特殊流程控制语名"><a href="#特殊流程控制语名" class="headerlink" title="特殊流程控制语名"></a>特殊流程控制语名</h4><p>a）exit语句</p>
<p>系统是有exit命令的，用于退出当前用户的登录状态。可是在shell脚本中，exit语句是用来退出当前脚本的。也就是说，在Shell脚本中，只要碰到了exit语句，后续的程序就不再执行，而是直接退出脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exit [返回值]</span><br></pre></td></tr></table></figure>

<p>如果exit命令之后定义了返回值，那么这个脚本执行之后的返回值就是我们自己定义的返回值。可以通过$?这个变量来查看返回值。如果exit之后没有定义返回值，脚本执行之后的返回值是执行exit语句之前，最后执行的一条命令的返回值。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">read -p &quot;Please input a number: &quot; -t 30 num</span><br><span class="line"></span><br><span class="line">y=$(echo $num | sed &quot;s/[0-9]//g&quot;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断变量num的值如果不为空，则输出报错信息，并且退出脚本，退出返回值为18</span></span><br><span class="line">[ -n &quot;$y&quot; ] &amp;&amp; echo &quot;Error! Please input a number!&quot; &amp;&amp; exit 18</span><br><span class="line"></span><br><span class="line">echo &quot;The number is: $num&quot;</span><br></pre></td></tr></table></figure>



<p>b）break语句</p>
<p>当程序执行到break语句时，会结束整个当前循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail: 17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		if [ $i -eq 4 ];then</span><br><span class="line">			break</span><br><span class="line">		fi</span><br><span class="line">		echo $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>



<p>c）continue语句</p>
<p>continue也是结束流程控制的语句。continue语句只会结束单次当前循环。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author:Ben（E-mail:17620170099@163.com）</span></span><br><span class="line"></span><br><span class="line">for (( i=1;i&lt;=10;i=i+1 ))</span><br><span class="line">	do</span><br><span class="line">		if [ $i -eq 4 ];then</span><br><span class="line">			continue</span><br><span class="line">		fi</span><br><span class="line">		echo $i</span><br><span class="line">	done</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Shell</category>
      </categories>
  </entry>
  <entry>
    <title>vim编辑器</title>
    <url>/2025/02/25/vim%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<h1 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h1><p>vim是一个全屏幕纯文本编辑器，是vi编辑器的增强版。</p>
<p>可以利用别名让输入vi命令的时候，实际上执行vim编辑器，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义别名</span></span><br><span class="line">alias vi=&#x27;vim&#x27;</span><br></pre></td></tr></table></figure>

<p>这样定义的别名是临时生效，如果需要永久生效，需要放入环境变量配置文件(~&#x2F;.bashrc)。</p>
<h2 id="1-vim工作模式"><a href="#1-vim工作模式" class="headerlink" title="1. vim工作模式"></a>1. vim工作模式</h2><h3 id="1）命令模式"><a href="#1）命令模式" class="headerlink" title="1）命令模式"></a>1）命令模式</h3><p>主要使用快捷键的模式。</p>
<p>命令模式想要进入输入模式，可以使用以下方式：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>在光标所在字符后插入</td>
</tr>
<tr>
<td>A</td>
<td>在光标所在行尾插入</td>
</tr>
<tr>
<td>i</td>
<td>在光标所在字符前插入</td>
</tr>
<tr>
<td>I</td>
<td>在光标所在行行首插入</td>
</tr>
<tr>
<td>o</td>
<td>在光标下插入新行</td>
</tr>
<tr>
<td>O</td>
<td>在光标上插入新行</td>
</tr>
<tr>
<td>ZZ</td>
<td>保存退出</td>
</tr>
</tbody></table>
<h3 id="2）输入模式"><a href="#2）输入模式" class="headerlink" title="2）输入模式"></a>2）输入模式</h3><p>主要用于文本编辑，和记事本类似，输入数据就好。</p>
<h3 id="3）编辑模式-末行模式"><a href="#3）编辑模式-末行模式" class="headerlink" title="3）编辑模式(末行模式)"></a>3）编辑模式(末行模式)</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:w</td>
<td>保存不退出</td>
</tr>
<tr>
<td>:w 新文件名</td>
<td>把文件另存为新文件</td>
</tr>
<tr>
<td>:q</td>
<td>不保存退出</td>
</tr>
<tr>
<td>:wq</td>
<td>保存退出</td>
</tr>
<tr>
<td>:!</td>
<td>强制</td>
</tr>
<tr>
<td>:q!</td>
<td>强制不保存退出，用于修改文件之后，不保存数据退出</td>
</tr>
<tr>
<td>:wq!</td>
<td>强制保存退出，当文件的所有者或者root用户，对文件没有写权限的时候，强制写入数据使用</td>
</tr>
</tbody></table>
<h2 id="2-命令模式操作"><a href="#2-命令模式操作" class="headerlink" title="2. 命令模式操作"></a>2. 命令模式操作</h2><h3 id="1）移动光标"><a href="#1）移动光标" class="headerlink" title="1）移动光标"></a>1）移动光标</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>上下左右移动光标</td>
<td>上、下、左、右方向键或者k、j、h、l</td>
</tr>
<tr>
<td>移动到文件头</td>
<td>gg</td>
</tr>
<tr>
<td>移动到文件尾</td>
<td>G或者shift+g</td>
</tr>
<tr>
<td>移动到行首</td>
<td>^</td>
</tr>
<tr>
<td>移动到行尾</td>
<td>$</td>
</tr>
<tr>
<td>移动到指定行</td>
<td>:n(这里n是数字，准备移动到第几行，就用哪个数字</td>
</tr>
</tbody></table>
<h3 id="2）删除或剪切"><a href="#2）删除或剪切" class="headerlink" title="2）删除或剪切"></a>2）删除或剪切</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>删除单个字母</td>
<td>x</td>
</tr>
<tr>
<td>删除n个字母</td>
<td>nx</td>
</tr>
<tr>
<td>删除单行</td>
<td>dd</td>
</tr>
<tr>
<td>删除多行</td>
<td>ndd</td>
</tr>
<tr>
<td>删除指定范围的行</td>
<td>:n1,n2d</td>
</tr>
<tr>
<td>粘贴到光标后</td>
<td>p</td>
</tr>
<tr>
<td>粘贴到光标前</td>
<td>P(大)</td>
</tr>
<tr>
<td>从光标所在行删除到文件尾</td>
<td>dG</td>
</tr>
</tbody></table>
<p>删除整行或多行，这是比较常用的删除方法，这里的dd快捷键既是删除，也是剪切。删除内容放入了剪切板，如果不粘贴就是剪切。</p>
<h3 id="3）复制"><a href="#3）复制" class="headerlink" title="3）复制"></a>3）复制</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>复制单行</td>
<td>yy</td>
</tr>
<tr>
<td>复制多行</td>
<td>nyy</td>
</tr>
</tbody></table>
<h3 id="4）撤销"><a href="#4）撤销" class="headerlink" title="4）撤销"></a>4）撤销</h3><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>撤销</td>
<td>u</td>
</tr>
<tr>
<td>反撤销</td>
<td>ctrl+r</td>
</tr>
</tbody></table>
<p>u键能一直撤销到文件打开时的状态，类似Windows下ctrl+z键的作用。</p>
<p>ctrl+z能一直反撤销到最后一次操作状态，类似Windows下ctrl+y键的作用。</p>
<h3 id="5）vim配置文件"><a href="#5）vim配置文件" class="headerlink" title="5）vim配置文件"></a>5）vim配置文件</h3><p>这些末行模式参数设置，多数需要在vim中才能生效。</p>
<table>
<thead>
<tr>
<th>设置参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set nonu</td>
<td>取消行号</td>
</tr>
<tr>
<td>:syntax on</td>
<td>依据语法显示相关的颜色帮助</td>
</tr>
<tr>
<td>:syntax off</td>
<td>不显示语法相关的颜色帮助</td>
</tr>
<tr>
<td>:set hlsearch</td>
<td>设置将查找的字符串高亮显示，默认是set hlsearch高亮显示</td>
</tr>
<tr>
<td>:set nohlsearch</td>
<td>取消将查找的字符串高亮显示</td>
</tr>
<tr>
<td>:set ruler</td>
<td>设置显示右下角的状态栏</td>
</tr>
<tr>
<td>:set noruler</td>
<td>取消显示右下角的状态栏</td>
</tr>
<tr>
<td>:set showmode</td>
<td>设置在左下角显示如“–INSERT–”之类的状态栏，默认是set showmode显示</td>
</tr>
<tr>
<td>:set noshowmode</td>
<td>取消在左下角显示如”–INSERT–”之类的状态栏</td>
</tr>
<tr>
<td>:set list</td>
<td>设置显示隐藏字符(Tab键用”I”表示，回车符用“$”表示)</td>
</tr>
<tr>
<td>:set nolist</td>
<td>设置不显示隐藏字符，默认是nolist</td>
</tr>
<tr>
<td>:set all</td>
<td>查看所有设置参数</td>
</tr>
</tbody></table>
<p>大家会发现，这些设置参数都只是临时生效，一旦关闭文件再打开，又需要重新输入。如果想要永久生效，需要手工建立vim的配置文件”~&#x2F;.vimrc”，把你需要的参数写入配置文件就永久生效了。</p>
<p>Windows下回车符在Linux中是用“^M$”符号显示，而不是”$”符。这样会导致Windows下编辑的程序脚本，无法在Linux中执行。这时可以通过命令”dos2unix”，把Windows格式转为Linux格式，当然反过来”unix2dos”命令就是把Linux格式转为Windows格式。这两个命令默认没有安装，需要手工安装才能使用。</p>
<h3 id="6）查找"><a href="#6）查找" class="headerlink" title="6）查找"></a>6）查找</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;查找内容</td>
<td>从光标所在行向下查找</td>
</tr>
<tr>
<td>?查找内容</td>
<td>从光标所在行向上查找</td>
</tr>
<tr>
<td>n</td>
<td>下一个</td>
</tr>
<tr>
<td>N</td>
<td>上一个</td>
</tr>
</tbody></table>
<h3 id="7）替换"><a href="#7）替换" class="headerlink" title="7）替换"></a>7）替换</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>替换光标所在处的字符</td>
</tr>
<tr>
<td>R</td>
<td>从光标所在处开始替换字符，按ESC结束</td>
</tr>
<tr>
<td>:1,10s&#x2F;old&#x2F;new&#x2F;g</td>
<td>替换1到10行的所有old为new</td>
</tr>
<tr>
<td>:%s&#x2F;old&#x2F;new&#x2F;g</td>
<td>替换整个文件的old为new</td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在shell中“#”开头是注释，批量注释1到10行</span><br><span class="line">:1,10s/^/#/g</span><br><span class="line"></span><br><span class="line"># 取消注释</span><br><span class="line">:1,10s/^#//g</span><br><span class="line"></span><br><span class="line"># 批量添加“//”注释</span><br><span class="line">:1,10s/^/\/\//g</span><br><span class="line"></span><br><span class="line"># 取消注释</span><br><span class="line">:1,10s/^\/\///g</span><br></pre></td></tr></table></figure>



<h2 id="3-vim使用技巧"><a href="#3-vim使用技巧" class="headerlink" title="3. vim使用技巧"></a>3. vim使用技巧</h2><h3 id="1）在vim中导入其他文件内容或命令结果"><a href="#1）在vim中导入其他文件内容或命令结果" class="headerlink" title="1）在vim中导入其他文件内容或命令结果"></a>1）在vim中导入其他文件内容或命令结果</h3><p>a）导入其他文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 把文件内容导入光标下一行</span><br><span class="line">:r 文件名            </span><br></pre></td></tr></table></figure>

<p>可以把其他文件的内容导入到光标下一行位置。</p>
<p>b）在vim中执行系统命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在vim中执行系统命令</span><br><span class="line">:!命令</span><br></pre></td></tr></table></figure>

<p>这里只是在vim中执行系统命令，但并不把系统命令的结果写入到文件中，主要用于在文件编辑中，查看系统信息如时间。</p>
<p>c）导入命令结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在vim中执行系统命令，并把命令结果导入光标下一行</span><br><span class="line">:r !命令</span><br></pre></td></tr></table></figure>



<h3 id="2）设定快捷键"><a href="#2）设定快捷键" class="headerlink" title="2）设定快捷键"></a>2）设定快捷键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 自定义快捷键</span><br><span class="line">:map 快捷键 快捷键执行的命令</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按ctrl+p时，在行首加入注释</span><br><span class="line">:map ^P I#&lt;ESC&gt;</span><br><span class="line"></span><br><span class="line"># 按ctrl+b时，删除行首第一个字母</span><br><span class="line">:map ^B ^x</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：^P快捷键不能手工输入，需要执行ctrl+V+P来定义，或ctrl+v，然后ctrl+p。</p>
<h3 id="3）字符替换"><a href="#3）字符替换" class="headerlink" title="3）字符替换"></a>3）字符替换</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 字符替换</span><br><span class="line">:ab 源字符 替换为字符</span><br></pre></td></tr></table></figure>

<p>在vim编辑中，有时候需要频繁输入某一长字符串(比如邮箱)，这时使用字符串替换，能增加输入效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当碰到“mymail”时，转变为邮箱</span><br><span class="line">:ab mymail ben@163.com</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>“源字符”不应设置的太短，否则有可能影响输入。</p>
<h3 id="4）多文件打开"><a href="#4）多文件打开" class="headerlink" title="4）多文件打开"></a>4）多文件打开</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># vim上下分屏同时打开两个文件</span><br><span class="line">vim -o 文件1 文件2</span><br><span class="line"></span><br><span class="line"># vim左右分屏同时打开两个文件</span><br><span class="line">vim -O 文件1 文件2</span><br></pre></td></tr></table></figure>

<p>这样可以同时打开两个文件，方便操作。可以通过先按”ctrl+w”，再按方向键的方式在两个文件之间切换。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Terraform</title>
    <url>/2025/02/28/Terraform/</url>
    <content><![CDATA[<h2 id="Terraform工作流程"><a href="#Terraform工作流程" class="headerlink" title="Terraform工作流程"></a>Terraform工作流程</h2><p>Terraform是一个基础设施即代码(IaC)工具，通过以下几个步骤来管理基础设施：</p>
<ul>
<li><p>配置文件（.tf文件）</p>
<p>用户首先通过编写Terraform配置文件来定义所需的基础设施。这些文件使用HCL（HashiCorp Configuration Language）语言，描述资源的类型、属性和配置。</p>
</li>
<li><p>初始化（terraform init）</p>
<p>在开始Terraform之前，用户需要运行terraform init命令。这一步会初始化工作目录，下载所需的提供程序(如AWS、Azure等)，并准备后续的操作。</p>
</li>
<li><p>生成执行计划（terraform plan）</p>
<p>使用terraform plan命令，Terraform会读取配置文件并生成执行计划，展示将要执行的操作（如创建、更新或删除资源）。这一步允许用户预览即将进行的变更，避免意外操作。</p>
</li>
<li><p>应用变更（terraform apply）</p>
<p>在确认执行计划后，用户可以运行terraform apply命令，Terraform会根据生成的计划实际执行相应的操作，创建、更新或删除云资源。</p>
</li>
<li><p>状态管理</p>
<p>Terraform会维护一个状态文件（terraform.tfstate），记录当前基础设施的状态。这个文件用于跟踪资源的实际状态，以便在后续操作中进行对比和管理。</p>
</li>
<li><p>变更管理</p>
<p>当需要对基础设施进行更改时，用户只需要修改配置文件，然后重复执行plan和apply流程。Terraform会自动识别资源的变更，并进行相应的更新。</p>
</li>
<li><p>销毁资源（terraform destory）</p>
<p>当不再需要某些资源时，用户可以运行terraform destory命令，Terraform会删除所有配置文件中定义的资源，确保清理工作整洁。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>terraform</category>
      </categories>
  </entry>
  <entry>
    <title>启动引导与修复</title>
    <url>/2025/03/04/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E4%B8%8E%E4%BF%AE%E5%A4%8D/</url>
    <content><![CDATA[<h2 id="系统运行级别"><a href="#系统运行级别" class="headerlink" title="系统运行级别"></a>系统运行级别</h2><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>Linux默认有7个运行级别</p>
<table>
<thead>
<tr>
<th>运行级别</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>关机</td>
</tr>
<tr>
<td>1</td>
<td>单用户模式，可以想象为windows的安全模式，主要用于系统修复</td>
</tr>
<tr>
<td>2</td>
<td>不完全的命令行模式，不含NFS服务</td>
</tr>
<tr>
<td>3</td>
<td>完全的命令行模式，就是标准字符界面</td>
</tr>
<tr>
<td>4</td>
<td>系统保留</td>
</tr>
<tr>
<td>5</td>
<td>图形模式</td>
</tr>
<tr>
<td>6</td>
<td>重启动</td>
</tr>
</tbody></table>
<p>在Linux系统中可以使用runlevel命令来查看系统的运行级别：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">N 5</span><br></pre></td></tr></table></figure>

<p>在这个命令的结果中，”N 5”中的N代表进入这个级别前，上一个级别是什么，5代表当前级别。”N”就是None的意思，也就是说系统是开机直接进入的5运行级别，没有上一个运行级别。那如果是从图形界面切换到字符界面的话，再查看运行级别，应该是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# runlevel</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure>

<p>使用init命令可以手工改变当前的运行级别：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入图形界面，当然要已经安装了图形界面才可以</span></span><br><span class="line">[root@localhost ~]# init 5</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关机</span></span><br><span class="line">[root@localhost ~]# init 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">[root@localhost ~]# init 6</span><br></pre></td></tr></table></figure>

<p>不过要注意使用init命令关机和重启并不是太安全，容易造成数据丢失。所以推荐还是使用shutdown命令进行关机和重启。</p>
<h3 id="系统默认运行级别"><a href="#系统默认运行级别" class="headerlink" title="系统默认运行级别"></a>系统默认运行级别</h3><p>&#x2F;etc&#x2F;init&#x2F;rcS.conf配置文件调用&#x2F;etc&#x2F;inittab配置文件的目的就是为了确定系统的默认运行级别。也就是系统一开机后会进入那个运行级别。</p>
<p>注意这里的默认运行级别只能写成3或5，其的级别要不就是关机重启，要不就是保留或单用户，都不能作为系统默认运行级别。</p>
<h3 id="etc-rc-d-rc-local文件"><a href="#etc-rc-d-rc-local文件" class="headerlink" title="&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件"></a>&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件</h3><p>这个配置文件会在用户登录之前读取，这个文件中写入什么命令，在每次系统启动时都会执行一次。也就是说，如果有任何需要在系统启动就运行的工作，只需要写入&#x2F;etc&#x2F;rc.d&#x2F;rc.local这个配置文件即可。</p>
<h2 id="启动引导程序-Boot-Loader"><a href="#启动引导程序-Boot-Loader" class="headerlink" title="启动引导程序(Boot Loader)"></a>启动引导程序(Boot Loader)</h2><p>早期的Lilo引导程序已经不是很常见了，grub相比有很多优势，主要有：</p>
<ul>
<li>支持更多的文件系统；</li>
<li>grub的主程序可以直接在文件系统中查找内核文件；</li>
<li>在系统启动时，可以利用grub的交互界面编辑和修改启动选项；</li>
<li>可以动态的修改grub的配置文件，这样在修改配置文件之后不需要重新安装grub，而只需要重新启动就可以生效了。</li>
</ul>
<p>a）&#x2F;boot&#x2F;grub目录</p>
<p>grub的作用有以下几个：</p>
<ul>
<li>加载操作系统的内核。</li>
<li>拥有一个可以让用户选择的菜单，来选择到底启动哪个系统。</li>
<li>还可以调用其他的启动引导程序，来实现多系统引导。</li>
</ul>
<p>grub的配置文件主要是放置在&#x2F;boot&#x2F;grub&#x2F;目录中的。其实这个目录中主要就是grub的配置文件和各种文件系统的stage1.5文件。不过grub的配置文件有两个&#x2F;boot&#x2F;grub&#x2F;grub.conf和&#x2F;boot&#x2F;grub&#x2F;menu.lst，这两个配置文件是软链接，所以修改哪一个都可以，个人习惯改grub.conf。</p>
<p>b）grub的配置文件</p>
<p>在grub中分区的表示方法</p>
<table>
<thead>
<tr>
<th>硬盘</th>
<th>分区</th>
<th>Linux中设备文件名</th>
<th>grub中设备文件名</th>
</tr>
</thead>
<tbody><tr>
<td>第一块SCSI硬盘</td>
<td>第一个主分区</td>
<td>&#x2F;dev&#x2F;sda1</td>
<td>hd(0,0)</td>
</tr>
<tr>
<td></td>
<td>第二个主分区</td>
<td>&#x2F;dev&#x2F;sda2</td>
<td>hd(0,1)</td>
</tr>
<tr>
<td></td>
<td>扩展分区</td>
<td>&#x2F;dev&#x2F;sda3</td>
<td>hd(0,2)</td>
</tr>
<tr>
<td></td>
<td>第一个逻辑分区</td>
<td>&#x2F;dev&#x2F;sda5</td>
<td>hd(0,4)</td>
</tr>
<tr>
<td>第二块SCSI硬盘</td>
<td>第一个主分区</td>
<td>&#x2F;dev&#x2F;sdb1</td>
<td>hd(1,0)</td>
</tr>
<tr>
<td></td>
<td>第二个主分区</td>
<td>&#x2F;dev&#x2F;sdb2</td>
<td>hd(1,1)</td>
</tr>
<tr>
<td></td>
<td>扩展分区</td>
<td>&#x2F;dev&#x2F;sdb3</td>
<td>hd(1,2)</td>
</tr>
<tr>
<td></td>
<td>第一个逻辑分区</td>
<td>&#x2F;dev&#x2F;sdb5</td>
<td>hd(1,4)</td>
</tr>
</tbody></table>
<p>grub的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">		root (hd0,0)</span><br><span class="line">		kernel				/vmlinuz-2.6.32-279.el6.i686			ro		root=UUID=b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS	KEYBOARDTYPE=pc	KEYTABLE=us rd_NO_MD crashkernel=auto LANG=zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</span><br><span class="line">		initrd	/initramfs-2.6.32-279.el6.i686.img</span><br></pre></td></tr></table></figure>

<ul>
<li><p>default&#x3D;0</p>
<p>默认启动第一个系统。也就是如蛤在等待时间结束后，用户没有选择进入哪一个系统，那么系统会默认进入第一个系统。如果有多系统并存，那么每个系统都会有自己的titile字段，如果想要默认进入第二个系统，可以设为default&#x3D;1。</p>
</li>
<li><p>timeout&#x3D;5</p>
<p>等待时间，默认是5秒。也就是进入系统时，如果5秒内用户没有按下任意键，那么系统会进入default字段定义的系统。当然可以手工修改这个等待时间，如果timeout&#x3D;0则不会等待直接进入系统，timeout&#x3D;-1则是一直等待用户输入，而不会自动进入系统。</p>
</li>
<li><p>splashimage&#x3D;(hd0,0)&#x2F;grub&#x2F;splash.xpm.gz</p>
<p>这里是指定grub启动时的背景图像文件的保存位置。hd(0,0)代表第一个硬盘的第一个分区。</p>
</li>
<li><p>hiddenmenu</p>
<p>隐藏菜单。启动时默认只能看到读秒，而不能看到菜单，如果想要看到菜单需要按任意键。如果注释了这句话，那么启动时就能直接看到菜单了。</p>
</li>
</ul>
<p>Centos系统的启动配置：</p>
<ul>
<li><p>title Centos (2.6.32-279.el6.i686)</p>
<p>title就是标题的意思，也就是说在title后面写入的是什么，那么系统启动时在grub的启动菜单中看到的就是什么。</p>
</li>
<li><p>root (hd0,0)</p>
<p>是指启动程序的保存分区。这个root并不是管理员。在我的系统中，&#x2F;boot分区是独立划分的，而且设备文件名为&#x2F;dev&#x2F;sda1，所以在grub中，就被描述为hd（0,0）。</p>
</li>
<li><p>kernel				&#x2F;vmlinuz-2.6.32-279.el6.i686			ro		root&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS	KEYBOARDTYPE&#x3D;pc	KEYTABLE&#x3D;us rd_NO_MD crashkernel&#x3D;auto LANG&#x3D;zh_CN.UTF-8 rd_NO_LVM rd_NO_DM rhgb quiet</p>
<ul>
<li><p>&#x2F;vmlinuz-2.6.32-279.el6.i686</p>
<p>指定了内核文件的位置，这里的&#x2F;是指&#x2F;boot分区。</p>
</li>
<li><p>ro</p>
<p>启动时以只读方式挂载根文件系统，这是为了不让启动过程影响磁盘内的文件系统。</p>
</li>
<li><p>root&#x3D;UUID&#x3D;b9a7a1a8-767f-4a87-8a2b-a535edb362c9 rd_NO_LUKS</p>
<p>指定根文件系统所在位置。</p>
</li>
<li><p>rd_NO_LUKS</p>
<p>禁用LUKS，LUKS用于给磁盘加密。</p>
</li>
<li><p>rd_NO_MD</p>
<p>禁用软RAID</p>
</li>
<li><p>rd_NO_DM</p>
<p>禁用硬RAID</p>
</li>
<li><p>rd_NO_LVM</p>
<p>禁用LVM。以上禁用都只是在启动过程中禁用，是为加速系统启动的。</p>
</li>
<li><p>KEYBOARDTYPE&#x3D;pc    KEYTABLE&#x3D;us</p>
<p>键盘类型</p>
</li>
<li><p>crashkernel&#x3D;auto</p>
<p>自动为crashkernel预留内存</p>
</li>
<li><p>LANG&#x3D;zh_CN.UTF-8</p>
<p>语言环境</p>
</li>
<li><p>rhgb</p>
<p>（redhat graphics boot）用图片来代替启动过程中的文字信息。启动完成之后可以使用dmesg命令来查看这些文字信息。</p>
</li>
<li><p>quiet</p>
<p>隐藏启动信息，只显示重要信息。</p>
</li>
<li><p>initrd    &#x2F;initramfs-2.6.32-279.el6.i686.img</p>
<p>指定了initramfs内存文件系统镜像文件的所在位置。</p>
</li>
</ul>
</li>
</ul>
<p>grub加密</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grub-mkpasswd-pbkdf2</span><br><span class="line">输入密码： </span><br><span class="line">重新输入口令： </span><br><span class="line">您的密码的 PBKDF2 哈希为 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br></pre></td></tr></table></figure>

<p>这样就可以生成加密密码字串，这个字串是采用md5加密的，就是你的密码经md5编码之后的。</p>
<p>grub菜单整体加密</p>
<p>如果只是加密单个启动菜单，grub的编辑模式是不能锁定的，还是可以按“e”键进入编辑模式。而且进入编辑模式后，是可以删除password字段的，再按“b”（boot启动）键就可以不用密码直接进入系统。这时就需要给grub菜单整体加密了，整体加密后，如果想进入grub编辑界面必须输入正确的密码。加密方法其实只是把password字段换个位置而已。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout=5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但是这样加密，启动CentOS时，是不需要密码就能正常启动的。如果需要grub整体加密，又需要系统启动时输入正确的密码时，则需：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /boot/grub/grub.conf</span><br><span class="line">default=0</span><br><span class="line">timeout-5</span><br><span class="line">password --md5 grub.pbkdf2.sha512.10000.E71038F43B0B8C0F0EE05B6BA49AA7D8EB87EB3D4293A9A0A97DD81FBC773BBCB8A268A833245C687C8D6C6F352A4E5E0C77C1BC78A956C7FBBB0B8DAC1F0BC8.3CF79D7B2F0F6BEC4BF54D0D7D8A7F9B9B5CC2BE1609BFC33ADB08EC0372276B555D051AAD5ECA95B92E92CAC12FC0BCFD574A50E69ABA74A1BA214A729EBC80</span><br><span class="line">splashimage=(hd0,0)/grub/splash.xmp.gz</span><br><span class="line">hiddenmenu</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以上为grub整体设置</span></span><br><span class="line">title Centos6 (2.6.32-279.el6.i686)</span><br><span class="line">		lock</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<p>在title字段加入lock。代表锁死，如果不输入正确的grub密码也不能启动。</p>
<h2 id="系统修复模式"><a href="#系统修复模式" class="headerlink" title="系统修复模式"></a>系统修复模式</h2><h3 id="单用户模式"><a href="#单用户模式" class="headerlink" title="单用户模式"></a>单用户模式</h3><p>Linux的单用户模式有些类似Windows的安全模式，只启动最少的程序用于系统修复。在单用户模式(运行级别为1)中，Linux引导进入根shell，网络被禁用，只有少数进程运行。单用户模式可以用来修改文件系统损坏、还原配置文件、移动用户数据等。</p>
<p>a）进入单用户模式</p>
<p>开机进入引导界面，按“e”进入。</p>
<p>b）单用户模式常见的错误修复</p>
<ul>
<li><p>遗忘root密码</p>
<p>进入单用户模式最大的特点就是不需要输入用户名和密码就能登录。既然已经登录了单用户模式，那么直接给root用户设定新密码即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost /]# passwd root</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改系统默认运行级别</p>
<p>如果把系统的默认运行级别修改错误，比如改为了0或6，系统就不能正常启动了。这时也可以利用单用户模式进行修复，只要直接修改默认运行级别配置文件&#x2F;etc&#x2F;inittab，把系统默认运行级别修改回来即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/inittab</span><br><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure>

<p>绝大多数系统错误都可以通过单用户模式进行修复，理论上是只要能够进入单用户模式，那么系统错误就可以被单用户模式修复。当然意判断系统到底是哪里出现了问题，是需要不断地经验积累。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>文件系统管理</title>
    <url>/2025/02/25/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h1><h2 id="1-硬盘结构"><a href="#1-硬盘结构" class="headerlink" title="1. 硬盘结构"></a>1. 硬盘结构</h2><h3 id="1）硬盘的逻辑结构"><a href="#1）硬盘的逻辑结构" class="headerlink" title="1）硬盘的逻辑结构"></a>1）硬盘的逻辑结构</h3><p>每个扇区的大小是固定的，为512Byte。扇区也是磁盘的最小存储单位。</p>
<p>硬盘的大小是用”磁头数X柱面数X扇区数X每个扇区的大小”这样的公式来计算的。其中磁头数(Heads)表示硬盘总共有几个磁头，也可以理解成硬盘有几个盘面，然后乘以2；柱面数(Cylinders)表示硬盘每一面盘片有几条磁道；扇区数(Sectors)表示每条磁道上有几个扇区；每个扇区的大小一般是512Byte。</p>
<h3 id="2）硬盘接口"><a href="#2）硬盘接口" class="headerlink" title="2）硬盘接口"></a>2）硬盘接口</h3><ul>
<li><p>IDE硬盘接口(Integrated Drive Electronics，并口，即电子集成驱动器)</p>
<p>也称作”ATA硬盘”或”PATA硬盘”，是早期机械硬盘的主要接口，ATA133硬盘的理论速度可以达到133MB&#x2F;s(此速度为理论平均值)。</p>
</li>
<li><p>SATA接口(Serial ATA，串口)</p>
<p>是速度更高的硬盘标准，具备了更高的传输速度，并具备了更强的纠错能力。目前已经是SATA三代，理论传输速度达到600MB&#x2F;s(此速度为理论平均值)。</p>
</li>
<li><p>SCSI接口(Small Computer System Interface，小型计算机系统接口)广泛用在服务器上，具有应用范围广、多任务、带宽大、CPU占用率低及支持执插拔等优点，理论传输速度达到320MB&#x2F;s。</p>
</li>
</ul>
<h2 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2. 文件系统"></a>2. 文件系统</h2><h3 id="1）Linux文件系统的特性"><a href="#1）Linux文件系统的特性" class="headerlink" title="1）Linux文件系统的特性"></a>1）Linux文件系统的特性</h3><ul>
<li><p>super block（超级块）</p>
<p>记录整个文件系统的信息，包括：</p>
<ul>
<li>block与inode的总量</li>
<li>已经使用的inode和block的数量</li>
<li>未使用的inode和block的数量</li>
<li>block与inode的大小</li>
<li>文件系统的挂载时间</li>
<li>最近一次的写入时间</li>
<li>最近一次的磁盘检验时间等</li>
</ul>
</li>
<li><p>data block（数据块，也称作block）</p>
<p>用来实际保存数据的，block的大小(1KB|2KB|4KB)和数量在格式化后就已经决定，不能改变，除非重新格式化。每个block只能保存一个文件的数据，要是文件数据小于一个block块，那么这个block的剩余空间不能被其他文件使用；要是文件数据大于一个block块，则占用多个block块。Windows中磁盘碎片整理工具的原理就是把一个文件占用的多个block块尽量整理到一起，这样可以加快读写速度。</p>
</li>
<li><p>inode（i节点）</p>
<p>用来记录文件的权限(r、w、x)，文件的所有者和属组，文件的大小，文件的状态改变时间(ctime)，文件的最近一次读取时间(atime)，文件的最近一次修改时间(mtime)，文件的数据真正保存的block编号。每个文件需要占一个inode。</p>
</li>
</ul>
<h3 id="2）Linux常见文件系统"><a href="#2）Linux常见文件系统" class="headerlink" title="2）Linux常见文件系统"></a>2）Linux常见文件系统</h3><table>
<thead>
<tr>
<th>文件系统</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ext</td>
<td>Linux中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用。</td>
</tr>
<tr>
<td>ext2</td>
<td>是ext文件系统的升级版本，Red Hat Linux 7.2版本以前的系统默认都是ext2文件系统。于1993年发布，支持最大16TB的分区和最大2TB的文件</td>
</tr>
<tr>
<td>ext3</td>
<td>是ext2文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大16TB的分区和最大2TB的文件</td>
</tr>
<tr>
<td>ext4</td>
<td>是ext3文件系统的升级版。ext4在性能、伸缩性和可靠性方面进行了大量改进。ext4的变化可以说是翻天覆地的，比如向下兼容ext3、最大1EB文件系统和16TB文件、无限数量子目录、Extents连续数据块概念、多块分配、延迟分配、持久分配、快速FSCK、日志校验、无日志模式、在线碎片整理、inode增强、默认启用barrier等。它是CentOS 6.x的默认文件系统</td>
</tr>
<tr>
<td>xfs</td>
<td>XFS最早针对IRIX操作系统开发，是一个高性能的日志型文件系统，能够在断电以及操作系统崩溃的情况下保证文件系统数据的一致性。它是一个64位的文件系统，后来进行开源并且移植到了Linux操作系统中，目前CentOS 7.x将XFS+LVM作为默认的文件系统，据官方所称，XFS对于大文件的读写性能较好。</td>
</tr>
<tr>
<td>swap</td>
<td>swap是Linux中用于交换分区的文件系统(类似于Windows中的虚拟内存)，当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的2倍，但不要超2GB。它是Linux的必需分区。</td>
</tr>
<tr>
<td>NFS</td>
<td>NFS是网络文件系统(Network File System)的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源</td>
</tr>
<tr>
<td>ISO9660</td>
<td>光盘的标准文件系统，Linux要想使用光盘，必须支持iso9660文件系统</td>
</tr>
<tr>
<td>fat</td>
<td>就是Windows下的fat16文件系统，在Linux中识别为fat</td>
</tr>
<tr>
<td>vfat</td>
<td>就是Windows下的fat32文件系统，在Linux中识别为vfat。支持最大32GB的分区和最大4GB的文件。</td>
</tr>
<tr>
<td>NTFS</td>
<td>就是Windows下的NTFS文件系统，不过Linux默认是不能识别NTFS文件系统的，如果需要识别，则需要重新编译内核才能支持。它比fat32文件系统更加安全，速度更快，支持最大2TB的分区和最大64GB的文件。</td>
</tr>
</tbody></table>
<h2 id="3-常用的硬盘管理命令"><a href="#3-常用的硬盘管理命令" class="headerlink" title="3. 常用的硬盘管理命令"></a>3. 常用的硬盘管理命令</h2><h3 id="1）df命令"><a href="#1）df命令" class="headerlink" title="1）df命令"></a>1）df命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -ahT</span><br><span class="line">选项：</span><br><span class="line">  -a:    显示特殊文件系统，这些文件系统几乎都是保存在内存中的。如/proc,因为挂载在内存中，所以占用量都是0</span><br><span class="line">  -h:    单位不是只用KB，而是换算成习惯单位</span><br><span class="line">  -T:    多出了文件系统类型一列</span><br></pre></td></tr></table></figure>



<h3 id="2）du命令"><a href="#2）du命令" class="headerlink" title="2）du命令"></a>2）du命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# du [选项] [目录或文件名]</span><br><span class="line">选项：</span><br><span class="line">  -a 显示每个子文件的磁盘占用量。默认只统计子目录的磁盘占用量</span><br><span class="line">  -h 使用习惯单位显示磁盘占用量，如KB，MB或GB等</span><br><span class="line">  -s 统计总占用量，而不列出子目录和子文件的占用量</span><br></pre></td></tr></table></figure>

<p>du与df的区别：du是用于统计文件大小的，统计的文件大小是准确的；df是用于统计空间大小的，统计的剩余空间是准确的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# df -Th</span><br><span class="line">文件系统        类型      大小  已用  可用 已用% 挂载点</span><br><span class="line">tmpfs           tmpfs     687M  2.5M  685M    1% /run</span><br><span class="line">/dev/nvme0n1p10 ext4      187G  144G   34G   82% /</span><br><span class="line">tmpfs           tmpfs     3.4G  5.4M  3.4G    1% /dev/shm</span><br><span class="line">tmpfs           tmpfs     5.0M   12K  5.0M    1% /run/lock</span><br><span class="line">efivarfs        efivarfs  148K  112K   32K   79% /sys/firmware/efi/efivars</span><br><span class="line">/dev/nvme0n1p1  vfat       96M   53M   44M   56% /boot/efi</span><br><span class="line">tmpfs           tmpfs     687M  172K  687M    1% /run/user/1000</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# du -sh /</span><br><span class="line">113G	/</span><br></pre></td></tr></table></figure>

<p>df和du统计的根目录大小有差异，是因为du统计的是根目录文件大小，df统计的不仅只有根目录文件大小，还有临时文件的大小。</p>
<h3 id="3）fsck文件系统修复命令"><a href="#3）fsck文件系统修复命令" class="headerlink" title="3）fsck文件系统修复命令"></a>3）fsck文件系统修复命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fsck -y 分区                  # 开机重启自动修复</span><br></pre></td></tr></table></figure>



<h3 id="4）显示磁盘状态"><a href="#4）显示磁盘状态" class="headerlink" title="4）显示磁盘状态"></a>4）显示磁盘状态</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs -h 分区</span><br></pre></td></tr></table></figure>



<h3 id="5）查看文件的详细时间"><a href="#5）查看文件的详细时间" class="headerlink" title="5）查看文件的详细时间"></a>5）查看文件的详细时间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# stat 文件名</span><br></pre></td></tr></table></figure>



<h3 id="6）判断文件类型"><a href="#6）判断文件类型" class="headerlink" title="6）判断文件类型"></a>6）判断文件类型</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# file 文件名</span><br></pre></td></tr></table></figure>



<h3 id="7）判断命令类型"><a href="#7）判断命令类型" class="headerlink" title="7）判断命令类型"></a>7）判断命令类型</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# type 命令名</span><br></pre></td></tr></table></figure>



<h2 id="4-fdisk命令手工分区"><a href="#4-fdisk命令手工分区" class="headerlink" title="4. fdisk命令手工分区"></a>4. fdisk命令手工分区</h2><h3 id="1）查看系统所有硬盘及分区"><a href="#1）查看系统所有硬盘及分区" class="headerlink" title="1）查看系统所有硬盘及分区"></a>1）查看系统所有硬盘及分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk -l</span><br></pre></td></tr></table></figure>



<h3 id="2）磁盘分区"><a href="#2）磁盘分区" class="headerlink" title="2）磁盘分区"></a>2）磁盘分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk 磁盘</span><br></pre></td></tr></table></figure>

<p>fdisk交互指令说明：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>设置可引导标记</td>
</tr>
<tr>
<td>b</td>
<td>编辑bsd磁盘标签</td>
</tr>
<tr>
<td>c</td>
<td>设置DOS操作系统兼容标记</td>
</tr>
<tr>
<td>d</td>
<td>删除一个分区</td>
</tr>
<tr>
<td>l</td>
<td>显示已知的文件系统类型。82为Linux swap分区，83为Linux分区</td>
</tr>
<tr>
<td>m</td>
<td>显示帮助菜单</td>
</tr>
<tr>
<td>n</td>
<td>新建分区</td>
</tr>
<tr>
<td>o</td>
<td>建立空白DOS分区表</td>
</tr>
<tr>
<td>p</td>
<td>显示分区列表</td>
</tr>
<tr>
<td>q</td>
<td>不保存退出</td>
</tr>
<tr>
<td>s</td>
<td>新建空白SUN磁盘标签</td>
</tr>
<tr>
<td>t</td>
<td>改变一个分区的系统ID</td>
</tr>
<tr>
<td>u</td>
<td>改变显示记录单位</td>
</tr>
<tr>
<td>v</td>
<td>验证分区表</td>
</tr>
<tr>
<td>w</td>
<td>保存退出</td>
</tr>
<tr>
<td>x</td>
<td>附加功能</td>
</tr>
</tbody></table>
<p>新建主分区：n—p—1—1分区号—分区大小+100M—w</p>
<p>新建扩展分区：n—e—2分区号—124起始柱面—1024柱面(所有剩余空间都分配给扩展分区)</p>
<p>新建逻辑分区：n—l—不用指定分区号—124起始柱面—+100M(指定大小)—w</p>
<h3 id="3）格式化"><a href="#3）格式化" class="headerlink" title="3）格式化"></a>3）格式化</h3><p>a）mkfs</p>
<p>mkfs命令非常简单易用，不过是不能调整分区的默认参数的（比如块大小是4096），这些默认参数除非特殊情况，否则不能调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t 文件系统类型 分区</span><br></pre></td></tr></table></figure>



<p>b）mke2fs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mke2fs [选项] 分区</span><br><span class="line">[选项]：</span><br><span class="line">  -t 文件系统：    指定格式化成哪个文件系统，如ext4, xfs</span><br><span class="line">  -b 字节:        指定block块的大小</span><br><span class="line">  -i 字切:        指定&quot;字节/inode&quot;的比例，也就是多少个字节分配一个inode</span><br><span class="line">  -j：            建立带有ext3日志功能的文件系统</span><br><span class="line">  -L 卷标名:      给文件系统设置卷标名，就不使用e2label命令设定了</span><br></pre></td></tr></table></figure>



<h3 id="4）建立挂载点"><a href="#4）建立挂载点" class="headerlink" title="4）建立挂载点"></a>4）建立挂载点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkdir /disk1</span><br></pre></td></tr></table></figure>



<h3 id="5）挂载"><a href="#5）挂载" class="headerlink" title="5）挂载"></a>5）挂载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mount 分区 挂载点</span><br></pre></td></tr></table></figure>



<h3 id="6）查看"><a href="#6）查看" class="headerlink" title="6）查看"></a>6）查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有已经挂载的分区和光盘</span><br><span class="line">[root@localhost ~]# mount</span><br><span class="line"></span><br><span class="line"># 查看系统分区</span><br><span class="line">[root@localhost ~]# fdisk -l</span><br><span class="line"></span><br><span class="line"># 查看分区占用百分比</span><br><span class="line">[root@Loaclhost ~]# df -Th</span><br></pre></td></tr></table></figure>



<h3 id="7）自动挂载"><a href="#7）自动挂载" class="headerlink" title="7）自动挂载"></a>7）自动挂载</h3><p>修改分区自动挂载文件(&#x2F;etc&#x2F;fstab)。此文件直接参与系统启动，如果修改错误，系统启动报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1              /disk1               ext4            defaults            1                  2</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：设备文件名</li>
<li>第二列：挂载点</li>
<li>第三列：文件系统</li>
<li>第四列：挂载选项</li>
<li>第五列：是否可以被备份。0（不备份） 1（每天备份） 2（不定期备份）</li>
<li>第六列：是否检测磁盘。0（不检测） 1（启动时检测） 2（启动后检测）</li>
</ul>
<p>也可以使用UUID进行挂载，UUID（硬盘通用唯一识别码，可以理解为硬盘的ID）。</p>
<ul>
<li>这个字段在CentOS 5.5的系统当中是写入分区的卷标名或分区设备文件名的，现在变更成硬盘的UUID。这样做的好处是当硬盘增加了新的分区，或者分区的顺序改变，再或者内核升级后，仍然能够保证分区能够正确的加载，而不至于造成启动障碍。</li>
<li>dumpe2fs命令可以查看磁盘状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# dumpe2fs /dev/sdb5</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ls -l /dev/disk/by-uuid/</span><br></pre></td></tr></table></figure>



<h3 id="8）重启测试"><a href="#8）重启测试" class="headerlink" title="8）重启测试"></a>8）重启测试</h3><p>或者使用”mount -a”重新挂载所有内容，用它进行测试。</p>
<h2 id="5-etc-fstab文件修复"><a href="#5-etc-fstab文件修复" class="headerlink" title="5. &#x2F;etc&#x2F;fstab文件修复"></a>5. &#x2F;etc&#x2F;fstab文件修复</h2><ul>
<li><p>服务器连接显示器输入root密码登录系统。</p>
</li>
<li><p>此时根目录为只读文件系统，需要重新挂载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,rw /</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;fstab文件内容至正确。</p>
</li>
<li><p>重启服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# reboot</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-parted命令分区"><a href="#6-parted命令分区" class="headerlink" title="6 parted命令分区"></a>6 parted命令分区</h2><p>Linux系统中有两种常见的分区表：</p>
<ul>
<li><p>MBR分区表（主引导记录分区表）</p>
<p>支持的最大分区是2TB，最多支持4个主分区，或3个主分区1个扩展分区。</p>
</li>
<li><p>GPT分区表（GUID分区表）</p>
<p>支持最大18EB分区，最多支持128个分区，其中1个系统保留分区，127个用户自定义分区。</p>
</li>
</ul>
<p>不过parted命令也有点小问题，就是命令自身分区的时候只能格式化成ext2文件系统，不支持ext3和ext4文件系统。不过这没有太多的影响，因为我们可以先分区再用mkfs进行格式化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# parted 硬盘</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>parted交互命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>check NUMBER</td>
<td>做一次简单的文件系统检测</td>
</tr>
<tr>
<td>cp [FROM-DEVICE] FROM-NUMBER TO NUMBER</td>
<td>复制文件系统到另一个分区</td>
</tr>
<tr>
<td>help [COMMAND]</td>
<td>显示所有的命令帮助</td>
</tr>
<tr>
<td>mklabel,mktable LABEL-TYPE</td>
<td>创建新的磁盘卷标(分区表)</td>
</tr>
<tr>
<td>mkfs NUMBER FS-TYPE</td>
<td>在分区上建立文件系统</td>
</tr>
<tr>
<td>mkpart PART-TYPE [FS-TYPE] START END</td>
<td>创建一个分区</td>
</tr>
<tr>
<td>mkpartfs PART-TYPE FS-TYPE START END</td>
<td>创建分区，并建立文件系统</td>
</tr>
<tr>
<td>move NUMBER START END</td>
<td>移动分区</td>
</tr>
<tr>
<td>name NUMBER NAME</td>
<td>给分区命名</td>
</tr>
<tr>
<td>print [devices|free|list,all|NUMBER]</td>
<td>显示分区表，活动设备，空闲空间，所有分区</td>
</tr>
<tr>
<td>quit</td>
<td>退出</td>
</tr>
<tr>
<td>rescue START END</td>
<td>修复丢失的分区</td>
</tr>
<tr>
<td>resize NUMBER START END</td>
<td>修改分区大小</td>
</tr>
<tr>
<td>rm NUMBER</td>
<td>删除分区</td>
</tr>
<tr>
<td>select DEVICE</td>
<td>选择需要编辑的设备</td>
</tr>
<tr>
<td>set NUMBER FLAG STATE</td>
<td>改变分区标记</td>
</tr>
<tr>
<td>toggle [NUMBER [FLAG]]</td>
<td>切换分区表的状态</td>
</tr>
<tr>
<td>unit UNIT</td>
<td>设置默认的单位</td>
</tr>
<tr>
<td>Version</td>
<td>显示版本</td>
</tr>
</tbody></table>
<h3 id="1）查看分区"><a href="#1）查看分区" class="headerlink" title="1）查看分区"></a>1）查看分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">(parted) print                                 # 输入print指令</span><br><span class="line">Model： VMware, VMware Virtual S（scsi）        # 硬盘参数</span><br><span class="line">Disk /dev/sdb：21.5GB                           # 硬盘大小</span><br><span class="line">Sector size (logical/physical)：512B/512B       # 扇区大小</span><br><span class="line">Partition Table：msdos                          # 分区表类型，就是MBR分区表</span><br><span class="line">Number      Start    End     Size    Type    File system    标志</span><br><span class="line">1           32.3kB   5379MB  5379MB   primary</span><br></pre></td></tr></table></figure>

<h3 id="2）修改成GPT分区表"><a href="#2）修改成GPT分区表" class="headerlink" title="2）修改成GPT分区表"></a>2）修改成GPT分区表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">（parted）mklabel gpt</span><br><span class="line">警告：正在使用/dev/sdb上的分区                            # 由于/dev/sdb分区已经挂载，所以有警告</span><br><span class="line"></span><br><span class="line">忽略/Ingore/放弃/Cancel? ignore                         # 输入ignore忽略报错</span><br><span class="line">警告：The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost, Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes                                       # 输入yes</span><br><span class="line">警告：WARNING：the kernel failed to re-read the partition table on /dev/sdb（设备或资源忙）. As a result,it may not reflect all of your changes until after reboot.                        # 下次重启后，才能生效</span><br><span class="line"></span><br><span class="line">（parted）print                                          # 查看分区表</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt                                     # 分区表已经变成GPT</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志          # 所有的分区都消失了</span><br></pre></td></tr></table></figure>

<p>修改了分区表，如果这块硬盘已经有分区了，那么原有分区和分区中的数据都会消失，而且需要重启系统才会生效。</p>
<p>转换分区表的目的是为了支持大于2TB的分区，如果分区并没有大于2TB，那么这步是可以不执行的。</p>
<p>**注意：**一定要把&#x2F;etc&#x2F;fstab文件中和原有分区的内容删除掉，才能重启，不然系统重启一定会报错。</p>
<h3 id="3）建立分区"><a href="#3）建立分区" class="headerlink" title="3）建立分区"></a>3）建立分区</h3><p>因为修改过分区表，所以&#x2F;dev&#x2F;sdb中的所有数据丢失了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# parted /dev/sdb</span><br><span class="line">（parted）mkpart                                    # 输入创建分区命令</span><br><span class="line">分区名称?  []? disk1                                 # 分区名称</span><br><span class="line">文件系统类型？  [ext2]?                               # 文件系统类型，直接回车，使用默认ext2</span><br><span class="line">起始点? 1MB                                          # 分区从1MB开始</span><br><span class="line">结束点? 5GB                                          # 分区到5GB结束</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br><span class="line">1         1049kB   5000MB  4999MB                disk1</span><br></pre></td></tr></table></figure>



<h3 id="4）建立文件系统"><a href="#4）建立文件系统" class="headerlink" title="4）建立文件系统"></a>4）建立文件系统</h3><p>分区分完了，还需要格式化。不过如果使用parted交互命令格式化的话，只能格式化成ext2文件系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（parted）mkfs</span><br><span class="line">WARNING：you are attempting to use parted to operate on （mkfs） a file system. parted&#x27;s file system manipulation code is not as rebust as what you&#x27;ll find in dedicated, file-system-specific packages like e2fsprogs. We recommand you use parted only to manipulate partition tables, whenever possible. Support for performing most operations on most types of file systems will be removed in an upcoming release.</span><br><span class="line">警告：The existing file system will be destoryed and all data on the partition will be lost.</span><br><span class="line">Do you want to continue?</span><br><span class="line">是/Yes/否/No? yes                                # 警告你格式化数据会丢失</span><br><span class="line">分区编号? 1</span><br><span class="line">文件系统类型?  [ext2]?                             # 指定文件系统类型</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br><span class="line">1         1049kB   5000MB  4999MB    ext2        disk1</span><br></pre></td></tr></table></figure>

<p>如果要格式化成ext4文件系统，需要使用Linux的mkfs命令。</p>
<h3 id="5）删除分区"><a href="#5）删除分区" class="headerlink" title="5）删除分区"></a>5）删除分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(parted) rm                                     # 删除分区命令</span><br><span class="line">分区编号? 1                                      # 指定分区号</span><br><span class="line">(parted) print                                      # 查看分区</span><br><span class="line">Model：VMware, VMware Virtual S （scsi）</span><br><span class="line">Disk /dev/sdb：21.5GB</span><br><span class="line">Sector size （logical/physical）：512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line"></span><br><span class="line">Number    Start    End    Size    File system    Name    标志</span><br></pre></td></tr></table></figure>

<p>parted中的所有操作都是立即生效，没有保存生效的概念，这点和fdisk交互命令明显不同。</p>
<p>至于到底使用fdisk还是parted进行分区？推荐分区大小小于2GB，使用fdisk分区；分区大小大于2GB，使用parted分区。 </p>
<h2 id="7-swap分区"><a href="#7-swap分区" class="headerlink" title="7. swap分区"></a>7. swap分区</h2><h3 id="1）分区"><a href="#1）分区" class="headerlink" title="1）分区"></a>1）分区</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fdisk /dev/sdb</span><br><span class="line">Command (m for help): t                               # 修改分区的系统id</span><br><span class="line">Selected partition 1                                  # 选择分区</span><br><span class="line">Hex code (type L to list codes)：82                    # 改为swap的id</span><br><span class="line">Changed system type of partition 1 to 82 (Linux swap / Solaris)</span><br></pre></td></tr></table></figure>



<h3 id="2）格式化"><a href="#2）格式化" class="headerlink" title="2）格式化"></a>2）格式化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkswap /dev/sdb1</span><br><span class="line">Setting up swapspace version 1, size = 522076 KiB</span><br><span class="line">no label, UUID=C3351dc3-f403-419a-9666-c24615e170fb</span><br></pre></td></tr></table></figure>



<h3 id="3）挂载"><a href="#3）挂载" class="headerlink" title="3）挂载"></a>3）挂载</h3><p>swap空间支持扩容。扩容也使用swapon命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# swapon /dev/sdb1</span><br></pre></td></tr></table></figure>

<p>开机自动挂载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1      swap      swap      defaults      0      0</span><br></pre></td></tr></table></figure>

<p>也可以使用uuid。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>服务管理</title>
    <url>/2025/03/05/%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="服务的简介与分类"><a href="#服务的简介与分类" class="headerlink" title="服务的简介与分类"></a>服务的简介与分类</h2><h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><p>Linux服务：</p>
<ul>
<li><p>RPM包默认安装的服务</p>
<ul>
<li><p>独立的服务</p>
<p>就是独立启动的意思，这类型的服务可以自行启动，而不用依赖其他的管理服务。不依赖其他管理服务，那么当客户端请求访问时，独立的服务响应请求更迅速。Linux中目前大多数服务都是独立的服务，比如apache服务，FTP服务，Samba服务等。</p>
</li>
<li><p>基于xinetd服务</p>
<p>这种服务就不能独立启动了，而是要依靠管理服务来调用这种服务。这个负责管理的服务就是xinetd服务，xinetd服务是系统的超级守护进程。xinetd服务的作用就是管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务云唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释放资源。这样做的好处是只需要持续启动xinetd服务，而其他基于xinetd的服务只有在需要时才启动，不会占用过多的服务器资源。但是这种服务由于在有客户端靖求时才会被唤醒，所以响应时间相对较慢。</p>
</li>
</ul>
</li>
<li><p>源码包安装的服务</p>
</li>
</ul>
<h3 id="查询已经安装的服务"><a href="#查询已经安装的服务" class="headerlink" title="查询已经安装的服务"></a>查询已经安装的服务</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --list [服务名]</span><br><span class="line">选项：</span><br><span class="line">  --list: 列出所有RPM默认安装服务的自启动状态</span><br></pre></td></tr></table></figure>



<h2 id="RPM包默认安装的服务管理"><a href="#RPM包默认安装的服务管理" class="headerlink" title="RPM包默认安装的服务管理"></a>RPM包默认安装的服务管理</h2><h3 id="独立服务管理"><a href="#独立服务管理" class="headerlink" title="独立服务管理"></a>独立服务管理</h3><h4 id="独立服务的启动管理"><a href="#独立服务的启动管理" class="headerlink" title="独立服务的启动管理"></a>独立服务的启动管理</h4><ul>
<li><p>使用&#x2F;etc&#x2F;init.d&#x2F;目录中的启动脚本启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# /etc/init.d/httpd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用service命令来启动独立的服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# service [独立服务名] start|stop|restart|...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="独立服务的自启动管理"><a href="#独立服务的自启动管理" class="headerlink" title="独立服务的自启动管理"></a>独立服务的自启动管理</h4><ul>
<li><p>使用chkconfig服务自启动管理命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig [--level 运行级别] [独立服务名] [on|off]</span><br><span class="line">选项：</span><br><span class="line">  --level:    设定在哪个运行级别中开机自启动(on)，或是关闭自启动(off)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig --level 2345 httpd on</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改&#x2F;etc&#x2F;rc.d&#x2F;rc.local文件，设置服务自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/etc/rc.d/init.d/httpd start</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ntsysv命令管理自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ntsysv [--level 运行级别]</span><br><span class="line">选项：</span><br><span class="line">  --level 运行级别:  可以指定设定自启动的运行级别</span><br></pre></td></tr></table></figure>

<p>这个命令的操作是这样的：</p>
<ul>
<li>上下键：在不同服务之间移动</li>
<li>空格键：选定或取消服务的自启动，就是在服务之前是否打入“*”</li>
<li>tab键：在不同项目间切换</li>
<li>F1键：显示服务的说明</li>
</ul>
</li>
</ul>
<h3 id="基于xinetd服务的管理"><a href="#基于xinetd服务的管理" class="headerlink" title="基于xinetd服务的管理"></a>基于xinetd服务的管理</h3><h4 id="基于xinetd服务的启动"><a href="#基于xinetd服务的启动" class="headerlink" title="基于xinetd服务的启动"></a>基于xinetd服务的启动</h4><p>以telnet服务为例，telnet服务是用来进行系统远程管理的，端口是23。不过需要注意的是telnet的远程管理数据在网络中是明文传输，非常不安全。在生产服务器上不建议启动telnet服务。在生产服务器上，远程管理使用的是ssh协议，ssh是加密的，更加安全。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">default: on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">description: The telnet server serves telnet sessions: it uses \</span></span><br><span class="line"><span class="language-bash"><span class="comment">#       unencrypted username/password pairs for authentication.</span></span></span><br><span class="line">service telnet                                     # 服务的名称为telnet</span><br><span class="line">&#123;</span><br><span class="line">	flags				= REUSE                    # 标志为REUSE，设定TCP/IP socket可重用</span><br><span class="line">	socket_type         = stream                   # 使用TCP协议数据包</span><br><span class="line">	wait				= no					   # 允许多个连接同时连接</span><br><span class="line">	user				= root					   # 启动服务的用户为root</span><br><span class="line">	server				= /usr/sbin/in.telnetd     # 服务的启动程序</span><br><span class="line">	log_on_failure		+= USERID                  # 登录失败后，记录用户的ID</span><br><span class="line">	disable				= yes					   # 服务不启动</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/xinetd.d/telnet</span><br><span class="line">service telnet</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	disable				= no</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# service xinetd restart</span><br></pre></td></tr></table></figure>



<h4 id="基于xinetd服务的自启动"><a href="#基于xinetd服务的自启动" class="headerlink" title="基于xinetd服务的自启动"></a>基于xinetd服务的自启动</h4><ul>
<li><p>使用chkconfig命令管理自启动</p>
</li>
<li><p>使用ntsysv命令管理自启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# chkconfig 服务名 on|off</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="源码包安装的服务管理"><a href="#源码包安装的服务管理" class="headerlink" title="源码包安装的服务管理"></a>源码包安装的服务管理</h2><h3 id="源码包服务的启动管理"><a href="#源码包服务的启动管理" class="headerlink" title="源码包服务的启动管理"></a>源码包服务的启动管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# /usr/local/apache2/bin/apachectl start|stop|restart|...</span><br></pre></td></tr></table></figure>



<h3 id="源码包服务的自启动管理"><a href="#源码包服务的自启动管理" class="headerlink" title="源码包服务的自启动管理"></a>源码包服务的自启动管理</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/rc.d/rc.local</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script will be executed *after* all the other init scripts.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">You can put your own initialization stuff <span class="keyword">in</span> here <span class="keyword">if</span> you don<span class="string">&#x27;t</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">want to do the full Sys V style init stuff.</span></span></span><br><span class="line"></span><br><span class="line">touch /var/lock/subsys/local</span><br><span class="line">/usr/local/apache2/bin/apachectl start</span><br></pre></td></tr></table></figure>



<h2 id="Linux中常见服务的作用"><a href="#Linux中常见服务的作用" class="headerlink" title="Linux中常见服务的作用"></a>Linux中常见服务的作用</h2><table>
<thead>
<tr>
<th>服务名称</th>
<th>功能简介</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>acpid</td>
<td>电源管理接口。如果是笔记本用户建立开启，可以监听内核层的相关电源事件</td>
<td>on</td>
</tr>
<tr>
<td>anacron</td>
<td>系统的定时任务程序。cron的一个子系统，如果定时任务错过了执行时间，可以通过anacron继续唤醒执行。</td>
<td>off</td>
</tr>
<tr>
<td>alsasound</td>
<td>Alsa声卡驱动。如果使用alsa声卡，开启</td>
<td>off</td>
</tr>
<tr>
<td>apmd</td>
<td>电源管理模块。如果支持acpid，就不需要apmd，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>atd</td>
<td>指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用crond来进行循环定时任务。</td>
<td>off</td>
</tr>
<tr>
<td>auditd</td>
<td>审核子系统。如果开启了此服务，SELinux的审核信息会写入&#x2F;var&#x2F;log&#x2F;audit&#x2F;audit.log文件，如果不开启，审核信息会记录在syslog中</td>
<td>on</td>
</tr>
<tr>
<td>autofs</td>
<td>让服务器可以自动挂载网络中的其他服务器的共享数据，一般用来自动挂载NFS服务。如果没有NFS服务建立关闭</td>
<td>off</td>
</tr>
<tr>
<td>avahi-daemon</td>
<td>Avahi是zeroconf协议的实现。它可以在没有DNS服务的局域网里发现基于zeroconf协议的设备和服务。除非有兼容设备或使用zeroconf协议，否则关闭</td>
<td>off</td>
</tr>
<tr>
<td>bluetooth</td>
<td>蓝牙设备支持。一般不会在服务器上启用蓝牙设备。</td>
<td>off</td>
</tr>
<tr>
<td>capi</td>
<td>仅对使用ISND设备的用户有用。</td>
<td>off</td>
</tr>
<tr>
<td>chargen-dgram</td>
<td>使用UDP协议的chargen server。主要功能是提供类似远程打字的功能。</td>
<td>off</td>
</tr>
<tr>
<td>chargen-stream</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>cpuspeed</td>
<td>可以用来调整CPU的频率。当闲置时可以自动降低CPU频率来节省电量</td>
<td>on</td>
</tr>
<tr>
<td>crond</td>
<td>系统的定时任务，一般的Linux服务器都需要定时任务帮助系统维护</td>
<td>on</td>
</tr>
<tr>
<td>cvs</td>
<td>一个版本控制系统</td>
<td>off</td>
</tr>
<tr>
<td>daytime-dgram</td>
<td>daytime使用TCP协议的Daytime守护进程，该协议为客户机实现从远程服务器获取日期和时间的功能。</td>
<td>off</td>
</tr>
<tr>
<td>daytime-stream</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>dovecot</td>
<td>邮件服务中POP3&#x2F;IMAP服务的守护进程。主要用来接收信件，如果启动了邮件服务则开启，否则关闭</td>
<td>off</td>
</tr>
<tr>
<td>echo-dgram</td>
<td>服务器回显客户服务的进程。</td>
<td>off</td>
</tr>
<tr>
<td>echo-stream</td>
<td>同上。</td>
<td>off</td>
</tr>
<tr>
<td>firstboot</td>
<td>系统安装完成之后，有个欢迎界面，需要对系统进程初始设定，就是这个进程的作用。既然不是第一次启动，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>gpm</td>
<td>在字符终端(tty1-tty6)中可以使用鼠标复制和粘贴。就是这个服务的功能。</td>
<td>on</td>
</tr>
<tr>
<td>haldaemon</td>
<td>检测盒支持USB设备。如果是服务器可以关闭，个人建议关闭</td>
<td>off</td>
</tr>
<tr>
<td>hidd</td>
<td>蓝牙鼠标、键盘等蓝牙设备检测。必须启动bluetooth服务。</td>
<td>off</td>
</tr>
<tr>
<td>hplip</td>
<td>HP打印机支持，如果没有HP打印机则关闭</td>
<td>off</td>
</tr>
<tr>
<td>httpd</td>
<td>apache服务的守护进程。如果需要启动apache，则开启</td>
<td>on</td>
</tr>
<tr>
<td>ip6tables</td>
<td>IPv6防火墙，目前IPv6协议并没有使用，可以关闭</td>
<td>off</td>
</tr>
<tr>
<td>iptables</td>
<td>防火墙功能，Linux中防火墙是内核支持功能，这是服务器的主要防护手段，必须开启</td>
<td>on</td>
</tr>
<tr>
<td>irda</td>
<td>IrDA提供红外线设备(笔记本、PDA’s，手机，计算器等等)间的通讯支持。</td>
<td>off</td>
</tr>
<tr>
<td>irqbalance</td>
<td>支持多核处理器，让CPU可以自动分配系统中断(IRQ)，提高系统性能。</td>
<td>on</td>
</tr>
<tr>
<td>isdn</td>
<td>使用ISDN设备连接网络。目前主流的联网方式是光纤接入和ADSL，ISDN已经非常少见</td>
<td>off</td>
</tr>
<tr>
<td>kudzu</td>
<td>该服务可以在开机时进行硬件检测，并会调用相关的设置软件。</td>
<td>off</td>
</tr>
<tr>
<td>lvm2-monitor</td>
<td>该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM方式，那么应该开启</td>
<td>on</td>
</tr>
<tr>
<td>mcstrans</td>
<td>SELinux的支持服务</td>
<td>on</td>
</tr>
<tr>
<td>mdmonitor</td>
<td>该服务用来监测Software RAID或LVM的信息。不是必须服务</td>
<td>off</td>
</tr>
<tr>
<td>mdmpd</td>
<td>该服务用来监测Multi-Path设备</td>
<td>off</td>
</tr>
<tr>
<td>messagebus</td>
<td>这是Linuxr IPC（Interprocess Communication, 进程间通讯）服务，用来在各个软件中交换信息</td>
<td>off</td>
</tr>
<tr>
<td>microcode_ctl</td>
<td>Intel系列的CPU可以通过这个服务支持额外的微指令集。</td>
<td>off</td>
</tr>
<tr>
<td>mysqld</td>
<td>mysql数据库服务器。如果需要就开启，</td>
<td>off</td>
</tr>
<tr>
<td>named</td>
<td>DNS服务的守护进程，用来进行域名解析。如果是DNS服务器则开启</td>
<td>off</td>
</tr>
<tr>
<td>netfs</td>
<td>该服务用于在系统启动时自动挂载网络中的共享文件空间，比如：NFS, Samba等。需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>network</td>
<td>提供网络设置功能。通过这个服务来管理网络</td>
<td>on</td>
</tr>
<tr>
<td>nfs</td>
<td>NFS（Network File System）服务，Linux与Linux之间的文件共享服务。需要就开启</td>
<td>off</td>
</tr>
<tr>
<td>nfslock</td>
<td>在Linux中如果使用了NFS服务，为了避免同一个文件被不同的用户编辑，所以有了这个锁服务。有NFS是开启</td>
<td>off</td>
</tr>
<tr>
<td>ntpd</td>
<td>该服务可以通过互联网自动更新系统时间，使系统时间永远都准确。需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>pcscd</td>
<td>智能卡检测服务</td>
<td>off</td>
</tr>
<tr>
<td>portmap</td>
<td>用在远程过程调用（RPC）的服务，如果没有任何RPC服务时，可以关闭，主要是NFS和NIS服务需要</td>
<td>off</td>
</tr>
<tr>
<td>psacct</td>
<td>该守护进程支持几个监控进程活动的工具。</td>
<td>off</td>
</tr>
<tr>
<td>rdisc</td>
<td>客户端ICMP路由协议</td>
<td>off</td>
</tr>
<tr>
<td>readahead_early</td>
<td>在系统开机的时候，先将某些进程加载如内存整理，可以加快一点启动速度。</td>
<td>off</td>
</tr>
<tr>
<td>readahead_later</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>restorecond</td>
<td>用于给SELinux监测和重新加载正确的文件上下文。如果开启SELinux则需要开启。</td>
<td>off</td>
</tr>
<tr>
<td>rpcgssd</td>
<td>与NFS有关的客户端功能</td>
<td>off</td>
</tr>
<tr>
<td>rpcidmapd</td>
<td>同上</td>
<td>off</td>
</tr>
<tr>
<td>rsync</td>
<td>远程数据备份守护进程</td>
<td>off</td>
</tr>
<tr>
<td>sendmail</td>
<td>sendmail邮件服务的守护进程。如果有邮件服务就开启</td>
<td>off</td>
</tr>
<tr>
<td>setroubleshoot</td>
<td>该服务用于将SELinux相关信息记录在日志&#x2F;var&#x2F;log&#x2F;messages中</td>
<td>on</td>
</tr>
<tr>
<td>smartd</td>
<td>该服务用于自动检则硬盘状态</td>
<td>on</td>
</tr>
<tr>
<td>smb</td>
<td>网络服务samba守护进程。可以让Linux和Windows之间共享数据。如果需要则开启</td>
<td>off</td>
</tr>
<tr>
<td>squid</td>
<td>代理服务的守护进程。</td>
<td>off</td>
</tr>
<tr>
<td>sshd</td>
<td>ssh加密远程登录管理的服务。</td>
<td>on</td>
</tr>
<tr>
<td>syslog</td>
<td>日志的守护进程。</td>
<td>on</td>
</tr>
<tr>
<td>vsftpd</td>
<td>vsftpd服务的守护进程。如果需要FTP服务则开启</td>
<td>off</td>
</tr>
<tr>
<td>xfs</td>
<td>这个是X Window的字体守护进程。为图形界面提供字体服务，如果不启动图形界面就不用开启</td>
<td>off</td>
</tr>
<tr>
<td>xinetd</td>
<td>超级守护进程。如果有依赖xinetd的服务就必须开启</td>
<td>off</td>
</tr>
<tr>
<td>ypbind</td>
<td>为NIS(网络信息系统)客户机激活ypbind服务进程。</td>
<td>off</td>
</tr>
<tr>
<td>yum-updatesd</td>
<td>yum的在线升级服务</td>
<td>off</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>权限管理</title>
    <url>/2025/02/25/%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><h2 id="1-ACL权限"><a href="#1-ACL权限" class="headerlink" title="1. ACL权限"></a>1. ACL权限</h2><h3 id="1）ACL概述"><a href="#1）ACL概述" class="headerlink" title="1）ACL概述"></a>1）ACL概述</h3><p>ACL是用于解决用户对文件身份不足问题的。</p>
<h3 id="2）开启ACL"><a href="#2）开启ACL" class="headerlink" title="2）开启ACL"></a>2）开启ACL</h3><p>查询acl是否开启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dumpe2fs命令是查询指定分区详细文件系统信息的命令</span></span><br><span class="line">dumpe2fs -h &lt;根分区&gt;</span><br><span class="line">选项：</span><br><span class="line">  -h:    仅显示超级地中信息，而不显示磁盘块组的详细信息。</span><br><span class="line"> </span><br><span class="line"> ...</span><br><span class="line"> Default mount options:     user_xattr acl</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>如果没有开启，手工开启分区的ACL权限：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新挂载根分区，并挂载加入acl权限</span></span><br><span class="line">mount -o remount,acl /</span><br></pre></td></tr></table></figure>

<p>也可以通过修改&#x2F;etc&#x2F;fstab文件，永久开启ACL权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line">UUID=6f9a4f35-3b8f-425e-b8f3-4d46dbca87ad /               ext4       defaults.acl 0       1</span><br></pre></td></tr></table></figure>

<p>验证目录ACL权限存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -ahl /</span><br><span class="line">drwxrwx---+   2 sc   tg         4096  2月 14 20:19 www/</span><br><span class="line"># “+”代表有ACL权限</span><br></pre></td></tr></table></figure>



<h3 id="3）ACL基本命令"><a href="#3）ACL基本命令" class="headerlink" title="3）ACL基本命令"></a>3）ACL基本命令</h3><p>a）查询文件的ACL权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getfacl 文件名</span><br></pre></td></tr></table></figure>



<p>b）设定ACL权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setfacl [选项] 文件名</span><br><span class="line">选项：</span><br><span class="line">  -m    设定ACL权限</span><br><span class="line">  -b    删除ACL权限</span><br><span class="line">  -x    删除单个用户的ACL权限</span><br><span class="line">  -R    递归(只能赋予目录，且只对已经存在的文件生效)</span><br><span class="line"></span><br><span class="line">setfacl -m u:用户名:权限(1|2|4|5|7) 文件名</span><br><span class="line">setfacl -m g:组名:权限(1|2|4|5|7) 文件名</span><br><span class="line"></span><br><span class="line"># 赋予ACL默认权限。默认权限只能赋予目录，且只对以后新建的文件生效</span><br><span class="line">setfacl -m d:u:用户名|组名:权限(1|2|4|5|7) 目录</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 给test目录赋予aa用户读写执行的ACL权限</span><br><span class="line">setfacl -m u:aa:rwx /test</span><br><span class="line"></span><br><span class="line"># 赋予递归ACL权限</span><br><span class="line">setfacl -m u:cc:rx -R soft/</span><br><span class="line"></span><br><span class="line"># ACL默认权限</span><br><span class="line">setfacl -m d:u:aa:rwx -R soft/</span><br></pre></td></tr></table></figure>

<p>**注意：**ACL权限，一旦递归后，不可避免的出现权限溢出。因为x权限对目录来说相当于cd，而对文件是最大权限。所以ACL权限能不用则不用。</p>
<h3 id="4）最大有效权限-mask"><a href="#4）最大有效权限-mask" class="headerlink" title="4）最大有效权限(mask)"></a>4）最大有效权限(mask)</h3><p>即最大ACL权限。设定用户或组ACL权限后，该用户或组最终权限是最大ACL权限(mask权限)与该用户或组权限逻辑与的结果的权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设定mask权限为r-x,使用“m:权限”格式</span><br><span class="line">setfacl -m m:rx project/</span><br><span class="line"></span><br><span class="line"># 查询project/目录权限</span><br><span class="line"># file: project/</span><br><span class="line"># owner: root</span><br><span class="line"># group: tgroup</span><br><span class="line">user::rwx              #effective:r-x</span><br><span class="line">group::rwx             #effective:r-x</span><br><span class="line">mask::r-x</span><br><span class="line">other::---</span><br></pre></td></tr></table></figure>



<h3 id="5）删除ACL权限"><a href="#5）删除ACL权限" class="headerlink" title="5）删除ACL权限"></a>5）删除ACL权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除指定用户和用户组的ACL权限</span><br><span class="line">setfacl -x u:st /project/</span><br><span class="line"></span><br><span class="line"># 删除文件的所有ACL权限</span><br><span class="line">setfacl -b /project/</span><br></pre></td></tr></table></figure>



<h2 id="2-sudo授权"><a href="#2-sudo授权" class="headerlink" title="2. sudo授权"></a>2. sudo授权</h2><p>给普通用户赋予部分管理员权限。</p>
<p>在&#x2F;sbin&#x2F;和&#x2F;usr&#x2F;sbin&#x2F;目录下的命令只有超级用户才能使用。</p>
<h3 id="1）root身份"><a href="#1）root身份" class="headerlink" title="1）root身份"></a>1）root身份</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 执行visudo命令，赋予普通用户权限命令，命令执行后和vi一样使用</span><br><span class="line">visudo</span><br><span class="line"></span><br><span class="line">root     ALL=(ALL)                         ALL</span><br><span class="line">#用户名   被管理主机的地址=(可使用的身份)       授权命令(绝对路径)</span><br><span class="line"># %wheel        ALL=(ALL)                              ALL</span><br><span class="line">#%组名           被管理主机的地址=(可使用的身份)            授权命令(绝对路径)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>用户名&#x2F;组名：代表root给哪个用户或用户组赋予命令，注意组名前加“%”。</p>
</li>
<li><p>用户可以用指定的命令管理指定IP地址的服务器。如果写ALL，代表可以管理任务主机，如果写固定IP，代表用户可以管理指定的服务器。(这里的IP指定的是用户可以管理哪个IP地址的服务器，那么如果你是一台独立的服务器，这里写ALL和你服务器的IP地址，作用是一样的。而写入网段，只有对NIS服务这样用户和密码集中管理的服务器才有意义)。如果我们这里写本机的IP地址，不代表只允许本机的用户使用指定命令，而代表指定的用户可以从任何IP地址来管理当前服务器。</p>
</li>
<li><p>可使用身份：就是把来源用户切换成什么身份使用，(ALL)代表可以切换成任意身份。这个字段可以省略。</p>
</li>
<li><p>授权命令：代表root把什么命令授权给普通用户。默认是ALL，代表任何命令，这个当然不行，如果需要给哪个命令授权，写入命令名即可。不过需要注意一定要命令写成绝对路径。</p>
</li>
</ul>
<p>【示例1】：授权用户user1可以重启服务器。</p>
<p>则由root用户添加如下行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">user1         ALL=/sbin/shutdown -r now</span><br><span class="line"></span><br><span class="line"># 查看可用的授权</span><br><span class="line">[user1@localhost ~]$ sudo -l</span><br><span class="line"></span><br><span class="line"># 执行授权命令</span><br><span class="line">[user1@localhost ~]$ sudo /sbin/shutdown -r now</span><br></pre></td></tr></table></figure>



<p>【示例2】：授权一个用户管理web服务器。</p>
<p>首先要分析授权用户管理Apache至少要实现哪些基本授权：</p>
<ul>
<li>可以使用Apache管理脚本</li>
<li>可以修改Apache配置文件</li>
<li>可以更新网页内容</li>
</ul>
<p>假设Apache管理脚本程序为&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;httpd。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># visudo授权</span><br><span class="line">[root@loaclhost ~]# visudo</span><br><span class="line">user1      192.168.0.156=/etc/rc.d/init.d/httpd reload,/etc/rc.d/init.d/httpd configtest</span><br></pre></td></tr></table></figure>

<p>授权用户user1可以连接192.168.0.156上的Apache服务器，通过Apache管理脚本重新读取配置文件让更改的设置生效(reload)和可以检测Apache配置文件语法错误(configtest)。</p>
<p>为满足条件二：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">user1      192.168.0.156=/usr/bin/vim /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure>

<p>授权用户user1可以用root身份使用vi编辑Apache配置文件。</p>
<p>为满足条件三，假设网页存放目录为&#x2F;var&#x2F;www&#x2F;html，则只需要授权user1对此目录具有写权限或者索性更改目录所有者为user1即可。如果需要，还可以设置user1可以通过FTP等文件共享服务更新网页。</p>
<p>【示例3】：授权aa用户可以添加其他普通用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# visudo</span><br><span class="line">aa    ALL=/usr/sbin/useradd</span><br><span class="line">aa    ALL=/usr/bin/passwd [A-Za-z]*, !/usr/bin/passwd &quot;&quot;, !/usr/bin/passwd root    # 不能改root用户密码</span><br></pre></td></tr></table></figure>



<h2 id="3-文件特殊权限"><a href="#3-文件特殊权限" class="headerlink" title="3.文件特殊权限"></a>3.文件特殊权限</h2><h3 id="1）SetUID"><a href="#1）SetUID" class="headerlink" title="1）SetUID"></a>1）SetUID</h3><p>a）SetUID概念</p>
<p>SetUID的功能可以这样理解：</p>
<ul>
<li>只有可以执行的文件才能设定SUID权限</li>
<li>命令执行者要对该程序拥有x（执行）权限</li>
<li>命令执行者在执行该程序时获得该程序文件属主的身份(在执行程序的过程中灵魂附体为文件的属主)</li>
<li>SetUID权限只在该程序执行过程中有效，也就是说身份改变只在程序执行过程中有效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /etc/passwd</span><br><span class="line">-rw-r--r-- 1 root root 3626  2月 15 11:38 /etc/passwd</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll /etc/shadow</span><br><span class="line">-rw-r----- 1 root shadow 2092  2月 15 11:37 /etc/shadow</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# ll /usr/bin/passwd</span><br><span class="line">-rwsr-xr-x 1 root root 64152  5月 30  2024 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p>&#x2F;usr&#x2F;bin&#x2F;passwd命令拥有特殊权限SetUID，也就是在属主的权限位的执行权限上是s。可以这样来理解它：当一个具有执行权限的文件设置SetUID权限后，用户执行这个文件时将以文件所有者的身份执行。&#x2F;usr&#x2F;bin&#x2F;passwd命令具有SetUID权限，所有者为root（Linux中的命令默认所有者都是root），也就是说当普通用户使用passwd更改自己密码的时候，那一瞬间突然灵魂附体了，实际是用passwd命令所有者root的身份在执行passwd命令，root当然可以将密码写入&#x2F;etc&#x2F;shadow文件，所以普通用户也可以修改&#x2F;etc&#x2F;shadow文件，命令执行完成后该身份也随之消失。如果取消SetUID权限，则普通用户就不能修改自己的密码了。</p>
<p>b）设置SetUID权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置SetUID权限</span><br><span class="line">[root@localhost ~]# chmod u+s /usr/bin/vim      # 极其危险，意味着把服务器送给别人了，别人可以打开、修改任何文件了</span><br><span class="line"></span><br><span class="line"># 查看SetUID权限</span><br><span class="line">[root@localhost ~]# ll /usr/bin/vim</span><br><span class="line">-rwsr-xr-x 1 root root 1847752 4月 5 2012 /usr/bin/vim </span><br></pre></td></tr></table></figure>



<p>c）建议</p>
<ul>
<li>关键目录应严格控制写权限，比如“&#x2F;”、“&#x2F;usr”等；</li>
<li>用户的密码设置要严格遵守密码三原则；</li>
<li>对系统中默认应该具有SetUID权限的文件作一列表，定时检查有没有这之外的文件被设置了SetUID权限。</li>
</ul>
<p>d）检测SetUID的脚本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Author: ben (E-main: 326525276@qq.com)</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索系统中所有拥有SUID和SGID的文件，并保存到临时目录中</span></span><br><span class="line">find / -perm -4000 -o -perm -2000 &gt; /tmp/setuid.check</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">做循环，每次循环取出临时文件中的文件名</span></span><br><span class="line">for i in $(cat /tmp/setuid.check)</span><br><span class="line">do</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">比对这个文件名是否在模板文件中</span></span><br><span class="line">	grep $i /root/suid.list &gt; /dev/null</span><br><span class="line">	if [&quot;$?&quot; != &quot;0&quot;]</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果在，不报错</span></span><br><span class="line">	then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">如果文件不在模板文件中，则报错，并把报错存在日志中</span></span><br><span class="line">		echo &quot;$i isn&#x27;t in listfile!&quot; &gt;&gt; /root/suid_log_$(date +%F)</span><br><span class="line">	fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除临时文件</span></span><br><span class="line">rm -rf /tmp/setuid.check</span><br></pre></td></tr></table></figure>



<h3 id="2）SetGID"><a href="#2）SetGID" class="headerlink" title="2）SetGID"></a>2）SetGID</h3><p>SGID既可以针对文件生效，也可以针对目录生效。这和SUID明显不同。</p>
<p>a）针对文件的作用</p>
<p>针对文件，SGID的含义如下：</p>
<ul>
<li>只有可执行的文件才能设置SGID权限</li>
<li>命令执行者要对该文件拥有x（执行）权限</li>
<li>命令执行者在执行文件的时候，组身份升级为该文件的属组</li>
<li>SetGID权限同样只在该文件执行过程中有效，也就是说组身份改变只在文件执行过程中有效</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /var/lib/mlocate/mlocate.db</span><br><span class="line">-rw-r----- 1 root slocate 1838850 1月    20 04：29 /var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>

<p>属主权限是r、w，属组权限是r，其他人权限是0；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /usr/bin/locate</span><br><span class="line">-rwx--s--x. 1 root slocate 38464  8月 24 2010 /usr/bin/locate    # 所属组s代表SetGID权限</span><br></pre></td></tr></table></figure>

<p>当普通用户user1执行locate命令时，会发生如下事情：</p>
<ul>
<li>&#x2F;usr&#x2F;bin&#x2F;locate是可执行二进制程序，可以赋予SGID</li>
<li>执行用户user1对&#x2F;usr&#x2F;bin&#x2F;locate命令拥有执行权限</li>
<li>执行&#x2F;usr&#x2F;bin&#x2F;locate命令时，组身份会升级为slocate组，而slocate组对&#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db数据库拥有r权限，所以普通用户可以使用locate</li>
</ul>
<p>命令查询mlocate.db数据库</p>
<ul>
<li>命令结束，user1用户的组身份返回为user1组</li>
</ul>
<p>b）针对目录的作用</p>
<p>如果SGID针对目录设置，含义如下：</p>
<ul>
<li>普通用户必须对此目录拥有r和x权限，才能进入此目录</li>
<li>普通用户在此目录中的有效组会变成此目录的属组</li>
<li>若普通用户对此目录拥有w权限时，新建的文件的默认属组就是这个目录的属组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 进入临时目录</span><br><span class="line">[root@localhost ~]# cd /tmp</span><br><span class="line"># 建立测试目录</span><br><span class="line">[root@localhost tmp]# mkdir dtest</span><br><span class="line"># 给测试目录赋予SGID</span><br><span class="line">[root@localhost tmp]# chmod g+s dtest</span><br><span class="line"># 查询SGID是否生效</span><br><span class="line">[root@localhost tmp]# ll -d dtest/</span><br><span class="line">drwxr-sr-x 2 root root 4096 1月 20 06：04 dtest/</span><br><span class="line"># 给测试目录权限，让普通用户可以写</span><br><span class="line">[root@localhost tmp]# chmod 777 dtest/</span><br><span class="line"># 切换成普通用户user1</span><br><span class="line">[root@localhost tmp]# su - user1</span><br><span class="line"># 普通用户进入测试目录</span><br><span class="line">[user1@localhost ~]$ cd /tmp/dtest/</span><br><span class="line"># 普通用户建立abc文件</span><br><span class="line">[user1@localhost ~]$ touch abc</span><br><span class="line"># abc文件的默认属组是root, 说明SGID生效</span><br><span class="line">[user1@localhost ~]$ ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-rw-r-- 1 user1 root 0 1月 20 06：07 abc</span><br></pre></td></tr></table></figure>



<h3 id="3）Sticky-BIT"><a href="#3）Sticky-BIT" class="headerlink" title="3）Sticky BIT"></a>3）Sticky BIT</h3><p>Sticky BIT粘着位，也简称为SBIT，SBIT目前仅针对目录有效。</p>
<p>SBIT作用如下：</p>
<ul>
<li>粘着位目录只对目录有效</li>
<li>普通用户对该目录拥有w和x权限，即普通用户可以在此目录拥有写入权限</li>
<li>如果没有粘着位，因为普通用户拥有w权限，所以可以删除此目录下所有文件，包括其他用户建立的文件，一旦赋予了粘着位，除了root可以删除所有文件，普通用户就算拥有w权限，也只能删除自己建立的文件，但是不能删除其他用户建立的文件。</li>
</ul>
<h3 id="4）设定文件特殊权限"><a href="#4）设定文件特殊权限" class="headerlink" title="4）设定文件特殊权限"></a>4）设定文件特殊权限</h3><p>特殊权限：</p>
<ul>
<li>4代表SUID</li>
<li>2代表SGID</li>
<li>1代表SBIT</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 赋予SUID权限</span><br><span class="line">[root@localhost ~]# chmod 4755 ftest              # 或者chmod u+s ftest</span><br><span class="line"></span><br><span class="line"># 赋予SGID权限</span><br><span class="line">[root@localhost ~]# chmod 2755 ftest              # 或者chmod g+s ftest</span><br><span class="line"></span><br><span class="line"># 赋予SBIT权限</span><br><span class="line">[root@localhost ~]# mkdir dtest</span><br><span class="line">[root@localhost ~]# chmod 1755 dtest/             # 或者chmod o+t ftest</span><br></pre></td></tr></table></figure>



<h2 id="4-文件系统属性chattr权限"><a href="#4-文件系统属性chattr权限" class="headerlink" title="4. 文件系统属性chattr权限"></a>4. 文件系统属性chattr权限</h2><p>a）命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]chattr [+-=] [选项] 文件或目录名</span><br><span class="line">选项：</span><br><span class="line">  +：    增加权限</span><br><span class="line">  -：    删除权限</span><br><span class="line">  =：    等于某权限</span><br><span class="line">  i：    如果对文件设置i属性，那么不允许对文件进行删除、改名，也不能添加和修改数据；如果对目录设置i属性，那么只能修改目录下文件的数据，但不允许建立和          删除文件</span><br><span class="line">  a：    如果对文件设置a属性，那么只能在文件中增加数据，但是不能删除也不能修改数据；如果对目录设置a属性，那么只允许在目录中建立和修改文件，但是不允许          删除</span><br><span class="line">  e：    Linux中绝大多数的文件都默认拥有e属性。表示该文件是使用ext文件系统进行存储的，而且不能使用“chattr -e”命令取消e属性</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 赋予文件i属性</span><br><span class="line">chattr +i abc</span><br><span class="line"></span><br><span class="line"># 取消文件i属性</span><br><span class="line">chattr -i abc</span><br><span class="line"></span><br><span class="line"># 赋予目录i属性</span><br><span class="line">chattr +i bcd/</span><br><span class="line"></span><br><span class="line"># 取消目录i属性</span><br><span class="line">chattr -i bcd/</span><br></pre></td></tr></table></figure>



<p>b) 查看文件系统属性(lsattr)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lsattr 选项 文件名</span><br><span class="line">选项：</span><br><span class="line">  -a:    显示所有文件和目录</span><br><span class="line">  -d:    若目标是目录，仅列出目录本身的属性，而不是子文件</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>用户管理</title>
    <url>/2025/02/25/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><h2 id="1-用户相关文件"><a href="#1-用户相关文件" class="headerlink" title="1. 用户相关文件"></a>1. 用户相关文件</h2><h3 id="1）用户信息文件"><a href="#1）用户信息文件" class="headerlink" title="1）用户信息文件"></a>1）用户信息文件</h3><p>&#x2F;etc&#x2F;passwd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一列：用户名</p>
</li>
<li><p>第二列：密码位</p>
<p>x为密码标志位，代表用户有密码，用户密码放置在&#x2F;etc&#x2F;shadow文件中。</p>
</li>
<li><p>第三列：用户ID</p>
<ul>
<li>0：超级用户UID，如果用户UID为0，代表这个账号是管理员账号。那Linux中如何把普通用户升级为管理员呢？就是把其他用户的UID修改为0就可以了。不过不建议建立多个管理员账号。</li>
<li>1-499：系统用户(伪用户)UID，这些UID账号是系统保留给系统用户的UID，也就是说UID是1-499范围内的用户是不能登录系统的，而是用来运行系统或服务的，其中1-99是系统保留的账号，系统自动创建。100-499是预留给用户创建系统账号的。</li>
<li>500-65535：普通用户UID。建立的普通用户UID从500开始，最大到65535。这些用户足够使用了，但是如果不够也不用害怕，2.6.x内核以后的Linux系统用户UID已经可以支持2的32次方了。</li>
</ul>
</li>
<li><p>第四列：组ID（GID）</p>
<p>添加用户时，如果不指定用户所属的初始组，那么会建立和用户名相同的组。</p>
</li>
<li><p>第五列：用户说明</p>
</li>
<li><p>第六列：用户家目录（~）</p>
</li>
<li><p>第七列：登录shell（标准是&#x2F;bin&#x2F;bash）</p>
</li>
</ul>
<h3 id="2）影子文件"><a href="#2）影子文件" class="headerlink" title="2）影子文件"></a>2）影子文件</h3><p>&#x2F;etc&#x2F;shadow</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:$6$jvGI3Z2PqL/TT4lT$q1lVTdba3dRsmWsEJVHzTqAHOSlb3qvM/hL7wKTQCo5148xfMiT0mnq1zQ7n7wCZu/QEdtP/57BVko4X6U4in0:18929:0:99999:7:::</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一列：用户名</p>
</li>
<li><p>第二列：加密密码</p>
<p>我们也可以在密码前人为的加入“!”或“*”改变加密值让密码暂时失效，使这个用户无法登录，达到暂时禁止用户登录的效果。</p>
<p>所有伪用户的密码都是”!!”或“*”，代表没有密码是不能登录的。当然新创建的用户如果不设定密码，它的密码项也是”!!”，代表这个用户没有密码，不能登录。</p>
</li>
<li><p>第三列：密码最近更改时间（day），1970年1月1日作为标准时间</p>
<p>时间戳转日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date -d &quot;1970-01-01 18929 days&quot;</span><br><span class="line">2021年 10月 29日 星期五 00:00:00 CST</span><br></pre></td></tr></table></figure>

<p>日期转时间戳</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $(($(date --date=&quot;2021/10/29&quot; +%s)/86400+1))</span><br><span class="line">18929</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四列：两次密码的修改间隔时间（和第3个字段相比）</p>
</li>
<li><p>第五列：密码有效期(和第3个字段相比)</p>
</li>
<li><p>第六列：密码修改到期前警告天数(和第5个字段相比)</p>
</li>
<li><p>第七列：密码过期后的宽限天数(和第5个字段相比)</p>
</li>
<li><p>第八列：密码失效时间</p>
<p>这里同样要写时间戳，也就是用1970年1月1日进行时间换算，如果超过了失效时间，就算密码没有过期，用户也就失效无法使用了。</p>
</li>
<li><p>第九列：保留</p>
</li>
</ul>
<h3 id="3）组信息文件"><a href="#3）组信息文件" class="headerlink" title="3）组信息文件"></a>3）组信息文件</h3><p>&#x2F;etc&#x2F;group</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:x:0:</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：组名</li>
<li>第二列：组密码位</li>
<li>第三列：GID</li>
<li>第四列：此组中支持的其他用户，附加组是此组的用户<ul>
<li>初始组：每个用户初始组只能有一个，一般都是和用户名相同的组作为初始组。</li>
<li>附加组：每个用户可以属于多个附加组。要把用户加入组，都是加入附加组。</li>
</ul>
</li>
</ul>
<h3 id="4）组密码文件-不建议使用"><a href="#4）组密码文件-不建议使用" class="headerlink" title="4）组密码文件(不建议使用)"></a>4）组密码文件(不建议使用)</h3><p>&#x2F;etc&#x2F;gshadow</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root:*::</span><br></pre></td></tr></table></figure>

<p>如果给用户组设定了组管理员，并给该用户组设定了组密码，组密码就保存在这个文件当中。组管理员就可以利用这个密码管理这个用户组了。</p>
<h3 id="5）用户家目录"><a href="#5）用户家目录" class="headerlink" title="5）用户家目录"></a>5）用户家目录</h3><h3 id="6）用户邮箱目录"><a href="#6）用户邮箱目录" class="headerlink" title="6）用户邮箱目录"></a>6）用户邮箱目录</h3><p>这个邮箱在&#x2F;var&#x2F;spool&#x2F;mail目录当中，例如lamp用户的邮箱就是&#x2F;var&#x2F;spool&#x2F;mail&#x2F;lamp文件</p>
<h3 id="7）用户模板目录"><a href="#7）用户模板目录" class="headerlink" title="7）用户模板目录"></a>7）用户模板目录</h3><p>&#x2F;etc&#x2F;skel&#x2F;</p>
<p>用户家目录初始化时的模板目录。</p>
<h2 id="2-用户管理命令"><a href="#2-用户管理命令" class="headerlink" title="2.用户管理命令"></a>2.用户管理命令</h2><h3 id="1）添加用户"><a href="#1）添加用户" class="headerlink" title="1）添加用户"></a>1）添加用户</h3><p>a）手工删除用户</p>
<p>手工删除用户试验：手工删除，如果可以正常建立用户，证明用户删除干净。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建用户，就是写入这6个文件</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow</span><br><span class="line">/etc/group</span><br><span class="line">/etc/gshadow</span><br><span class="line">/home/user1</span><br><span class="line">/var/spool/mail/user1</span><br></pre></td></tr></table></figure>



<p>b）useradd命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">useradd 选项 用户名</span><br><span class="line">选项：</span><br><span class="line">  -u：UID   指定UID</span><br><span class="line">  -g：组名   指定初始组，不要手工指定</span><br><span class="line">  -G：组名   指定附加组，把用户加入组，使用附加组</span><br><span class="line">  -c：说明   添加说明</span><br><span class="line">  -d：目录   手工指定家目录，目录不需要事先建立</span><br><span class="line">  -s：shell  /bin/bash</span><br><span class="line">  -m：创建家目录</span><br></pre></td></tr></table></figure>



<p>c）useradd默认值</p>
<p>useradd添加用户时参考的默认值文件主要有两个：</p>
<ul>
<li><p>&#x2F;etc&#x2F;default&#x2F;useradd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># useradd defaults file</span><br><span class="line">GROUP=100</span><br><span class="line">HOME=/home</span><br><span class="line">INACTIVE=-1</span><br><span class="line">EXPIRE=</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">SKEL=/etc/skel</span><br><span class="line">CREATE_MAIL_SPOOL=yes</span><br></pre></td></tr></table></figure>

<ul>
<li><p>GROUP&#x3D;100</p>
<p>这个选项是建立用户的默认组，也就是说添加每个用户时，用户的初始组就是GID为100的这个用户组。</p>
</li>
<li><p>HOME&#x3D;&#x2F;home</p>
<p>这个选项是用户的家目录的默认位置，所以所有的新建用户的家目录默认都在&#x2F;home&#x2F;下。</p>
</li>
<li><p>INACTIVE&#x3D;-1</p>
<p>这个选项就是密码过期后的宽限天数，也就是&#x2F;etc&#x2F;shadow文件的第七个字段。如果是天数，比如10代表密码过期后10天后失效；如果是0，代表密码过期后立即失效；如果是-1，则代表密码永远不会失效。这是默认值是-1，所以所有新建立的用户密码都不会失效。</p>
</li>
<li><p>EXPIRE&#x3D;</p>
<p>这个选项是密码失效时间，也就是&#x2F;etc&#x2F;shadow文件的第八个字段，也就是说用户到达这个日期后就会直接失效。当然这里也是使用时间戳来表示日期的。默认是空，所以所有新建用户没有失效时间。永久有效。</p>
</li>
<li><p>SHELL&#x3D;&#x2F;bin&#x2F;bash</p>
<p>这个选项是用户的默认shell。&#x2F;bin&#x2F;bash是Linux的标志shell，所以所有新建立的用户默认都具备shell赋予的权限。</p>
</li>
<li><p>SKEL&#x3D;&#x2F;etc&#x2F;skel</p>
<p>这个选项就是定义用户的模板目录的位置，&#x2F;etc&#x2F;skel&#x2F;目录中的文件都会复制到新建用户的家目录当中。</p>
</li>
<li><p>CREATE_MAIL_SPOOL&#x3D;yes</p>
<p>这个选项定义是否给新建用户建立邮箱，默认是创建，也就是说所有的新建用户系统都会新建一个邮箱，放在&#x2F;var&#x2F;spool&#x2F;mail&#x2F;下，和用户名相同。</p>
</li>
</ul>
</li>
<li><p>&#x2F;etc&#x2F;login.defs</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAIL_DIR        /var/spool/mail</span><br><span class="line"></span><br><span class="line">PASS_MAX_DAYS   99999</span><br><span class="line">PASS_MIN_DYAS   0</span><br><span class="line">PASS_MIN_LEN    5</span><br><span class="line">PASS_WARN_AGE   7</span><br><span class="line"></span><br><span class="line">UID_MIN         500</span><br><span class="line">UID_MAX         60000</span><br><span class="line"></span><br><span class="line">GID_MIN         500</span><br><span class="line">GID_MAX         60000</span><br><span class="line"></span><br><span class="line">CREATE_HOME     yes</span><br><span class="line"></span><br><span class="line">UMASK           077</span><br><span class="line"></span><br><span class="line">USERGROUPS_ENAB yes</span><br><span class="line"></span><br><span class="line">ENCRYPT_METHOD  SHA512</span><br></pre></td></tr></table></figure>

<ul>
<li><p>MAIL_DIR          &#x2F;var&#x2F;spool&#x2F;mail</p>
<p>这行指定了新建用户的默认邮箱位置。比如lamp用户的邮箱就是&#x2F;var&#x2F;spool&#x2F;mail&#x2F;lamp。</p>
</li>
<li><p>PASS_MAX_DAYS    99999</p>
<p>这行指定的是密码的有效期，也就是&#x2F;etc&#x2F;shadow文件的第五个字段。代表多少天之后必须修改密码，默认值是99999</p>
</li>
<li><p>PASS_MIN_DAYS    0</p>
<p>这行指定是两次密码的修改间隔时间，也就是&#x2F;etc&#x2F;shadow文件的第四个字段。代表第一次修改密码之后，几天后才能再次修改密码，默认值是0</p>
</li>
<li><p>PASS_MIN_LEN    5</p>
<p>这行代表密码的最小长度，默认不小于5位，但是我们现在用户登录时验证已经被PAM模块取代，所以这个选项并不生效。</p>
</li>
<li><p>PASS_WARN_AGE    7</p>
<p>这行代表密码修改到期前的警告天数。也就是&#x2F;etc&#x2F;shadow文件的第六个字段。代表密码到底有效期前多少天开始进行警告提醒，默认值是7天。</p>
</li>
<li><p>UID_MIN|UID_MAX</p>
<p>这两行指定了UID的最小值和最大值之间的范围。</p>
</li>
<li><p>GID_MIN|GID_MAX</p>
<p>这两行指定了GID的最小值和最大值之间的范围。</p>
</li>
<li><p>CREATE_HOME    yes</p>
<p>这行指定建立用户时是否自动建立用户的家目录，默认是建立。</p>
</li>
<li><p>UMASK    077</p>
<p>这行指定的是建立的用户家目录的默认权限，因为umask值是077，所以新建的用户家目录的权限是700。</p>
</li>
<li><p>USERGROUPS_ENAB    yes</p>
<p>这行指定的是使用命令userdel删除用户时，是否删除用户的初始组，默认是删除。</p>
</li>
<li><p>ENCRYPT_METHOD    SHA512</p>
<p>这行指定Linux用户的密码使用SHA512散列模式加密，这是新的密码加密模式，原先的Linux只能用DES或MD5方式加密。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2）设定密码"><a href="#2）设定密码" class="headerlink" title="2）设定密码"></a>2）设定密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">passwd [选项] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -l:         暂时锁定用户。仅root用户可用（lock）</span><br><span class="line">  -u:         解锁用户。仅root用户可用（unlock）</span><br><span class="line">  --stdin:    可以将通过管道符输出的数据作为用户的密码。主要在批量添加用户时使用</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改当前用户的密码</span><br><span class="line">passwd</span><br><span class="line"></span><br><span class="line"># 使用字符串作为密码</span><br><span class="line">echo &quot;123&quot; | passwd --stdin lamp</span><br><span class="line"></span><br><span class="line"># 把密码修改日期归零(shadow第3个字段，0代表1970年1月1日)。这样用户一登录就要修改密码。</span><br><span class="line">chage -d 0 lamp</span><br></pre></td></tr></table></figure>



<h3 id="3）用户信息修改"><a href="#3）用户信息修改" class="headerlink" title="3）用户信息修改"></a>3）用户信息修改</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usermod [选项] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -u UID:        修改用户的UID</span><br><span class="line">  -d 家目录：     修改用户的家目录。家目录必须写绝对路径</span><br><span class="line">  -c 用户说明:    修改用户的说明信息，就是/etc/passwd文件的第五个字段</span><br><span class="line">  -g 组名：       修改用户的初始组，就是/etc/passwd文件的第四个字段</span><br><span class="line">  -G 组名：       修改用户的附加组，其实就是把用户加入其他用户组</span><br><span class="line">  -s shell:      修改用户的登录Shell。默认是/bin/bash</span><br><span class="line">  -e 日期：       修改用户的失效日期，格式为&quot;YYYY-MM-DD&quot;。也就是/etc/shadow文件的第八个字段</span><br><span class="line">  -L:            临时锁定用户(Lock)</span><br><span class="line">  -U:            解锁用户(Unlock)</span><br></pre></td></tr></table></figure>

<p>usermod也可以修改用户名，但不建议这么做，这样及其容易把管理员自己稿晕。建议删除旧用户，再建立新用户。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改用户名</span><br><span class="line">usermod -l 新名 旧名</span><br></pre></td></tr></table></figure>



<h3 id="4）删除用户"><a href="#4）删除用户" class="headerlink" title="4）删除用户"></a>4）删除用户</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">userdel [-r] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -r:    在删除用户的同时删除用户的家目录</span><br></pre></td></tr></table></figure>



<h3 id="5）切换用户身份"><a href="#5）切换用户身份" class="headerlink" title="5）切换用户身份"></a>5）切换用户身份</h3><p>su命令可以切换成不同的用户身份。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su [选项] 用户名</span><br><span class="line">选项：</span><br><span class="line">  -:          选项只使用“-”代表连带用户的环境变量一起切换</span><br><span class="line">  -c 命令:    仅执行一次命令，而不切换用户身份</span><br></pre></td></tr></table></figure>

<p>“-”不能省略，它代表切换用户身份时，用户的环境变量也要切换成新用户的环境变量。</p>
<h2 id="3-组管理命令"><a href="#3-组管理命令" class="headerlink" title="3. 组管理命令"></a>3. 组管理命令</h2><h3 id="1）添加用户组"><a href="#1）添加用户组" class="headerlink" title="1）添加用户组"></a>1）添加用户组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd [选项] 组名</span><br><span class="line">选项：</span><br><span class="line">  -g GID:    指定组ID</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加group1组</span><br><span class="line">groupadd group1</span><br></pre></td></tr></table></figure>



<h3 id="2）删除用户组"><a href="#2）删除用户组" class="headerlink" title="2）删除用户组"></a>2）删除用户组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupdel 组名</span><br></pre></td></tr></table></figure>

<p>不过要注意，要删除的组不能是其他用户的初始组，也就是说这个组中没有初始用户才可以删除。如果组中有附加用户，则删除组时不受影响。</p>
<h3 id="3）把用户添加进组或从组中删除"><a href="#3）把用户添加进组或从组中删除" class="headerlink" title="3）把用户添加进组或从组中删除"></a>3）把用户添加进组或从组中删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gpasswd [选项] 组名</span><br><span class="line">选项：</span><br><span class="line">  -a 用户名：    把用户加入组</span><br><span class="line">  -d 用户名：    把用户从组中删除</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加test组</span><br><span class="line">groupadd test</span><br><span class="line"></span><br><span class="line"># 把test1用户加入test组</span><br><span class="line">gpasswd -a test1 test</span><br><span class="line"></span><br><span class="line"># 把用户test1从test组中删除</span><br><span class="line">gpasswd -d test1 test</span><br></pre></td></tr></table></figure>



<h3 id="4）改变有效组"><a href="#4）改变有效组" class="headerlink" title="4）改变有效组"></a>4）改变有效组</h3><p>每个用户可以属于一个初始组（用户是这个组的初始用户），也可以属于多个附加组（用户是这个组的附加用户）。既然用户可以属于这么多用户组，那么用户在创建文件后，默认生效的组身份是哪个呢？当然是初始用户组的组身份。因为初始组是用户一旦登录就直接获得的组身份。也就是说，用户在创建文件后，文件的属组就是用户的初始组，因为用户的有效组默认是初始组。使用newgrp可以切换用户的有效组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newgrp 组名</span><br></pre></td></tr></table></figure>



<h3 id="5-组权限实验"><a href="#5-组权限实验" class="headerlink" title="5. 组权限实验"></a>5. 组权限实验</h3><p>根目录下创建个www目录，属主为teacher, 学生st1，st2可以往这个目录提交作业。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建www目录</span><br><span class="line">mkdir /www</span><br><span class="line"></span><br><span class="line"># 创建teacher用户</span><br><span class="line">useradd -m teacher</span><br><span class="line"></span><br><span class="line"># 设置teacher用户密码</span><br><span class="line">passwd teacher</span><br><span class="line"></span><br><span class="line"># 创建st1,st2用户并设置密码</span><br><span class="line">useradd -m st1</span><br><span class="line">useradd -m st2</span><br><span class="line"></span><br><span class="line"># 创建tg组</span><br><span class="line">groupadd tg</span><br><span class="line"></span><br><span class="line"># 将st1, st2加入tg组</span><br><span class="line">gpasswd -a st1 tg</span><br><span class="line">gpasswd -a st2 tg</span><br><span class="line"></span><br><span class="line"># 设置www目录属主和属组</span><br><span class="line">chown teacher:tg /www/</span><br><span class="line"></span><br><span class="line"># 设置www目录权限</span><br><span class="line">chmod 770 /www/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>系统管理</title>
    <url>/2025/03/05/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程简介"><a href="#进程简介" class="headerlink" title="进程简介"></a>进程简介</h3><p>1）什么是进程</p>
<p>进程是正在执行的一个程序或命令，每一个进程都是一个运行的实体，都有自己的地址空间，并占用一定的系统资源。</p>
<p>2）什么是程序</p>
<p>程序是人使用计算机语言编写的可以实现特定目标或解决特定问题的代码集合。</p>
<p>程序是人使用计算机语言编写的，可以实现一定功能，并且可以执行的代码集合。</p>
<p>进程是正在执行当中的程序。程序被执行时，执行人的权限和属性、以及程序的代码都会被加载如内存，操作系统给这个进程分配一个ID号，称为PID（进程ID）。</p>
<p>3）进程管理的作用</p>
<ul>
<li><p>判断服务器健康状态</p>
<p>运维工程师最主要的工作就是保证服务器安全稳定的运行。理想的状态是，在服务器出现问题，但是还没有造成服务器宕机或停止服务时，就人为干预解决了问题。进程管理最主要的工作就是判断服务器当前运行是否健康，是否需要人为干预。如果服务器的CPU占用率、内存占用率过高，就需要人为介入解决问题了。</p>
</li>
<li><p>查看系统中所有的进程</p>
<p>我们需要查看系统中所有正在运行的进程，通过这些进程可以判断系统中运行了哪些服务，是否有非法服务运行。</p>
</li>
<li><p>杀死进程</p>
<p>这是进程管理中最不常用的手段，当需要停止服务时，会通过正确关闭命令来停止服务（如apache服务可以通过service httpd sotp来关闭）。只有当正确终止进程的手段失效的情况下，才会考虑使用kill命令杀死进程（你不是杀手，不要什么进程都用kill来终止，否则非常容易导致服务器崩溃）。</p>
</li>
</ul>
<h3 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h3><h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>ps命令是用来静态显示系统中进程的命令。不过这个命令有些特殊，它的部分命令的选项不能加入“-”，比如“ps aux”，这是因为ps命令的部分选项需要遵守BSD操作系统的格式，所以ps命令的常用选项的组合是固定的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统中所有进程，使用BSD操作系统格式</span></span><br><span class="line">[root@localhost ~]# pa aux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看系统中所有进程，使用Linux标准命令格式</span></span><br><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">选项：</span><br><span class="line">  a:		显示一个终端的所有进程，除了会话引线</span><br><span class="line">  u:		显示进程的归属用户及内存的使用情况</span><br><span class="line">  x:		显示没有控制终端的进程</span><br><span class="line">  -l:		长格式显示。显示更加详细的信息</span><br><span class="line">  -e:		显示所有进程，和-A作用一致</span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ps aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.2  24104 15260 ?        Ss   3月04   0:10 /sbin/init splash</span><br><span class="line">root           2  0.0  0.0      0     0 ?        S    3月04   0:00 [kthreadd]</span><br></pre></td></tr></table></figure>

<ul>
<li>USER：该进程是由哪个用户产生的</li>
<li>PID：进程的ID号</li>
<li>%CPU：该进程占用CPU资源的百分比，占用越高，进程越耗费资源</li>
<li>%MEM：该进程占用物理内存的百分比，占用越高，进程越耗费资源</li>
<li>VSZ：该进程占用虚拟内存的大小，单位KB</li>
<li>RSS：该进程占用实际物理内存的大小，单位KB</li>
<li>TTY：该进程是在哪个终端中运行的。其中tty1-tty7代表本地控制台终端(可以通过alt+F1-F7键切换不同的终端)，tty1-tty6是本地的字符界面终端，tty7是图形终端。pts&#x2F;0-255代表虚拟终端，一般是远程连接终端，第一个远程连接占用的是pts&#x2F;0终端，第二个远程连接占用pts&#x2F;1，依次增长。</li>
<li>STAT：进程状态。常见状态有：<ul>
<li>D：不可被唤醒的睡眠状态，通常用于I&#x2F;O情况</li>
<li>R：该进程正在运行</li>
<li>S：该进程在睡眠状态，可被唤醒</li>
<li>T：停止状态，可能是在后台暂停或进程在除错状态</li>
<li>W：内存交互状态（从2.6内核开始无效）</li>
<li>X：死掉的进程（应该不会出现）</li>
<li>Z：僵尸进程。进程已经终止，但是部分程序还在内存当中。</li>
<li>&lt;：高优先级（以下状态在BSD格式当中出现）</li>
<li>N：低优先级</li>
<li>L：被锁入内存</li>
<li>s：包含子进程</li>
<li>l：多线程</li>
<li>+：位于后台</li>
</ul>
</li>
<li>START：该进程的启动时间</li>
<li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li>
<li>COMMAND：产生此进程的命令名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ps -le</span><br><span class="line">F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0       1       0  0  80   0 -  6026 -      ?        00:00:10 systemd</span><br><span class="line">1 S     0       2       0  0  80   0 -     0 -      ?        00:00:00 kthreadd</span><br></pre></td></tr></table></figure>

<ul>
<li>F：进程标志，说明进程的权限，常见标志有：<ul>
<li>1：进程可以复制，但是不能执行</li>
<li>4：进程使用超级用户权限</li>
</ul>
</li>
<li>S：进程状态。具体的状态和“ps aux”命令中STAT状态一致</li>
<li>UID：进程是哪个UID用户调用运行的</li>
<li>PID：进程的ID号</li>
<li>PPID：代进程的ID号</li>
<li>C：该进程的CPU使用率，单位是百分比</li>
<li>PRI：进程的优先级，数值越小该进程优先级越高，越快被CPU执行</li>
<li>NI：进程的优先级，也是数值越小越早被执行</li>
<li>ADDR：该进程在内存的哪个位置</li>
<li>SZ：该进程占用多大内存</li>
<li>WCHAN：该进程是否运行。“-”代表正在运行</li>
<li>TTY：该进程由哪个终端产生</li>
<li>TIME：该进程占用CPU的运算时间，注意不是系统时间</li>
<li>CMD：产生此进程的命令名</li>
</ul>
<h4 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# top [选项]</span><br><span class="line">选项：</span><br><span class="line">  -d 秒数：    指定top命令每隔几秒更新。默认是3秒。</span><br><span class="line">  -b:  		  使用批处理模式输出。一般和&quot;-n&quot;选项合用，用于把top命令重定向到文件中 </span><br><span class="line">  -n 次数:	 指定top命令执行的次数。一般和&quot;-b&quot;选项合用</span><br><span class="line">  -p:		   指定PID。只查看某个PID的进程</span><br><span class="line">  -s:          使top在安全模式运行，避免在交互模式中出现错误</span><br><span class="line">  -u 用户名:    只监听某个用户的进程</span><br><span class="line">在top命令的交互模式当中可以执行的命令：</span><br><span class="line">  ？或h:	   显示交互模式的帮助</span><br><span class="line">  P:		以CPU使用率排序，默认就是此项</span><br><span class="line">  M:		以内存的使用率排序</span><br><span class="line">  N:		以PID排序</span><br><span class="line">  T:		按照CPU的累积运算时间排序，也就是用于TIME+项排序</span><br><span class="line">  k:		按照PID号，给予某个进程一个信号，一般用于终止某个进程，信号9是强制终止的信号</span><br><span class="line">  r:		按照PID号，给某个进程重设优先级（Nice）值</span><br><span class="line">  q:		退出top</span><br></pre></td></tr></table></figure>

<p>top执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 20:40:42 up 1 day, 11:10,  1 user,  load average: 0.62, 0.43, 0.45</span><br><span class="line">任务: 394 total,   1 running, 385 sleeping,   8 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  1.9 us,  3.9 sy,  0.0 ni, 94.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st </span><br><span class="line">MiB Mem :   6865.1 total,    245.4 free,   4582.3 used,   2676.1 buff/cache     </span><br><span class="line">MiB Swap:   2048.0 total,    789.7 free,   1258.3 used.   2282.8 avail Mem </span><br><span class="line"> 进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND                                                     </span><br><span class="line"> 231207 ben       20   0   17672   5632   3456 R  23.1   0.1   0:00.06 top                                                       </span><br><span class="line">      1 root      20   0   24104  14620   9348 S   0.0   0.2   0:11.09 systemd                                                   </span><br><span class="line">      2 root      20   0       0      0      0 S   0.0   0.0   0:00.06 kthreadd                                                   </span><br><span class="line">      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_workqueue_release        </span><br></pre></td></tr></table></figure>

<p>top命令的输出内容是动态的，默认每3秒刷新一次。命令的输出主要分为两大部分；第一部分是前五行，显示的是整个系统的资源使用状况，我们就是通过这些输出判断服务器的健康状态；第二部分从第六行开始，显示的是系统中进程的信息。</p>
<ul>
<li><p>第一部分内容</p>
<ul>
<li><p>第一行信息为任务队列信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>20:40:42</td>
<td>系统当前时间</td>
</tr>
<tr>
<td>up 1 day, 11:10</td>
<td>系统的运行时间，本机已经运行1天11小时10分钟</td>
</tr>
<tr>
<td>1 user</td>
<td>当前登录了1个用户</td>
</tr>
<tr>
<td>load average: 0.62, 0.43, 0.45</td>
<td>系统在之前1分钟，5分钟，15分钟的平均负载。如果CPU是单核，则这个数超过1，就是高负载。如果CPU是四核，则这个数超过4，就是高负载。（这个平均负载完全是个人经验来进行判断的，一般认为不应该超过服务器CPU的核数。）</td>
</tr>
</tbody></table>
</li>
<li><p>第二行为进程信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>任务: 394 total</td>
<td>系统中的进程总数</td>
</tr>
<tr>
<td>1 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>385 sleeping</td>
<td>睡眠的进程</td>
</tr>
<tr>
<td>8 stopped</td>
<td>正在停止的进程</td>
</tr>
<tr>
<td>0 zombie</td>
<td>僵尸进程。如果不是0，需要手工检查僵尸进程</td>
</tr>
</tbody></table>
</li>
<li><p>第三行为CPU信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%Cpu(s):  1.9 us</td>
<td>用户模式占用的CPU百分比</td>
</tr>
<tr>
<td>3.9 sy</td>
<td>系统模式占用的CPU百分比</td>
</tr>
<tr>
<td>0.0 ni</td>
<td>改变过优先级的用户进程占用的CPU百分比</td>
</tr>
<tr>
<td>94.2 id</td>
<td>空闲CPU的CPU百分比</td>
</tr>
<tr>
<td>0.0 wa</td>
<td>等待输入&#x2F;输出的进程的占用CPU百分比</td>
</tr>
<tr>
<td>0.0 hi</td>
<td>硬中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td>0.0 si</td>
<td>软中断请求服务占用的CPU百分比</td>
</tr>
<tr>
<td>0.0 st</td>
<td>st（Steal time）虚拟时间百分比。就是当有虚拟机时，虚拟CPU等待实际CPU的时间百分比</td>
</tr>
</tbody></table>
</li>
<li><p>第四行为物理内存信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Mem :   6865.1 total</td>
<td>物理内存的总量</td>
</tr>
<tr>
<td>245.4 free</td>
<td>空闲的物理内存数量</td>
</tr>
<tr>
<td>4582.3 used</td>
<td>已经使用的物理内存数量</td>
</tr>
<tr>
<td>2676.1 buff&#x2F;cache</td>
<td>作为缓冲&#x2F;缓存的内存数量</td>
</tr>
</tbody></table>
</li>
<li><p>第五行为交换分区（swap）信息</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Swap:   2048.0 total</td>
<td>交换分区（虚拟分区）的总大小</td>
</tr>
<tr>
<td>789.7 free</td>
<td>空闲交换分区的大小</td>
</tr>
<tr>
<td>1258.3 used</td>
<td>已经使用的交互分区的大小</td>
</tr>
<tr>
<td>2282.8 avail Mem</td>
<td>可利用的交互分区的大小</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>第二部分内容</p>
<p>主要是系统进程信息。这部分和ps命令的输出比较类似，只是如果在终端中执行top命令不能看到所有的进程，而只能看到占比靠前的进程。</p>
<ul>
<li>PID: 进程ID</li>
<li>USER: 该进程所属的用户</li>
<li>PR: 优先级，数值越小优先级越高</li>
<li>NI: 优先级，数值越小优先级越高</li>
<li>VIRT: 该进程使用的虚拟内存的大小，单位KB</li>
<li>RES: 该进程使用的物理内存的大小，单位KB</li>
<li>SHR: 共享内存大小，单位KB</li>
<li>%CPU: 该进程占用CPU的百分比</li>
<li>%MEM: 该进程占用内存的百分比</li>
<li>TIME+: 该进程总共占用的CPU时间</li>
<li>COMMAND: 进程的命令名</li>
</ul>
</li>
</ul>
<p>top命令查看某一个进程:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只查看PID为15273的apache进程</span></span><br><span class="line">[root@localhost ~]# top -p 15273</span><br></pre></td></tr></table></figure>

<p>在top命令的交互界面中按“q”键会退出top命令。也可以按“?”或“h”得到top命令交互界面的帮助信息。也可以按“k”键终止某个进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# top</span><br><span class="line">top - 21:30:33 up 1 day, 12:00,  1 user,  load average: 2.53, 1.43, 1.12</span><br><span class="line">任务: 391 total,   1 running, 382 sleeping,   8 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  5.5 us,  3.1 sy,  0.0 ni, 91.2 <span class="built_in">id</span>,  0.2 wa,  0.0 hi,  0.1 si,  0.0 st</span> </span><br><span class="line">MiB Mem :   6865.1 total,    196.3 free,   4604.8 used,   2714.5 buff/cache     </span><br><span class="line">MiB Swap:   2048.0 total,    742.7 free,   1305.3 used.   2260.2 avail Mem </span><br><span class="line">PID to signal/kill [default pid = 166294]                               # 按&quot;k&quot;键，会提示输入要杀死进程的PID</span><br></pre></td></tr></table></figure>

<p>如果在操作终端执行top命令，并不能看到系统中所有的进程，默认看到的只是CPU占比靠前的进程。如果我们想要看到所有的进程可以把top命令的结果重定向到文件当中即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">让top命令只执行一次，然后把结果保存到top.log文件中。这样就能看到所有的进程了</span></span><br><span class="line">[root@localhost ~]# top -b -n 1 &gt; /root/top.log</span><br></pre></td></tr></table></figure>



<h4 id="pstree命令"><a href="#pstree命令" class="headerlink" title="pstree命令"></a>pstree命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pstree [选项]</span><br><span class="line">选项：</span><br><span class="line">  -p:		显示进程的PID</span><br><span class="line">  -u:		显示进程的所属用户</span><br></pre></td></tr></table></figure>



<h3 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h3><p>系统中可以识别的信号较多，可以使用命令“kill -l”或“man 7 signal”来查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# kill -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure>

<p>主要信号：</p>
<table>
<thead>
<tr>
<th>信号代号</th>
<th>信号名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>该信号让进程立即关闭，然后重新读取配置文件之后重启。</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>程序终止信号，用于终止前台进程。相当于输出ctrl+c快捷键。</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>在发生致命的算术运算错误时发出，不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术的错误。</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。一般用于强制终止进程。</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>时钟定时信号，计算的是实际的时间或时钟时间. alarm函数使用该信号。</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>正常结束进程的信号，kill命令的默认信号。有时如果进程已经发生问题，这个信号是无法正常终止进程的，我们才会尝试SIGKILL信号，也就是信号9。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>该信号可以让暂停的进程恢复执行，本信号不能被阻断。</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>该信号可以暂停前台进程，相当于输入ctrl+z快捷键。本信号不能被阻断。</td>
</tr>
</tbody></table>
<h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# kill [信号] PID</span><br></pre></td></tr></table></figure>

<p>使用“-1”信号，让进程重启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# kill -1 2246</span><br></pre></td></tr></table></figure>

<p>使用“-19”信号，让进程暂停：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用vim命令编辑一个文件，不要退出</span></span><br><span class="line">[root@localhost ~]# vim /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">换不同的终端，查看下这个进程的状态</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vim&quot; | grep -v &quot;grep&quot;</span><br><span class="line">ben       271840  0.2  0.1  31228 13568 pts/0    Sl+  16:00   0:00 vim /tmp/test.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用-19信号，让PID是271840的进程暂停。相当于在vim界面按<span class="string">&quot;ctrl+z&quot;</span>快捷键</span></span><br><span class="line">[root@localhost ~]# kill -19 271840</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">271840进程的状态变成为T(暂停)状态。271840进程会卡在后台，如果想要恢复可以使用<span class="string">&quot;kill -9 271840&quot;</span>强制终止进程。</span></span><br><span class="line">[root@localhost ~]# ps aux | grep &quot;vim&quot; | grep -v &quot;grep&quot;</span><br><span class="line">ben       271840  0.0  0.1  31228 13568 pts/0    Tl   16:00   0:00 vim /tmp/test.txt</span><br></pre></td></tr></table></figure>



<h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# killall [选项][信号] 进程名</span><br><span class="line">选项：</span><br><span class="line">  -i:	交互式，询问是否要杀死某个进程</span><br><span class="line">  -l:	忽略进程名的大小写</span><br></pre></td></tr></table></figure>

<p>交互式杀死docker进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ps aux | grep &quot;docker-proxy&quot;</span><br><span class="line">root        5331  0.0  0.0 1746028 2160 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 127.0.0.1 -host-port 9090 -container-ip 172.23.0.2 -container-port 9090</span><br><span class="line">root        5345  0.0  0.0 1746028 2076 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 7891 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5352  0.0  0.0 1819504 2008 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 7891 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5366  0.0  0.0 1745772 2152 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5373  0.0  0.0 1746028 2088 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto udp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5388  0.0  0.0 1894260 4148 ?        Sl   3月04   0:02 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5395  0.0  0.0 1745772 2104 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 1090 -container-ip 172.23.0.2 -container-port 7891</span><br><span class="line">root        5409  0.0  0.0 1671784 2204 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 7890 -container-ip 172.23.0.2 -container-port 7890</span><br><span class="line">root        5416  0.0  0.0 1671784 2168 ?        Sl   3月04   0:00 /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 7890 -container-ip 172.23.0.2 -container-port 7890</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式杀死docker进程</span></span><br><span class="line">[root@localhost ~]# killall -i docker-proxy</span><br><span class="line">杀死 docker-proxy(5331) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5345) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5352) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5366) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5373) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5388) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5395) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5409) ? (y/N) n</span><br><span class="line">杀死 docker-proxy(5416) ? (y/N) n</span><br></pre></td></tr></table></figure>



<h4 id="pkill命令"><a href="#pkill命令" class="headerlink" title="pkill命令"></a>pkill命令</h4><p>pkill命令和killall命令非常类似，也是按照进程名来杀死进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pkill [选项] [信号] 进程名</span><br><span class="line">选项：</span><br><span class="line">  -t 终端号:	按照终端号踢出用户</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制杀死从pts/1虚拟终端登录的进程</span></span><br><span class="line">[root@localhost ~]# pkill -9 -t pts/1</span><br></pre></td></tr></table></figure>



<h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><h3 id="工作管理简介"><a href="#工作管理简介" class="headerlink" title="工作管理简介"></a>工作管理简介</h3><p>后台管理有个事项需要注意：</p>
<ul>
<li>前台是指当前可以操控和执行命令的这个操作环境，后台是指工作可以自行运行，但是不能直接用ctrl+c来终止它，只能使用fg&#x2F;bg来调用工作；</li>
<li>当前的登录终端，只能管理当前终端的工作，而不能管理其他登录终端的工作。如tty1登录终端是不能管理tty2终端中的工作的；</li>
<li>放入后台的命令必须可以持续运行一段时间，这样我们才能捕捉和操作这个工作。如果把1s命令放入后台执行，它很快就会执行完成，我们很难操作它。</li>
<li>放入后台执行的命令不能和前台用户有交互或需要前台输入，否则放入后台只能暂停，而不能执行。比如vim命令放入后台只能暂停，而不能执行，因为vim需要前台输入信息。top命令也不能放入后台执行，而只能放入后台暂停，因为top命令需要和前台有交互。</li>
</ul>
<h3 id="如何把命令放入后台"><a href="#如何把命令放入后台" class="headerlink" title="如何把命令放入后台"></a>如何把命令放入后台</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令 &amp;"></a>命令 &amp;</h4><p>第一种方法把命令放入后台的方法是在命令后面加入“空格&amp;”，这种方法放入后台的命令，在后台是执行状态。但是注意，放入后台执行的命令不能与前台有交互，否则这个命令是不能在后台执行的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">find命令放入后台执行，每个后台命令会分配一个工作号，命令既然可以执行，就会有进程产生，所以也会有进程号。</span></span><br><span class="line">[root@localhost ~]# find / -name install.log &amp;</span><br><span class="line">[2] 284313</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[工作号] 进程号</span></span><br></pre></td></tr></table></figure>

<p>虽然find命令在执行，但是当前操作还是可以进行其他命令操作的。如果在终端出现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">证明后台这个任务已经完成了，当然命令如果有执行结果的话，也会显示到操作终端上。[2]是这个命令的工作号，+号代表这个任务是最近一个被放入后台的工作。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">### ctrl+z</span></span></span><br><span class="line"></span><br><span class="line">第二种方法是在命令执行过程中按ctrl+z快捷键，命令在后台是暂停状态。</span><br><span class="line"></span><br><span class="line">使用这种方法放入后台的命令，就算是不和前台有交互，能在后台执行的命令，也是暂停状态，ctrl+z快捷键就是暂停的快捷键。</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在top命令执行的过程中，按下ctrl+z快捷键</span></span><br><span class="line">[root@localhost ~]# top</span><br><span class="line">[1]+  已停止               top</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提示命令被放入后台，工作号是1，状态是暂停。而且虽然top命令没有结束，也能取得控制台权限</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩一下/etc/目录</span></span><br><span class="line">[root@localhost ~]# tar -zcf etc.tar.gz /etc</span><br><span class="line">tar: 从成员名中删除开头的&quot;/&quot;</span><br><span class="line">tar: 从硬连接目标中删除开头的&quot;/&quot;</span><br><span class="line">^Z                              # 执行过程中，按下ctrl+z快捷键</span><br><span class="line">[2]+   Stopped    tar -zcf etc.tar.gz /etc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令被放入后台，工作号是2，状态是暂停</span></span><br></pre></td></tr></table></figure>



<h3 id="后台命令管理"><a href="#后台命令管理" class="headerlink" title="后台命令管理"></a>后台命令管理</h3><h4 id="查看后台的工作"><a href="#查看后台的工作" class="headerlink" title="查看后台的工作"></a>查看后台的工作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# jobs [-l]</span><br><span class="line">选项：</span><br><span class="line">  -l:	显示工作的PID</span><br></pre></td></tr></table></figure>

<h4 id="将后台暂停的工作恢复到前台执行"><a href="#将后台暂停的工作恢复到前台执行" class="headerlink" title="将后台暂停的工作恢复到前台执行"></a>将后台暂停的工作恢复到前台执行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# fg %工作号</span><br><span class="line">参数：</span><br><span class="line">  %工作号:		%号可以省略，但是注意工作号和PID的区别</span><br></pre></td></tr></table></figure>

<h4 id="把后台暂停的工作恢复到后台执行"><a href="#把后台暂停的工作恢复到后台执行" class="headerlink" title="把后台暂停的工作恢复到后台执行"></a>把后台暂停的工作恢复到后台执行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# bg %工作号</span><br></pre></td></tr></table></figure>

<h4 id="后台命令脱离登录终端运行"><a href="#后台命令脱离登录终端运行" class="headerlink" title="后台命令脱离登录终端运行"></a>后台命令脱离登录终端运行</h4><p>我们已经知道把命令放入后台，只能在当前登录终端执行。那如果我是远程管理的服务器，在远程终端中执行了后台命令，这时我退出终端，这个后台命令还能继续执行吗？当然是不行的， 这个后台命令会被终止。如果确实需要在远程终端中执行某些后台命令，可以这么做：</p>
<ul>
<li>把需要后台执行的命令加入&#x2F;etc&#x2F;rc.local文件，让系统在启动时执行这个后台程序。这种方法的问题是，服务器是不能随便重启的，万一有临时后台任务，就不能执行。</li>
<li>使用系统定时任务，让系统在指定的时间执行某个后台命令。这样放入后台的命令与终端无关，是不依赖登录终端的。</li>
<li>使用nohup命令。</li>
</ul>
<p>nohup命令的作用就是让后台工作在离开操作终端时，也能够正确的在后台执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nohup [命令] &amp; </span><br></pre></td></tr></table></figure>

<p>用find命令打印&#x2F;下所有文件，放入后台执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nohup find / -print &gt; /root/file.log &amp;</span><br><span class="line">[3] 2349</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有提示信息</span></span><br><span class="line">[root@localhost ~]# nohup：忽略输入并把输出追加到&quot;nohup.out&quot;</span><br></pre></td></tr></table></figure>



<h2 id="系统资源查看"><a href="#系统资源查看" class="headerlink" title="系统资源查看"></a>系统资源查看</h2><h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>监控系统资源</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vmstat [刷新延时 刷新次数]</span><br></pre></td></tr></table></figure>

<p>使用vmstat检测，每1秒刷新一次，共刷新3次：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vmstat 1 3</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- -------cpu-------</span><br><span class="line"> r  b 交换 空闲 缓冲 缓存   si   so    bi    bo   in   cs us sy id wa st gu</span><br><span class="line"> 1  0 1975536 315116 888372 2032876    1   13    58    88  912    6  4  2 94  0  0  0</span><br><span class="line"> 0  0 1975536 296724 888372 2032912    8    0     8     0 2845 3503  4  2 94  0  0  0</span><br><span class="line"> 3  0 1975536 294804 888372 2032916    0    0     0     0 2592 3581  1  2 97  0  0  0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>procs：进程信息字段</p>
<ul>
<li>r：等待运行的进程数，数量越大，系统越繁忙。</li>
<li>b：不可被唤醒的进程数量，数量越大，系统越繁忙。</li>
</ul>
</li>
<li><p>memory：内存信息字段</p>
<ul>
<li>swpd：虚拟内存的使用情况，单位KB</li>
<li>free：空闲的内存容量，单位KB</li>
<li>buff：缓冲的内存容量，单位KB</li>
<li>cache：缓存的内存容量，单位KB</li>
</ul>
</li>
<li><p>swap：交换分区的信息字段</p>
<ul>
<li>si：从磁盘中交换到内存中数据的数量，单位KB</li>
<li>so：从内存中交换到磁盘中数据的数量，单位KB。此两个数越大，证明数据需要经常在磁盘和内存之间交换，系统性能越差。</li>
</ul>
</li>
<li><p>io：磁盘读写信息字段</p>
<ul>
<li>bi：从块设备读入数据的总量，单位是块</li>
<li>bo：写到块设备的数据的总量，单位是块。此两个数越大，代表系统的I&#x2F;O越繁忙。</li>
</ul>
</li>
<li><p>system：系统信息字段</p>
<ul>
<li>in：每秒被中断的进程次数</li>
<li>cs：每秒钟进行的事件切换次数。此两个数越大，代表系统与接口设备的通信非常繁忙。</li>
</ul>
</li>
<li><p>cpu：cpu信息字段</p>
<ul>
<li>us：非内核进程消耗cpu运算时间的百分比</li>
<li>sy：内核进程消耗cpu运算时间的百分比</li>
<li>id：空闲cpu的百分比</li>
<li>wa：等待I&#x2F;0所消耗的cpu百分比</li>
<li>st：被虚拟机所盗用的cpu百分比</li>
</ul>
</li>
</ul>
<h3 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h3><p>显示开机时内核检测信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看CPU信息</span></span><br><span class="line">[root@localhost ~]# dmesg | grep CPU</span><br></pre></td></tr></table></figure>



<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>查看内存使用状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# free [-b|-k|-m|-g]</span><br><span class="line">选项：</span><br><span class="line">  -b:	以字节为单位显示</span><br><span class="line">  -k:	以KB为单位显示，默认是以KB为单位显示</span><br><span class="line">  -m:	以MB为单位显示</span><br><span class="line">  -g:	以GB为单位显示</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# free -h</span><br><span class="line">               total        used        free      shared  buff/cache   available</span><br><span class="line">内存：         6.7Gi       4.2Gi       283Mi       277Mi       2.8Gi       2.5Gi</span><br><span class="line">交换：         2.0Gi       1.9Gi       122Mi</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一行</p>
<ul>
<li>total：总内存数。</li>
<li>used：已经使用的内存数。</li>
<li>free：空闲的内存数。</li>
<li>shared：多个进程共享的内存总数。</li>
<li>buff&#x2F;cache：缓冲&#x2F;缓存内存数。</li>
</ul>
</li>
<li><p>第二行</p>
<ul>
<li>total：swap的总数</li>
<li>used：已经使用的swap数</li>
<li>free：空闲的swap数。</li>
</ul>
</li>
</ul>
<h3 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h3><p>CPU的主要信息保存在&#x2F;proc&#x2F;cpuinfo这个文件中，只要查看这个文件，就可以知道cpu的相关信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /proc/cpuinfo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">逻辑CPU编号</span></span><br><span class="line">processor	: 0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU制造厂商</span></span><br><span class="line">vendor_id	: AuthenticAMD</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">产品的系列代号</span></span><br><span class="line">cpu family	: 23</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU系列代号</span></span><br><span class="line">model		: 24</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CPU系列的名字，编号，主频</span></span><br><span class="line">model name	: AMD Ryzen 7 3700U with Radeon Vega Mobile Gfx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新版本</span></span><br><span class="line">stepping	: 1</span><br><span class="line">microcode	: 0x8108109</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实际主频</span></span><br><span class="line">cpu MHz		: 1372.114</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">二级缓存</span></span><br><span class="line">cache size	: 512 KB</span><br></pre></td></tr></table></figure>



<h3 id="查看本机登录用户信息"><a href="#查看本机登录用户信息" class="headerlink" title="查看本机登录用户信息"></a>查看本机登录用户信息</h3><p>如果我们想要知道Linux服务器上目前已经登录的用户信息，可以使用w或who命令来进行查询。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# w</span><br><span class="line"> 17:54:27 up 2 days,  8:24,  1 user,  load average: 0.82, 0.89, 1.04</span><br><span class="line">USER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU  WHAT</span><br><span class="line">ben               -                二09    2:27m  0.00s  0.04s lightdm --session-child 13 20</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行：和top命令的第一行非常类似，主要显示了系统当前时间，开机多久(up)，有多少用户登录(users)，1分钟、5分钟、15分种前的平均负载(load average)。</li>
<li>第二行：项目的说明<ul>
<li>USER：登录的用户名</li>
<li>TTY：登录终端</li>
<li>FROM：从哪个IP地址登录</li>
<li>LOGIN@：登录时间</li>
<li>IDLE：用户闲置时间</li>
<li>JCPU：指的是和该终端连接的所有进程占用的CPU运算时间。这个时间里并不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间</li>
<li>PCPU：是指当前进程所占用的CPU运算时间</li>
<li>WHAT：当前正在运行的命令</li>
</ul>
</li>
<li>第三行：代表一个用户</li>
</ul>
<p>who命令比w命令稍微简单一点，也可以用来查看系统中已经登录的用户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# who</span><br><span class="line">ben      tty7         2025-03-04 09:29 (:0)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用户名  登录终端      登录时间(登录来源IP地址)</span></span><br></pre></td></tr></table></figure>



<h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>uptime命令的作用就是显示系统的启动时间和平均负载，也就是top命令的第一行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uptime</span><br><span class="line"> 18:05:21 up 2 days,  8:35,  1 user,  load average: 1.61, 1.24, 1.10</span><br></pre></td></tr></table></figure>



<h3 id="查看系统与内核相关信息"><a href="#查看系统与内核相关信息" class="headerlink" title="查看系统与内核相关信息"></a>查看系统与内核相关信息</h3><p>使用uname命令查看内核的相关信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# uname [选项]</span><br><span class="line">选项：</span><br><span class="line">  -a:	查看系统所有相关信息</span><br><span class="line">  -r:   查看内核版本</span><br><span class="line">  -s:   查看内核名称</span><br></pre></td></tr></table></figure>

<p>如果我们想要判断当前系统的位数，可以通过file命令来判断系统文件(主要系统命令)的位数来推断系统的位数。如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# file /bin/ls</span><br><span class="line">/bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3eca7e3905b37d48cf0a88b576faa7b95cc3097b, for GNU/Linux 3.2.0, stripped</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">很明显，当前系统是64位的</span></span><br></pre></td></tr></table></figure>

<p>如果想要查询当前Linux系统的发行版本，可以使用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lsb_release -a </span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID:	Ubuntu</span><br><span class="line">Description:	Ubuntu 24.04.1 LTS</span><br><span class="line">Release:	24.04</span><br><span class="line">Codename:	noble</span><br></pre></td></tr></table></figure>



<h2 id="系统定时任务"><a href="#系统定时任务" class="headerlink" title="系统定时任务"></a>系统定时任务</h2><h3 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h3><p>循环执行定时任务。</p>
<p>1）crond服务管理与访问控制</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>软件包安装</title>
    <url>/2025/02/25/%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="软件包安装"><a href="#软件包安装" class="headerlink" title="软件包安装"></a>软件包安装</h1><h2 id="1-软件包分类"><a href="#1-软件包分类" class="headerlink" title="1. 软件包分类"></a>1. 软件包分类</h2><ul>
<li>源码包</li>
<li>二进制包</li>
</ul>
<h2 id="2-源码包"><a href="#2-源码包" class="headerlink" title="2. 源码包"></a>2. 源码包</h2><h3 id="1）源码包优点"><a href="#1）源码包优点" class="headerlink" title="1）源码包优点"></a>1）源码包优点</h3><ul>
<li>开源，如果有足够的能力，可以修改源码包。</li>
<li>可以自由选择所需的功能</li>
<li>软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高</li>
<li>卸载方便</li>
</ul>
<h3 id="2）源码包缺点"><a href="#2）源码包缺点" class="headerlink" title="2）源码包缺点"></a>2）源码包缺点</h3><ul>
<li>安装过程步骤较多，尤其安装较大的软件集合时(如LAMP环境搭建)，容易出现拼写错误</li>
<li>编译过程时间较长，安装比二进制安装时间长</li>
<li>因为是编译安装，安装过程中一旦报错新手很难解决</li>
</ul>
<h2 id="3-二进制包"><a href="#3-二进制包" class="headerlink" title="3. 二进制包"></a>3. 二进制包</h2><p>Linux系列：Debian和RedHat。</p>
<h3 id="1）二进制包分类"><a href="#1）二进制包分类" class="headerlink" title="1）二进制包分类"></a>1）二进制包分类</h3><p>a）DPKG包</p>
<p>是由Debian Linux所开发出来的包管理机制，通过DPKG包，Debian Linux就可以进行软件包管理。主要应用在Debian和Ubuntu中。</p>
<p>b）RPM包</p>
<p>是由Red Hat公司所开发的包管理系统。功能强大，安装、升级、查询和卸载都非常简单和方便。目前很多Linux都在使用这种包管理方式，包括Fedora、CentOS、SuSE等。</p>
<h3 id="2）RPM包特点"><a href="#2）RPM包特点" class="headerlink" title="2）RPM包特点"></a>2）RPM包特点</h3><p>RPM包优点：</p>
<ul>
<li>包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载</li>
<li>安装速度比源码包安装快的多</li>
</ul>
<p>RPM包缺点：</p>
<ul>
<li>经过编译，不再可以看到源代码</li>
<li>功能选择不如源码包灵活</li>
<li>依赖性。有时我们会发现需要安装软件包a时需要先安装b和c，而安装b时需要安装d和e。这时需要先安装d和e，再安装b和c，最后才能安装a包。</li>
</ul>
<h3 id="3）RPM包依赖"><a href="#3）RPM包依赖" class="headerlink" title="3）RPM包依赖"></a>3）RPM包依赖</h3><p>a）树形依赖</p>
<p>a——&gt;b——&gt;c</p>
<p>b）环形依赖</p>
<p>a——&gt;b——&gt;c——&gt;a</p>
<p>c）模块依赖</p>
<p>什么是模块依赖？例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh mysql-connector-odbc-5.2.5-7.el7.x86_64.rpm</span><br><span class="line">错误：依赖检测失败：</span><br><span class="line">    libodbc.so.2()(64bit) 被 mysql-connector-odbc-5.2.5-7.el7.x86_64 需要</span><br><span class="line">    libodbcinst.so.2()(64bit) 被 mysql-connector-odbc-5.2.5-7.el7.x86_64 需要</span><br></pre></td></tr></table></figure>

<p>发现报错，需要安装”libodbc.so.2”函数库文件，这时会发现在光盘中根本找不到这个文件，那是因为函数库没有单独成包，是包含在某一个软件包中的，而如果知道在哪个软件包中，需要查询网站<a href="http://www.rpmfind.net./">www.rpmfind.net。</a></p>
<h3 id="4）RPM包安装方法"><a href="#4）RPM包安装方法" class="headerlink" title="4）RPM包安装方法"></a>4）RPM包安装方法</h3><ul>
<li>手工安装</li>
<li>yum在线安装</li>
</ul>
<h2 id="4-软件包选择建议"><a href="#4-软件包选择建议" class="headerlink" title="4. 软件包选择建议"></a>4. 软件包选择建议</h2><ul>
<li>源码包：如果软件包是给大量客户端提供访问，建议使用源码包安装，源码包效率更高(LAMP)。</li>
<li>RPM包：如果软件包是给Linux底层使用，或只给少量客户访问，建议使用RPM包安装，因为RPM包简单。</li>
</ul>
<h2 id="5-RPM手工安装"><a href="#5-RPM手工安装" class="headerlink" title="5. RPM手工安装"></a>5. RPM手工安装</h2><p>rpm数据库路径：&#x2F;var&#x2F;lib&#x2F;rpm&#x2F;</p>
<h3 id="1）RPM包命名规则"><a href="#1）RPM包命名规则" class="headerlink" title="1）RPM包命名规则"></a>1）RPM包命名规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">httpd-2.2.15-15.el6.centos.1.i686.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li>httpd：软件包名</li>
<li>2.2.15：软件版本</li>
<li>15：软件发布的次数</li>
<li>el6：软件发行商。el6是RedHat公司发布，适合RHEL6.x(Red Hat Enterprise Linux)和CentOS6.x下使用</li>
<li>i686：适合的硬件平台。RPM包可以在不同的硬件平台安装，选择适合不同CPU的软件版本，可以最大化的发挥CPU性能，所以出现了所谓的i386（386以上计算机都可以安装）、i586（586以上的计算机都可以安装）、i686（奔腾II以上计算机都可以安装，目前所有的CPU都是奔腾II以上，所以这个软件版本居多）、x86_64（64位CPU可以安装）和noarch（没有硬件限制）等文件名了。</li>
<li>rpm：rpm包的扩展名，我们说过Linux下文件不是靠扩展名区分文件类型，也就是Linux中扩展名没有任何意义。可是这里怎么又出现了扩展名呢？如果RPM包不用“rpm”作为扩展名，系统可以正确识别没有问题，可是管理员很难识别这是个什么样的软件。</li>
</ul>
<h3 id="2）RPM包手工命令安装"><a href="#2）RPM包手工命令安装" class="headerlink" title="2）RPM包手工命令安装"></a>2）RPM包手工命令安装</h3><p>a）默认安装位置</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;etc&#x2F;</td>
<td>配置文件安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;bin&#x2F;</td>
<td>可执行的命令安装目录</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;lib&#x2F;</td>
<td>程序所使用的函数库保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;doc&#x2F;</td>
<td>基本的软件使用手册保存位置</td>
</tr>
<tr>
<td>&#x2F;usr&#x2F;share&#x2F;man&#x2F;</td>
<td>帮助文件保存位置</td>
</tr>
</tbody></table>
<p>b）安装命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh 包全名</span><br><span class="line">选项：</span><br><span class="line">  -i    install安装(install)</span><br><span class="line">  -v    显示更详细的信息(verbose)</span><br><span class="line">  -h    打印#显示安装进度(hash)</span><br></pre></td></tr></table></figure>

<p>其他选项：</p>
<ul>
<li>–nodeps：不检测依赖性安装。安装软件时会检测依赖性，确定所需的底层软件是否安装。如果没有安装则会报错。如果我不管依赖性，想强行安装，可以使用这个选项。这样不检测依赖性安装的软件是不能使用的，所以不建议这样做。</li>
<li>–replacefiles：替换文件安装。如果安装软件包，可是包中部分文件已经存在，那么正常安装时，会报错”某个文件已经存在”从而导致软件无法安装，使用这个选项可以忽视这个报错，而覆盖安装。</li>
<li>–replacepkgs：替换软件包安装。如果软件包已经安装，此选项可以把软件包重复安装一遍。</li>
<li>–force：强制安装。不管是否已经安装，都重新安装。就是–replacefiles和–replacepkgs的综合。</li>
<li>–test：测试安装。不会实际安装，只是检测一下依赖性。</li>
<li>–prefix：指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。如果指定了安装路径，软件没有安装到系统默认路径中的话，系统会找不到这些安装的软件，需要进行手工配置才能被系统识别。所以rpm包我们一般都采用默认路径安装：1）默认安装位置是系统的习惯位置。2）RPM包管理系统是有卸载命令的(数据库记录安装位置)</li>
</ul>
<p>c）服务启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># service启动</span><br><span class="line">service 服务名 start|stop|restart|status</span><br><span class="line">参数：</span><br><span class="line">  start:    启动服务</span><br><span class="line">  stop:     停止服务</span><br><span class="line">  restart:  重启服务</span><br><span class="line">  status:   查看服务状态</span><br><span class="line">  </span><br><span class="line">  # 标准启动</span><br><span class="line">  /etc/init.d/服务名 start|stop|restart|status</span><br></pre></td></tr></table></figure>



<h3 id="3）RPM包升级"><a href="#3）RPM包升级" class="headerlink" title="3）RPM包升级"></a>3）RPM包升级</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -Uvh 包全名</span><br><span class="line">选项：</span><br><span class="line">  -U      升级安装，如果没有安装过，系统直接安装。如果安装过的版本较旧，则升级到新版本(upgrade)</span><br><span class="line"> </span><br><span class="line">rpm -Fvh 包全名</span><br><span class="line">选项：</span><br><span class="line">  -F      升级安装，如果没有安装过，则不会安装，必须安装有较旧版本，才能升级(freshen)</span><br></pre></td></tr></table></figure>



<h3 id="4）RPM包卸载"><a href="#4）RPM包卸载" class="headerlink" title="4）RPM包卸载"></a>4）RPM包卸载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -e 包名</span><br><span class="line">选项：</span><br><span class="line">  --nodeps      不检查依赖性</span><br><span class="line">  -e            卸载</span><br></pre></td></tr></table></figure>



<h3 id="5）RPM包查询"><a href="#5）RPM包查询" class="headerlink" title="5）RPM包查询"></a>5）RPM包查询</h3><p>a）查询软件包是否安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -q 包名</span><br><span class="line">选项：</span><br><span class="line">  -q：查询(query)</span><br></pre></td></tr></table></figure>



<p>b）查询系统中的所有安装软件包</p>
<p>可以查询Linux系统中所有已经安装的软件包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa</span><br><span class="line">选项：</span><br><span class="line">  -a：所有(all)</span><br></pre></td></tr></table></figure>

<p>可以用管道符来查看所需内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep 包名</span><br></pre></td></tr></table></figure>



<p>c）查询软件包的详细信息</p>
<p>可以查询已经安装的某个软件包的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qi 包名</span><br><span class="line">选项：</span><br><span class="line">  -i：查询软件信息(information)</span><br></pre></td></tr></table></figure>

<p>也可以查询还没有安装的软件包的详细信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qip 包全名</span><br><span class="line">选项：</span><br><span class="line">  -p：查询没有安装的软件包(package)</span><br></pre></td></tr></table></figure>



<p>d）查询软件包中的文件列表</p>
<p>可以查询已经安装的软件包中的文件列表和安装的完整目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ql 包名</span><br><span class="line">选项：</span><br><span class="line">  -l：列出软件包中所有的文件列表和软件所安装的目录(list)</span><br></pre></td></tr></table></figure>

<p>查询未安装的软件包中的文件列表和打算安装的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qlp 包全名</span><br><span class="line">选项：</span><br><span class="line">  -p：查询没有安装的软件包信息(package)</span><br></pre></td></tr></table></figure>



<p>e）查询系统文件属于哪个RPM包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qf 系统文件名</span><br><span class="line">选项：</span><br><span class="line">  -f：查询系统文件属于哪个软件包(file)</span><br></pre></td></tr></table></figure>



<p>f）查询软件包所依赖的软件包</p>
<p>查询系统中和已经安装的软件包有依赖关系的软件包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qR 包名</span><br><span class="line">选项：</span><br><span class="line">  -R：查询软件包的依赖性(requires)</span><br></pre></td></tr></table></figure>

<p>查询未安装的软件包的依赖包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qRp 包全名</span><br></pre></td></tr></table></figure>



<h3 id="6）验证"><a href="#6）验证" class="headerlink" title="6）验证"></a>6）验证</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验本机已经安装的所有软件包</span></span><br><span class="line">rpm -Va</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验指定RPM包中的文件(verify)</span></span><br><span class="line">rpm -V 已安装的名包</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">校验某个系统文件是否被修改</span></span><br><span class="line">rpm -Vf 系统文件名</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -V httpd</span><br><span class="line">S.5....T.    c             /etc/httpd/conf/httpd.conf</span><br><span class="line">验证内容    文件类型          文件名</span><br></pre></td></tr></table></figure>

<p>验证内容详情：</p>
<ul>
<li>S：文件大小是否改变</li>
<li>M：文件的类型或文件的权限(rwx)是否被改变</li>
<li>5：文件MD5校验和是否改变(可以看成文件内容是否改变)</li>
<li>D：设备的主从代码是否改变</li>
<li>L：文件路径是否改变</li>
<li>U：文件的属主(所有者)是否改变</li>
<li>G：文件的属组是否改变</li>
<li>T：文件的修改时间是否改变</li>
</ul>
<p>文件类型：</p>
<ul>
<li>c：配置文件(config file)</li>
<li>d：普通文档(documention)</li>
<li>g：“鬼”文件(ghost file)，很少见，就是该文件不应该被这个RPM包包含 </li>
<li>l：授权文件(license file)</li>
<li>r：描述文件(readme)</li>
</ul>
<h3 id="7）数字证书"><a href="#7）数字证书" class="headerlink" title="7）数字证书"></a>7）数字证书</h3><p>前面的校验方法只能对已经安装的RPM包中的文件进行校验，但是如果RPM包本身就被动过手脚，那么校验就不能解决问题了，我们就必须使用数字证书验证了。</p>
<p>数字证书特点：</p>
<ul>
<li>首先必须找到原厂的公钥文件，然后进行安装</li>
<li>再安装RPM包时会提取RPM包中的证书信息，然后和本机安装的原厂证书进行验证</li>
<li>如果验证通过，则允许安装；如果验证不通过，则不允许安装并警告</li>
</ul>
<p> a）数字证书导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm --import 数字证书文件</span><br><span class="line">选项：</span><br><span class="line">  --import：导入数字证书</span><br></pre></td></tr></table></figure>



<p>b）查询系统中安装好的数字证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep gpg-pubkey</span><br></pre></td></tr></table></figure>



<h3 id="8）RPM包中文件的提取"><a href="#8）RPM包中文件的提取" class="headerlink" title="8）RPM包中文件的提取"></a>8）RPM包中文件的提取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm2cpio 包全名 | cpio -idv . 文件的绝对路径</span><br></pre></td></tr></table></figure>

<p>rpm2cpio：将rpm包转换为cpio格式的命令。</p>
<p>cpio：是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件。</p>
<h2 id="6-RPM包在线安装-yum"><a href="#6-RPM包在线安装-yum" class="headerlink" title="6. RPM包在线安装(yum)"></a>6. RPM包在线安装(yum)</h2><h3 id="1）yum源文件解析"><a href="#1）yum源文件解析" class="headerlink" title="1）yum源文件解析"></a>1）yum源文件解析</h3><p>yum源配置文件保存在&#x2F;etc&#x2F;yum.repos.d&#x2F;目录中，文件的扩展名一定是”*.repo”。也就是说，yum源配置文件只要扩展名是”*.repo”就会生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /etc/yum.repos.d/</span><br><span class="line">CentOS-Base.repo    CentOS-Debuginfo.repo    CentOS-fasttrack.repo    CentOS-Media.repo    CentOS-Vault.repo</span><br></pre></td></tr></table></figure>

<p>这个目录中有5个yum源配置文件，默认情况下CentOS-Base.repo文件生效。</p>
<p>CentOS-Base.repo中有5个yum源容器，以base容器解释其内容详情：</p>
<ul>
<li>[base]：容器名称，一定要放在[]中。</li>
<li>name：容器说明，可以自己随便写。</li>
<li>mirrorlist：镜像站点，这个可以注释掉。</li>
<li>baseurl：yum源服务器的地址。默认是CentOS官方的yum源服务器，是可以使用的。如果觉得慢，可以改成国内yum源地址。</li>
<li>enabled：此容器是否生效，如果不写或写成enabled&#x3D;1则表示此容器生效，写成enabled&#x3D;0则表示此容器不生效。</li>
<li>gpgcheck：如果为1则表示RPM的数字证书生效，如果为0则表示RPM的数字证书不生效。</li>
<li>gpgkey：数字证书的公钥文件保存位置，不用修改。</li>
</ul>
<h3 id="2）搭建本地光盘yum源"><a href="#2）搭建本地光盘yum源" class="headerlink" title="2）搭建本地光盘yum源"></a>2）搭建本地光盘yum源</h3><p>a）放入CentOS安装光盘，并挂载光盘到指定位置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建cdrom目录，作为光盘的挂载点</span></span><br><span class="line">mkdir /mnt/cdrom</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">挂载光盘到/mnt/cdrom</span></span><br><span class="line">mount /dev/cdrom /mnt/cdrom/</span><br></pre></td></tr></table></figure>

<p>b）修改其他几个yum源配置文件的扩展名，让它们失效，因为只有扩展名是”*.repo”的文件才能作为yum源配置文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /etc/yum.repo.d</span><br><span class="line">mv CentOS-Base.repo CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure>

<p>c）修改光盘yum源配置文件CentOS-Media.repo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim CentOS-Media.repo</span><br><span class="line">[c6-media]</span><br><span class="line">name=CentOS-$releasever - Media</span><br><span class="line">baseurl=file:///mnt/cdrom/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1   # 让配置生效</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6</span><br></pre></td></tr></table></figure>

<p>d）查看是否生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询yum源所有可安装的软件包列表</span></span><br><span class="line">yum list</span><br></pre></td></tr></table></figure>



<h3 id="3）yum命令"><a href="#3）yum命令" class="headerlink" title="3）yum命令"></a>3）yum命令</h3><p>a）查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询yum所有安装包</span></span><br><span class="line">yum list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询yum源服务器中是否包含某个软件包</span></span><br><span class="line">yum list 包名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索yum源服务器上所有和关键字相关的软件包</span></span><br><span class="line">yum search 关键字</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查询指定软件包的信息</span></span><br><span class="line">yum info samba</span><br></pre></td></tr></table></figure>

<p>yum search搜索可以用于确定某个软件在哪个相关包当中。</p>
<p>b）安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install 包名</span><br><span class="line">选项：</span><br><span class="line">  install：    安装</span><br><span class="line">  -y：         自动回答yes。如果不加-y，那么每个安装的软件都需要手工回答yes</span><br></pre></td></tr></table></figure>



<p>c）升级</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y update 包名</span><br><span class="line">选项：</span><br><span class="line">  update:    升级</span><br><span class="line">  -y：       自动回答yes</span><br><span class="line"><span class="meta prompt_">  </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">升级本机所有软件包（包括内核，不常用）</span></span><br><span class="line">yum -y update</span><br></pre></td></tr></table></figure>



<p>d）卸载</p>
<p>除非你确定卸载的软件的依赖包不会对系统产生影响，否则不要执行yum的卸载，因为很有可能在卸载软件包的同时卸载的依赖包也是重要的系统文件，这就可能导致系统崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove 包名</span><br></pre></td></tr></table></figure>



<h3 id="4）yum组管理命令"><a href="#4）yum组管理命令" class="headerlink" title="4）yum组管理命令"></a>4）yum组管理命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有可用的软件组列表</span></span><br><span class="line">yum grouplist</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出软件组中包含的软件</span></span><br><span class="line">yum groupinfo 软件组名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装指定软件组</span></span><br><span class="line">yum groupinstall 软件组名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载指定软件组</span></span><br><span class="line">yum groupremove 软件组名</span><br></pre></td></tr></table></figure>



<h2 id="7-源码包安装"><a href="#7-源码包安装" class="headerlink" title="7.源码包安装"></a>7.源码包安装</h2><h3 id="1）注意事项"><a href="#1）注意事项" class="headerlink" title="1）注意事项"></a>1）注意事项</h3><p>a）源码包是从哪里来的？</p>
<p>源码包是通过官方网站下载的，如果需要使用，是需要单独下载的。</p>
<p>b）是否可以在系统中既安装rpm包的Apache，又安装源码包的Apache？</p>
<p>可以，因为两种安装方法安装的Apache，安装位置是不一样的：</p>
<ul>
<li>源码包必须指定安装位置(源码包没有安装数据库，没有删除命令)</li>
<li>RPM包不建议指定安装位置，建议安装在默认位置(RPM包安装的服务有标准卸载命令，不怕文件到处安装)</li>
</ul>
<h3 id="2）安装过程"><a href="#2）安装过程" class="headerlink" title="2）安装过程"></a>2）安装过程</h3><p>a）下载软件包</p>
<p>b）解压缩</p>
<p>c）进入解压目录</p>
<p>d）.&#x2F;configure（编译前准备）</p>
<p>这一步主要有三个作用：</p>
<ul>
<li>在安装之前需要检测系统环境是否符合安装要求。</li>
<li>定义需要的功能选项。”.&#x2F;configure”支持的功能选项较多，可以执行“.&#x2F;configure –help”命令查询其支持的功能，一般都会通过”.&#x2F;configure –prefix&#x3D;安装路径”来指定安装路径。</li>
<li>把系统环境的检测结果和定义好的功能选项写入Makefile文件，后续的编译和安装需要依赖这个文件的内容。</li>
</ul>
<p>需要注意的是，configure不是系统命令，而是源码包软件自带的一个脚本程序，所以必须采用“.&#x2F;configure”方式执行。</p>
<p>e）make（编译）</p>
<p>make会调用gcc编译器，并读取Makefile文件中的信息进行系统软件编译。编译的目的就是把源码程序转变为能被Linux识别的可执行文件，这些可执行文件保存在当前目录下。编译过程较为耗时，需要有足够的耐心。</p>
<p>f）make clean（清空编译内容，非必需步骤）</p>
<p>如果在”.&#x2F;configure”或“make”编译中报错，那么我们在重新执行命令前一定要记得执行make clean命令，它会清空Makefile文件或编译产生的“.o”文件。</p>
<p>g）make install（编译安装）</p>
<p>这才是真正的安装过程，一般会写清楚程序的安装位置。如果忘记指定安装目录，则可以把这个命令的执行过程保存下来，以备将来删除使用。</p>
<h3 id="3）删除"><a href="#3）删除" class="headerlink" title="3）删除"></a>3）删除</h3><p>源码包没有删除命令，如果需要删除，直接删除安装目录即可。</p>
<h3 id="4）打入补丁"><a href="#4）打入补丁" class="headerlink" title="4）打入补丁"></a>4）打入补丁</h3><p>a）补丁的生成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 比较old和new文件的不同</span><br><span class="line">diff 选项 old new</span><br><span class="line">选项：</span><br><span class="line">  -a    将任何文档当做文本文档处理</span><br><span class="line">  -b    忽略空格造成的不同</span><br><span class="line">  -B    忽略空白行造成的不同</span><br><span class="line">  -I    忽略大小写造成的不同</span><br><span class="line">  -N    当比较两个目录时，如果某个文件只在一个目录中，则另一个目录中视作空文件。</span><br><span class="line">  -r    当比较目录时，递归比较子目录</span><br><span class="line">  -u    使用统一的输出格式</span><br></pre></td></tr></table></figure>

<p>比较两个文件的不同，并生成补丁文件”txt.patch”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 比较两个文件的不同，同时生成txt.patch补丁文件</span><br><span class="line">diff -Naur /root/test/old.txt /root/test/new.txt &gt; txt.patch</span><br></pre></td></tr></table></figure>



<p>b）打入补丁</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按照补丁文件进行更新</span><br><span class="line">patch -pn &lt; 补丁文件</span><br><span class="line">选项：</span><br><span class="line">  -pn    n为数字。代表按照补丁文件中的路径，指定更新文件的位置。</span><br></pre></td></tr></table></figure>

<p>“-pn”不好理解，补丁文件是要打入旧文件的，但是你当前所在的目录和补丁文件中的记录是不一定匹配的，所以就需要”-pn”来同步两个目录。</p>
<p>比如我当前在“&#x2F;root&#x2F;test”目录下，补丁文件中记录的文件目录是为“&#x2F;root&#x2F;test&#x2F;old.txt”。这时如果写入“p1”，那么补丁文件就会打入”&#x2F;root&#x2F;test&#x2F;root&#x2F;test&#x2F;old.txt”。如果写入的是“p2”，那么补丁文件就会打入”&#x2F;root&#x2F;test&#x2F;test&#x2F;old.txt”。如果写入的是“p3”，那么补丁文件就会打入”&#x2F;root&#x2F;test&#x2F;old.txt”。即n表示删除补丁文件中记录的文件目录的路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch -p3 &lt; txt.patch</span><br></pre></td></tr></table></figure>



<h2 id="8-脚本安装程序"><a href="#8-脚本安装程序" class="headerlink" title="8. 脚本安装程序"></a>8. 脚本安装程序</h2><p>以Webmin安装为例。</p>
<p>a）下载webmin软件，地址：<a href="http://sourceforge.net/projects/webadmin/files/webmin/">http://sourceforge.net/projects/webadmin/files/webmin/</a></p>
<p>b）解压软件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf webmin-1.610.tar.gz</span><br></pre></td></tr></table></figure>

<p>c）进入解压目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd webmin-1.610</span><br></pre></td></tr></table></figure>

<p>d）执行安装程序setup.sh，并指定功能选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>高级文件系统管理</title>
    <url>/2025/02/25/%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="高级文件系统管理"><a href="#高级文件系统管理" class="headerlink" title="高级文件系统管理"></a>高级文件系统管理</h1><h2 id="1-磁盘配额"><a href="#1-磁盘配额" class="headerlink" title="1. 磁盘配额"></a>1. 磁盘配额</h2><h3 id="1）磁盘配额条件"><a href="#1）磁盘配额条件" class="headerlink" title="1）磁盘配额条件"></a>1）磁盘配额条件</h3><ul>
<li><p>内核必须支持磁盘配额</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# grep CONFIG_QUOTA /boot/config-2.6.32-279.el6.i686</span><br><span class="line">CONFIG_QUOTA=y</span><br><span class="line">CONFIG_QUOTA_NETLINK_INTERFACE=y</span><br><span class="line"># CONFIG_QUOTA_DEBUG is not set</span><br><span class="line">CONFIG_QUOTA_TREE=m</span><br><span class="line">CONFIG_QUOTACTL=y</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统中必须安装了quota工具，Linux默认是安装了quota工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# rpm -qa | grep quota</span><br><span class="line">quota-3.17-16.el6.i686</span><br></pre></td></tr></table></figure>

<p>要支持磁盘配额的分区必须开启磁盘配额功能，这个功能需要手工开启，不再是默认就开启的。</p>
</li>
</ul>
<h3 id="2）概念"><a href="#2）概念" class="headerlink" title="2）概念"></a>2）概念</h3><ul>
<li>用户配额和组配额</li>
<li>磁盘容量限制和文件个数限制</li>
<li>软限制和硬限制</li>
<li>宽限时间</li>
</ul>
<p>如果用户的空间占用数处于软限制和硬限制之间，都会在用户登录时警告用户磁盘将满，这个时间就是宽限时间，默认是7天。如果达到了宽限时间，用户的磁盘占用量还超过软限制，那么软限制就会升级为硬限制。</p>
<h3 id="3）磁盘配额规划"><a href="#3）磁盘配额规划" class="headerlink" title="3）磁盘配额规划"></a>3）磁盘配额规划</h3><p>磁盘配额实验：</p>
<ul>
<li>磁盘配额是限制普通用户在分区上使用磁盘空间和文件个数的，所以我们需要指定一个分区，那么我们手工建立一个5GB的&#x2F;dev&#x2F;sdb1分区，把它挂载到&#x2F;disk目录当中。</li>
<li>还有我们需要建立被限制的用户和用户组。那么我们假设需要限制user1、user2和user3用户，这三个用户属于test组。</li>
<li>其中test组磁盘容量硬限制为500MB，软限制450MB，文件个数不做限制。user1用户为了便于测试，磁盘容量硬限制为50MB，软限制为40MB，文件个数硬限制为10个，软限制为8个。user2和user3用户磁盘容量硬限制为250MB，软限制为200MB，文件个数不做限制。</li>
<li>user1、user2和user3用户加起来的磁盘容量限制为550MB，超过了test组的磁盘容量500MB。这样的话，某个用户可能达不到自己的用户限制，而达到组限制时就不能再写入数据了。也就是说，如果用户限制和组限制同时存在，那么哪个限制更小，哪个限制优先生效。</li>
<li>系统宽限时间改为8天。</li>
</ul>
<p>磁盘配额步骤：</p>
<ul>
<li><p>分配5GB的&#x2F;dev&#x2F;sdb1分区，并将它挂载到&#x2F;disk目录当中。</p>
</li>
<li><p>建立需要做限制的用户和用户组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# groupadd test</span><br><span class="line">[root@localhost ~]# useradd -G test user1</span><br><span class="line">[root@localhost ~]# useradd -G test user2</span><br><span class="line">[root@localhost ~]# useradd -G test user3</span><br><span class="line">[root@localhost ~]# passwd user1</span><br><span class="line">[root@localhost ~]# passwd user2</span><br><span class="line">[root@localhost ~]# passwd user3</span><br></pre></td></tr></table></figure>
</li>
<li><p>在分区上开启磁盘配额功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mount -o remount,usruota,grpquota /disk    # 重新挂载/disk分区，并加入用户和用户组的磁盘配额功能</span><br></pre></td></tr></table></figure>

<p>要想永久生效，则需要修改&#x2F;etc&#x2F;fstab文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">/dev/sdb1    /disk    ext4    defaults,usrquota,grpquota    0    0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /disk    # 修改配置文件如果想要生效，必须重启系统，否则也需要把分区重新挂载一遍</span><br></pre></td></tr></table></figure>
</li>
<li><p>建立磁盘配额的配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：扫描/etc/mtab文件中所有启用磁盘配额功能的分区。如果加入此参数，命令后面就不需要加入分区名了</span><br><span class="line">  -c：不管原有的配置文件，重新扫描并建立新的配置文件</span><br><span class="line">  -u：建立用户配额的配置文件，也就是生成aquota.user文件</span><br><span class="line">  -g：建立组配额的配置文件，会生成aquota.group文件</span><br><span class="line">  -v：显示扫描过程</span><br><span class="line">  -m：强制以读写的方式扫描文件系统，和-M类似。一般扫描根分区时使用。</span><br><span class="line">  -f：强制扫描文件系统，并写入新的配置文件。一般扫描新添加的硬盘分区时使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quotacheck -avug</span><br></pre></td></tr></table></figure>

<p>需要关闭SELinux，否则会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# ll /disk/</span><br><span class="line">总计 24</span><br><span class="line">-rw-------   1 root root  6144  4月 31 19:30 aquota.group</span><br><span class="line">-rw-------   1 root root  6144  4月 18 19:30 aquota.user</span><br><span class="line"># /disk目录中两个配额配置文件已经建立</span><br></pre></td></tr></table></figure>

<p>如果需要给根分区开启配额功能，需要：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vim /etc/fstab</span><br><span class="line">...</span><br><span class="line">UUID=c2ca6f57-b15c-43ea-bca0-f239083d8bd2    /    ext4    defaults,usrquota,grpquota    1    1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# mount -o remount /</span><br><span class="line">[root@localhost ~]# quotacheck -avugm</span><br></pre></td></tr></table></figure>

<p>如果我们自动扫描&#x2F;分区建立配额文件时，因为&#x2F;分区已经挂载成读写系统，而quotacheck需要把分区先挂载成只读分区，然后建立配置文件，最后再挂载回来，所以不能直接在&#x2F;分区建立配置文件，这时就需要使用-m强制以读写方式扫描文件系统了。</p>
<ul>
<li><p>设置用户和组的配额限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# edquota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：  设定用户配额</span><br><span class="line">  -g 组名：    设定组配额</span><br><span class="line">  -t：        设定宽限时间</span><br><span class="line">  -p：        复制配额限制。如果已经设定好某个用户的配额限制，其他用户的配额限制如果和这个用户相同，那么可以直接复制配额限制，而不用都手工指定</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# edquota -u user1</span><br><span class="line"># edquota命令进入之后，就是标准的vi操作方法</span><br><span class="line">Disk quotas for user user1（uid 500）：</span><br><span class="line"># 磁盘配额是设定用户user1（UID是500）</span><br><span class="line">Filesystem    blocks        soft     hard     inodes        soft      hard</span><br><span class="line">/dev/sdb1       0           40000    50000      0            8         10</span><br><span class="line"># 分区名        已占用容量    软限制    硬限制     已占用文件数   软限制     硬限制</span><br></pre></td></tr></table></figure>
</li>
<li><p>配额复制</p>
<p>user3用户的配额值和user2用户完全一样，就可以使用user2用户作为模板进行复制，这样我们如果需要建立大量的配额值一致的用户时，就会非常方便，不用一个个手工建立了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# edquota -p user2 -u user3</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改宽限时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# edquota -t</span><br><span class="line">Grace period before enforcing soft limits for users:</span><br><span class="line">Time units may be: days, hours, minutes, or seconds</span><br><span class="line">Filesystem    Block grace period    Inode grace period</span><br><span class="line">/dev/sdb1       8days                8days</span><br><span class="line"># 分区名        容量的宽限时间          个数的宽限时间</span><br></pre></td></tr></table></figure>


</li>
<li><p>启动和关闭配额</p>
<p>启动配额：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quotaon [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件启动所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：启动用户配额</span><br><span class="line">  -g：启动组配额</span><br><span class="line">  -v：显示启动过程的信息</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quotaon -vug /disk/        # 启动/disk分区的配额</span><br><span class="line">/dev/sdb1 [/disk]：group quotas turned on</span><br><span class="line">/dev/sdb1 [/disk]：user quotas turned on</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# quotaon -avug        # 这条命令也可以</span><br></pre></td></tr></table></figure>

<p>关闭配额：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quotaoff [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：依据/etc/mtab文件关闭所有的配额分区。如果不加-a，后面就一定要指定分区名</span><br><span class="line">  -u：关闭用户配额</span><br><span class="line">  -g：关闭组配额</span><br><span class="line">  </span><br><span class="line"> [root@localhost ~]# quotaoff -a        # 依据/etc/mtab文件关闭配额分区</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4）磁盘配额查询"><a href="#4）磁盘配额查询" class="headerlink" title="4）磁盘配额查询"></a>4）磁盘配额查询</h3><ul>
<li><p>quota查询用户或用户组配额</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# quota [选项] [用户名或组名]</span><br><span class="line">选项：</span><br><span class="line">  -u 用户名：   查询用户配额</span><br><span class="line">  -g 组名：     查询组配额</span><br><span class="line">  -v：          显示详细信息</span><br><span class="line">  -s：          以习惯单位显示容量大小，如M,G</span><br><span class="line">  </span><br><span class="line">[root@localhost ~]# quota -uvs user1</span><br></pre></td></tr></table></figure>
</li>
<li><p>repquota查询文件系统配额</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# repquota [选项] [分区名]</span><br><span class="line">选项：</span><br><span class="line">  -a：    依据/etc/mtab文件查询配额，如果不加-a选项，就一定要加分区名</span><br><span class="line">  -u：    查询用户配额</span><br><span class="line">  -g:     查询组配额</span><br><span class="line">  -v：    显示详细信息</span><br><span class="line">  -s：    以习惯单位显示容量大小</span><br><span class="line"></span><br><span class="line">[root@localhost ~]# repquota -augvs</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5）测试"><a href="#5）测试" class="headerlink" title="5）测试"></a>5）测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[user1@localhost disk]$ dd if=/dev/zero of=/disk/testfile bs=1M count=60    # 建立testfile文件，指定大小60MB</span><br></pre></td></tr></table></figure>



<h3 id="6）非交互设定用户磁盘配额"><a href="#6）非交互设定用户磁盘配额" class="headerlink" title="6）非交互设定用户磁盘配额"></a>6）非交互设定用户磁盘配额</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# setquota -u 用户名 容量软限制 容量硬限制 个数软限制 个数硬限制 分区名</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">[root@localhost ~]# setquota -u user4 10000 20000 5 8 /disk</span><br></pre></td></tr></table></figure>



<h2 id="2-LVM逻辑卷管理"><a href="#2-LVM逻辑卷管理" class="headerlink" title="2. LVM逻辑卷管理"></a>2. LVM逻辑卷管理</h2><h3 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h3><p>LVM是Logical Volume Manager的简称，中文就是逻辑卷管理。</p>
<ul>
<li>物理卷(PV, Physical Volume)：就是真正的物理硬盘或分区。</li>
<li>卷组(VG, Volume Group)：将多个物理卷合起来就组成了卷组，组成同一个卷组的物理卷可以是同一个硬盘的不同分区，也可以是不同硬盘上的不同分区，可以把卷组想象为一个逻辑硬盘。</li>
<li>逻辑卷(LV, Logical Volume)：卷组是一个逻辑硬盘，硬盘必须分区之后才能使用，这个分区称作逻辑卷，逻辑卷可以格式化和写入数据。可以把逻辑卷想象成为分区。</li>
<li>物理扩展(PE, Physical Extend)：PE是用来保存数据的最小单元，数据实际上都是写入PE当中，PE的大小是可以配置的，默认是4MB。</li>
</ul>
<h3 id="2）建立LVM的步骤"><a href="#2）建立LVM的步骤" class="headerlink" title="2）建立LVM的步骤"></a>2）建立LVM的步骤</h3><ul>
<li>首先需要把物理硬盘分成分区，当然也可以是整块物理硬盘。</li>
<li>然后把物理分区建立成为物理卷(PV)，也可以直接把整块硬盘都建立为物理卷。</li>
<li>接下来把物理卷整合成为卷组(VG)。卷组就已经可以动态的调整大小了，可以把物理分区加入卷组，也可以把物理分区从卷组中删除。</li>
<li>最后就是把卷组再划分成为逻辑卷(LV)，当然逻辑卷也是可以直接调整大小的。逻辑卷可以想象成为分区，所以也需要格式化和挂载。</li>
</ul>
<h3 id="3）物理卷管理"><a href="#3）物理卷管理" class="headerlink" title="3）物理卷管理"></a>3）物理卷管理</h3><p>a）硬盘分区</p>
<p>创建方式就是使用fdisk交互命令，不过需要注意的是分区的系统ID不再是Linux默认的分区ID号(83)了，而要改为LVM的ID号8e。</p>
<p>b）建立物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvcreate [设备文件名]</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line"># 把整块硬盘都建立成物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb</span><br><span class="line"></span><br><span class="line"># 把分区建立成为物理卷</span><br><span class="line">[root@localhost ~]# pvcreate /dev/sdb5</span><br></pre></td></tr></table></figure>



<p>c）查看物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvscan</span><br><span class="line">[root@localhost ~]# pvdisplay        # 更详细的物理卷信息</span><br></pre></td></tr></table></figure>



<p>d）删除物理卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# pvremove /dev/sdb5</span><br></pre></td></tr></table></figure>



<h3 id="4）卷组管理"><a href="#4）卷组管理" class="headerlink" title="4）卷组管理"></a>4）卷组管理</h3><p>a）建立卷组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate [选项] 卷组名 物理卷名</span><br><span class="line">[选项]：</span><br><span class="line">  -s PE大小    指定PE的大小，单位可以是MB,GB,TB等。如是不写默认PE大小为4MB</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgcreate -s 8MB scvg /dev/sdb5 /dev/sdb6</span><br></pre></td></tr></table></figure>



<p>b）查看卷组</p>
<p>查看卷组的命令有两个：</p>
<ul>
<li><p>vgscan</p>
<p>vgscan主要是查看系统中是否有卷组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgscan</span><br></pre></td></tr></table></figure>
</li>
<li><p>vgdisplay</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgdisplay</span><br></pre></td></tr></table></figure></li>
</ul>
<p>c）增加卷组容量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgextend scvg /dev/sdb7</span><br></pre></td></tr></table></figure>



<p>d）减小卷组容量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在卷组中删除/dev/sdb7物理卷</span><br><span class="line">[root@localhost ~]# vgreduce scvg /dev/sdb7</span><br><span class="line"># 删除所有的未使用物理卷</span><br><span class="line">[root@localhost ~]# vgreduce -a</span><br></pre></td></tr></table></figure>



<p>e）删除卷组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# vgremove scvg</span><br></pre></td></tr></table></figure>

<p>卷组删除之后，才能删除物理卷，要注意的是scvg卷组还没有添加任何的逻辑卷，如果拥有了逻辑卷，得先删除逻辑卷再删除卷组。</p>
<h3 id="5）逻辑卷管理"><a href="#5）逻辑卷管理" class="headerlink" title="5）逻辑卷管理"></a>5）逻辑卷管理</h3><p>a）建立逻辑卷</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate [选项] [-n 逻辑卷名] 卷组名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：指定逻辑卷大小，单位MB，GB，TB等</span><br><span class="line">  -l 个数：按照PE个数指定逻辑卷大小，这个参数需要换算容量，太麻烦</span><br><span class="line">  -n 逻辑卷名：指定逻辑卷名</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvcreate -L 1.5G -n userlv scvg    # 在scvg卷组中建立1.5GB的userlv逻辑卷</span><br></pre></td></tr></table></figure>

<p>建立完成逻辑卷之后，还要格式化和挂载之后逻辑卷才能正常使用。不过需要注意的是逻辑卷的设备文件名是&#x2F;dev&#x2F;卷组名&#x2F;逻辑卷名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# mkfs -t ext4 /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# mkdir /disklvm</span><br><span class="line">[root@localhost ~]# mount /dev/scvg/userlv /disklvm/</span><br><span class="line">[root@localhost ~]# mount      # 查看挂载</span><br></pre></td></tr></table></figure>

<p>如果需要开机自动挂载，也要修改&#x2F;etc&#x2F;fstab文件。</p>
<p>b）查看逻辑卷</p>
<p>查看命令有两个：</p>
<ul>
<li><p>lvscan</p>
<p>lvscan只能看到系统中是否拥有逻辑卷。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvscan</span><br></pre></td></tr></table></figure>
</li>
<li><p>lvdisplay</p>
<p>lvdisplay可以看到逻辑卷的详细信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvdisplay</span><br></pre></td></tr></table></figure></li>
</ul>
<p>c）调整逻辑卷大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvresize [选项] 逻辑卷设备文件名</span><br><span class="line">选项：</span><br><span class="line">  -L 容量：安装容量调整大小，单位KB,GB,TB等。使用+代表增加空间，-号代表减少空间。如果直接写容量，代表设定逻辑卷大小为指定大小。</span><br><span class="line">  -l 个数：按照PE个数调整逻辑卷大小</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvresize -L 2.5.G /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# lvdisplay               # 逻辑卷的大小已经改变了</span><br><span class="line">[root@localhost ~]# df -h /disklvm/         # 大小没有变化</span><br></pre></td></tr></table></figure>

<p>lvresize只能改变逻辑卷的大小，如果需要让分区使用这个新逻辑卷，还要使用resize2fs命令来调整分区的大小。不过这里体现了LVM的优势，不需要卸载分区，直接就能调整分区的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs [选项] [设备文件名] [调整的大小]</span><br><span class="line">选项：</span><br><span class="line">  -f：    强制调整</span><br><span class="line">  设备文件名：指定调整哪个分区的大小</span><br><span class="line">  调整的大小：指定把分区调整到多大，要加M,G等单位。如果不加大小，会使用整个分区</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# resize2fs /dev/scvg/userlv</span><br><span class="line">[root@localhost ~]# df -h /disklvm/       # 已经调整过来了</span><br></pre></td></tr></table></figure>



<h3 id="4）删除逻辑卷"><a href="#4）删除逻辑卷" class="headerlink" title="4）删除逻辑卷"></a>4）删除逻辑卷</h3><p>删除逻辑卷前要先卸载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# lvremove 逻辑卷设备文件名</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
